<!DOCTYPE html>
<html>
<head>
  <!--link href="http://www.w3.org/StyleSheets/TR/W3C-ED" rel="stylesheet" type="text/css" charset="utf-8"-->
  <title>User Interface Security Directives for Content Security Policy</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <!--
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
  <!--script src='js/respec-w3c-common.js' class='remove' async></script-->
  <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        // Member-SUBM
        specStatus: "ED",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName:  "UISecurity",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        publishDate:  "2014-06-30",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        copyrightStart: "2012",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        previousPublishDate:  "2013-05-23",
        previousMaturity:  "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "http://dvcs.w3.org/hg/user-interface-safety/raw-file/tip/user-interface-safety.html",

        // if this is a LCWD, uncomment and set the end of its review period
        lcEnd: "2014-06-18",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        //extraCSS: ["css/respec.css"],

        // editors, add as many as you like
        // only "name" is required
        editors:  [
          { name: "Giorgio Maone", url: "http://maone.net/",
            company: "Invited Expert", companyURL: "" },
          { name: "David Lin-Shung Huang", url: "mailto:linshung.huang@sv.cmu.edu",
            company: "Carnegie Mellon University", companyURL: "http://www.cmu.edu/" },
	  { name: "Tobias Gondrom", url: "mailto:tobias.gondrom@gondrom.org", company: "Invited Expert" },
          { name: "Brad Hill", url: "mailto:bhill@paypal-inc.com",
            company: "PayPal Inc.", companyURL: "https://www.paypal.com/" },
        ],

        // authors, add as many as you like. 
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // name of the WG
        wg:           "Web Application Security Working Group",

        // URI of the public WG page
        wgURI:        "http://www.w3.org/2011/webappsec/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-webappsec",


        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/49309/status",


	// local bibliography
	localBiblio: {
"CSP" : "B. Sterne and A. Barth <a href=\"http://www.w3.org/TR/CSP/\"><cite>Content Security Policy 1.0</cite></a>. W3C Candidate Recommendation. (Work in progress.) URL: <a href=\"http://www.w3.org/TR/2012/CR-CSP-20121115/\">http://www.w3.org/TR/2012/CR-CSP-20121115/</a>",
"RFC7034" : "D. Ross and T. Gondrom, IETF <a href=\"http://tools.ietf.org/html/rfc7034\"><cite>HTTP Header X-Frame-Options</cite></a>. Internet RFC 7034 URL: <a href=\"http://tools.ietf.org/html/rfc7034\">http://tools.ietf.org/html/rfc7034</a>",
"CLEARCLICK" : "G. Maone <a href=\"http://noscript.net/downloads/ClearClick_WAS2012_rv2.pdf\"><cite>ClearClick: Effective Client-Side Protection Against UI Redressing Attacks</cite></a>. (Work in progress.) URL: <a href=\"http://noscript.net/downloads/ClearClick_WAS2012_rv2.pdf\">http://noscript.net/downloads/ClearClick_WAS2012_rv2.pdf</a>",
"UIREDRESS" : "M. Zalewski <a href=\"http://code.google.com/p/browsersec/wiki/Part2#Arbitrary_page_mashups_(UI_redressing)\"><cite>Browser Security Handbook, part 2</cite></a>. URL: <a href=\"http://code.google.com/p/browsersec/wiki/Part2#Arbitrary_page_mashups_(UI_redressing)\">http://code.google.com/p/browsersec/wiki/Part2#Arbitrary_page_mashups_(UI_redressing)</a>",
"FRAMEBUSTING" : "Boneh, et al. <a href=\"http://seclab.stanford.edu/websec/framebusting/\"><cite>Busting frame busting: a study of clickjacking vulnerabilities at popular sites</cite></a>. URL: <a href=\"http://seclab.stanford.edu/websec/framebusting/\">http://seclab.stanford.edu/websec/framebusting/</a>",
"MEDIACAPTURE":"D. Burnett, A. Bergkvist, C. Jennings and A. Narayanan <a href=\"http://www.w3.org/TR/mediacapture-streams/\"<cite>Media Capture and Streams</cite></a>. W3C Working Draft (Work in progress.) URL: <a href=\"http://www.w3.org/TR/mediacapture-streams/\">http://www.w3.org/TR/mediacapture-streams/</a>",
"INCONTEXT" : "Lin-Shung Huang, et al. <a href=\"https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final39.pdf\"><cite>Clickjacking:Attacks and Defenses</cite></a> published in the 21st USENIX Security Symposium Proceedings.  URL: <a href=\"https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final39.pdf\">https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final39.pdf</a>","SELECTORS4" : "Elika J. Etemad. <a href=\"http://www.w3.org/TR/2011/WD-selectors4-20110929/\"><cite>Selectors Level 4.</cite></a> 29 September 2011. W3C Working Draft. (Work in progress.) URL: <a href=\"http://www.w3.org/TR/2011/WD-selectors4-20110929/\">http://www.w3.org/TR/2011/WD-selectors4-20110929/</a>","POINTER-EVENTS" : "Jacob Rossi and Matt Brubeck. <a href=\"http://www.w3.org/TR/pointerevents/\"><cite>Pointer Events.</cite></a> 19 February 2013 W3C Working Draft. (Work in progress.) URL: <a href=\"http://www.w3.org/TR/pointerevents/\">http://www.w3.org/TR/pointerevents/</a>", "CAPTCHA-Wikipedia" : "Wikipedia <a href=\"http://en.wikipedia.org/wiki/CAPTCHA\"><cite>CAPTCHA</cite></a> from Wikipedia. URL: <a href=\"http://en.wikipedia.org/wiki/CAPTCHA\">http://en.wikipedia.org/wiki/CAPTCHA</a>", "CLICKJACKING-Unresolved" : "Lin-Shung Huang and Collin Jackson. <a href=\"https://docs.google.com/document/pub?id=1hVcxPeCidZrM5acFH9ZoTYzg1D0VjkG3BDW_oUdn5qc\"><cite>Clickjacking Attacks Unresolved.</cite></a> Carnegie Mellon University, 06 July 2011. URL: <a href=\"https://docs.google.com/document/pub?id=1hVcxPeCidZrM5acFH9ZoTYzg1D0VjkG3BDW_oUdn5qc\">https://docs.google.com/document/pub?id=1hVcxPeCidZrM5acFH9ZoTYzg1D0VjkG3BDW_oUdn5qc</a>","CSP11" : "A. Barth, D. Veditz and M. West <a href=\"https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html\"><cite>Content Security Policy 1.1</cite></a>. W3C Editors' Draft. (Work in progress.) URL: <a href=\"https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html\">https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html</a>" 
		     }


      };
  </script>
</head>

<body>

<section id=abstract>

<p>This document defines directives for the Content Security Policy mechanism to
declare a set of input protections for a web resource's user interface, defines 
a non-normative set of heuristics for Web user agents to implement these input 
protections, and a reporting mechanism for when they are triggered. </p>

</section>


<section id=sotd>
<p>This is a Working Draft of the User Interface Security Directives for Content
Security Policy. [[!CSP]]</p>

<p>Portions of the technology described in this document were originally 
developed as part of <code>X-Frame-Options</code> [[!RFC7034]], the ClearClick 
module of the Mozilla Firefox add-on NoScript, [[CLEARCLICK]] and in the InContext
system implemented experimentally in Internet Explorer [[INCONTEXT]]. </p>

<p>In addition to the documents in the W3C Web Application Security working group,
the work on this document is also informed by the work of the 
<a href="http://tools.ietf.org/wg/websec/">IETF websec working group</a>, 
particularly that working group's requirements document: 
<a href="http://tools.ietf.org/id/draft-hodges-websec-framework-reqs">draft-hodges-websec-framework-reqs</a>.
</p>

 


</section><section class=informative>
<h2>Introduction</h2>

<p>This document defines User Interface Security directives for Content Security
Policy, a mechanism web applications can use to mitigate some of the risks of 
User Interface (UI) Redressing [[UIREDRESS]] (AKA "Clickjacking") vulnerabilities
that can lead to fraudulent actions not intended by the user. </p>

<p>Content Security Policy (CSP) is a declarative policy that lets the authors 
(or server administrators) of a web application restrict the behavior of a 
document, e.g.  the origins where it can load its resources from or the ways it 
can execute scripts.  This document defines directives to restrict the 
presentation or the interactivity of a resource when its interaction with the
user may be happening in an ambiguous or deceitful context due to the spatial 
and/or temporal contiguity with other content displayed by the user agent. </p>

<p>A user agent may implement the core directives of CSP independently from the 
directives in this specification, but this specification requires the policy 
conveyance and reporting mechanisms described in CSP.  The interpretation of 
terms imported into this document from CSP may vary depending on the version 
implemented by the user agent.  For example, a <code>source-expression</code> 
in Content Security Policy 1.0 is at the granularity of an <code>origin</code>
[[!ORIGIN]] but may be more granular in future versions of the core Content 
Security Policy.  </p>

<p>Application authors SHOULD transmit the directives in this specification 
as part of a single, complete Content Security Policy, as indicated by that 
specification. </p>

<p>In some UI Redressing attacks (also known as Clickjacking), a malicious web 
application presents a user interface of another web application in a manipulated 
context to the user, e.g. by partially obscuring the genuine user interface with
opaque layers on top, hence tricking the user to click on a button out of context. </p>

<p>Existing anti-clickjacking measures including frame-busting [[FRAMEBUSTING]] 
codes and <code>X-Frame-Options</code> cannot be used to protect resources where
the set of origins that should be allowed and disallowed is unknown, where 
attacks might come from origins intended to be allowed by a use scenario,  or 
defend against timing-based attacks involving multiple windows instead of multiple
frames.  Frame-busting scripts also rely on browser behavior that has not been 
engineered to provide a security guarantee.  As a consequence, such scripts may 
be unreliable if loaded inside a sandbox or otherwise disabled.</p>

<p>The User Interface Security directives encompass the policies defined in 
<code>X-Frame-Options</code> and also provide a new mechanism to allow web 
applications to enable heuristic input protections for its user interfaces on 
user agents. </p>

<p>To mitigate UI redressing, for example, a web application can request that a user interface element should be fully visible for a minimum period of time before a user input can be delivered. </p>

<p>The User Interface Security directive can often be applied to existing applications with few or no changes, but the heuristic hints supplied by the policy may require considerable experimental fine-tuning to achieve an acceptable error rate. </p>

<p>This specification supercedes <code>X-Frame-Options</code>. Resources may supply an <code>X-Frame-Options</code> header in addition to a Content-Security-Policy header to indicate policy to user agents that do not implement the directives in this specification. A user agent that understands the directives in this document SHOULD ignore the <code>X-Frame-Options</code> header, when present, if User Interface Security directives are also present in a Content-Security-Policy header. This is to allow resources to only be embedded if the mechanisms described in this specification are enforced, and more restrictive <code>X-Frame-Options</code> policies applied otherwise.</p>

</section><section id=conformance>
<p>Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the key word ("MUST", "SHOULD", "MAY", etc) used in introducing the algorithm. </p>

<p>A conformant user agent is one that implements all the requirements listed in this specification that are applicable to user-agents. Treatment of
the <code>input-protection</code>, <code>input-protection-clip</code> and <code>input-protection-selectors</code> directives are at the discretion of the 
user agent.</p>

<p>A conformant server is one that implements all the requirements listed in this specification that are applicable to servers. </p>

<section>

<h3>Terminology</h3>

<p>This section defines several terms used throughout the document. </p>

<p>The term <dfn>security policy</dfn>, or simply <dfn>policy</dfn>, for the
purposes of this specification refers to either: </p>
<ol>
  <li>a set of security preferences for restricting the behavior of content
    within a given resource, or</li>
  <li>a fragment of text that codifies these preferences.</li>
</ol>

<p>The security policies defined by this document are applied by a user agent on a <em>per-resource representation basis</em>. Specifically, when a user agent receives a policy along with the representation of a given resource, that policy applies to <em>that resource representation only</em>. This document often refers to that resource representation as the <dfn>protected resource</dfn>. </p>

<p>A server transmits its security policy for a particular resource as a collection of <dfn>directives</dfn>, such as <code>default-src 'self'</code>, each of which controls a specific set of privileges for a document rendered by the user agent. More details are provided in the <a href="#directives">directives</a> section. </p>

<p>A directive consists of a <dfn>directive name</dfn>, which indicates the privileges controlled by the directive, and a <dfn>directive value</dfn>, which specifies the restrictions the policy imposes on those privileges. </p> 

<p> An <dfn>ancestor</dfn> is any resource between the protected resource and the top of the window frame tree; for example, if A embeds B which embeds C, both A and B are ancestors of C. If A embeds both B and C, B is not an ancestor of C, but A still is.</p>

<p>The term <dfn>origin</dfn> is defined in the Origin specification. [<em><a href="http://tools.ietf.org/html/draft-ietf-websec-origin">ORIGIN</a></em>] </p>

<p>The term <dfn>URI</dfn> is defined in the URI specification. [[!URI]] </p>

<p>The <code>&lt;iframe&gt;</code>, <code>&lt;object&gt;</code>,
<code>&lt;embed&gt;</code>, and <code>&lt;frame&gt;</code>
elements are defined in the HTML5 standard.
[[!HTML5]]. </p>

<p>The <code>&lt;applet&gt;</code> element is defined in the HTML 4.01
standard. [[!HTML401]]. </p>

<p>The Augmented Backus-Naur Form (ABNF) notation used in this document is
specified in RFC 5234. [[!ABNF]] </p>

<p>The following core rules are included by reference, as defined in [<em><a
href="http://tools.ietf.org/html/rfc5234#appendix-B.1">ABNF Appendix
B.1</a></em>]: <code>ALPHA</code> (letters), <code>DIGIT</code> (decimal 0-9),
<code>WSP</code> (white space) and <code>VCHAR</code> (printing characters).
</p>

<p>The OWS rule is used where zero or more linear whitespace octets might
appear. OWS SHOULD either not be produced or be produced as a single SP.
Multiple OWS octets that occur within field-content SHOULD either be replaced
with a single SP or transformed to all SP octets (each octet other than SP
replaced with SP) before interpreting the field value or forwarding the message
downstream. </p>
<pre>OWS            = *( SP / HTAB / obs-fold )
               ; "optional" whitespace
obs-fold       = CRLF ( SP / HTAB )
               ; obsolete line folding</pre>


<p>A <dfn id=selector-string>selector string</dfn> is a list of one or more
  <a href="http://dev.w3.org/csswg/selectors4/#complex">complex
  selectors</a>(see [[SELECTORS4]], section 3.1) that
  <em class=ct>may</em> be surrounded by whitespace and matches the
  <code>dom_selectors_group</code> production.
</p>
<pre>dom_selectors_group
  : S* [ selectors_group ] S*
  ;
</pre>
               

<p>A <dfn id="embedding-source-list">embedding source list</dfn> follows the ABNF and parsing rules defined for <a href="http://www.w3.org/TR/CSP/#source-list">source-list</a> (see [[!CSP]] section 3.22) with the following new productions:

<pre>embedding-keyword-source = "'self'" / "'deny'"
embedding-source-expression = host-source / embedding-keyword-source
embedding-source-list = *WSP [ embedding-source-expression *( 1*WSP embedding-source-expression ) *WSP ]
</pre>

</section>

</section>

<section>
<h2 id="sec-directives">Directives</h2>

<p>This section describes the content security policy directives introduced in
this specification. </p>


<section id="input-protection">
<h3><code>input-protection</code></h3>

<p>The <code>input-protection</code> directive, if present or implied, instructs the user
agent to apply the heuristic UI redressing protections described in the <a
href="#heuristic">Input Protection Heuristic</a> section to user input events, such as <code>click</code>,
<code>keypress</code>, <code>touch</code>, and <code>drag</code>, before they
are delivered to the resource. </p>
<p>The screenshot comparison heuristic, in particular, uses the body-bounding rectangle 
of the document triggering the event as its default reference area,
or the rectangle defined by the <code>input-protection-clip</code>
and by the <code>input-protection-selectors</code> directives if any of those is explicitly set.
</p>

<p>If the <code>input-protection-clip</code> directive is set as part of a <code>Content-Security-Policy</code>, triggering of
the heuristic should cancel delivery of the UI event to the target and
cause a violation report to be sent.  If set as part of a 
<code>Content-Security-Policy-Report-Only</code>, triggering of the heuristic 
should result in the event being delivered with the <code>unsafe</code> 
attribute on the <code>UIEvent</code> set to <code>true</code>
and cause a violation report to be sent.</p>

<p>The optional directive value allows resource authors to provide <a href="#input-protection-options">options</a> for heuristic tuning
in the form of space-separated <code>option-name=option-value</code> pairs. </p>

<pre>
directive-name    = "input-protection"
directive-value   = ["display-time=" num-val] ["tolerance=" num-val]</pre>

<p>If the policy does not contain a value for this directive
or any of the hint name=value pairs are absent, the user agent SHOULD apply default
values for hints as described in the following. </p>
<dl id="input-protection-options">
<dt><code>display-time</code></dt>
<dd>is a numeric value from 0 to 10000 that specifies how long, in
milliseconds, the screen area containing the protected user interface
must have been displayed continuously unchanged when the event is processed.
If not specified, it defaults to 800. If a value out of the range stated above is specified, it defaults to the nearest
value between the lower and the higher bounds.
</dd> 

<dt><code>tolerance</code></dt>
<dd>is a numeric value from 0 to 99 that defines the difference
threshold at which the screenshot comparison procedure of the input protection
heuristic triggers a violation. A value of 0 indicates that no difference
between the two images is permitted. A value of 99 provides little to no
practical protection. If not specified, it defaults to 0.
</dd>
</dl>
</section>

<section id="input-protection-clip">
<h3><code>input-protection-clip</code></h3>

<p>The <code>input-protection-clip</code> directive defines a rectangular screen area 
whose intersection with the bounding rectangle of the whole document's body should be used as the reference area in
the screenshot comparison check explained in the <a href="#heuristic">Input Protection Heuristic</a> section.</p>
<p>If the <code>input-protection-clip</code> directive is not explicitly set in a policy
which includes the <code>input-protection</code> directive
and no <code>input-protection-selectors</code> directive is set either,
the bounding rectangle of the whole document's body should be used for screenshot comparisons.</p>
<p>If explicitly set as part of a policy where no <code>input-protection</code>
directive is explicitly set, the <code>input-protection-clip</code> directive
implies the <code>input-protection</code> directive as if it was set in the same policy with its default value.</p>

<pre>
directive-name  = "input-protection-clip"
directive-value = ["before=" num-val] ["above=" num-val] ["after=" num-val] ["below=" num-val]</pre>

<p>The optional directive value can include up to four non-negative numeric labeled offsets,
expressed in CSS pixels and relative to the screen coordinates of the UI event being processed
(<code>event.screenX</code> and <code>event.screenY</code> for mouse, touch or pointer events) or, if not applicable (e.g. for keyboard events),
to the geometrical center of the event target in screen coordinates.
These offsets define a rectangle with
<pre>
x = eX - left, y = eY - top, width = left + right, height = top + bottom
</pre>
where <code>eX</code> and <code>eY</code> are the event's explicit (when possible) or inferred (the target's center) screen ordinates.
The <code>left</code>, <code>top</code>, <code>right</code> and <code>bottom</code>
values are mapped to the offsets labeled as
<code>before</code>, <code>above</code>, <code>after</code> and <code>below</code>
respectively, unless the bi-directional text properties of the event target suggest otherwise: for instance,
if the target's direction is RTL, <code>before</code> translates to <code>right</code> and <code>after</code>
 translates to <code>left</code>.

<p>The default value for this directive is <code>before=250 above=250 after=50 below=50</code>.  If a partial value is provided (i.e. any offset has been omitted) the default values should be implied for the missing offsets.  </p>

<p>The intersection of the computed rectangle with the bounding rectangle of the document's body should be used as the reference area for the screenshot comparison check explained in the <a href="#heuristic">Input Protection Heuristic</a> section, unless the UI event's target or one of its DOM ancestors match a <code>input-protection-selector</code> directive set in the same policy.</p> 

<p>If the <code>input-protection-clip</code> directive is not set or provides an invalid value, the whole bounding rectangle of the document's body must be used as the reference area for the screenshot comparison, unless an <code>input-protection-selectors</code> directive is set in the same policy.</p> 

</section>


<section>
<h3><code>input-protection-selectors</code></h3>

<p>The <code>input-protection-selectors</code> directive overrides the
implicit or explicit <code>input-protection-clip</code> value when
the processed UI event target or one of its DOM ancestors match the <code>dom_selectors_group</code>
<a href="#selector-string">selector string</a> provided as the mandatory directive's value:
in this case, the reference area used for screenshot comparison is the
bounding box of the event target itself, if it matches the selectors, or the bounding box of its nearest
matching DOM ancestor, if any, augmented by the margins given by the leading optional labeled offsets, if any.
UI events whose target and ancestors don't match any of the specified selectors should be ignored (not blocked)
unless an <code>input-protection-clip</code> directive is explicitly included in the policy:
if this is the case, the UI event must be checked and the screenshot reference area
should be computed using the <code>input-protection-clip</code> directive.
</p>

<p>If set as part of a policy where no <code>input-protection</code>
directive is explicitly set, the <code>input-protection-selectors</code> directive
implies the <code>input-protection</code> directive as if it was set in the same policy with its default value.</p>
</p>

<pre>
directive-name  = "input-protection-selectors"
directive-value = ["before=" num-value] ["after=" num-value] ["above=" num-value] ["below=" num-value] dom_selectors_group</pre>

<p>Any of the four non-negative numeric labeled offsets, which represent margins expressed in CSS pixels,
may be omitted, taking 0 (zero) as their default values.</p>
<p>
The reference screenshot area is computed as the rectangle having
<pre>
x = match.x - left, y = match.y - top, width = left + match.width + right, height = top + match.height + bottom
</pre>
where <code>match</code> is the bounding rectangle around the UI event target, if it matches <code>dom_selectors_group</code>,
or around its nearest matching ancestor. The
<code>left</code>, <code>top</code>, <code>right</code> and <code>bottom</code> values 
are mapped to the offsets labeled as
<code>before</code>, <code>above</code>, <code>after</code> and <code>below</code>
respectively, unless the bi-directional text properties of the event target suggest otherwise: for instance,
if the target's direction is RTL, <code>before</code> translates to <code>right</code> and <code>after</code>
 translates to <code>left</code> (similarly to the <a href="#input-protection-clip"><code>input-protection-clip</code></a> directive).
</section>

<section>
<h3><code>report-uri</code></h3>

<p>The <code>report-uri</code> directive specifies a URI to which the
user agent sends reports about policy violation. 

<p>The syntax for the name and value of this directive and the
algorithm to prepare a report are described 
by Content Security Policy. [[!CSP]]</p>  

<p>The core Content Security Policy specification provides directives to
restrict from where external content may be loaded.  As such, violation
reports include a <dfn>blocked-uri</dfn> key/value pair that specifies the
attempted resource load that was blocked by the policy.</p>

<p>As this is not applicable to the directives in this document, the
following additional steps MUST be added to the algorithm defined in
Content Security Policy to <em>prepare a violation report</em>:</p>

<p>In step 1, when preparing the JSON object <em>violation-object</em>,
add the following keys and values to the <dfn>csp-report</dfn>: [[!CSP]]</p>

<p>If the violation is of the <code>input-protection</code> directive, add the following keys and values.  If a value is not set or applicable for the violation (e.g. pointer-height, if the violating event type is not a Pointer Event) the key SHOULD be omitted.
</P>

<dl>
	<dt>blocked-event-type</dt>
	<dd>The <code>type</code> attribute of the <code>UIEvent</code> that was blocked by policy.</dd>

	<dt>touch-event</dt>
	<dd>A <dfn>boolean</dfn> indicating whether the event blocked by policy was a <dfn>Touch Event</dfn> [[!TOUCH-EVENTS]].</dd>

	<dt>pointer-type</dt>
	<dd>The <code>pointerType</code> value of a <dfn>Pointer Event</dfn> [[POINTER-EVENTS]].</dd>

	<dt>pointer-height</dt>
	<dd>The <code>height</code> value of a <code>Pointer Event</code>.</dd>

	<dt>pointer-width</dt>
	<dd>The <code>width</code> value of a <code>Pointer Event</code>.</dd>

	<dt>device-height</dt>
	<dd>The <code>device-height</code> property as defined in [[!CSS3-MEDIAQUERIES]].</dd>

	<dt>device-width</dt>
	<dd>The <code>device-width</code> property as defined in [[!CSS3-MEDIAQUERIES]].</dd>

	<dt>blocked-event-client-x</dt>
	<dd>The <code>clientX</code> attribute of the <code>UIEvent</code> [[!DOM-LEVEL-2-EVENTS]] that was blocked by policy, if set.</dd>

	<dt>blocked-event-client-y</dt>
	<dd>The <code>clientY</code> attribute of the <code>UIEvent</code> [[!DOM-LEVEL-2-EVENTS]] that was blocked by policy, if set.</dd>

</dl>

<p>If the target of an <code>UIEvent</code> which triggers an <code>input-protection</code> violation has an explictly-set <code>id</code> attribute:


<dl>
	<dt>blocked-target-id</dt>
	<dd>The <code>id</code> attribute of the DOM Element that a violating
	<code>UIEvent</code> targeted.</dd>
</dl>

<p>Otherwise, if the target element does not have an explicit <code>id</code> attribute:

<dl>
	<dt>blocked-target-xpath</dt>
	<dd>An XPath [[!XPATH]] expression that returns the target <code>Element</code> of the <code>UIEvent</code> that was blocked by policy.</dd>

</dl>

<section class=informative>
<h3>Producing <code>blocked-target-xpath</code></h3>
User agent implementers may provide any unambiguous XPath in the report. The following example code using the ECMAScript language bindings for DOM Level 2 Core [[!DOM-LEVEL-2-CORE]] produces an unambiguous XPath to the target DOM element <em>"e"</em>:

<pre class="example" title="Sample implementation of XPath generation for reporting">
function getXPathFor(e) {
 
    var xpath = '';
    
    while(e.nodeType == e.ELEMENT_NODE) {
      
      var child = e;
      var siblingIndex = 0;
      while( (child = child.previousSibling) != null ) {
        if(child.tagName == e.tagName) {
          siblingIndex++;  
        }
      }
        
      xpath = e.tagName + 
              '[' + siblingIndex + ']' + 
              (xpath == '' ? '' : '/') +
              xpath;
        
      e = e.parentNode;
   }
   xpath = '/' + xpath; 
   return(xpath);
}
</pre>
Documents may be dynamically constructed and change structure in response to user
interaction or other events, so an unambiguous XPath expression in the context of the current
state of the DOM may not be unambiguous to the content author.  To avoid this confusion,
resource authors SHOULD include an <code>id</code> attribute for all elements of interest
and user agent implementers MAY include any additional information in the XPath they feel
may help disambiguate the blocked target, including class names and id attributes of
ancestors.
</section>


</section>


</section>
<section>
<h2 id="sec-api">DOM interface</h2>

<p>This specification introduces a new attribute for the <code>UIEvent</code>
interface introduced in DOM Level 2. [[!DOM-LEVEL-2-EVENTS]]</p>
<section>

<dl title="partial interface UIEvent" class="idl">
  <dt>[Unforgeable] readonly attribute bool unsafe</dt>
    <dd>This is a non-configurable boolean property of input event objects.
      Set to "true" if a violation of an input-protection directive 
      violation occurred for the event.</dd>
</dl>

<p>The <code>unsafe</code> attribute allows web applications to monitor and
immediately respond to suspect violations in the <code>report-only</code>
mode. Applications may also use this interface for capability detection. For
example, a web application may monitor user inputs on a payment button element
like this: </p>
<pre class="example" title="Example code responing to unsafe attribute">document.getElementById('payment-button').addEventListener("click", function(eventObj) {
  if ("unsafe" in eventObj) {
    if (eventObj.unsafe == true) {
      return reportUnsafeOrShowDialog();
    }
  }
  makePayment();
};</pre>
</section></section>


<section>
<h2>Script Interfaces</h2>

<p>If associated with a Content Security Policy 1.1 [[CSP11]] or later implementation, the User Interface Security Directives include
the following script interfaces which extend the experimental functinality defined therein: <a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#script-interfaces--experimental">https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#script-interfaces--experimental</a></p>

<section>
          <h4><code>SecurityPolicyViolationEvent</code> Events</h4>

          <dl title="[Constructor(DOMString type, optional SecurityPolicyViolationEventInit eventInitDict)] partial interface SecurityPolicyViolationEvent : Event" class="idl">
            <dt>readonly attribute DOMString blockedEventType</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-event-type</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute bool touchEvent</dt>
            <dd>Refer to the <a href="#report-uri"><code>touch-event</code></a> property of violation reports for a description of htis property.</dd>

            <dt>readonly attribute DOMString pointerType</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-type</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long pointerHeight</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-height</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long pointerWidth</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-width</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long deviceHeight</dt>
            <dd>Refer to the <a href="#report-uri"><code>device-height</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long deviceWidth</dt>
            <dd>Refer to the <a href="#report-uri"><code>device-width</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long blockedEventClientX</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-event-client-x</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute long blockedEventClientY</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-event-client-y</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute DOMString blockedTargetID</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-target-id</code></a> property of violation reports for a description of this property.</dd>

            <dt>readonly attribute DOMString blockedTargetXPath</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-target-xpath</code></a> property of violation reports for a description of this property.</dd>
          </dl>

          <dl title="partial dictionary SecurityPolicyViolationEventInit" class="idl">
             <dt>DOMString blockedEventType</dt>
            <dd>Refer to the <a href="#report-uri"><code>document-uri</code></a> property of violation reports for a description of this property.</dd>

            <dt>bool touchEvent</dt>
            <dd>Refer to the <a href="#report-uri"><code>touch-event</code></a> property of violation reports for a description of htis property.</dd>

            <dt>DOMString pointerType</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-type</code></a> property of violation reports for a description of this property.</dd>

            <dt>long pointerHeight</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-height</code></a> property of violation reports for a description of this property.</dd>

            <dt>long pointerWidth</dt>
            <dd>Refer to the <a href="#report-uri"><code>pointer-width</code></a> property of violation reports for a description of this property.</dd>

            <dt>long deviceHeight</dt>
            <dd>Refer to the <a href="#report-uri"><code>device-height</code></a> property of violation reports for a description of this property.</dd>

            <dt>long deviceWidth</dt>
            <dd>Refer to the <a href="#report-uri"><code>device-width</code></a> property of violation reports for a description of this property.</dd>

            <dt>long blockedEventClientX</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-event-client-x</code></a> property of violation reports for a description of this property.</dd>

            <dt>long blockedEventClientY</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-event-client-y</code></a> property of violation reports for a description of this property.</dd>

            <dt>DOMString blockedTargetID</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-target-id</code></a> property of violation reports for a description of this property.</dd>

            <dt>DOMString blockedTargetXPath</dt>
            <dd>Refer to the <a href="#report-uri"><code>blocked-target-xpath</code></a> property of violation reports for a description of this property.</dd>
          </dl>
	  </section>
       <section>
          <h4>SecurityPolicy</h4>

          <p>Let the <dfn>active CSP policies</dfn> be the set of CSP policies
          the user agent is currently enforcing for the associated
          document.</p>

          <dl title="partial interface Security Policy" class="idl">
            <dt>readonly attribute bool inputProtection</dt>
            <dd>A boolean representing the logical <code>or</code> of whether
            the <code>input-protection</code> directive is present or implied in
            each of the <a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/45f6ccaba0ef/csp-specification.dev.html#dfn-active-csp-policies">active CSP
            policies</a>. [[CSP11]]</dd>

          </dl>
        </section>

</section>
</section>
</section>

<section id="heuristic"  class=informative>
<h2>Input Protection Heuristic</h2>
<section>
<p>The algorithm described here can be
implemented mostly in terms of HTML5 constructs, but requires the ability to
monitor and intercept actions in the rendering of a resource and delivery of
events to that resource. User agents may apply equivalent protections using
means more optimized for their implementation details, may ignore
recommendations where the browsing environment eliminates certain classes of
attack, (e.g. the cursor sanity check in a touch-only environment) or may implement
some features in terms of the underlying operating system or platform rather
than directly in the user agent.</p>
</section>
<section>
<h4>Preparation</h4>    
<ol>
  <li><strong>Listener registration</strong> - On the topmost window, register a "global" capturing
    event listener for mouse button, tapping, keyboard, drag &amp; drop and
    focus events, which must be guaranteed to run before any other event
    handler of the same kind and therefore be able to prevent any event from
    being handled by the content, if needed. </li>
  <li><strong>Display changes tracking</strong> - whenever a repaint occurs in the topmost window or in one of its descendants,
      create a record containing a weak reference to the Origin causing the repaint, the screen coordinates of the
      regions being repainted and a timestamp detailing when the repaint occurred, and add this record
      to a screen-global list named "Display Changes List".
      Records older than the maximum value for <code>input-protection</code> <code>display-time</code> can be discarded on update.
  </li>
</ol>
</section>
<section>
<h4>UI Event handling</h4>
<ol>
  <!-- 1 --> <li><strong>Timing attacks countermeasure</strong> -
  check whether the "Display Change List" contains any record younger than the
  <code>input-protection</code> <code>display-time</code> value, whose repainted regions
  intersect with the protected UI elements <em>and</em> whose repaint-causing
  Origin is <em>different</em> than the protected one. If this is true, hinting at
  a recent change in the way the protected UI is displayed, with causes external to the UI
  itself (e.g. an overlapping element in an ancestor document or a
  floating window being suddenly moved away), assume a timing attack is happening
  and jump to step 4.
  </li>
  <!-- 2 --> <li><strong>Cursor sanity check</strong> - By querying computed-style with
    the ":hover" pseudo-class on the element (if the target is plugin content)
    or on the host frame element and its ancestors (if the target is a nested
    document), check whether the cursor has been hidden or changed to an
    possibly attacker-provided bitmap: if it has, jump to step 4. This provides
    protection against "Phantom cursor" attacks, also known as
  "Cursorjacking".</li>
  <!-- 3 --> <li><strong>Obstruction check</strong> Take two screenshots of the area defined by the
    <a href="#input-protection-clip"><code>input-protection-clip</code></a> and
    <a href="#input-protection-selectors"><code>input-protection-selectors</code></a>
    directives and containing the DOM element which is about to receive the event.

    <ol>
    <li> The <dfn>control image</dfn> is taken from its owner document's "point of view" (unobstructed by definition) in an off-screen HTML5 canvas element [[!HTML5]].  The <dfn>user image</dfn> is taken from either the topmost window's point of view in an off-screen HTML5 canvas element [[!HTML5]] or using the fully compositied operating system perspective, obtained using OS-native APIs.</li> 
    
    <li>When this heuristic is applied to plugin content, the <strong>control image</strong> must contain the element itself only.</li>
   
    <li>If the number of the pixels which are different 
    between the screenshots don't exceed a
    percentage threshold defined by the
    <code>tolerance</code> property of the <code>input-protection</code> directive,
    return. </li>

    <li>Differences are computed at a pixel-by-pixel level. Any difference in the value
    of a pixel and it does not match.  For example, a protected area in blue
    overlayed entirely by cross-origin content in red at 1% opacity is considered to
    be 100% different, not 1% different. 
    If portions of the <strong><em>control image</em></strong> are clipped by 
    the view port or otherwise occluded, all such pixels must be
    considered not to match.</li>

    <li>Otherwise, if the differences exceed the tolerance, assume that the DOM element which the user is
    interacting with has been obstructed or obscured by a UI Redressing
    attempt and proceed with step 4.</li>
   </ol>

   </li>

   <li><strong>Violation management</strong> -
   If in report-only mode, set the <code>unsafe</code> property of the event been handled to <code>true</code> and let the event processing continue. Otherwise, prevent the event from reaching its target.  Create and send a violation report if a valid report-uri has been specified.
  </li>
</ol>


    <p class="note" title="Implementation Note">
    In the first implementation of this
    hueristic, NoScript's ClearClick, the screenshots are taken by using the 
    CanvasRenderingContext2D.drawWindow() method, which is a
    Mozilla-proprietary extension of the HTML 5 Canvas API available to
    privileged code only, allowing the content of DOM windows to be drawn on a
    canvas surface exactly as rendered on the screen. The rest of this phase
    relies on cross-browser canvas features, instead, such as pixel grabbing
    and data URL serialization.
    </p>

</section>
</section>
<section id="alt_heuristic" class=informative>
<h2>Alternate Heuristic</h2>
<p>Some user agents use a strategy for hit testing and delivering 
UI events involving multiple composited layers managed on a GPU.  
This alternative heuristic describes one possible implementation 
strategy for the input-protection directive in this architecture that
may be a better fit than the standard heuristic.</p>

<p>GPU-optimized user agents typically separate the browser UI process from the
process that handles building and displaying the visual representation of the 
resource.  (In this context the term "process" refers to any encapsulated 
subunit of user-agent functionality that communicates to other subunits
through message passing, without implying any particular implementation details
such as locality to a thread, OS-level "processes" or the like.)  It is typical
for the browser UI process to receive user events such as mouse clicks and then
marshal these to the render process, where the event is hit tested through the 
page's DOM, checking for event handlers along the way.  As an optimization, the 
render process may communicate hit test rectangles back to the UI process in 
advance so that the UI process can immediately respond to, e.g. a Touch event 
by scrolling, if the event target falls within coordinates for which there are 
no other registered handlers in the DOM.   A similar strategy can be used to 
create an implementation of the input protection heuristic that is 
consistent with this multi-process, compositing architecture.
</p>

<p>If a resource is being loaded in a <code>frame</code>, <code>iframe</code>,
<code>object</code>, <code>embed</code> or <code>applet</code> context
specifies an <code>input-protection</code> directive, apply the following steps:</p>
<section>
<h4>Preparation</h4>
<ol>
<li><strong>Protected hit test rectangle tracking:</strong> Hook the creation of event 
handlers for protected events and elements and add the DOM nodes with any such 
handler to a collection. After a layout occurs, or when an event handler is 
added or removed, iterate across all DOM nodes to generate a vector of rectangles and
their associated Origins where events must be checked for safety.  
If the <code>input-protection</code> applies to 
the DOMWindow or Document node, avoid this expensive process of walking the 
renderers and simply use the view's bounds, as they're guaranteed to be inclusive.  
</li>

<li><strong>(Optionally) Put the protected areas into a backing store / composited
layer:</strong> To avoid the expense of having to re-layout and re-paint
protected regions during the <strong>obstruction check</strong>, it may make sense
to designate and place these regions into their own backing store or composited
layer which can serve as a cached <strong><em>control image</em></strong>.
</li>

<li><strong>Display changes tracking:</strong> whenever a region in a protected
hit test rectangle is invalidated, create a record containing a weak reference to the
Origin causing the repaint, the screen coordinates of the regions being
repainted and a timestamp detailing when the repaint occurred, and add this
record to a screen-global list named "Display Changes List".  Records older than
the maximum value of <code>input-protection display-time</code> can be discarded
on update.</li>
</ol>
</section>
<section>
<h4>UI Event handling</h4>
<ol>
<li><strong>Hit testing in the compositor:</strong> When an event is received, check
whether it is on any layer and then walk the layer hierarchy checking the
protected hit test rectangles on every layer.  If there is a hit, continue this heuristic.
Otherwise, exit this heuristic and event processing proceeds as normal.
</li>

<li><strong>Timing attacks countermeasure</strong> check whether the "Display
Change List" contains any record younger than the <code>input-protection display-time</code>
value, whose repainted regions intersect with the protected regions <em>and</em>
whose repaint-causing Origin is <em>different</em> than the protected one.
If this is true, hinting at a recent change in the way the protected UI is 
displayed, with causes external to the UI itself (e.g. an overlapping element
in an ancestor document or a floating window being suddenly moved away), assume
a timing attack is happening and jump to <strong>Violation management</strong>.
</li>

<li><strong>Cursor sanity check:</strong> By querying computed-style with the 
":hover" pseudo-class on the element (if the target is plugin content) or on the
host frame element and its ancestors (if the target is a nested document), check
whether the cursor has been hidden or changed to a possibly attacker-provided
bitmap.  If it has, proceed to <strong>Violation management</strong>.  This provides
protection against "Phantom cursor" attacks, also known as "Cursorjacking".
</li>

<li><strong>Obstruction check:</strong> Compare two sets of pixels: the
<strong><em>control image</em></strong> is the protected region as if it was
rendered alone, unobstructed by pixels originating from any other document
context.  If the protected regions were placed into their own backing store /
composited layer, this should be readily available, although the pixels may
need to be read back from the GPU to perform a comparision.  The <strong><em>user image
</em></strong> represents the same area as the <strong><em>control image</em>
</strong> in the outermost document's coordinate system and contains the final
set of common pixels for the fully rendered page.  The <strong><em>control
image</em></strong> can be acquired through operating system APIs or from the
compositor for the outermost document context.
These images are compared, and if the number of pixels that differ are below the
<code>tolerance</code> threshold associated with the <code>input-protection</code>
directive, proceed to deliver the event normally, otherwise proceed to
<strong>Violation management</strong>.  

    <p>Differences are computed at a pixel-by-pixel level. Any difference in the value
    of a pixel and it does not match.  For example, a protected area in blue
    overlayed entirely by cross-origin content in red at 1% opacity is considered to
    be 100% different, not 1% different.  If portions of the <strong><em>control
    image</em></strong> are clipped by the view port or otherwise occluded, all such pixels must be
    considered not to match.</p>

    <p>As a short-cut, a user agent MAY choose to treat any pixels in a protected layer with an
    opacity of less than 100% as failing to match by definition.  In cases where a fully-composited
    user view is not available or extremely expensive to calculate, this optimization allows
    the obstruction check to be performed with only a knowledge of the layers that fall on top of
    the protected layer.</p> 
</li>

 <li><strong>Violation management</strong> -
 If in report-only mode, set the <code>unsafe</code> property of the event been
 handled to <code>true</code> and let the event processing continue. Otherwise,
 prevent the event from reaching its target.  Create and send a violation report
 if a valid report-uri has been specified.
</li>
</ol>
    <p class="note" title="Implementation note">
        Optimized and potentially cross-platform
	implementations of screen and cursor capturing and monitoring 
	regions for invalidation may be available as part of e.g. screen-
	sharing functionality through getUserMedia() [[MEDIACAPTURE]] or other
	remote desktop-type functionality available in certian user agents,
	e.g. the ScreenCapturer interface in Chromium.
    </p>
</section>
</section>



<section>
<h2>Examples</h2>

<section class=informative>
<h3>Sample Policy Definitions</h3>

<p>This section provides some sample use cases and accompanying security
policies.</p>

<p>
A resource wishes to block delivery of UI events to the document unless its whole body
has been entirely visible (no tolerance) during the past 1 second (default display-time value):</p>
<pre class="example" title="Policy Header">Content-Security-Policy: input-protection</pre>

<p>A resource wishes to block delivery of UI events to the element with id "send-box", all the elements with class
".tweet" and all the forms in the page unless those elements have been visible for the past 800 milliseconds at least,
(their intrinsic sizes is used as a reference for screenshot comparison): </p>
<pre class="example" title="Policy Header">
Content-Security-Policy: input-protection display-time 800;
        input-protection-selectors #send-button, .tweet, form</pre>

<p>A resource wishes to block delivery of UI events
to any obstructed HTML button and suggests a 15% tolerance
threshold for determining obstruction of the element with a 200 pixels wide margin above and before (on the top and on the left,
if orientation is LTR) the triggering element:</p>
<pre  class="example" title="Policy Header">Content-Security-Policy: input-protection tolerance=15;
                input-protection-selectors above=200 before=200 after=0 below=0 button, input[type=submit], input[type=button]</pre>

<p>A resource wishes to receive reports when the
UI Security heuristic is triggered for any element in the <code>&lt;body&gt;</code>,
with the default 300 by 300 pixels clipped reference area and 0 tolerance:</p>
<pre  class="example" title="Policy Header">Content-Security-Policy-Report-Only: input-protection; input-protection-clip;
                                     report-uri https://example.com/csp-report?unique_id=XKSJ9KAAHJDK9928KKSJEQ</pre>

<p>A resource wants to react to potential clickjacking
directly, without sending a report, so it sets a report-only header but does not 
specify a report-uri. When a <code>UIEvent</code> is sent, the <code>unsafe</code>
attribute will still be set when the heuristic is triggered:</p>
<pre  class="example" title="Policy Header">Content-Security-Policy-Report-Only: input-protection</pre>

<p>A resource wants to allow itself to be embedded by <strong>ancestors</strong> that are same-origin or from the origin <code>https://checkout.example.com</code>, but also to have the <code>unsafe</code> attribute set on events that violate the <code>input protection</code> heuristic.</p>
<pre  class="example" title="Policy Header">Content-Security-Policy: frame-ancestors 'self' https://checkout.example.com
Content-Security-Policy-Report-Only: input-protection </pre>

</section>



<section class=informative>
<h3>Sample Violation Report</h3>

<p>This section contains an example violation report the user agent might sent
to a server when the protected resource violations a sample policy.</p>

<p>In the following example, a document from
<code>http://example.org/page.html</code> was rendered with the following CSP
policy:</p>
<pre>input-protection; report-uri https://example.org/csp-report.cgi?unique_id=12345</pre>

<p>A <code>click</code> violated the policy.</p>
<pre class="example" title="Sample violation report JSON body">{
  "csp-report": {
    "document-uri": "http://example.org/page.html",
    "referrer": "http://evil.example.com/haxor.html",
    "blocked-event-type": "click",
    "blocked-event-client-x": "325",
    "blocked-event-client-y": "122",
    "touch-event": "false",
    "device-width": "800",
    "device-height": "300",
    "blocked-target-xpath": "/html[0]/body[0]/div[6]/form[2]/input[0]",
    "violated-directive": "input-protection",
    "original-policy": "input-protection; report-uri https://example.org/csp-report.cgi?unique_id=12345"
  }
}</pre>
</section>


<section>
<h3>Example Boundary Calculations for the Obstruction Check</h3>
<p>A resource at OriginX embeds a resource at OriginY. The OriginY resource has the following policy:</p>
<p><code>Content-Security-Policy: input-protection tolerance=50; input-protection-selectors div;</code></p>
<p>and results in the following layout:</p>

<img src="1.svg" width="800" height="650" alt="Example frame layout."/>

<p>The element with the id "div1" has an <code>onClick</code> handler defined, and a click event is triggered
at 120,120 in the OriginX document's coordinate system.  The red dot indicates the position of the event.
The event is delivered to "div1", which matches the <code>input-protection-selectors</code>, and no parent of
"div1" matches.  As no <code>input-protection-clip</code> value is defined, the entire area of "div1" becomes the boundaries for
the <strong><em>obstruction check</em></strong>, indicated by the cyan fill.   As more than 50% of this
area is occluded behind the iframe viewport, and so does not match by definition, this will trigger a violation.</p>

<img src="2.svg" width="800" height="650" alt="Example frame layout showing selector policy with an event."/>

<p>If the OriginY protected resource set the following policy, instead:</p>
<p><code>Content-Security-Policy: input-protection tolerance=50; input-protection-selectors div; input-protection-clip before=60 after=60 above=60 below=60;</code></p>
<p>The region for the <strong><em>obstruction check</em></strong>, still indicated in solid cyan, is now only 
the intersection of the boundaries of the protected element handling the event, indicated by diagonal cyan lines, and the clipping 
window around the event, indicated by the green dotted line. If the OriginX resource has not painted anything over the iframe viewport, this check will not trigger
a violation because the entire cyan area will be identical in the <strong><em>user image</em></strong> and <strong><em>control image</strong></em>.</p> 

<img src="3.svg" width="800" height="650" alt="Example frame layout showing selector policy with an event."/>

<p>If the OriginY protected resource omitted selectors, as in this policy:</p>
<p><code>Content-Security-Policy: input-protection tolerance=50; input-protection-clip before=60 after=60 above=60 below=60;</code></p>
<p>The region for the <strong><em>obstruction check</em></strong>, still indicated in solid cyan, is now 
the intersection of the boundaries of the entire document, indicated by diagonal cyan lines, and the clipping 
window around the event, indicated by the green dotted line. This demonstrates that portions of the protected resource may be
included in the obstruction check region, even if they do not have event listeners.  Thus, the hit test rectangles which trigger the
heuristic do not necessarily compose the entire region that must be checked.</p>
<p>As in the previous example, if the OriginX resource has not painted anything over the iframe viewport, this check will not trigger
a violation because the entire cyan area will be identical in the <strong><em>user image</em></strong> and <strong><em>control image</strong></em>.</p> 

<img src="4.svg" width="800" height="650" alt="Example frame layout showing selector policy with an event."/>

</section>

</section>
<section id="security-considerations">
<h2>Security Considerations</h2>


<p>UI Redressing and Clickjacking attacks rely on violating the contextual and temporal integrity of embedded content.  Because these attacks target the subjective perception of the user and not well-defined security boundaries, the heuristic protections afforded by the <code>input-protection</code> directive can never be 100% effective for every interface. It provides no protection against certain classes of attacks, such as displaying content around an embedded resource that appears to extend a trusted dialog but provides misleading information.<p>


</section><section class=informative>
<h2>Implementation Considerations</h2>

<p>The policy and intent of the user always takes precedence over the policy
of resources.  In particular, transformations, customizations or enhancements
of visual content made by the user agent or user-installed plugins SHOULD NOT cause the
<code>input-protection</code> heuristic to be triggered.</p>


<p>Many UI Redressing and Clickjacking attacks rely on exploiting specific features of user agents, such as repositioning of the browsing window, hiding or creating fake cursors, and script-driven scrolling and content repositioning.  Not all attacks apply to all user agents in all contexts.  User agents are free to optimize or not implement suggested heuristics when they do not apply, for example:
<ul>
	<li>Cursor integrity in a touch-only environment</li>
	<li>Drag and drop protections for user agents where 
	<code>drag</code> is not a supported event type</li>
	<li><code>ui-width</code> and <code>ui-height</code> values that exceed the
	capabilities of the browsing environment</li>
</ul>

<p>Some resource owners may specify a restrictive policy forbidding embedding in
user agents that only understand <code>X-Frame-Options</code> but be more 
permissive with user agents that implement UI Security directives.  User agents
that are aware of but choose not to implement any of the heuristics in this
document MAY still ignore <code>X-Frame-Options</code> when
presented in combination with UI Security directives in a Content Security Policy.
For example, a browsing environment that deliberately chooses not to implement 
UI Security features because they interfere with assistive technologies SHOULD NOT deny
users access to resources on this account.  User agents taking this stance SHOULD
implement the <code>unsafe</code> attribute of the <code>UIEvent</code> interface
as this may be interrogated by client applications doing feature detection.</p>

<p>In environments that support multiple, overlapping browser windows, attacks
may be mounted by positioning a target window under another, instructing the
user to double click, and closing the obstructing window with the first click.
[[CLICKJACKING-Unresolved]]  In such environments user agent
implementers may wish to use a native operating system screenshot facility to
calculate the user's view for the <strong>obstruction check</strong> phase of
the heuristic. In such cases user agents should take special caution to  
potential infereference from <a href=#accessibility>accessibility technologies</a></p>

<p>While this document describes a mechanism for resource authors to opt-in to 
User Interface Security protections, user agents MAY choose to opt-in resources
to <code>input-protection</code> by default, or provide users with an option
to manually enable such protections.</p>

<p>If a user agent or user chooses to apply input protection in the absence of
an explicit directive, violations SHOULD NOT cause a violation report to be
generated, even if the resource supplied a Content Security Policy with a 
<code>report-uri.</code></p>

<!--<p>In support of enabling default protection, user agents MAY, with appropriate
user consent and privacy protections, gather large-scale data on when the
heuristic would have been triggered, if it had been enabled, for various values
of the configurable hint parameters.  Such data would allow the user agent to
determine what default settings can provide broad protection with an acceptable
rate of false positives, and perhaps to build a compatibility opt-out list of
sites or resources to further reduce the false positive rate.</p>-->

<section id="accessibility">
<h3>Accessibility Technologies</h3>
<p>Certain classes of accessibility technologies such as
screen readers will provide strong defenses against many classes
of UI Redressing attacks by presenting the content to the user
in a manner not subject to interference. Such SHOULD ignore 
<code>X-Frame-Options</code> headers when presented in 
combination with UI Security directives in a
Content Security Policy.</p>

<p>Use of accessibility technologies MUST NOT by itself cause
the <code>input-protection</code> heuristic to be triggered.
Accessibility technologies that modify the appearance of a resource,
such as screen magnifiers, contrast enhancers, or screen readers
that highlight the element currently being read, have the potential to 
interfere with the <strong>obstruction check</strong>. 
If a user agent is able to detect that accessibility technologies are in use
that could cause interference, the check MUST be disabled.  In some cases,
interference from accessiblity tools may be avoided by acquiring
the <strong>user image</strong> in terms of the user agent's local
rendering surface, rather than using an operating-system level 
screenshot.</p>

<p>User agents MUST provide a means for the user to manually disable
enforcement of the <strong>Input Protection Heuristic</strong> if it 
interferes with their chosen accessibility technologies. The mechanism 
for manually disabling enforcement of the Input Protection Heuristic MUST
be operable by assistive technolgies and by people with cognitive 
disabilities who are able to understand the security risk</p>

<p>Accessibility technologies that act as a proxy MAY filter
any UISecurity policies if they cause interference with the user's
chosen methods of accessing the content.</p>
    
</section>

</section><section class=informative>
<h2>Implementation Considerations for Resource Authors</h2>

<p>When possible, resource authors SHOULD make use of violation reports and the <code>unsafe</code> attribute to apply additional security measures in the application or during back-end processing.  Real-time measures in the application might include requiring completion of a CAPTCHA [[CAPTCHA-Wikipedia]] or responding to an out-of-band confirmation when the UI Security heuristic is triggered.  Example back-end measures might include increasing a fraud risk score for individual actions that trigger or targets accounts/resources that frequently trigger UI Security heuristics.  To be able to do this effectively, it is likely necessary to encode into the <code>report-uri</code> a unique identifier that can be correlated to the authenticated user and the action they are taking.</p>

<p>Mechanisms for CAPTCHA and user verification should include options for people with different disabilities, including cognitive disabilities, people with impaired visual and auditory discrimination skills, and for different modalities. For example, if CAPTCHA or user verification  require biometrics, a choice should be offered of what biometrics to use, as people with different disabilities may be unable to use one or more specific  biometric mechanisms. Further, when two step verification procedures are used, any time limit is problem and it should not be dependent on the user's short term memory or on the user's ability to copy accurately. See <a href="http://www.w3.org/TR/turingtest/">Inaccessibility of CAPTCHA</a> for more information about accessible CAPTCHA.</p>

</section>
<section>
<h2>IANA Considerations</h2>

<p>This document does not define new message headers and uses the existing grammar
of the Content-Security-Policy and Content-Security-Policy-Report-Only headers, so
no updates to the permanent message header field registry (see [<a
href="http://tools.ietf.org/html/rfc3864">RFC3864</a>]) are required.
</p>

</section>

<section class='appendix'>
</section>

</body>
</html>
