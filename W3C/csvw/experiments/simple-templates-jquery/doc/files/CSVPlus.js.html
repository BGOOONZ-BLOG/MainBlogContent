<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CSVPlus.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <!--
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
-->
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/$.html">$</a></li>
            
                <li><a href="../classes/$.CSV_format.html">$.CSV_format</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/CSVPlus.html">CSVPlus</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: CSVPlus.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Experimental CSV+ extension to jQuery, including location of the CSV+ metadata and a mustache-like simple
* template to convert the CSV data into a javascript object, JSON, Turtle, XML, or any other text.
*
* * Author: Ivan Herman
* * Licence: © Copyright W3C® SOFTWARE NOTICE AND LICENSE &lt;http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231&gt;, Ivan Herman, 2014
* 
* @module CSVPlus
* @main CSVPlus
* @author Ivan Herman
* @license W3C
*/

/*
Dependencies:
- PapaParse: http://papaparse.com, CSV parser.
- URI.js: https://medialize.github.io/URI.js/, URI library. The site gives the option of a custom build; this uses just the basic module.
*/

/*
 * @class CSVPlus
 * @static
*/


/* ======================================================================================= */
/*              jQuery extension to access CSV data                                        */
/* ======================================================================================= */  

/**
 * Extension jQuery (a.k.a. $)to handle CSV+ files.
 *
 * @class $
 * @static
 */
(function($) {

  /* ======================================================================================= */
  /*              Output format strings                                                      */
  /* ======================================================================================= */
  /**
  *
  * Constants to be used for the output format: &#x60;&#x60;JSON&#x60;&#x60;, &#x60;&#x60;JAVASCRIPT&#x60;&#x60;, &#x60;&#x60;TURTLE&#x60;&#x60;, &#x60;&#x60;XML&#x60;&#x60;.
  *
  * @class $.CSV_format
  * @static
  * @final
  * @for $
  */
  $.CSV_format = {
    JSON : &quot;json&quot;,
    JAVASCRIPT : &quot;javascript&quot;,
    TURTLE : &quot;turtle&quot;,
    RDF : &quot;rdf&quot;,
    XML : &quot;xml&quot;
  };  

  /* ======================================================================================= */  
  // Filters that the current implementation recognizes for templates. The 
  // list has to be defined by the WG, eventually. These are just examples.
  /**
  * Filters that the current implementation recognizes for templates. The list has to be defined by
  * the WG, eventually. Each of the filters is invoked with the arguments:
  * * &#x60;&#x60;var&#x60;&#x60; - String
  * * &#x60;&#x60;context&#x60;&#x60; - Template context object containing:
  *   * &#x60;&#x60;column_name&#x60;&#x60;: name of the column (used in the &#x60;&#x60;{{name}}&#x60;&#x60; part of the template tag)
  *   * &#x60;&#x60;meta&#x60;&#x60;: (cumulative) metadata object
  *   * &#x60;&#x60;row&#x60;&#x60;: array of the row being processed by the template process
  *   * &#x60;&#x60;row_index&#x60;&#x60;: index of the row being processed
  *   * &#x60;&#x60;target_format&#x60;&#x60;: target format of the template (i.e., &quot;json&quot;, &quot;turtle&quot;, &quot;xml&quot;, etc. )
  * * &#x60;&#x60;string1&#x60;&#x60; (optional) - additional string provided in the template
  * * &#x60;&#x60;string2&#x60;&#x60; (optional) - additional string provided in the template
  * * …
  * * &#x60;&#x60;stringn&#x60;&#x60; (optional) - additional string provided in the template
  * The filter returns a string to be used as a replacement.
  *
  * At the moment, the following filters are defined:
  * * upper - convert to upper case
  * * lower - convert to lower case
  * * number - convert the string into a number
  * * row_number - return the index of the data row being processed (starting with 1)
  * * replace - replace the regexp (in &#x60;&#x60;string1&#x60;&#x60;) with the string value in &#x60;&#x60;string2&#x60;&#x60;
  * * concat - concatenate &#x60;&#x60;val&#x60;&#x60; with &#x60;&#x60;string1&#x60;&#x60;
  * * preconcat - concatenate &#x60;&#x60;string1&#x60;&#x60; with &#x60;&#x60;val&#x60;&#x60;
  * * URI_encode - encode the string following RFC3986 (to be used as a URI component)
  *
  * @property builtin_filters
  * @type Array
  * @static
  * @final
  * @private
  * @for $
  */
  var builtin_filters = {
    &quot;upper&quot;      : function(val, context)           { return val.toUpperCase(); },
    &quot;lower&quot;      : function(val, context)           { return val.toLowerCase(); },
    &quot;number&quot;     : function(val, context)           { return 1*val; },
    &quot;row_number&quot; : function(val, context)           { return context.row_index + 1 },
    &quot;replace&quot;    : function(val, context, from, to) { return val.replace(new RegExp(from), to); },
    &quot;concat&quot;     : function(val, context, str)      { return val + str; },
    &quot;preconcat&quot;  : function(val, context, str)      { return str + val; },
    &quot;URI_encode&quot; : function(val, context)           { return URI.encode(val); }
  }
  , filters = {}
  ;

  /* =========================================================================== */
  /*  Various helper functions                                                   */
  /* =========================================================================== */ 
  //
  //
  // Merge the various metadata objects into one 
  /**
  * Merge the various objects into one; the priority is right to left, i.e., key-value pairs on the
  * right override, if any, a similar key value on the left.
  *
  * Used to merge the various metadata objects
  *
  * @method mergeMeta
  * @private
  * @param {Object} m1 - Lowest priority object
  * @param {Object} m2 - Object
  * @param {Object} m3 - Object
  * @param {Object} m4 - Highest priority object
  * @return {Object} - New class consisting of the merge incoming objects
  */
  var mergeMeta = function(m1, m2, m3, m4) {
    // The metadata can include other objects, ie, extension should be &quot;deep&quot;
    return $.extend(true, {}, m1, m2, m3, m4);
  }

  /**
  * Default metadata: to be used when no metadata is specified whatsoever.
  * It lists the column names, whether from the first row or creating a column name on the fly
  * (this depends on user setting, ie, whether the first row is indeed column names).
  *
  * Additional metadatata items may be added, this will depend on the WG&#x27;s final spec.
  *
  * @method default_meta
  * @private
  * @param {Array} data - row of raw data, as extracted from the CSV files
  * @param {String} url - url of the CSV data
  * @param {boolean} headers - Whether the first row in the data give the column headers; if &#x60;&#x60;false&#x60;&#x60;, 
  *    the column names are generated as described in the data model document. Note that if the value is &#x60;&#x60;true&#x60;&#x60;,
  *    the first row in &#x60;&#x60;data&#x60;&#x60; will be removed.
  * @return {Object} - New metadata
  */
  var default_meta = function(data, url, headers) {
    // The default metadata just includes the names of the columns
    var retval = {
      &quot;@id&quot;   : url,
      schema : {
        columns : []
      }
    };
    if( headers ) {
      // The first row of the data contains the header names
      for( var i = 0; i &lt; data[0].length; i++ ) {
        retval.schema.columns.push({ name : data[0][i], &quot;@type&quot; : &quot;Column&quot; });
      }
      // Remove the first row from the real data
      data.shift();
    } else {
      // The length of the first row in the data is what counts
      for( var i = 0; i &lt; data[0].length; i++ ) {
        retval.schema.columns.push({ name : &quot;Column &quot; + (i+1), &quot;@type&quot; : &quot;Column&quot; });
      }      
    }
    return retval;
  } 

  /**
  * Extract the current templates, if any, from the metadata. This depends on the user’s option
  * that determines what the output format should be.
  *
  * Default case is to return no template in Javascript object
  *
  * @method get_template_data
  * @private
  * @param {Object} options - User’s options object
  * @param {Object} meta - CSV metadata
  * @return {Object} - template data of the form:
  * * &#x60;&#x60;url&#x60;&#x60;: URL of the template file. Default is empty
  * * &#x60;&#x60;format&#x60;&#x60;: output format (ie, Javascript, JSON, etc.). Default is JAVASCRIPT_FORMAT
  */
  var get_template_data = function(options, meta) {
    // The (user&#x27;s) option dictates the required output format
    // The metadata contains (possibly) the template for different formats
    var retval = { url: &quot;&quot;, format: options.format };
    // See if there is a template to be extracted. If not, the template will be returned as &quot;&quot;
    if( meta.template !== undefined ) {
      if( $.isArray(meta.template) ) {
        for( var i = 0; i &lt; meta.template.length; i++ ) {
          if( meta.template[i].url !== undefined &amp;&amp; meta.template[i].format === options.format ) {
            retval.url = meta.template[i].url;
            break;
          }          
        }
      } else {
        if( meta.template.url !== undefined &amp;&amp; meta.template.format === options.format ) {
          retval.url = meta.template.url;
        }
      }
    }
    return retval;
  }

  /**
  * Turn a data row into an object with column names (as specified in the metadata) as keys and cells as values.
  * The row is then processed through a callback function. The method performs these actions for each row in the 
  * data separately
  *
  * @method process_rows
  * @private
  * @param {Array} data - current data row
  * @param {Object} meta - CSV metadata
  * @param {Function} callback - callback called with two arguments:
  * * row: the data row Array
  * * context: object containing:
  *   * &#x60;&#x60;meta&#x60;&#x60;: the CSV metadata
  *   * &#x60;&#x60;row_index&#x60;&#x60;: the index of the row within the whole CSV file
  *   * &#x60;&#x60;row&#x60;&#x60;: the current data row Array
  */
  var process_rows = function(data, meta, callback) {
    data.forEach( function(data_row, rindex) {
      context = {
        meta      : meta,
        row_index : rindex,
        row       : data_row
      };
      row = {}
      meta.schema.columns.forEach( function(col, cindex) {
        row[col.name] = data_row[cindex];
      })
      callback(row, context);      
    })
  }

  /**
  * Extract the arguments from a tag, ie, if a filter looks like
  * &#x60;&#x60;filter(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&#x60;&#x60;, then extract an array of the form &#x60;&#x60;[a,b,c]&#x60;&#x60; from the
  * &#x60;&#x60;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#x60;&#x60; string.
  * 
  * The method is used recursively to fill the incoming (initially empty) array.
  *
  * @method get_args
  * @private
  * @param {String} arg_string - the string to be parsed
  * @param {Array} args_array - the array to be filled with the individual arguments
  */
  var get_args = function( args_string, args_array ) {
    if( args_string.length === 0 ) return false;
    if( args_string[0] === &quot;,&quot;) {
      args_string = args_string.slice(1).trim();
    }

    // String must begin with a quote:
    if( args_string[0] !== &quot;&#x27;&quot; &amp;&amp; args_string[0] !== &#x27;&quot;&#x27; ) return false;

    // Try to match...
    var reg = /([&quot;&#x27;])(.*?)\1/;
    var matched = args_string.trim().match(reg);

    if( matched !== null ) {
      args_array.push(matched[2]);

      get_args( matched.input.slice(matched[0].length), args_array )
    } else {
      return false;
    }
    return true;
  } 

  /* =========================================================================== */
  /* =========================================================================== */
  /* =========================================================================== */

  /* =========================================================================== */
  /* Mini mustache implementation                                                */
  /* =========================================================================== */

  /**
  * The full template has to be cut into a series of separate templates
  *  * global templates
  *  * per-row templates to be repeated
  * 
  * The result of the processing is an array of templates with a flag on whether it is
  * global or not. The objects returned in the array are of the form:
  * * &#x60;&#x60;repeat&#x60;&#x60; (boolean): true means this is a template for rows, i.e,, to be repeated for all the rows
  * * &#x60;&#x60;template&#x60;&#x60;: the template itself.
  *
  * @method split_template
  * @private
  * @param {String} template - The full template
  * @return {Array} - objects of the form described above.
  */
  var split_template = function(template) {
    var set_global = function(t) {
      retval.push({ repeat:false, template:t })
    };
    var retval       = [];
    var templ = template;
    while( templ !== &quot;&quot; ) {
      // Careful with the regexp: 
      //   - [\s\S] must be used to allow for a multiline template, ie, to match over new lines
      //   - &#x27;?&#x27; must be used in the group to avoid a greedy match, ie, to ensure all 
      //     row templates are handled properly
      var a = templ.match( /{{#rows}}([\s\S]*?){{\/rows}}/m );
      if( a === null ) {
        set_global(templ);
        break;
      } else {
        // See if there is a global portion:
        if( a.index &gt; 0 ) {
          set_global(templ.slice(0, a.index));
        }
        // See if there is local portion
        if( a[1] !== &quot;&quot; ) {
          retval.push({
            repeat:  true,
            template: a[1],
          })
        }
        // get the rest of the string...
        templ = templ.slice(a.index + a[0].length);     
      }
    }
    return retval;
  }

  /**
  * Process one (optionally filtered) mustache tag, i.e., the content of something like &#x60;&#x60;{{a.b.c.d}}&#x60;&#x60; 
  * The first symbol should be used to get a value; all the others are filters.
  *
  * (The implementation does not handle escape characters... :-()
  *
  * @method process_one_tag
  * @private
  * @param {String} tag  - The tag itself
  * @param {Object} view - A mapping object providing a value for the (first) symbol                                                             
  * @param {Object} context - Object containing:
  * @param {Object} context.meta - Metadata associated to the CSV file
  * @param {Object} context.index - Index of the row being processed, if applicable, -1 otherwise 
  * @param {Object} context.row - Full row being processed, if applicable, &#x60;&#x60;null&#x60;&#x60; otherwise
  * @return {String} - value of the tag, i.e., the value from &#x60;&#x60;view&#x60;&#x60;, possibly ran through the chain of filters
  */                                                        
  var process_one_tag = function(tag, view, context) {
    var tags = tag.split(&#x27;.&#x27;);

    // Start by getting the base value
    var col_name        = tags[0].trim();
    var retval          = col_name === &quot;&quot; ? &quot;&quot; : view[col_name];
    var final_context   = $.extend({
      column_name : col_name
    }, context);

    // Go through the filters, if any
    for( i = 1; i &lt; tags.length; i++ ) {
      var filter = tags[i].trim();
      // see if there are argumnets attached to the filter
      var with_args = filter.split(&#x27;(&#x27;);
      if( with_args.length === 1 ) {
        // There are no arguments, just a simple filter
        retval = filters[filter](retval, final_context)
      } else {
        // There are arguments to handle;
        var func     = filters[with_args[0]];

        var all_args = [];
        get_args( with_args[1],all_args );

        // To call the filter, the argument should be preceded with the previous value
        // in the filter and the meta
        all_args.unshift(final_context);
        all_args.unshift(retval);

        // The filter can be invoked now:
        retval = func.apply(this, all_args);
      }
    }
    return retval;
  };

  /**
  * Process a template, i.e., find all the tags, process them individually (through the &#x60;&#x60;process_one_tag&#x60;&#x60; method)
  * and return the concatenated result.
  * Process a template, without the {{#rows}}...{{\#rows}} sections. The function goes through the templates recursively,
  * by taking the templates from left-to-right and concatenating the results.
  *
  * @method render_template
  * @private
  * @param {String} template  - The full template
  * @param {Object} view - A mapping object providing a value for the (first) symbol                                                             
  * @param {Object} context - Object containing:
  * @param {Object} context.meta - Metadata associated to the CSV file
  * @param {Object} context.index - Index of the row being processed, if applicable, -1 otherwise 
  * @param {Object} context.row - Full row being processed, if applicable, &#x60;&#x60;null&#x60;&#x60; otherwise
  * @return {String} - value of the full template
  */                                                     
  var render_template = function(template, view, context) {
    var matched = template.match(/{{.*?}}/m);
    if( matched == null ) {
      // No template given, we are done; this also means the end of the line
      return template;
    } else {
      // There is a match on the left of the string...
      var begin  = template.slice(0, matched.index);
      var middle = process_one_tag(matched[0].slice(2, -2), view, context);
      var end    = template.slice(matched.index + matched[0].length);
      return begin + middle + render_template(end, view, context);
    }
  };

  /**
  * Convert the CSV data with templates.
  *
  * @method c_templates
  * @private
  * @param {Array} data - The CSV data itself, an array of array (latter being a row from the file)
  * @param {Object} meta - Metadata object, as defined in the spec
  * @param {String} template - Template string. 
  * @param {Sring} target_format - can be JSON, Turtle, Javascript,…
  * @param {Array} warnings - array of warnings that may have to be extended if an error occurs
  * @return {String or Object} - Converted data. If the &#x60;&#x60;target_format&#x60;&#x60; argument is JAVASCRIPT, the retun is an Object,
  * otherwise a string with the converted value in the &#x60;&#x60;target_format&#x60;&#x60; syntax.
  *
  */
  var c_templates = function(data, meta, template, target_format, warnings) {
    // There is no template: the default is to get the rows and columns in JSON
    // Cut the template into global/repeat portion
    // the result is an array of separate templates
    var templates = split_template(template);

    // The &#x27;global&#x27; template is used on a &quot;view&quot; (in mustache jargon)
    // containing only the top level keys from the metadata. This
    // can be set once and for all
    var global_mview = {};
    Object.keys(meta).forEach( function(key) {
      if( typeof meta[key] === &quot;string&quot; ) global_mview[key] = meta[key];
    });

    // The main processing cycle: Go through the templates and perform 
    // each individually. The results are concatenated into one string to be returned
    var result = &quot;&quot;;
    templates.forEach( function(tstruct) {
      // The major switch: is the template to be repeated or not?
      if( tstruct.repeat === true ) {
        process_rows(data, meta, function(row, context) {
          result += render_template(tstruct.template, $.extend({}, global_mview, row), $.extend({target_format:target_format}, context));
        });
      } else {
        // Just apply the template against the global view and append the outcome
        // to the result string
        context = {
          meta          : meta,
          target_format : target_format,
          row_index     : null,
          col_index     : null,
          row           : null
        };
        result += render_template(tstruct.template, global_mview, context);
      }
    });

    if( target_format === $.CSV_format.JSON || target_format === $.CSV_format.JAVASCRIPT ) {
      try {
        var j_result = eval( &#x27;(&#x27; + result + &#x27;)&#x27; );
        return target_format === $.CSV_format.JSON ? JSON.stringify(j_result,null,2) : j_result;          
      } catch(e) {
        warnings.push(&quot;Template (Javascript) syntax error in: &quot; + e.message)
        return result;
      }
    } else {
      return result;
    }
  }

  /* =========================================================================== */
  /* =========================================================================== */
  /* =========================================================================== */

  /* =========================================================================== */
  /* Default RDF/JSON conversion                                                 */
  /* =========================================================================== */

  /**
  * Objects referring to the default conversion functions for Javascript and JSON
  * 
  * @property js_conversions
  * @private
  */
  var js_conversions = {
    start : function( state, data, meta, warnings ) {
      state.obj = {
        &quot;@id&quot;   : state[&quot;@id&quot;],
        &quot;@base&quot; : state[&quot;@base&quot;],
        &quot;@rows&quot; : []
      };
      state.current = state.obj;
      if( &quot;@context&quot; in state ) {
        state.obj[&quot;@context&quot;] = state[&quot;@context&quot;];
      };
    },

    end : function( state, meta, target_format, warnings ) {
      state.retval = target_format === $.CSV_format.JSON ? JSON.stringify( state.obj, null, 2 ) : state.obj;
    },

    add_type : function( state, type ) {
      state.current[&quot;@type&quot;] = type;
    },

    add_core_property : function( state, term, value, uri, isid ) {
      state.current[term] = value;
    },

    new_row: function( state, rid ) {
      state.current = {};
      state.obj[&quot;@rows&quot;].push(state.current);
      if( rid !== undefined ) {
        state.current[&quot;@id&quot;] = rid;
      }
    },

    add : function( state, key, val ) {
      var v = (&quot;datatype&quot; in val &amp;&amp; val.datatype == &quot;integer&quot; ) ? 1*val.value : val.value;
      state.current[key.value] = v;
    },
  };

  /**
  * Objects referring to the default conversion functions for RDF and Turtle/NT
  * 
  * @property rdf_conversions
  * @private
  */
  var rdf_conversions = {
    start : function( state, data, meta, warnings ) {
      state.graph = new RDFJSInterface.Graph();
      state.rdf   = new RDFJSInterface.RDFEnvironment();

      state.rdf.setPrefix(&quot;csv&quot;, &quot;http://www.w3.org/ns/csvw#&quot;);
      state.rdf.setDefaultPrefix(state[&quot;@base&quot;]);

      state.current = state.rdf.createNamedNode(state[&quot;@id&quot;]);
    },

    end : function( state, meta, target_format, warnings ) {
      state.retval = target_format === $.CSV_format.TURTLE ? state.graph.toNT() : state.graph;
    },

    add_type : function( state, type ) {
      state.graph.add(state.rdf.createTriple( state.current,
                                              state.rdf.createNamedNode(&quot;rdf:type&quot;),
                                              state.rdf.createNamedNode(&quot;csv:&quot; + type) ));
    },

    add_core_property : function( state, term, value, uri, isid ) {
      var p = state.rdf.createNamedNode( uri !== undefined ? uri : &quot;:&quot; + term );
      var o = isid ? state.rdf.createNamedNode(value) : state.rdf.createLiteral(value);
      state.graph.add(state.rdf.createTriple( state.current,p,o ));
    },

    new_row: function( state, rid ) {
      if( rid === undefined ) {
        state.current = state.rdf.createBlankNode();
      } else {
        state.current = state.rdf.createNamedNode(&quot;:&quot; + rid)
      }
    },

    add : function( state, predicate, object ) {
      // See how the URI for the predicate is set up
      if( &quot;prefix&quot; in predicate ) {
        var p = state.rdf.createNamedNode(predicate.prefix + &quot;:&quot; + predicate.value)
      } else {
        var p = state.rdf.createNamedNode(predicate.value)
      }

      if( object.isuri ) {
        var o = state.rdf.createNamedNode(object.value)
      } else {
        if( &quot;datatype&quot; in object ) {
          var d = state.rdf.createNamedNode(&quot;xsd:&quot; + object.datatype)
          var o = state.rdf.createLiteral(object.value, null, d);
        } else {
          var o = state.rdf.createLiteral(object.value);
        }
      }
      state.graph.add(state.rdf.createTriple( state.current,p,o ));
    },
  };

  /**
  * Object referring to the conversion function objects, keyed through the possible formats
  *
  * @property conversions
  * @private
  */
  var conversions = {};
  conversions[$.CSV_format.JSON]       = js_conversions;
  conversions[$.CSV_format.JAVASCRIPT] = js_conversions;
  conversions[$.CSV_format.TURTLE]     = rdf_conversions;
  conversions[$.CSV_format.RDF]        = rdf_conversions;

  /**
  * The core global properties that are defined by the group, i.e., not dependent on
  * DCMI or schema.org 
  *
  * @property core_properties
  */
  var core_properties = [
    &quot;creator&quot;,
    &quot;license&quot;,
    &quot;created&quot;,
    &quot;modified&quot;,
    &quot;description&quot;
  ];

  /**
  * Resolve core property. The property is looked up in the (possible) 
  * &#x60;&#x60;@context&#x60;&#x60; structure to see if a URI is assigned to it and, if yes,
  * whether it is specified as having a URI as a value/object
  *
  * @method resolve_core_property
  * @private
  * @param {Sring} term - the term to be looked up
  * @param {Object} meta - Metadata object, as defined in the spec
  * @return {Object} with values of &#x27;uri&#x27; (if an URI is assigned to the term) and a &#x27;id&#x27; boolean value on 
  * whether the value should be a URI or a string. The former defaults to &#x60;&#x60;undefined&#x60;&#x60;, the latter to &#x60;&#x60;false&#x60;&#x60;.
  *
  */
  var resolve_core_property = function( term, meta ) {
    var retval = {
      uri: undefined,
      isid: false
    }
    if( &quot;@context&quot; in meta ) {
      var context = meta[&quot;@context&quot;];
      if( term in context ) {
        // bingo...
        var cval = context[term];
        if( typeof cval === &quot;string&quot; ) {
          retval.uri = cval;
        } else {
          retval.uri  = &quot;@id&quot; in cval ? cval[&quot;@id&quot;] : undefined;
          retval.isid = (&quot;@type&quot; in cval) &amp;&amp; (cval[&quot;@type&quot;] === &quot;@id&quot;);
        }
      }
    }
    return retval;
  }

  /**
  * Create a default conversion.
  * This is called when there is no template, ie, provides the default conversion
  * of a CSV file. This is the conversion that is defined, as a standard, by the WG.
  *
  * This method implements the overall structure in a final format agnostic way. The &#x60;&#x60;target_format&#x60;&#x60; argument
  * is used to choose among the possible conversion function sets, using the &#x60;&#x60;conversions&#x60;&#x60; object.
  * 
  *
  * @method c_default
  * @private
  * @param {Array} data - The CSV data itself, an array of array (latter being a row from the file)
  * @param {Object} meta - Metadata object, as defined in the spec
  * @param {Sring} target_format - can be JSON, Turtle, Javascript,…
  * @return {String or Object} - Converted data. If the &#x60;&#x60;target_format&#x60;&#x60; argument is JAVASCRIPT, the return is an Object; if it is RDF,
  * the return is a Graph as defined by the rdf_interface package; otherwise a string with the converted value in the &#x60;&#x60;target_format&#x60;&#x60; syntax.
  *
  */
  var c_default = function(data, meta, target_format, warnings) {
    var conv_functions = conversions[target_format];
    // This object is shared by all conversion functions as a common state, and also stores
    // the final output
    var url = new URI(meta[&quot;@id&quot;]).normalize().toString();
    var state = {
      retval  : undefined,
      &quot;@id&quot;   : url,
      &quot;@base&quot; : url + &quot;#&quot;,
    };
    if( &quot;@context&quot; in meta ) {
      state[&quot;@context&quot;] = meta[&quot;@context&quot;];
      // TODO: this has to be refined with a proper URI handling
      if( state[&quot;@context&quot;][&quot;@base&quot;] !== undefined ) {
        state[&quot;@base&quot;] = new URI( state[&quot;@context&quot;][&quot;@base&quot;] ).normalize().toString();
      }
    } 

    // Start: set up the environment
    conv_functions.start( state, data, meta, warnings );

    // Set the &#x27;Table&#x27; type
    conv_functions.add_type( state, &quot;Table&quot; );

    // Get the global, core properties into the output
    for( var i = 0; i &lt; core_properties.length; i++ ) {
      var term = core_properties[i];
      if( term in meta ) {
        // Get the characteristics of the term from the (possible) @context
        var term_c = resolve_core_property( term, meta);
        conv_functions.add_core_property( state, term, meta[term], term_c.uri, term_c.isid )        
      }
    }

    // Establish the final column names (or URIs) and primary keys (if any)
    var col_names    = [];
    var primary_keys = [];
    var primaryKey   = &quot;primaryKey&quot; in meta.schema ? ($.isArray(meta.schema.primaryKey) ? meta.schema.primaryKey : [meta.schema.primaryKey]) : [];

    meta.schema.columns.forEach( function(col, index) {
      // This structure anticipates on the URI templates a bit
      col_names.push({
        name  : col.name,
        uri   : new URI(col.name).normalize().toString(),
        isURI : false,
        index : index
      });
      // Check the primary key

      if( &quot;@id&quot; in col ) {
        // Check if that id is present in the defined keys
        var i = $.inArray(col[&quot;@id&quot;], primaryKey);
        if( i &gt;= 0 ) {
          primary_keys[i] = index;
        }
      }
    });

    // Go through each row:
    data.forEach( function(data_row, rindex) {
      // Establish the subject/@id to be used for that row.
      if( &quot;primaryKey&quot; in meta.schema ) {
        // establish the subject
        var rid_array = [];
        primary_keys.forEach( function(key,index) {
          rid_array.push(data_row[key]);
        })
        var rid = new URI( rid_array.join(&quot;-&quot;) ).normalize().toString();
        // console.log(rid);
        conv_functions.new_row(state, rid);
      } else {
        conv_functions.new_row(state)
      }
      // Set the row type
      conv_functions.add_type(state, &quot;Row&quot;);
      // Set the row number as a signal
      conv_functions.add(state, {value: &quot;row&quot;, prefix: &quot;csv&quot;}, {value: rindex, isuri: false, datatype: &quot;integer&quot;});
      // Go through the individual cells now
      data_row.forEach( function(cell, cindex) {
        var predicate = {
          value  : col_names[cindex].uri,
          prefix : &quot;&quot;,
        };
        // This is where the datatype issue will come in!
        var subject = {
          value : cell,
          isuri : false,
        }
        conv_functions.add(state, predicate, subject);
      })
    });


    // End: close the processing altogether. This may involve a serialization, depending on the target format
    conv_functions.end( state, meta, target_format, warnings );

    // Just return the generated output:
    return state.retval;
  };


  /* ============================================================================== */
  /* ============================================================================== */
  /* ============================================================================== */

  /* ============================================================================== */
  /**
  * Main conversion entry point. In reality, this is just a switch between the &#x27;direct&#x27;
  * i.e., default mapping as defined by the standard, and the templated version if a template
  * has been added to the metadata.
  *
  * @method convertCSV
  * @private
  * @param {Array} data - The CSV data itself, an array of array (latter being a row from the file)
  * @param {Object} meta - Metadata object, as defined in the spec
  * @param {String} template - Template string. If &#x60;&#x60;&quot;&quot;&#x60;&#x60; (ie, no template) a default Javascript object is generated
  * @param {Sring} target_format - can be JSON, Turtle, Javascript,…
  * @param {Array} warnings - array of warnings that may have to be extended if an error occurs
  * @return {String or Object} - Converted data. If the &#x60;&#x60;target_format&#x60;&#x60; argument is JAVASCRIPT, the retun is an Object,
  * otherwise a string with the converted value in the &#x60;&#x60;target_format&#x60;&#x60; syntax.
  *
  */
  var convertCSV = function(data, meta, template, target_format, warnings) {
    // There is no template: the default is to get the rows and columns in JSON
    return ( template === &quot;&quot; ) ? c_default(data, meta, target_format, warnings) : c_templates(data, meta, template, target_format, warnings);
  }

  /* =========================================================================== */
  /* =========================================================================== */
  /* =========================================================================== */

  /* =========================================================================== */
  /**  
  *  Public interface, as a jQuery extension. The function
  * 
  * 1. Fetches the CSV content (in memory, i.e., it is very inefficient for large CSV files)
  * 1. Retrieves and combines the metadata associated to the CSV (i.e., trough the link response header, and at the well known places; see the specification)
  * 1. Retrieves the associated templates (if any), based on the requested output format
  * 1. Converts the CSV content into either a Javascript object or a text file with a specified syntax (JSON, Turtle, XML) and makes the result available through asyncrhonous callbacks 
  *
  *  The method can either be used as an asynchronous function through callbacks, or as a Deferred object.
  * 
  * @example
  * Simple, asynchronous usage:

       $.getCSV(&quot;http://www.example.org&quot;, function(csv_data) {
         // display the CSV data; by default, the data is a javascript object
         display(csv_data.data[&quot;Col1&quot;]);
         display(csv_data.data[&quot;Col2&quot;]);
         ...
       });
   
  * Using JSON output, and display the result in a &#x60;&#x60;&lt;pre&gt;&#x60;&#x60; element

       var request = { url: &quot;http://www.example.org&quot;, format: &quot;json&quot;};
       $.getCSV(request, function(csv_data) {
         $(&quot;div#example&quot;).append(&quot;&lt;pre&gt;&quot; + massage(csv_data.data) + &quot;&lt;/pre&gt;&quot;);
       });

  * Same, but using the “Promise” style, and adding an error handling

       var request = { url: &quot;http://www.example.org&quot;, format: &quot;json&quot;};
       $.getCSV(request)
         .done(function(csv_data) {
           $(&quot;div#example&quot;).append(&quot;&lt;pre&gt;&quot; + massage(csv_data.data) + &quot;&lt;/pre&gt;&quot;);
         })
         .fail( function(status,error) {
          console.log(status + &quot; &quot; + error);
         });
  *       
  *
  * @method $.getCSV
  * @async
  * @param {String or Object} options - identification of the CSV. If it is a string, it is the URL of the CSV file. If it is an object, it has the following (optional) fields:
  * @param {String} options.url - URL of csv file (required),
  * @param {String} options.delimiter - CSV delimiter character (optional, default is &#x60;&#x60;&quot;&quot;&#x60;&#x60;, ie, auto-detect)
  * @param {String} options.comments - Specifies a comment character (like &#x60;&#x60;&quot;#&quot;&#x60;&#x60;) to skip lines; &#x60;&#x60;false&#x60;&#x60; if no comment is allowed (optional, default is &#x27;#&#x27;)
  * @param {String} options.format - Expected output format (can be &quot;json&quot;, &quot;javascript&quot;, &quot;turtle&quot;, etc.; default is &quot;javascript&quot;)
  * @param {Object} options.filters - Object providing user-defined filters; each key denotes a (template) filter function. 
  * A filter is invoked with the arguments:
  * * &#x60;&#x60;var&#x60;&#x60; - String
  * * &#x60;&#x60;context&#x60;&#x60; - Template context object containing:
  *     * &#x60;&#x60;column_name&#x60;&#x60;: name of the column (used in the &#x60;&#x60;{{name}}&#x60;&#x60; part of the template tag)
  *     * &#x60;&#x60;meta&#x60;&#x60;: (cumulative) metadata object
  *     * &#x60;&#x60;row&#x60;&#x60;: array of the row being processed by the template process
  *     * &#x60;&#x60;row_index&#x60;&#x60;: index of the row being processed
  *     * &#x60;&#x60;target_format&#x60;&#x60;: target format of the template (i.e., &quot;json&quot;, &quot;turtle&quot;, &quot;xml&quot;, etc. )
  * * &#x60;&#x60;string1&#x60;&#x60; (optional) - additional string provided in the template
  * * &#x60;&#x60;string2&#x60;&#x60; (optional) - additional string provided in the template
  * * …
  * * &#x60;&#x60;stringn&#x60;&#x60; (optional) - additional string provided in the template
  *
  * The filter returns a string to be used as a replacement.
  * @param {Function} [success] - Callback to process the result, called with an input argument, i.e., result object
  * @param {Function} [failure] - Callback to process in case of HTTP errors. Function two arguments: HTTP Status code and error message
  * @return {Promise Object} - A promise with the result object of the form:
  * * &#x60;&#x60;data&#x60;&#x60;: result of the CSV conversion in the format required by the options
  * * &#x60;&#x60;meta&#x60;&#x60;: the (combined) metadata of the CSV content
  * * &#x60;&#x60;errors&#x60;&#x60;: array of error or warning messages (including possible CSV parsing errors)
  *
  * 

  */
  $.getCSV = function(options, success, failure) {
    var result = $.Deferred();

    var final_warnings = [];
    /* ----------------------- get all the input arguments --------------------- */
    // Get the URI of the file
    var url;
    if( typeof options == &quot;string&quot; ) {
      // We just got a single string that is supposed to be the final url
      url = options
    } else {
      if( options.url === undefined ) {
        // there is an error, still to be finalized how it should be handled
      } else {
        url = options.url;
      }
    }

    if( success === undefined || typeof success !== &quot;function&quot; ) {
      var success_callback = function(){};
    } else {
      var success_callback = success;
    }

    if( failure === undefined || typeof failure !== &quot;function&quot; ) {
      var failure_callback = function(){};
    } else {
      var failure_callback = failure;
    }

    /* ----------------------- Set the parser&#x27;s options --------------------- */
    // The defaults come, partially, from papaparse.js
    var settings = $.extend({
      delimiter: &quot;&quot;,  // empty: auto-detect
      header: false,
      dynamicTyping: false,
      comments: &#x27;#&#x27;,
      keepEmptyRows: false,
      format: $.CSV_format.JAVASCRIPT,
      download: false,
      filters: {}
    },options);
    filters = $.extend(settings.filters, builtin_filters);

    /* ----------------------- Start CSV processing ----------------------- */
    // Processing is part of a jQuery deferred structure on reading the CSV file
    $.get(url)
      .done(function(data, status, xhr) {

        // By getting here, the CSV data itself is available. The big deal
        // is to find the metadata!

        // Metadata #1: the file contains the header by default, but
        // it may be switched off explicitly through a header
        // As an aside, the Content-type header may also contain encoding information,
        // to be used by the CSV Parser 
        /*---- The return header may contain relevant information ----*/
        var content_type = xhr.getResponseHeader(&#x27;Content-Type&#x27;);
        var parameters = content_type.split(&quot;;&quot;);
        // No headers?
        var headers = true;
        for( var i = 0; i &lt; parameters.length; i++ ) {
          if( parameters[i].search(&#x27;header=absent&#x27;) &gt;= 0 )  {
            headers = false;
            break;
          }
        }
        // Encoding not in UTF-8?
        for( var i = 0; i &lt; parameters.length; i++ ) {
          if( parameters[i].search(&#x27;charset=&#x27;) &gt;= 0 )  {
            settings.encoding = parameters[i].split(&#x27;=&#x27;)[1];
            break;
          }
        }

        /*----- Parse the CSV data -----*/
        var pcsv = Papa.parse(data, settings);

        /*---- Find the reference to the various metadata ----*/
        /* Get the default metadata, ie, the column headers */
        var embedded_meta = default_meta(pcsv.data, url, headers);

        // Local metadata reference 
        var linked_meta_url = &quot;&quot;;
        // Return header may indicate the (local) metadata URI
        var link_header = xhr.getResponseHeader(&quot;Link&quot;);
        if( link_header !== null ) {
          var lheader = link_header.split(&quot;;&quot;);
          if( lheader.length &gt; 1 ) {
            for( var i = 0; i &lt; lheader.length; i++ ) {
              if( lheader[i] === &quot;rel=describedby&quot; ) {
                linked_meta_url = lheader[0];
                break;
              }
            }
          }
        }

        // Local metadata reference: derived name in the same directory 
        var local_meta_url = new URI(url).normalize().suffix(&quot;csvm&quot;).toString();

        // Global metadata reference: standard name in the same directory 
        var global_meta_url = new URI(url).normalize().filename(&quot;metadata&quot;).suffix(&quot;csvm&quot;).toString();
        /* ---- */

        /* ---- Get the metadata; doing a bit of jquery/promises tricks to get, possibly, the access in parallel ---- */
        // Reused the patterns in &quot;http://joseoncode.com/2011/09/26/a-walkthrough-jquery-deferred-and-promise/&quot;
        var get_metadata = function(murl) {
          var retval = $.Deferred();
          if( murl === &quot;&quot; ) {
            // Nothing to retrieve here
            retval.resolve({})
          } else {
            $.get(murl)
              .done(function (m) {
                try {
                  retval.resolve(JSON.parse(m));
                } catch(e) {
                  final_warnings.push(&quot;JSON syntax error in &quot; + murl + &quot;: &quot; + e.message);
                  retval.resolve({});
                }
              })
              .fail(function(xhr, status, error) {
                final_warnings.push(&quot;HTTP error &quot; + xhr.status + &quot; (&quot; + error + &quot;) for resource &#x27;&quot; + murl + &quot;&#x27;&quot;);
                retval.resolve({})
              });            
          }
          return retval.promise();
        };

        var get_template = function(turl) {
          var retval = $.Deferred();
          if( turl === &quot;&quot; ) {
            // Nothing to retrieve here
            retval.resolve(&quot;&quot;)
          } else {
            $.get(turl)
              .done(function (t) {
                retval.resolve(t);
              })
              .fail(function(xhr, status, error) {
                final_warnings.push(&quot;HTTP error &quot; + xhr.status + &quot; (&quot; + error + &quot;) for resource &#x27;&quot; + turl + &quot;&#x27;&quot;);
                retval.resolve(&quot;&quot;);
              });            
          }
          return retval.promise();
        };

        // The .done for the promise below fires when all the metadata are in
        // The following actions are then done:
        // - Merge all the metadata in a cascade
        // - Convert the incoming data into a Javascript Object ( ie, a JSON object per standard converted into an object...)
        // - Extract the template reference
        // - Call the user&#x27;s call back
        // We are then done...
        $.when(get_metadata(linked_meta_url), get_metadata(local_meta_url), get_metadata(global_meta_url))
          .done(function(linked_meta, local_meta, global_meta){
            // These should be merged
            var final_meta = mergeMeta(embedded_meta, linked_meta, local_meta, global_meta);
            var required_template = get_template_data(settings, final_meta);

            get_template(required_template.url)
              .done( function(template) {
                // We finally arrived at the core: make the conversion of the CSV content to whatever the user wants...
                var final_data = convertCSV(pcsv.data, final_meta, template, required_template.format, final_warnings);
                retval = {
                  data      : final_data,
                  meta      : final_meta,
                  errors    : final_warnings.concat(pcsv.errors)
                }
                success_callback(retval);
                result.resolve(retval);                
              })
          });
      })
      .fail( function(xhr, status, error) {
        failure_callback(xhr.status, error);
        result.reject(xhr.status, error);
      });    
    return result.promise();
  };
}(jQuery));


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
