<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>The Languages of Thot</title>
</head>

<body>

<div class="frontmatter" align="center">
<h1>The Languages of Thot</h1>

<h3>Vincent Quint</h3>

<h4>Translated from French by Ethan Munson</h4>

<h4>Version of March 24, 2005</h4>

<p>© 1996-2004 INRIA</p>
<hr />
</div>

<div class="tableofcontents">
<h2><a href="languages.toc.html">Contents</a></h2>
<ul>
  <li><big><a href="#sect2">The document model of Thot</a></big>
    <ul>
      <li><strong><a href="#sectb21">The logical structure of
        documents</a></strong></li>
      <li><strong><a href="#sectb22">Generic and specific
        structures</a></strong></li>
      <li><strong><a href="#sectb23">Logical structure and physical
        structure</a></strong></li>
      <li><strong><a href="#sectb24">Document structures and object
        structures</a></strong></li>
    </ul>
  </li>
  <li><big><a href="#sect3">The S language</a></big>
    <ul>
      <li><strong><a href="#sectb31">Document meta-structure</a></strong>
        <ul>
          <li><a href="#sectc311">The basic types</a></li>
          <li><a href="#sectc312">Constructed elements</a></li>
          <li><a href="#sectc313">Logical structure constructors</a>
            <ul>
              <li><small><a href="#sectd3131">Aggregate and
              List</a></small></li>
              <li><small><a href="#sectd3132">Choice, Schema, and
                Unit</a></small></li>
              <li><small><a href="#sectd3133">Reference and
                Inclusion</a></small></li>
              <li><small><a href="#sectd3134">Mark pairs</a></small></li>
              <li><small><a href="#sectd3135">Restrictions and
                Extensions</a></small></li>
              <li><small><a href="#sectd3136">Summary</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc315">Attributes</a></li>
          <li><a href="#sectc316">Discussion of the model</a></li>
        </ul>
      </li>
      <li><strong><a href="#sectb32">The definition language for generic
        structures</a></strong>
        <ul>
          <li><a href="#sectc321">Writing Conventions</a></li>
          <li><a href="#sectc322">Extension schemas</a></li>
          <li><a href="#sectc323">The general organization of structure
            schemas</a></li>
          <li><a href="#sectc324">The default presentation</a></li>
          <li><a href="#sectc325">Global Attributes</a></li>
          <li><a href="#sectc327">Structured elements</a></li>
          <li><a href="#sectc328">Structure definitions</a>
            <ul>
              <li><small><a href="#sectd3281">List</a></small></li>
              <li><small><a href="#sectd3282">Aggregate</a></small></li>
              <li><small><a href="#sectd3283">Choice</a></small></li>
              <li><small><a href="#sectd3284">Reference</a></small></li>
              <li><small><a href="#sectd3285">Mark pairs</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc329">Imports</a></li>
          <li><a href="#sectc3210">Extension rules</a></li>
          <li><a href="#sectc3212">Units</a></li>
          <li><a href="#sectc3213">Skeleton elements</a></li>
          <li><a href="#sectc3214">Exceptions</a></li>
        </ul>
      </li>
      <li><strong><a href="#sectb33">Some examples</a></strong>
        <ul>
          <li><a href="#sectc331">A class of documents: articles</a></li>
          <li><a href="#sectc332">A class of objects: mathematical
            formulas</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><big><a href="#sect4">The P language</a></big>
    <ul>
      <li><strong><a href="#sectb41">Document presentation</a></strong>
        <ul>
          <li><a href="#sectc411">Two levels of presentation</a></li>
          <li><a href="#sectc412">Boxes</a></li>
          <li><a href="#sectc413">Views and visibility</a></li>
          <li><a href="#sectc414">Pages</a></li>
          <li><a href="#sectc415">Numbering</a></li>
          <li><a href="#sectc416">Presentation properties</a></li>
        </ul>
      </li>
      <li><strong><a href="#sectb42">Presentation description
        language</a></strong>
        <ul>
          <li><a href="#sectc421">The organization of a presentation
            schema</a></li>
          <li><a href="#sectc422">Views</a></li>
          <li><a href="#sectc423">Print Views</a></li>
          <li><a href="#sectc424">Counters</a></li>
          <li><a href="#sectc425">Presentation constants</a></li>
          <li><a href="#sectc426">Variables</a></li>
          <li><a href="#sectc427">Default presentation rules</a></li>
          <li><a href="#sectc428">Presentation and page layout boxes</a></li>
          <li><a href="#sectc429">Presentation of structured elements</a></li>
          <li><a href="#sectc4210">Logical attribute presentation</a></li>
          <li><a href="#sectc4212">Value transmission rules</a></li>
          <li><a href="#sectc4213">Presentation rules</a></li>
          <li><a href="#sectc4214">Conditions applying to presentation
            rules</a>
            <ul>
              <li><small><a href="#sectd42141">Conditions based on the
                logical position of the element</a></small></li>
              <li><small><a href="#sectd421411">Conditions based on the
                element type</a></small></li>
              <li><small><a href="#sectd42142">Conditions on
                references</a></small></li>
              <li><small><a href="#sectd42143">Conditions on logical
                attributes</a></small></li>
              <li><small><a href="#sectd42144">Conditions on page
                breaks</a></small></li>
              <li><small><a href="#sectd42145">Conditions on the element's
                content</a></small></li>
              <li><small><a href="#sectd42146">Conditions on
                counters</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc4215">A presentation rule</a></li>
          <li><a href="#sectc4216">Box axes</a></li>
          <li><a href="#sectc4217">Distance units</a></li>
          <li><a href="#sectc4218">Relative positions</a></li>
          <li><a href="#Floats">Floats</a></li>
          <li><a href="#sectc4219">Box extents</a>
            <ul>
              <li><small><a href="#sectd42191">Fixed extents</a></small></li>
              <li><small><a href="#sectd42192">Relative
              extents</a></small></li>
              <li><small><a href="#sectd42193">Elastic
              extents</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc4220">Overflow</a></li>
          <li><a href="#sectc4221">Inheritance</a></li>
          <li><a href="#sectc4222">Line breaking</a>
            <ul>
              <li><small><a href="#sectd42221">Line spacing</a></small></li>
              <li><small><a href="#sectd42222">First line
                indentation</a></small></li>
              <li><small><a href="#sectd42223">Alignment</a></small></li>
              <li><small><a href="#sectd42225">Hyphenation</a></small></li>
              <li><small><a href="#sectd422251">Writing
              direction</a></small></li>
              <li><small><a href="#sectd42226">Avoiding line
                breaking</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc4223">Page breaking and line breaking
            conditions</a></li>
          <li><a href="#Controllin">Controlling style of lists</a>
            <ul>
              <li><a href="#litype">List item type</a></li>
              <li><a href="#liimage">List item image</a></li>
              <li><a href="#liposition">List item position</a></li>
            </ul>
          </li>
          <li><a href="#sectc4224">Visibility</a></li>
          <li><a href="#sectc4225">Character style properties</a>
            <ul>
              <li><small><a href="#sectd42251">Character size</a></small></li>
              <li><small><a href="#sectd42252">Font and character
                style</a></small></li>
              <li><small><a href="#sectd42253">Underlining</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc4226">Stacking order</a></li>
          <li><a href="#sectc4227">Line style</a></li>
          <li><a href="#sectc4228">Line thickness</a></li>
          <li><a href="#sectc4229">Fill pattern</a></li>
          <li><a href="#sectc4230">Colors</a></li>
          <li><a href="#sectc4230a">Background color and border</a></li>
          <li><a href="#sectc4230b">Background pictures</a></li>
          <li><a href="#sectc4230c">Opacity</a></li>
          <li><a href="#sectc4231">Presentation box content</a></li>
          <li><a href="#sectc4232">Presentation box creation</a></li>
          <li><a href="#sectc4233">Page layout</a></li>
          <li><a href="#sectc4234">Box copies</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><big><a href="#sect5">The T language</a></big>
    <ul>
      <li><strong><a href="#sectb51">Document translation</a></strong>
        <ul>
          <li><a href="#sectc511">Translation principles</a></li>
          <li><a href="#sectc512">Translation procedure</a></li>
        </ul>
      </li>
      <li><strong><a href="#sectb52">Translation definition
        language</a></strong>
        <ul>
          <li><a href="#sectc521">Organization of a translation
          schema</a></li>
          <li><a href="#sectc522">Line length</a></li>
          <li><a href="#sectc523">Buffers</a></li>
          <li><a href="#sectc524">Counters</a></li>
          <li><a href="#sectc525">Constants</a></li>
          <li><a href="#sectc526">Variables</a></li>
          <li><a href="#sectc527">Translating structure elements</a></li>
          <li><a href="#sectc528">Conditional rules</a>
            <ul>
              <li><small><a href="#sectd5281">Conditions based on the logical
                position of the element</a></small></li>
              <li><small><a href="#sectd5282">Conditions on
                references</a></small></li>
              <li><small><a href="#sectd5284">Conditions on the
                scripts</a></small></li>
              <li><small><a href="#sectd5285">Conditions on page
                breaks</a></small></li>
              <li><small><a href="#sectd5286">Conditions on the element's
                content</a></small></li>
              <li><small><a href="#sectd5288">Conditions on the presence of
                specific presentation rules</a></small></li>
              <li><small><a href="#sectd5289">Conditions on the presence of
                logical attributes</a></small></li>
              <li><small><a href="#sectd52810">Conditions on logical
                attributes</a></small></li>
              <li><small><a href="#sectd52811">Conditions on specific
                presentation rules</a></small></li>
            </ul>
          </li>
          <li><a href="#sectc529">Translation rules</a></li>
          <li><a href="#sectc5210">The <tt>Create</tt> rule</a></li>
          <li><a href="#sectc5211">The <tt>Write</tt> rule</a></li>
          <li><a href="#sectc5212">The <tt>Read</tt> rule</a></li>
          <li><a href="#sectc5213">The <tt>Include</tt> rule</a></li>
          <li><a href="#sectc5214">The <tt>Get</tt> rule</a></li>
          <li><a href="#sectc5215">The <tt>Copy</tt> rule</a></li>
          <li><a href="#sectc5216">The <tt>Use</tt> rule</a></li>
          <li><a href="#sectc5217">The <tt>Remove</tt> rule</a></li>
          <li><a href="#sectc5217a">The <code>Ignore</code> rule</a></li>
          <li><a href="#sectc5218">The <tt>NoTranslation</tt> rule</a></li>
          <li><a href="#sectc5219">The <tt>NoLineBreak</tt> rule</a></li>
          <li><a href="#sectc5220">The <tt>ChangeMainFile</tt> rule</a></li>
          <li><a href="#sectc5220a">The <tt>RemoveFile</tt> rule</a></li>
          <li><a href="#sectc5221">The <tt>Set</tt> and <tt>Add</tt>
          rules</a></li>
          <li><a href="#sectc5221a">The <tt>Indent</tt> rule</a></li>
          <li><a href="#sectc5222">Rule application order</a></li>
          <li><a href="#sectc5223">Translation of logical attributes</a></li>
          <li><a href="#sectc5224">Translation of specific
          presentations</a></li>
          <li><a href="#sectc5225">Recoding of characters, symbols and
            graphics</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><big><a href="#sect6">Language grammars</a></big>
    <ul>
      <li><strong><a href="#sectb61">The M meta-language</a></strong></li>
      <li><strong><a href="#sectb62">The S language</a></strong></li>
      <li><strong><a href="#sectb63">The P language</a></strong></li>
      <li><strong><a href="#sectb64">The T language</a></strong></li>
    </ul>
  </li>
  <li><big><a href="#sect7">Character coding</a></big>
    <ul>
      <li><strong><a href="#sectb71">Characters</a></strong></li>
      <li><strong><a href="#sectb72">Symbols</a></strong></li>
      <li><strong><a href="#sectb73">Graphical elements</a></strong></li>
    </ul>
  </li>
</ul>
<hr />
</div>

<div class="chapter">
<h1><a name="sect2" id="sect2">The document model of Thot</a></h1>

<p>All of the services which Thot provides to the user are based on the
system's internal document representation. This representation is itself
derived from the document model which underlies Thot. The model is presented
here, prior to the description of the languages which permit the generic
specification of documents.</p>

<div class="section">
<h2><a name="sectb21" id="sectb21">The logical structure of documents</a></h2>

<p>The document model of Thot is primarily designed to allow the user to
operate on those entities which s/he has in mind when s/he works on a
document. The model makes no assumptions about the nature of these entities.
It is essentially these logical entities, such as paragraphs, sections,
chapters, notes, titles, and cross-references which give a document its
logical structure.</p>

<p>Because of this model, the author can divide the document into chapters,
giving each one a title. The content of these chapters can be further divided
into sections, subsections, etc. The text is organized into successive
paragraphs, according to the content. In the writing phase, the lines, pages,
margins, spacing, fonts, and character styles are not very important. In
fact, if the system requires documents to be written in these terms, it gets
in the way. So, Thot's model is primarily based on the logical aspect of
documents. The creation of a model of this type essentially requires the
definition :</p>
<ul>
  <li>of the entities which can appear in the documents,</li>
  <li>and the relations between these entities.</li>
</ul>

<p>The choice of entities to include in the model can be subtle. Some
documents require chapters, while others only need various levels of
sections. Certain documents contain appendices, others don't. In different
documents the same logical entity may go by different names (e.g.
``Conclusion'' and ``Summary''). Certain entities which are absolutely
necessary in some documents, such as clauses in a contract or the address of
the recipient in a letter, are useless in most other cases.</p>

<p>The differences between documents result from more than just the entities
that appear in them, but also from the relationships between these entities
and the ways that they are linked. In certain documents, notes are spread
throughout the document, for example at the bottom of the page containing the
cross-reference to them, while in other documents they are collected at the
end of each chapter or even at the end of the work. As another example, the
introduction of some documents can contain many sections, while in other
documents, the introduction is restricted to be a short sequence of
paragraphs.</p>

<p>All of this makes it unlikely that a single model can describe any
document at a relatively high level. It is obviously tempting to make up a
list of widely used entities, such as chapters, sections, paragraphs, and
titles, and then map all other entities onto the available choices. In this
way, an introduction can be supported as a chapter and a contract clause
supported as a paragraph or section. However, in trying to widen the range of
usage of certain entities, their meaning can be lost and the power of the
model reduced. In addition, while this widening partially solves the problem
of choosing entities, it does not solve the problem of their organization:
when a chapter must be composed of sections, how does one indicate that an
introduction has none when it is merely another chapter? One solution is to
include introductions in the list of supported entities. But then, how does
one distinguish those introductions which are allowed to have sections from
those which are not. Perhaps this could be done by defining two types of
introduction. Clearly, this approach risks an infinite expansion of the list
of widely used entities.</p>
</div>

<div class="section">
<h2><a name="sectb22" id="sectb22">Generic and specific structures</a></h2>

<p>Thus, it is apparently impossible to construct an exhaustive inventory of
all those entities which are necessary and sufficient to precisely describe
any document. It also seems impossible to specify all possible arrangements
of these entities in a document. This is why Thot uses a <em>meta-model</em>
instead, which permits the description of numerous <em>models</em>, each one
describing a <em>class</em> of documents.</p>

<p>A <em>class</em> is a set of documents having very similar structure.
Thus, the collection of research reports published by a laboratory
constitutes a class; the set of commercial proposals by the sales department
of a company constitutes another class; the set of articles published by a
journal constitutes a third class. Clearly, it is not possible to enumerate
every possible document class. It is also clear that new document classes
must be created to satisfy new needs and applications.</p>

<p>To give a more rigorous definition of classes, we must introduce the ideas
of <em>generic structure</em> and <em>specific structure</em>. Each document
has a <em>specific structure</em> which organizes the various parts which
comprise it. We illustrate this with the help of a simple example comparing
two reports, A and B (<a href="#specstruct">see Figure</a>). The report A
contains an introduction followed by three chapters and a conclusion. The
first chapter contains two sections, the second, three sections. That is the
<em>specific</em> structure of document A. Similarly, the structure of
document B is: an introduction, two chapters, a conclusion; Chapter 1 has
three sections while Chapter 2 has four. The specific structures of these two
documents are thus different.</p>

<div class="figure">
<hr />
<pre>        Report A                 Report B
             Introduction              Introduction
             Chapter 1                 Chapter 1
                  Section 1.1               Section 1.1
                  Section 1.2               Section 1.2
             Chapter 2                      Section 1.3
                  Section 2.1          Chapter 2
                  Section 2.2               Section 2.1
                  Section 2.3               Section 2.2
             Chapter 3                      Section 2.3
             Conclusion                     Section 2.4
                                       Conclusion</pre>

<p align="center"><em><a name="specstruct" id="specstruct">Two specific
structures</a></em></p>
<hr />
</div>

<p>The <em>generic structure</em> defines the ways in which specific
structures can be constructed. It specifies how to generate specific
structures. The reports A and B, though different, are constructed in
accordance with the same generic structure, which specifies that a report
contains an introduction followed by a variable number of chapters and a
conclusion, with each chapter containing a variable number of sections.</p>

<p>There is a one-to-one correspondence between a class and a generic
structure: all the documents of a class are constructed in accordance with
the same generic structure. Hence the definition of the class: a class is a
set of documents whose specific structure is constructed in accordance with
the same generic structure. A class is characterized by its generic
structure.</p>

<p>Thus, a generic structure can be considered to be a model at the level
which interests us, but only for one class of documents. When the definition
is limited to a single class of documents, it is possible to define a model
which does a good job of representing the documents of the class, including
the necessary entities and unencumbered by useless entities. The description
of the organization of the documents in the class can then be sufficiently
precise.</p>
</div>

<div class="section">
<h2><a name="sectb23" id="sectb23">Logical structure and physical
structure</a></h2>

<p>Generic structures only describe the <em>logical</em> organization of
documents, not their <em>physical</em> presentation on a screen or on sheets
of paper. However, for a document to be displayed or printed, its graphic
presentation must be taken into account.</p>

<p>An examination of current printed documents shows that the details of
presentation essentially serve to bring out their logical structure. Outside
of some particular domains, notably advertising, the presentation is rarely
independent of the logical organization of the text. Moreover, the art of
typography consists of enhancing the organization of the text being set,
without catching the eye of the reader with overly pronounced effects. Thus,
italic and boldface type are used to emphasize words or expressions which
have greater significance than the rest of the text: keywords, new ideas,
citations, book titles, etc. Other effects highlight the organization of the
text: vertical space, margin changes, page breaks, centering, eventually
combined with the changes in the shapes or weight of the characters. These
effects serve to indicate the transitions between paragraphs, sections, or
chapters: an object's level in the logical structure of the document is shown
by the markedness of the effects.</p>

<p>Since the model permits the description of all of the logical structure of
the document, the presentation can be derived from the model without being
submerged in the document itself. It suffices to use the logical structure of
the document to make the desired changes in its presentation: changes in type
size, type style, spacing, margin, centering, etc.</p>

<p>Just as one cannot define a unique generic logical structure for all
document classes, one cannot define universal presentation rules which can be
applied to all document classes. For certain types of documents the chapter
titles will be centered on the page and printed in large, bold type. For
other documents, the same chapter titles will be printed in small, italic
type and aligned on the left margin.</p>

<p>Therefore, it is necessary to base the presentation specifications for
documents on their class. Such a specification can be very fine-grained,
because the presentation is expressed in terms of the entities defined in the
generic logical structure of the class. Thus, it is possible to specify a
different presentation for the chapter titles and the section titles, and
similarly to specify titles for the sections according to their level in the
section hierarchy. The set of rules which specify the presentation of all the
elements defined in a generic logical structure is called a <em>generic
presentation</em>.</p>

<p>There are several advantages derived from having a presentation linked to
the generic structure and described by a generic presentation. Homogeneity is
the first. Since every document in a class corresponds to the same generic
logical structure, a homogenous presentation for different documents of the
same class can be assured by applying the same generic presentation to all
documents of the class. Homogeneity of presentation can also be found among
the entities of a single document: every section heading will be presented in
the same way, the first line of every paragraph of the same type will have
the same indentation, etc.</p>

<p>Another advantage of this approach to presentation is that it facilitates
changes to the graphical aspect of documents. A change to the generic
presentation rules attached to each type of entity will alter the
presentation of the entire document, and will do so homogenously. In this
case, the internal homogeneity of the class is no longer assured, but the way
to control it is simple. It suffices to adopt a single generic presentation
for the entire class.</p>

<p>If the presentation of the class does not have to be homogenous, then the
appearance of the document can be adapted to the way it will be used or to
the device used to render it. This quality is sufficient to allow the
existence of <a name="mulpres" id="mulpres">many generic presentations</a>
for the same document class. By applying one or the other of these
presentations to it, the document can be seen under different graphical
aspects. It must be emphasized that this type of modification of the
presentation is not a change to the document itself (in its specific logical
structure or its content), but only in its appearance at the time of editing
or printing.</p>
</div>

<div class="section">
<h2><a name="sectb24" id="sectb24">Document structures and object
structures</a></h2>

<p>So far, we have only discussed the global structure of documents and have
not considered the contents found in that structure. We could limit ourselves
to purely textual contents by assuming that a title or a paragraph contains a
simple linear text. But this model would be too restrictive. In fact, certain
documents contain not only text, but also contain tables, diagrams,
photographs, mathematical formulas, and program fragments. The model must
permit the representation of such <em>objects</em>.</p>

<p>Just as with the whole of the document, the model takes into account the
logical structure of objects of this type. Some are clearly structured,
others are less so. Logical structure can be recognized in mathematical
formulas, in tables, and in certain types of diagrams. On the other hand, it
is difficult to define the structure of a photograph or of some drawings. But
in any case, it does not seem possible to define one unique structure which
can represent every one of these types of objects. The approach taken in the
definition of meta-structure and document classes also applies to objects.
Object classes can be defined which put together objects of similar type,
constructed from the same generic logical structure.</p>

<p>Thus, a mathematical class can be defined and have a generic logical
structure associated with it. But even if a single generic structure can
represent a sufficient variety of mathematical formulas, for other objects
with less rigorous structure, multiple classes must be defined. As for
documents, using multiple classes assures that the model can describe the
full range of objects to be presented. It also permits the system to support
objects which were not initially anticipated. Moreover, this comment applies
equally to mathematics: different classes of formulas can be described
depending on the domain of mathematics being described.</p>

<p>Since objects have the same level of logical representation as documents,
they gain the same advantages. In particular, it is possible to define the
presentation separately from the objects themselves and attach it to the
class. Thus, as for documents, objects of the same type have a uniform
presentation and the presentation of every object in a given class can be
changed simply by changing the generic presentation of the class. Another
advantage of using this document model is that the system does not bother the
user with the details of presentation, but rather allows the user to
concentrate on the logical aspect of the document and the objects.</p>

<p>It is clear that the documents in a class do not necessarily use the same
classes of objects: one technical report will contain tables while another
report will have no tables but will use mathematical formulas. The usable
object classes are not always mentioned in a limiting way in the generic
logical structure of documents. Rather, they can be chosen freely from a
large set, independent of the document class.</p>

<p>Thus, the object classes will be made commonplace and usable in every
document. The notion of ``object'' can be enlarged to include not only
non-textual elements, but also certain types of textual elements which can
appear in practically every document, whatever their class. Among these
textual elements, one can mention enumerations, descriptions, examples,
quotations, even paragraphs.</p>

<p>Thus, the document model is not a single, general model describing every
type of document in one place. Rather, it is a meta-model which can be used
to describe many different models each of which represents either a class of
similar documents or a class of similar objects which every document can
include.</p>
</div>
<hr />
</div>

<div class="chapter">
<h1><a name="sect3" id="sect3">The S language</a></h1>

<div class="section">
<h2><a name="sectb31" id="sectb31">Document meta-structure</a></h2>

<p>Since the concept of meta-structure is well suited to the task of
describing documents at a high level of abstraction, this meta-structure must
be precisely defined. Toward that end this section first presents the basic
elements from which documents and structured objects are composed and then
specifies the ways in which these basic elements are assembled into
structures representing complete documents and objects.</p>

<div class="subsection">
<h3><a name="sectc311" id="sectc311">The basic types</a></h3>

<p>At the lowest level of a document's structure, the first atom considered
is the character. However, since characters are seldom isolated, usually
appearing as part of a linear sequence, and in order to reduce the complexity
of the document structure, <em>character strings</em> are used as atoms and
consecutive characters belonging to the same structural element are grouped
in the same character string.</p>

<p>If the structure of a document is not refined to go down to the level of
words or phrases, the contents of a simple paragraph can be considered to be
a single character string. On the other hand, the title of a chapter, the
title of the first section of that chapter, and the text of the first
paragraph of that section constitute three different character strings,
because they belong to distinct structural elements.</p>

<p>If, instead, a very fine-grained representation for the structure of a
document is sought, character strings could be defined to contain only a
single word, or even just a single character. This is the case, for example,
in programs, for which one wants to retain a structure very close to the
syntax of the programming language. In this case, an assignment statement
initializing a simple variable to zero would be composed of two structural
elements, the identifier of the variable (a short character string) and the
assigned value (a string of a single character, `0').</p>

<p>The character string is not the only atom necessary for representing those
documents that interest us. It suffices for purely textual documents, but as
soon as the non-textual objects which we have considered arise, there must be
other atoms; the number of objects which are to be represented determines the
number of types of atoms that are necessary.</p>

<p>Primitive <em>graphical elements</em> are used for tables and figures of
different types. These elements are simple geometric shapes like horizontal
or vertical lines, which are sufficient for tables, or even oblique lines,
arrows, rectangles, circles, polygons, and curves for use in figures. From
these elements and character strings, graphical objects and tables can be
constructed.</p>

<p>Photographs, though having very little structure, must still appear in
documents. They are supported by <em>picture</em> elements, which are
represented as matrices of pixels.</p>

<p>Finally, mathematical notations require certain elements which are
simultaneously characters and graphical elements, the <em>symbols</em>. By
way of example, radicals, integration signs, or even large parentheses are
examples of this type of atom. The size of each of these symbols is
determined by its environment, that is to say, by the expression to which it
is attached.</p>

<p>To summarize, the primitive elements which are used in the construction of
documents and structured objects are:</p>
<ul>
  <li>character strings,</li>
  <li>graphical elements,</li>
  <li>pictures,</li>
  <li>and mathematical symbols.</li>
</ul>
</div>

<div class="subsection">
<h3><a name="sectc312" id="sectc312">Constructed elements</a></h3>

<p>A document is evidently formed from primitive elements. But the model of
Thot also proposes higher level elements. Thus, in a document composed of
several chapters, each chapter is an element, and in the chapters each
section is also an element, and so on. A document is thus an organized set of
elements.</p>

<p>In a document there are different sorts of elements. Each element has a
<em>type</em> which indicates the role of the element within the document as
a whole. Thus, we have, for example, the chapter and section types. The
document is made up of typed elements: elements of the type chapter and
elements of the type section, among others, but also character string
elements and graphical elements: the primitive elements are typed elements
just as well. At the other extreme, the document itself is also considered to
be a typed element.</p>

<p>The important difference between the primitive elements and the other
elements of the document is that the primitive elements are atoms (they
cannot be decomposed), whereas the others, called <em>constructed
elements</em>, are composed of other elements, which can either be primitive
elements or constructed elements. A constructed element of type chapter (or
more simply, ``a chapter'') is composed of sections, which are also
constructed elements. A paragraph, a constructed element, can be made up of
character strings, which are primitive elements, and of equations, which are
constructed elements.</p>

<p>A document is also a constructed element. This is an important point. In
particular, it allows a document to be treated as part of another document,
and conversely, permits a part of a document to be treated as a complete
document. Thus, an article presented in a journal is treated by its author as
a document in itself, while the editor of the journal considers it to be part
of an issue. A table or a figure appearing in a document can be extracted and
treated as a complete document, for example to prepare transparencies for a
conference.</p>

<p>These thoughts about types and constructed elements apply just as well to
objects as they do to documents. A table is a constructed element made up of
other constructed elements, rows and columns. A row is formed of cells, which
are also constructed elements which contain primitive elements (character
strings) and/or constructed elements like equations.</p>
</div>

<div class="subsection">
<h3><a name="sectc313" id="sectc313">Logical structure constructors</a></h3>

<p>Having defined the primitive elements and the constructed elements, it is
now time to define the types of organization which allow the building of
structures. For this, we rely on the notion of the <em>constructor</em>. A
constructor defines a way of assembling certain elements in a structure. It
resides at the level of the meta-structure: it does not describe the existing
relations in a given structure, but rather defines how elements are assembled
to build a structure that conforms to a model.</p>

<p>In defining the overall organization of documents, the first two
constructors considered are the aggregate and the list.</p>

<div class="subsubsection">
<h4><a name="sectd3131" id="sectd3131">Aggregate and List</a></h4>

<p>The <em>aggregate</em> constructor is used to define constructed element
types which are collections of a given number of other elements. These
collections may or may not be ordered. The elements may be either constructed
or primitive and are specified by their type. A report (that is, a
constructed element of the report type) has an aggregate structure. It is
formed from a title, an author's name, an introduction, a body, and a
conclusion, making it a collection of five element types. This type of
constructor is found in practically every document, and generally at several
levels in a document.</p>

<p>The <em>list</em> constructor is used to define constructed elements which
are ordered sequences of elements (constructed or primitive) having the same
type. The minimum and maximum numbers of elements for the sequence can be
specified in the list constructor or the number of elements can be left
unconstrained. The body of a report is a list of chapters and is typically
required to contain a minimum of two chapters (is a chapter useful if it is
the only one in the report?) The chapter itself can contain a list of
sections, each section containing a list of paragraphs. In the same way as
the aggregate, the list is a very frequently used constructor in every type
of document. However, these two constructors are not sufficient to describe
every document structure; thus other constructors supplement them.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd3132" id="sectd3132">Choice, Schema, and Unit</a></h4>

<p>The <em>choice</em> constructor is used to define the structure of an
element type for which one alternative is chosen from several possibilities.
Thus, a paragraph can be either a simple text paragraph, or an enumeration,
or a citation.</p>

<p>The choice constructor indicates the complete list of possible options,
which can be too restrictive in certain cases, the paragraph being one such
case. Two constructors, <em>unit</em> and <em>schema</em>, address this
inconvenience. They allow more freedom in the choice of an element type. If a
paragraph is defined by a schema constructor, it is possible to put in the
place of a paragraph a table, an equation, a drawing or any other object
defined by another generic logical structure. It is also possible to define a
paragraph as a sequence of units, which could be character strings, symbols,
or pictures. The choice constructor alone defines a generic logical structure
that is relatively constrained; in contrast, using units and schemas, a very
open structure can be defined.</p>

<p>The <em>schema</em> constructor represents an object defined by a generic
logical structure chosen freely from among those available.</p>

<p>The <em>unit</em> constructor represents an element whose type can be
either a primitive type or an element type defined as a unit in the generic
logical structure of the document, or in another generic logical structure
used in the document. Such an element may be used in document objects
constructed according to other generic structures.</p>

<p>Thus, for example, if a cross-reference to a footnote is defined in the
generic logical structure ``Article'' as a unit, a table (an object defined
by another generic structure) can contain cross-references to footnotes, when
they appear in an article. In another type of document, a table defined by
the same generic structure can contain other types of elements, depending on
the type of document into which the table is inserted. All that is needed is
to declare, in the generic structure for tables, that the contents of cells
are units. In this way, the generic structure of objects is divided up
between different types of documents which are able to adapt themselves to
the environment into which they are inserted.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd3133" id="sectd3133">Reference and Inclusion</a></h4>

<p>The <em>reference</em> is used to define document elements that are
cross-references to other elements, such as a section, a chapter, a
bibliographic citation, or a figure. The reference is bi-directional. It can
be used to access both the element being cross-referenced and each of the
elements which make use of the cross-reference.</p>

<p>References can be either <em>internal</em> or <em>external</em>. That is,
they can designate elements which appear in the same document or in another
document.</p>

<p>The <em><a name="inclusion" id="inclusion">inclusion</a></em> constructor
is a special type of reference. Like the reference, it is an internal or
external bidirectional link, but it is not a cross-reference. This link
represents the ``live'' inclusion of the designated element; it accesses the
most recent version of that element and not a ``dead'' copy, fixed in the
state in which it was found at the moment the copy was made. As soon as an
element is modified, all of its inclusions are automatically brought up to
date. It must be noted that, in addition to inclusion, Thot permits the
creation of ``dead'' copies.</p>

<p>There are three types of inclusions: inclusions with full expansion,
inclusions with partial expansion, and inclusions without expansion. During
editing, inclusions without expansion are represented on the screen by the
name of the included document, in a special color, while inclusions with
expansion (full or partial) are represented by a copy (full or partial) of
the included element (also in a special color). The on-screen representation
of a partial inclusion is a <a href="#sectc3213">``skeleton''</a> image of
the included document.</p>

<p>Inclusion with complete expansion can be used to include parts of the same
document or of other documents. Thus, it can be either an internal or an
external link. It can be used to include certain bibliographic entries of a
scientific article in another article, or to copy part of a mathematical
formula into another formula of the same document, thus assuring that both
copies will remain synchronized.</p>

<p>Inclusion without expansion or with partial expansion is used to include
complete documents. It is always an external link. It is used primarily to
divide very large documents into sub-documents that are easier to manipulate,
especially when there are many authors. So, a book can include some chapters,
where each chapter is a different document which can be edited separately.
When viewing the book on the screen, it might be desirable to see only the
titles of the chapters and sections. This can be achieved using inclusion
with partial expansion.</p>

<p>During printing, inclusions without expansion or with partial expansion
can be represented either as they were shown on the screen or by a complete
(and up-to-date) copy of the included element or document.</p>

<p>The inclusion constructor, whatever its type, respects the generic
structure: only those elements authorized by the generic structure can be
included at a given position in a document.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd3134" id="sectd3134">Mark pairs</a></h4>

<p>It is often useful to delimit certain parts of a document independently
from the logical structure. For example, one might wish to attach some
information (in the form of an <a href="#sectc315">attribute</a>) or a
particular treatment to a group of words or a set of consecutive paragraphs.
<em>Mark pairs</em> are used to do this.</p>

<p>Mark pairs are elements which are always paired and are terminals in the
logical structure of the document. Their position in the structure of the
document is defined in the generic structure. It is important to note that
when the terminals of a mark pair are <em>extensions</em> (see the next
section), they can be used quite freely.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd3135" id="sectd3135">Restrictions and Extensions</a></h4>

<p>The primitive types and the constructors presented so far permit the
definition of the logical structure of documents and objects in a rigorous
way. But this definition can be very cumbersome in certain cases, notably
when trying to constrain or extend the authorized element types in a
particular context. <em>Restrictions</em> and <em>extensions</em> are used to
cope with these cases.</p>

<p>A restriction associates with a particular element type <em>A</em>, a list
of those element types which elements of type <em>A</em> may not contain,
even if the definition of type <em>A</em> and those of its components
authorize them otherwise. This simplifies the writing of generic logical
structures and allows limitations to be placed, when necessary, on the
choices offered by the schema and unit constructors.</p>

<p>Extensions are the inverse of restrictions. They identify a list of
element types whose presence <em>is</em> permitted, even if its definition
and those of its components do not authorize them otherwise.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd3136" id="sectd3136">Summary</a></h4>

<p>Thus, four constructors are used to construct a document:</p>
<ul>
  <li>the aggregate constructor (ordered or not),</li>
  <li>the list constructor,</li>
  <li>the choice constructor and its extensions, the unit and schema
    constructors,</li>
  <li>the reference constructor and its variant, the inclusion.</li>
</ul>

<p>These constructors are also sufficient for objects. Thus, these
constructors provide a homogenous meta-model which can describe both the
organization of the document as a whole and that of the various types of
objects which it contains. After presenting the description language for
generic structures, we will present several examples which illustrate the
appropriateness of the model.</p>

<p>The first three constructors (aggregate, list and choice) lead to
tree-like structures for documents and objects, the objects being simply the
subtrees of the tree of a document (or even of other objects' subtrees). The
reference constructor introduces other, non-hierarchical, relations which
augment those of the tree: when a paragraph makes reference to a chapter or a
section, that relation leaves the purely tree-like structure. Moreover,
external reference and inclusion constructors permit the establishment of
links between different documents, thus creating a hypertext structure.</p>
</div>
</div>

<div class="subsection">
<h3><a name="sectc315" id="sectc315">Attributes</a></h3>

<p>There remain logical aspects of documents that are not entirely described
by the structure. Certain types of semantic information, which are not stated
explicitly in the text, must also be taken into account. In particular, such
information is shown by typographic effects which do not correspond to a
change between structural elements. In fact, certain titles are set in bold
or italic or are printed in a different typeface from the rest of the text in
order to mark them as structurally distinct. But these same effects
frequently appear in the middle of continuous text (e.g. in the interior of a
paragraph). In this case, there is no change between structural elements; the
effect serves to highlight a word, expression, or phrase. The notion of an
<em>attribute</em> is used to express this type of information.</p>

<p>An attribute is a piece of information attached to a structural element
which augments the type of the element and clarifies its function in the
document. Keywords, foreign language words, and titles of other works can all
be represented by character strings with attached attributes. Attributes may
also be attached to constructed elements. Thus, an attribute indicating the
language can be attached to a single word or to a large part of a
document.</p>

<p>In fact, an attribute can be any piece of information which is linked to a
part of a document and which can be used by agents which work on the
document. For example, the language in which the document is written
determines the set of characters used by an editor or formatter. It also
determines the algorithm or hyphenation dictionary to be used. The attribute
``keyword'' facilitates the work of an information retrieval system. The
attribute ``index word'' allows a formatter to automatically construct an
index at the end of the document.</p>

<p>As with the types of constructed elements, the attributes and the values
they can take are defined separately in each generic logical structure, not
in the meta-model, according to the needs of the document class or the nature
of the object.</p>

<p>Many types of attributes are offered: numeric, textual, references, and
enumerations:</p>
<ul>
  <li><em>Numeric attributes</em> can take integer values (negative,
    positive, or null).</li>
  <li><em>Textual attributes</em> have as their values character strings.</li>
  <li><em>Reference attributes</em> designate an element of the logical
    structure.</li>
  <li><em>Enumeration attributes</em> can take one value from a limited list
    of possible values, each value being a name.</li>
</ul>

<p>In a generic structure, there is a distinction between <em>global
attributes</em> and <em>local attributes</em>. A global attribute can be
applied to every element type defined in the generic structure where it is
specified. In contrast, a local attribute can only be applied to certain
types of elements, even only a single type. The ``language'' attribute
presented above is an example of a global attribute. An example of a local
attribute is the rank of an author (principal author of the document or
secondary author): this attribute can only be applied sensibly to an element
of the ``author'' type.</p>

<p>Attributes can be assigned to the elements which make up the document in
many different ways. The author can freely and dynamically place them on any
part of the document in order to attach supplementary information of his/her
choice. However, attributes may only be assigned in accordance with the rules
of the generic structure; in particular, local attributes can only be
assigned to those element types for which they are defined.</p>

<p>In the generic structure, certain local attributes can be made mandatory
for certain element types. In this case, Thot automatically associates the
attribute with the elements of this type and it requires the user to provide
a value for this attribute.</p>

<p>Attributes can also be automatically assigned, with a given value, by
every application processing the document in order to systematically add a
piece of information to certain predefined elements of the document. By way
of example, in a report containing a French abstract and an English abstract,
each of the two abstracts is defined as a sequence of paragraphs. The first
abstract has a value of ``French'' for the ``language'' attribute while the
second abstract's ``language'' attribute has a value of ``English''.</p>

<p>In the case of mark pairs, attributes are logically associated with the
pair as a whole, but are actually attached to the first mark.</p>
</div>

<div class="subsection">
<h3><a name="sectc316" id="sectc316">Discussion of the model</a></h3>

<p>The notions of attribute, constructor, and structured element are used in
the definition of generic logical structures of documents and objects. The
problem is to assemble them to form generic structures. In fact, many types
of elements and attributes can be found in a variety of generic structures.
Rather than redefine them for each structure in which they appear, it is best
to share them between structures. The object classes already fill this
sharing function. If a mathematical class is defined, its formulas can be
used in many different document classes, without redefining the structure of
each class. This problem arises not only for the objects considered here; it
also arises for the commonplace textual elements found in many document
classes. This is the reason why the notion of object is so broad and why
paragraphs and enumerations are also considered to be objects. These object
classes not only permit the sharing of the structures of elements, but also
of the attributes defined in the generic structures.</p>

<p>Structure, such as that presented here, can appear very rigid, and it is
possible to imagine that a document editing system based on this model could
prove very constraining to the user. This is, in fact, a common criticism of
syntax-directed editors. This defect can be avoided with Thot, primarily for
three reasons:</p>
<ul>
  <li>the generic structures are not fixed in the model itself,</li>
  <li>the model takes the dynamics of documents into account,</li>
  <li>the constructors offer great flexibility.</li>
</ul>

<p>When the generic structure of a document is not predefined, but rather is
constructed specifically for each document class, it can be carefully adapted
to the current needs. In cases where the generic structure is inadequate for
a particular document of the class, it is always possible either to create a
new class with a generic structure well suited to the new case or to extend
the generic structure of the existing class to take into account the
specifics of the document which poses the problem. These two solutions can
also be applied to objects whose structures prove to be poorly designed.</p>

<p>The model is sufficiently flexible to take into account all the phases of
the life of the document. When a generic structure specifies that a report
must contain a title, an abstract, an introduction, at least two chapters,
and a conclusion, this means only that a report, <em>upon completion</em>,
will have to contain all of these elements. When the author begins writing,
none of these elements is present. Thot uses this model. Therefore, it
tolerates documents which do not conform strictly to the generic structure of
their class; it also considers the generic logical structure to be a way of
helping the user in the construction of a complex document.</p>

<p>In contrast, other applications may reject a document which does not
conform strictly to its generic structure. This is, for example, what is done
by compilers which refuse to generate code for a program which is not
syntactically correct. This might also occur when using a document
application for a report which does not have an abstract or title.</p>

<p>The constructors of the document model bring a great flexibility to the
generic structures. A choice constructor (and even more, a unit or schema
constructor) can represent several, very different elements. The list
constructor permits the addition of more elements of the same type. Used
together, these two constructors permit any series of elements of different
types. Of course, this flexibility can be reduced wherever necessary since a
generic structure can limit the choices or the number of elements in a
list.</p>

<p>Another difficulty linked to the use of structure in the document model
resides in the choice of the level of the structure. The structure of a
discussion could be extracted from the text itself via linguistic analysis.
Some studies are exploring this approach, but the model of Thot excludes this
type of structure. It only takes into account the logical structure provided
explicitly by the author.</p>

<p>However, the level of structure of the model is not imposed. Each generic
structure defines its own level of structure, adapted to the document class
or object and to the ways in which it will be processed. If it will only be
edited and printed, a relatively simple structure suffices. If more
specialized processing will be applied to it, the structure must represent
the element types on which this processing must act. By way of example, a
simple structure is sufficient for printing formulas, but a more complex
structure is required to perform symbolic or numeric calculations on the
mathematical expressions. The document model of Thot allows both types of
structure.</p>
</div>
</div>

<div class="section">
<h2><a name="sectb32" id="sectb32">The definition language for generic
structures</a></h2>

<p>Generic structures, which form the basis of the document model of Thot,
are specified using a special language. This definition language, called S,
is described in this section.</p>

<p>Each generic structure, which defines a class of documents or objects, is
specified by a file, written in the S language, which is called a
<em>structure schema</em>. Structure schemas are compiled into tables, called
structure tables, which are used by Thot and which determine its behavior.</p>

<div class="subsection">
<h3><a name="sectc321" id="sectc321">Writing Conventions</a></h3>

<p>The grammar of S, like those of the languages P and T presented later, is
described using the meta-language M, derived from the Backus-Naur Form
(BNF).</p>

<p>In this meta-language each rule of the grammar is composed of a grammar
symbol followed by an equals sign (`=') and the right part of the rule. The
equals sign plays the same role as the traditional `::=' of BNF: it indicates
that the right part defines the symbol of the left part. In the right
part,</p>
<dl>
  <dt>concatenation</dt>
    <dd>is shown by the juxtaposition of symbols;</dd>
  <dt>character strings</dt>
    <dd>between apostrophes ' represent terminal symbols, that is, keywords
      in the language defined. Keywords are written here in upper-case
      letters, but can be written in any combination of upper and lower-case
      letters. For example, the keyword <tt>DEFPRES</tt> of S can also be
      written as <tt>defpres</tt> or <tt>DefPres</tt>.</dd>
  <dt>material between brackets</dt>
    <dd>(`[' and `]') is optional;</dd>
  <dt>material between angle brackets</dt>
    <dd>(`&lt;' and `&gt;') can be repeated many times or omitted;</dd>
  <dt>the slash</dt>
    <dd>(`/') indicates an alternative, a choice between the options
      separated by the slash character;</dd>
  <dt>the period</dt>
    <dd>marks the end of a rule;</dd>
  <dt>text between braces</dt>
    <dd>(`{' and `}') is simply a comment.</dd>
</dl>

<p>The M meta-language also uses the concepts of identifiers, strings, and
integers:</p>
<dl>
  <dt><tt>NAME</tt></dt>
    <dd>represents an identifier, a sequence of letters (upper or
      lower-case), digits, and underline characters (`_'), beginning with a
      letter. Also considered a letter is the sequence of characters
      `<tt>\nnn</tt>' where the letter <tt>n</tt> represents the ISO Latin-1
      code of the letter in octal. It is thus possible to use accented
      letters in identifiers. The maximum length of identifiers is fixed by
      the compiler. It is normally 31 characters.
      <p>Unlike keywords, upper and lower-case letters are distinct in
      identifiers. Thus, <tt>Title</tt>, <tt>TITLE</tt>, and <tt>title</tt>
      are considered different identifiers.</p>
    </dd>
  <dt><tt>STRING</tt></dt>
    <dd>represents a string. This is a string of characters delimited by
      apostrophes. If an apostrophe must appear in a string, it is doubled.
      As with identifiers, strings can contain characters represented by
      their octal code (after a backslash). As with apostrophes, if a
      backslash must appear in a string, it is doubled.</dd>
  <dt><tt>NUMBER</tt></dt>
    <dd>represents a positive integer or zero (without a sign), or said
      another way, a sequence of decimal digits.</dd>
</dl>

<p>The M language can be used to define itself as follows:</p>
<pre>{ Any text between braces is a comment. }
Grammar      = Rule &lt; Rule &gt; 'END' .
               { The &lt; and &gt; signs indicate zero }
               { or more repetitions. }
               { END marks the end of the grammar. }
Rule         = Ident '=' RightPart '.' .
               { The period indicates the end of a rule }
RightPart    = RtTerminal / RtIntermed .
               { The slash indicates a choice }
RtTerminal   ='NAME' / 'STRING' / 'NUMBER' .
               { Right part of a terminal rule }
RtIntermed   = Possibility &lt; '/' Possibility &gt; .
               { Right part of an intermediate rule }
Possibility  = ElemOpt &lt; ElemOpt &gt; .
ElemOpt      = Element / '[' Element &lt; Element &gt; ']' /
              '&lt;' Element &lt; Element &gt; '&gt;'  .
               { Brackets delimit optional parts }
Element      = Ident / KeyWord .
Ident        = NAME .
               { Identifier, sequence of characters }
KeyWord      = STRING .
               { Character string delimited by apostrophes }
END</pre>
</div>

<div class="subsection">
<h3><a name="sectc322" id="sectc322">Extension schemas</a></h3>

<p>A structure schema defines the generic logical structure of a class of
documents or objects, independent of the operations which can be performed on
the documents. However, certain applications may require particular
information to be represented by the structure for the documents that they
operate on. Thus a document version manager will need to indicate in the
document the parts which belong to one version or another. An indexing system
will add highly-structured index tables as well as the links between these
tables and the rest of the document.</p>

<p>Thus, many applications need to extend the generic structure of the
documents on which they operate to introduce new attributes or element types.
These additions are specific to each application and must be able to be
applied to any generic structure: users will want to manage versions or
construct indices for many types of documents. Extension schemas fulfill this
role: they define attributes, elements, units, etc., but they can only be
used jointly with a structure schema that they complete. Otherwise, structure
schemas can always be used without these extensions when the corresponding
applications are not available.</p>
</div>

<div class="subsection">
<h3><a name="sectc323" id="sectc323">The general organization of structure
schemas</a></h3>

<p>Every structure schema begins with the keyword <tt>STRUCTURE</tt> and ends
with the keyword <tt>END</tt>. The keyword <tt>STRUCTURE</tt> is followed by
the keyword <tt>EXTENSION</tt> in the case where the schema defines an
extension, then by the name of the generic structure which the schema defines
(the name of the document or object class). The name of the structure is
followed by a semicolon.</p>

<p>In the case of a complete schema (that is, a schema which is not an
extension), the definition of the name of the structure is followed by the
declarations of the default presentation schema, the global attributes, the
structure rules, the units, the skeleton elements and the exceptions. Only
the definition of the structure rules is required. Each series of
declarations begins with a keyword: <tt>DEFPRES</tt>, <tt>ATTR</tt>,
<tt>STRUCT</tt>, <tt>UNITS</tt>, <tt>EXPORT</tt>, <tt>EXCEPT</tt>.</p>

<p>In the case of an extension schema, there are no skeleton elements and the
<tt>STRUCT</tt> section is optional, while that section is required in a
schema that is not an extension. On the other hand, extension schemas can
contain an <tt>EXTENS</tt> section, which must not appear in a schema which
is not an extension; this section defines the complements to attach to the
rules found in the schema to which the extension will be added. The sections
<tt>ATTR</tt>, <tt>STRUCT</tt>, and <tt>UNITS</tt> define new attributes, new
elements, and new units which add their definitions to the principal
schema.</p>
<pre>     StructSchema ='STRUCTURE' ElemID ';'
                   'DEFPRES' PresID ';'
                 [ 'ATTR' AttrSeq ]
                   'STRUCT' RulesSeq
                 [ 'UNITS' RulesSeq ]
                 [ 'EXPORT' SkeletonSeq ]
                 [ 'EXCEPT' ExceptSeq ]
                   'END' .
     ElemID       = NAME .</pre>

<p>or</p>
<pre>     ExtensSchema ='STRUCTURE' 'EXTENSION' ElemID ';'
                   'DEFPRES' PresID ';'
                 [ 'ATTR' AttrSeq ]
                 [ 'STRUCT' RulesSeq ]
                 [ 'EXTENS' ExtensRuleSeq ]
                 [ 'UNITS' RulesSeq ]
                 [ 'EXCEPT' ExceptSeq ]
                   'END' .
     ElemID       = NAME .</pre>
</div>

<div class="subsection">
<h3><a name="sectc324" id="sectc324">The default presentation</a></h3>

<p>It was shown <a href="#mulpres">above</a> that many different
presentations are possible for documents and objects of the same class. The
structure schema defines a preferred presentation for the class, called the
<em>default presentation</em>. Like generic structures, presentations are
described by programs, called <em>presentation schemas</em>, which are
written in a specific language, P, presented <a href="#sectb42">later</a> in
this document. The name appearing after the keyword <tt>DEFPRES</tt> is the
name of the default presentation schema. When a new document is created, Thot
will use this presentation schema by default, but the user remains free to
choose another if s/he wishes.</p>
<pre>     PresID = NAME .</pre>
</div>

<div class="subsection">
<h3><a name="sectc325" id="sectc325">Global Attributes</a></h3>

<p>If the generic structure includes global attributes of its own, they are
declared after the keyword <tt>ATTR</tt>. Each global attribute is defined by
its name, followed by an equals sign and the definition of its type. The
declaration of a global attribute is terminated by a semi-colon.</p>

<p>For attributes of the numeric, textual, or reference types, the type is
indicated by a keyword, <tt>INTEGER</tt>, <tt>TEXT</tt>, or
<tt>REFERENCE</tt> respectively.</p>

<p>In the case of a reference attribute, the keyword <tt>REFERENCE</tt> is
followed by the type of the referenced element in parentheses. It can refer
to any type at all, specified by using the keyword <tt>ANY</tt>, or to a
specific type. In the latter case, the element type designated by the
reference can be defined either in the <a href="#sectc327"><tt>STRUCT</tt>
section</a> of the same structure schema or in the <tt>STRUCT</tt> section of
another structure schema. When the type is defined in another schema, the
element type is followed by the name of the structure schema (within
parentheses) in which it is defined. The name of the designated element type
can be preceded by the keyword <tt>First</tt> or <tt>Second</tt>, but only in
the case where the type is defined as <a href="#sectd3285">a pair</a>. These
keywords indicate whether the attribute must designate the first mark of the
pair or the second. If the reference refers to a pair and neither of these
two keywords is present, then the first mark is used.</p>

<p>In the case of an enumeration attribute, the equals sign is followed by
the list of names representing the possible values of the attribute, the
names being separated from each other by commas. An enumeration attribute has
at least one possible value; the maximum number of values is defined by the
compiler for the S language.</p>
<pre>     AttrSeq   = Attribute &lt; Attribute &gt; .
     Attribute = AttrID '=' AttrType  ';' .
     AttrType  = 'INTEGER' / 'TEXT' /
                 'REFERENCE' '(' RefType ')' /
                 ValueSeq .
     RefType   = 'ANY' / [ FirstSec ] ElemID [ ExtStruct ] .
     FirstSec  = 'First' / 'Second' .
     ExtStruct = '(' ElemID ')' .
     ValueSeq  = AttrVal &lt; ',' AttrVal &gt; .
     AttrID    = NAME .
     AttrVal   = NAME .</pre>

<p>There is a predefined global text attribute, the <em>language</em>, which
is automatically added to every Thot structure schema. This attribute allows
Thot to perform certain actions, such as hyphenation and spell-checking,
which cannot be performed without knowing the language in which each part of
the document is written. This attribute can be used just like any explicitly
declared attribute: the system acts as if every structure schema contains</p>
<pre>ATTR
   Language = TEXT;</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following specification defines the global enumeration attribute
  WordType.</p>
  <pre>ATTR
   WordType = Definition, IndexWord, DocumentTitle;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc327" id="sectc327">Structured elements</a></h3>

<p>The rules for defining structured elements are required, except in an
extension schema: they constitute the core of a structure schema, since they
define the structure of the different types of elements that occur in a
document or object of the class defined by the schema.</p>

<p>The first structure rule after the keyword <tt>STRUCT</tt> must define the
structure of the class whose name appears in the first instruction
(<tt>STRUCTURE</tt>) of the schema. This is the root rule of the schema,
defining the root of the document tree or object tree.</p>

<p>The remaining rules may be placed in any order, since the language permits
the definition of element types before or after their use, or even in the
same instruction in which they are used. This last case allows the definition
of recursive structures.</p>

<p>Each rule is composed of a name (the name of the element type whose
structure is being defined) followed by an equals sign and a structure
definition.</p>

<p>If any local attributes are associated with the element type defined by
the rule, they appear between parentheses after the type name and before the
equals sign. The parentheses contain, first, the keyword <tt>ATTR</tt>, then
the list of local attributes, separated by commas. Each local attribute is
composed of the name of the attribute followed by an equals sign and the
definition of the attribute's type, just as in the definition of <a
href="#sectc325">global attributes</a>. The name of the attribute can be
preceded by an exclamation point to indicate that the attribute must always
be present for this element type. The same attribute, identified by its name,
can be defined as a local attribute for multiple element types. In this case,
the equals sign and definition of the attribute type need only appear in the
first occurrence of the attribute. It should be noted that global attributes
cannot also be defined as local attributes.</p>

<p>If any <a href="#sectd3135">extensions</a> are defined for this element
type, a plus sign follows the structure definition and the names of the
extension element types appear between parentheses after the plus. If there
are multiple extensions, they are separated by commas. These types can either
be defined in the same schema, defined in other schemas, or they may be base
types identified by the keywords <tt>TEXT</tt>, <tt>GRAPHICS</tt>,
<tt>SYMBOL</tt>, or <tt>PICTURE</tt>.</p>

<p><a href="#sectd3135">Restrictions</a> are indicated in the same manner as
extensions, but they are introduced by a minus sign and they come after the
extensions, or if there are no extensions, after the structure definition.</p>

<p>If the values of attributes must be attached systematically to this
element type, they are introduced by the keyword <tt>WITH</tt> and declared
in the form of a list of fixed-value attributes. When such definitions of
fixed attribute values appear, they are always the last part of the rule.</p>

<p>The rule is terminated by a semicolon.</p>
<pre>  RuleSeq       = Rule &lt; Rule &gt; .
  Rule          = ElemID [ LocAttrSeq ] '=' DefWithAttr ';'.
  LocAttrSeq    = '(' 'ATTR' LocAttr &lt; ';' LocAttr &gt; ')' .
  LocAttr       = [ '!' ] AttrID [ '=' AttrType ] .
  DefWithAttr   = Definition
                  [ '+' '(' ExtensionSeq ')' ]
                  [ '-' '(' RestrictSeq ')' ]
                  [ 'WITH' FixedAttrSeq ] .
  ExtensionSeq  = ExtensionElem &lt; ',' ExtensionElem &gt; .
  ExtensionElem = ElemID / 'TEXT' / 'GRAPHICS' /
                  'SYMBOL' / 'PICTURE' .
  RestrictSeq   = RestrictElem &lt; ',' RestrictElem &gt; .
  RestrictElem  = ElemID / 'TEXT' / 'GRAPHICS' /
                  'SYMBOL' / 'PICTURE' .</pre>

<p>The list of fixed-value attributes is composed of a sequence of
attribute-value pairs separated by commas. Each pair contains the name of the
attribute and the fixed value for this element type, the two being separated
by an equals sign. If the sign is preceded by a question mark the given value
is only an initial value that may be modified later rather than a value fixed
for all time. Reference attributes are an exception to this norm. They cannot
be assigned a fixed value, but when the name of such an attribute appears
this indicates that this element type must have a valid value for the
attribute. For the other attribute types, the fixed value is indicated by a
signed integer (numeric attributes), a character string between apostrophes
(textual attributes) or the name of a value (enumeration attributes).</p>

<p>Fixed-value attributes can either be <a href="#sectc325">global</a> or
local to the element type for which they are fixed, but they must be declared
before they are used.</p>
<pre>    FixedAttrSeq    = FixedAttr &lt; ',' FixedAttr &gt; .
    FixedAttr       = AttrID [ FixedOrModifVal ] .
    FixedOrModifVal = [ '?' ] '=' FixedValue .
    FixedValue      = [ '-' ] NumValue / TextVal / AttrVal .
    NumValue        = NUMBER .
    TextVal         = STRING .</pre>
</div>

<div class="subsection">
<h3><a name="sectc328" id="sectc328">Structure definitions</a></h3>

<p>The structure of an element type can be a simple base type or a
constructed type.</p>

<p>For constructed types, it is frequently the case that similar structures
appear in many places in a document. For example the contents of the
abstract, of the introduction, and of a section can have the same structure,
that of a sequence of paragraphs. In this case, a single, common structure
can be defined (the paragraph sequence in this example), and the schema is
written to indicate that each element type possesses this structure, as
follows:</p>
<pre>     Abstract           = Paragraph_sequence;
     Introduction       = Paragraph_sequence;
     Section_contents   = Paragraph_sequence;</pre>

<p>The equals sign means ``has the same structure as''.</p>

<p>If the element type defined is a simple base type, this is indicated by
one of the keywords <tt>TEXT</tt>, <tt>GRAPHICS</tt>, <tt>SYMBOL</tt>, or
<tt>PICTURE</tt>. If some local attributes must be associated with a base
type, the keyword of the base type is followed by the declaration of the
local attributes using the syntax <a href="#sectc327">presented above.</a></p>

<p>In the case of an open choice, the type is indicated by the keyword
<tt>UNIT</tt> for units or the keyword <tt>NATURE</tt> for objects having a
structure defined by any other schema.</p>

<p>A unit represents one of the two following categories:</p>
<ul>
  <li>a base type: text, graphical element, symbol, picture,</li>
  <li>an element whose type is chosen from among the types defined as units
    in the <tt>UNITS</tt> section of the document's structure schema. It can
    also be chosen from among the types defined as <a
    href="#sectd3132">units</a> in the <a href="#sectc3212"><tt>UNITS</tt>
    section</a> of the structure schemas that defines the ancestors of the
    element to which the rule is applied.</li>
</ul>

<p>Before the creation of an element defined as a unit, Thot asks the user to
choose between the categories of elements.</p>

<p>Thus, the contents of a paragraph can be specified as a sequence of units,
which will permit the inclusion in the paragraphs of character strings,
symbols, and various elements, such as cross-references, if these are defined
as units.</p>

<p>A schema object (keyword <tt>NATURE</tt>) represents an object defined by
a structure schema freely chosen from among the available schemas; in the
case the element type is defined by the first rule (the root rule) of the
chosen schema.</p>

<p>If the element type defined is a constructed type, the list, aggregate,
choice, and reference constructors are used. In this case the definition
begins with a keyword identifying the constructor. This keyword is followed
by a syntax specific to each constructor.</p>

<p>The local attribute definitions appear after the name of the element type
being defined, if this element type has <a href="#sectc327">local
attributes</a>.</p>
<pre>   Definition = BaseType [ LocAttrSeq ] / Constr / Element .
   BaseType   = 'TEXT' / 'GRAPHICS' / 'SYMBOL' / 'PICTURE' /
                'UNIT' / 'NATURE' .
   Element    = ElemID [ ExtOrDef ] .
   ExtOrDef   = 'EXTERN' / 'INCLUDED' / 
                [ LocAttrSeq ] '=' Definition .
   Constr     = 'LIST' [ '[' min '..' max ']' ] 'OF'
                       '(' DefWithAttr ')' /
                'BEGIN' DefOptSeq 'END' /
                'AGGREGATE' DefOptSeq 'END' /
                'CASE' 'OF' DefSeq 'END' /
                'REFERENCE' '(' RefType ')' /
                'PAIR' .</pre>

<div class="subsubsection">
<h4><a name="sectd3281" id="sectd3281">List</a></h4>

<p>The list constructor permits the definition of an element type composed of
a list of elements, all of the same type. A list definition begins with the
<tt>LIST</tt> keyword followed by an optional range, the keyword <tt>OF</tt>,
and the definition, between parentheses, of the element type which must
compose the list. The optional range is composed of the minimum and maximum
number of elements for the list separated by two periods and enclosed by
brackets. If the range is not present, the number of list elements is
unconstrained. When only one of the two bounds of the range is unconstrained,
it is represented by a star ('*') character. Even when both bounds are
unconstrained, they can be specified by <tt>[*..*]</tt>, but it is simpler
not to specify any bound.</p>
<pre>               'LIST' [ '[' min '..' max ']' ]
               'OF' '(' DefWithAttr ')'
     min     = Integer / '*' .
     max     = Integer / '*' .
     Integer = NUMBER .</pre>

<p>Before the document is edited, Thot creates the minimum number of elements
for the list. If no minimum was given, it creates a single element. If a
maximum number of elements is given and that number is attained, the editor
refuses to create new elements for the list.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following two instructions define the body of a document as a
  sequence of at least two chapters and the contents of a section as a
  sequence of paragraphs. A single paragraph can be the entire contents of a
  section.</p>
  <pre>Body             = LIST [2..*] OF (Chapter);
Section_contents = LIST OF (Paragraph);</pre>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd3282" id="sectd3282">Aggregate</a></h4>

<p>The aggregate constructor is used to define an element type as a
collection of sub-elements, each having a fixed type. The collection may be
ordered or unordered. The elements composing the collection are called
<em>components</em>. In the definition of an aggregate, a keyword indicates
whether or not the aggregate is ordered: <tt>BEGIN</tt> for an ordered
aggregate, <tt>AGGREGATE</tt> for an unordered aggregate. This keyword is
followed by the list of component type definitions which is terminated by the
<tt>END</tt> keyword. The component type definitions are separated by
commas.</p>

<p>Before creating an aggregate, the Thot editor creates all the aggregate's
components in the order they appear in the structure schema, even for
unordered aggregates. However, unlike ordered aggregates, the components of
an unordered aggregate may be rearranged using operations of the Thot editor.
The exceptions to the rule are any components whose name was preceded by a
question mark character ('?'). These components, which are optional, can be
created by explicit request, possibly at the time the aggregate is created,
but they are not created automatically <em>prior</em> to the creation of the
aggregate.</p>
<pre>                 'BEGIN' DefOptSeq 'END'
     DefOptSeq = DefOpt ';' &lt; DefOpt ';' &gt; .
     DefOpt    = [ '?' ] DefWithAttr .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>In a bilingual document, each paragraph has an English version and a
  French version. In certain cases, the translator wants to add a marginal
  note, but this note is present in very few paragraphs. Thus, it must not be
  created systematically for every paragraph. A bilingual paragraph of this
  type is declared:</p>
  <pre>Bilingual_paragraph = BEGIN
                      French_paragraph  = TEXT;
                      English_paragraph = TEXT;
                      ? Note            = TEXT;
                      END;</pre>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd3283" id="sectd3283">Choice</a></h4>

<p>The choice constructor permits the definition of an element type which is
chosen from among a set of possible types. The keywords <tt>CASE</tt> and
<tt>OF</tt> are followed by a list of definitions of possible types, which
are separated by semicolons and terminated by the <tt>END</tt> keyword.</p>
<pre>               'CASE' 'OF' DefSeq 'END'
     DefSeq = DefWithAttr ';' &lt; DefWithAttr ';' &gt; .</pre>

<p>Before the creation of an element defined as a choice, the Thot editor
presents the list of possible types for the element to the user. The user has
only to select the element type that s/he wants to create from this list.</p>

<p>The order of the type declarations is important. It determines the order
of the list presented to the user before the creation of the element. Also,
when a Choice element is being created automatically, the first type in the
list is used. In fact, using the Thot editor, when an empty Choice element is
selected, it is possible to select this element and to enter its text from
keyboard. In this case, the editor uses the first element type which can
contain an atom of the character string type.</p>

<p>The two special cases of the choice constructor, the <a
href="#sectc328"><em>schema</em></a> and the <a
href="#sectc3212"><em>unit</em></a> are discussed elsewhere.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>It is common in documents to treat a variety of objects as if they were
  ordinary paragraphs. Thus, a ``Paragraph'' might actually be composed of a
  block of text (an ordinary paragraph), or a mathematical formula whose
  structure is defined by another structure schema named Math, or a table,
  also defined by another structure schema. Here is a definition of such a
  paragraph:</p>
  <pre>Paragraph = CASE OF
              Simple_text = TEXT;
              Formula     = Math;
              Table_para  = Table;
              END;</pre>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd3284" id="sectd3284">Reference</a></h4>

<p>Like all elements in Thot, references are typed. An element type defined
as a reference is a cross-reference to an element of some other given type.
The keyword <tt>REFERENCE</tt> is followed by the name of a type enclosed in
parentheses. When the type which is being cross-referenced is defined in
another structure schema, the type name is itself followed by the name of the
external structure schema in which it is defined.</p>

<p>When the designated element type is a <a href="#sectd3285">mark pair</a>,
it can be preceded by a <tt>FIRST</tt> or <tt>SECOND</tt> keyword. These
keywords indicate whether the reference points to the first or second mark of
the pair. If the reference points to a pair and neither of these two keywords
is present, the reference is considered to point to the first mark of the
pair.</p>

<p>There is an exception to the principle of typed references: it is possible
to define a reference which designates an element of any type, which can
either be in the same document or another document. In this case, it suffices
to put the keyword <tt>ANY</tt> in the parentheses which indicate the
referenced element type.</p>
<pre>             'REFERENCE' '(' RefType ')'
   RefType = 'ANY' / [ FirstSec ] ElemID [ ExtStruct ] .</pre>

<p>When defining an inclusion, the <tt>REFERENCE</tt> keyword is not used.
Inclusions with complete expansion are not declared as such in the structure
schemas, since any element defined in a structure schema can be replaced by
an element of the same type. Instead, inclusions without expansion or with
partial expansion must be declared explicitly whenever they will include a
complete object ( and not a part of an object). In this case, the object type
to be included (that is, the name of its structure schema) is followed by a
keyword: <tt>EXTERN</tt> for inclusion without expansion and
<tt>INCLUDED</tt> for partial expansion.</p>

<p>Before creating a cross-reference or an inclusion, the Thot editor asks
the user to choose, from the document images displayed, the referenced or
included element.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If the types Note and Section are defined in the Article structure
  schema, it is possible to define, in the same structure schema, a reference
  to a note and a reference to a section in this manner:</p>
  <pre>Ref_note    = REFERENCE (Note);
Ref_section = REFERENCE (Section);</pre>

  <p>It is also possible to define the generic structure of a collection of
  articles, which include (with partial expansion) objects of the Article
  class and which possess an introduction which may include cross-references
  to sections of the included articles. In the Collection structure schema,
  the definitions are:</p>
  <pre>Collection = BEGIN
             Collection_title = TEXT;
             Introduction = LIST OF (Elem = CASE OF
                                           TEXT;
                                           Ref_sect;
                                           END);
             Body = LIST OF (Article INCLUDED);
             END;
Ref_sect   = REFERENCE (Section (Article));</pre>

  <p>Here we define a Folder document class which has a title and includes
  documents of different types, particularly Folders:</p>
  <pre>Folder   = BEGIN
           Folder_title    = TEXT;
           Folder_contents = LIST OF (Document);
           END;

Document = CASE OF
              Article EXTERN;
              Collection EXTERN;
              Folder EXTERN;
              END;</pre>

  <p>Under this definition, Folder represents either an aggregate which
  contains a folder title and the list of included documents or an included
  folder. To resolve this ambiguity, in the P language, the placement of a
  star character in front of the type name (here, Folder) indicates an
  included document.</p>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd3285" id="sectd3285">Mark pairs</a></h4>

<p>Like other elements, mark pairs are typed. The two marks of the pair have
the same type, but there exist two predefined subtypes which apply to all
mark pairs: the first mark of the pair (called <tt>First</tt> in the P and T
languages) and the second mark (called <tt>Second</tt>).</p>

<p>In the S language, a mark pair is noted simply by the <tt>PAIR</tt>
keyword.</p>

<p>In the Thot editor, marks are always moved or destroyed together. The two
marks of a pair have the same identifier, unique within the document, which
permits intertwining mark pairs without risk of ambiguity.</p>
</div>
</div>

<div class="subsection">
<h3><a name="sectc329" id="sectc329">Imports</a></h3>

<p>Because of schema constructors, it is possible, before editing a document,
to use classes defined by other structure schemas whenever they are needed.
It is also possible to assign specific document classes to certain element
types. In this case, these classes are simply designated by their name. In
fact, if a type name is not defined in the structure schema, it is assumed
that it specifies a structure defined by another structure schema.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If the types Math and Table don't appear in the left part of a structure
  rule in the schema, the following two rules indicate that a formula has the
  structure of an object defined by the structure schema Math and that a
  table element has the structure of an object defined by the Table
  schema.</p>
  <pre>Formula    = Math;
Table_elem = Table;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc3210" id="sectc3210">Extension rules</a></h3>

<p>The <tt>EXTENS</tt> section, which can only appear in an extension schema,
defines complements to the rules in the primary schema (i.e. the structure
schema to which the extension schema will be applied). More precisely, this
section permits the addition to an existing type of local attributes,
extensions, restrictions and fixed-value attributes.</p>

<p>These additions can be applied to the root rule of the primary schema,
designated by the keyword <tt>Root</tt>, or to any other explicitly named
rule.</p>

<p>Extension rules are separated from each other by a semicolon and each
extension rule has the same syntax as a <a href="#sectc327">structure
rule</a>, but the part which defines the constructor is absent.</p>
<pre>     ExtenRuleSeq = ExtensRule ';' &lt; ExtensRule ';' &gt; .
     ExtensRule   = RootOrElem [ LocAttrSeq ]
                    [ '+' '(' ExtensionSeq ')' ]
                    [ '-' '(' RestrictSeq ')' ]
                    [ 'WITH' FixedAttrSeq ] .
     RootOrElem   = 'Root' / ElemID .</pre>
</div>

<div class="subsection">
<h3><a name="sectc3212" id="sectc3212">Units</a></h3>

<p>The <tt>UNITS</tt> section of the structure schema contains the
declarations of the element types which can be used in the external objects
making up parts of the document or in objects of the class defined by the
schema. These element types are defined just like other structured element
types. They can be used in the other element types of the schema, but they
can also be used in any other rule of the schema.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If references to notes are declared as units:</p>
  <pre>UNITS
   Ref_note = REFERENCE (Note);</pre>

  <p>then it is possible to use references to notes in a cell of a table,
  even when <tt>Table</tt> is an external structure schema. The
  <tt>Table</tt> schema must declare a cell to be a sequence of units, which
  can then be base element types (text, for example) or references to notes
  in the document.</p>
  <pre>Cell = LIST OF (UNITS);</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc3213" id="sectc3213">Skeleton elements</a></h3>

<p>When editing a document which contains or must contain external references
to several other documents, it may be necessary to load a large number of
documents, simply to see the parts designated by the external references of
the document while editing, or to access the source of included elements. In
this case, the external documents are not modified and it is only necessary
to see the elements of these documents which could be referenced. Because of
this, the editor will suggest that the documents be loaded in ``skeleton''
form. This form contains only the elements of the document explicitly
mentioned in the <tt>EXPORT</tt> section of their structure schema and, for
these elements, only the part of the contents specified in that section. This
form has the advantage of being very compact, thus requiring very few
resources from the editor. This is also the skeleton form which constitutes
the expanded form of <a href="#inclusion">inclusions</a> with partial
expansion.</p>

<p>Skeleton elements must be declared explicitly in the <tt>EXPORT</tt>
section of the structure schema that defines them. This section begins with
the keyword <tt>EXPORT</tt> followed by a comma-separated list of the element
types which must appear in the skeleton form and ending with a semicolon.
These types must have been previously declared in the schema.</p>

<p>For each skeleton element type, the part of the contents which is loaded
by the editor, and therefore displayable, can be specified by putting the
keyword <tt>WITH</tt> and the name of the contained element type to be loaded
after the name of the skeleton element type. In this case only that named
element, among all the elements contained in the exportable element type,
will be loaded. If the <tt>WITH</tt> is absent, the entire contents of the
skeleton element will be loaded by the editor. If instead, it is better that
the skeleton form not load the contents of a particular element type, the
keyword <tt>WITH</tt> must be followed by the word <tt>Nothing</tt>.</p>
<pre>                [ 'EXPORT' SkeletonSeq ]

     SkeletonSeq = SkelElem &lt; ',' SkelElem &gt; ';' .
     SkelElem    = ElemID [ 'WITH' Contents ] .
     Contents    = 'Nothing' / ElemID [ ExtStruct ] .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that, in documents of the article class, the element types
  Article_title, Figure, Section, Paragraph, and Biblio should appear in the
  skeleton form in order to make it easier to create external references to
  them from other documents. When loading an article in its skeleton form,
  all of these element types will be loaded except for paragraphs, but only
  the article title will be loaded in its entirety. For figures, the caption
  will be loaded, while for sections, the title will be loaded, and for
  bibliographic entries, only the title that they contain will be loaded.
  Note that bibliographic elements are defined in another structure schema,
  RefBib. To produce this result, the following declarations should be placed
  in the Article structure schema:</p>
  <pre>EXPORT
   Article_title,
   Figure With Caption,
   Section With Section_title,
   Paragraph With Nothing,
   Biblio With Biblio_title(RefBib);</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc3214" id="sectc3214">Exceptions</a></h3>

<p>The behavior of the Thot editor and the actions that it performs are
determined by the structure schemas. These actions are applied to all
document and object types in accordance with their generic structure. For
certain object types, such as tables and graphics, these actions are not
sufficient or are poorly adapted and some special actions must be added to or
substituted for certain standard actions. These special actions are called
<em>exceptions</em>.</p>

<p>Exceptions only inhibit or modify certain standard actions, but they can
be used freely in every structure schema.</p>

<p>Each structure schema can contain a section defining exceptions. It begins
with the keyword <tt>EXCEPT</tt> and is composed of a sequence of exception
declarations, separated by semicolons. Each declaration of an exception
begins with the name of an element type or attribute followed by a colon.
This indicates the element type or attribute to which the following
exceptions apply. When the given element type name is a <a
href="#sectd3285">mark pair</a>, and only in this case, the type name can be
preceded by the keyword <tt>First</tt> or <tt>Second</tt>, to indicate if the
exceptions which follow are associated with the first mark of the pair or the
second. In the absence of this keyword, the first mark is used.</p>

<p>When placed in an <a href="#sectc322">extension schema</a>, the keyword
<tt>EXTERN</tt> indicates that the type name which follows is found in the
principal schema (the schema being extended by the extension schema). The
exceptions are indicated by a name. They are separated by semicolons.</p>
<pre>                  [ 'EXCEPT' ExceptSeq ]

     ExceptSeq     = Except ';' &lt; Except ';' &gt; .
     Except        = [ 'EXTERN' ] [ FirstSec ] ExcTypeOrAttr
                     ':' ExcValSeq .
     ExcTypeOrAttr = ElemID / AttrID .
     ExcValSeq     = ExcValue &lt; ',' ExcValue &gt; .
     ExcValue      ='NoCut' / 'CanCut' / 'NoCreate' / 'NoReplicate' /
                    'NoHMove' / 'NoVMove' / 'NoMove' /
                    'NoHResize' / 'NoVResize' / 'NoResize' /
                    'MoveResize' /
                    'NewWidth' / 'NewHeight' / 'NewPercentWidth' /
                    'NewHPos' / 'NewVPos' /
                    'Invisible' / 'Hidden' /
                    'PageBreak' / 'PageBreakAllowed' / 'PageBreakPlace' /
                    'PageBreakRepetition' / 'PageBreakRepBefore' /
                    'NoPaginate' / 'NoSpellCheck' /
                    'ActiveRef' /  'NoSelect' /
                    'HighlightChildren' / 'ExtendedSelection' /
                    'SelectParent' / 'ClickableSurface' /
                    'ParagraphBreak' / 'IsBreak' /
                    'ReturnCreateNL' / 'ReturnCreateWithin' / 'NoBreakByReturn' /
                    'ImportLine' / 'ImportParagraph' /
                    'GraphCreation' / 'IsDraw' / 'IsGroup' / 'EmptyGraphic' /
                    'IsTable' / 'IsRow' / 'IsColHead' / 'IsCell' /
                    'ColRef' / 'ColSpan' / 'RowSpan' /
                    'CssBackground' / 'CssClass' / 'CssId' / 'CssPseudoClass' /
                    'NoShowBox' / 'SetWindowBackground' /
                    'Shadow' / 'EventAttr' / 'SpacePreserve' /
                    'IsPlaceholder' / 'StartCounter' / 'SetCounter' /
                    ExceptNum .</pre>

<p>The following are the available exceptions:</p>
<dl>
  <dt><tt>NoCut</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be deleted by the
      editor.</dd>
  <dt><tt>CanCut</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied can be deleted by the
      editor, even if they are not marked as optional in an aggregate.</dd>
   <dt><tt>NoCreate</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be created by ordinary
      commands for creating new elements. These elements are usually created
      by special actions associated with other exceptions.</dd>
  <dt><tt>NoReplicate</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be duplicated by
      pressing the Return key. A default element (such as a paragraph) is
      created instead.</dd>
  <dt><tt>NoHMove</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be moved horizontally
      with the mouse. Their children elements cannot be moved either.</dd>
  <dt><tt>NoVMove</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be moved vertically with
      the mouse. Their children elements cannot be moved either.</dd>
  <dt><tt>NoMove</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be moved in any
      direction with the mouse. Their children elements cannot be moved
      either.</dd>
  <dt><tt>NoHResize</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be resized horizontally
      with the mouse. Their children elements cannot be resized either.</dd>
  <dt><tt>NoVResize</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be resized vertically
      with the mouse. Their children elements cannot be resized either.</dd>
  <dt><tt>NoResize</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be resized in any
      direction with the mouse. Their children elements cannot be resized
      either.</dd>
  <dt><tt>MoveResize</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied can be moved and resized in any
      direction with the mouse, even if one of their ancestor element has an
      exception that prevents moving or resizing. Their children elements can
      also be resized or moved.</dd>
  <dt><tt>NewWidth</tt></dt>
    <dd>This exception can only be applied to numeric attributes. If the
      width of an element which has this attribute is modified with the
      mouse, the value of the new width will be assigned to the
    attribute.</dd>
  <dt><tt>NewHeight</tt></dt>
    <dd>This exception can only be applied to numeric attributes. If the
      height of an element which has this attribute is modified with the
      mouse, the value of the new height will be assigned to the
    attribute.</dd>
  <dt><tt>NewPercentWidth</tt></dt>
    <dd>@@@@@</dd>
  <dt><tt>NewHPos</tt></dt>
    <dd>This exception can only be applied to numeric attributes. If the
      horizontal position of an element which has this attribute is modified
      with the mouse, the value of the new horizontal position will be
      assigned to the attribute.</dd>
  <dt><tt>NewVPos</tt></dt>
    <dd>This exception can only be applied to numeric attributes. If the
      vertical position of an element which has this attribute is modified
      with the mouse, the value of the new vertical position will be assigned
      to the attribute.</dd>
  <dt><tt>Invisible</tt></dt>
    <dd>This exception can only be applied to attributes, but can be applied
      to all attribute types. It indicates that the attribute must not be
      seen by the user and that its value must not be changed directly. This
      exception is usually used when another exception manipulates the value
      of an attribute.</dd>
  <dt><tt>Hidden</tt></dt>
    <dd>This exception can only be applied to element types. It indicates
      that elements of this type, although present in the document's
      structure, must not be shown to the user of the editor. In particular,
      the creation menus must not propose this type and the selection message
      must not pick it.</dd>
  <dt><tt>PageBreak</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>PageBreakAllowed</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>PageBreakPlace</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>PageBreakRepetition</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>PageBreakRepBefore</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>NoPaginate</tt></dt>
    <dd>This exception can only be applied to the root element, i.e. the name
      that appear after the keyword <tt>STRUCTURE</tt> at the beginning of
      the structure schema. It indicates that the editor should not allow the
      user to paginate documents of that type.</dd>
  <dt>NoSpellCheck</dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied are not taken into account by
      the spell checker.</dd>
  <dt><tt>ActiveRef</tt></dt>
    <dd>This exception can only be applied to attributes of the reference
      type. It indicates that when the user of the editor makes a double
      click on an element which possesses a reference attribute having this
      exception, the element designated by the reference attribute will be
      selected.</dd>
  <dt><tt>NoSelect</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied cannot be selected directly
      with the mouse, but they can be selected by other methods provided by
      the editor.</dd>
  <dt><tt>HighlightChildren</tt></dt>
    <dd>This exception can only be applied to element types. Elements of a
      type to which this exception is applied are not highlighted themselves
      when they are selected in the main view, but all their children are
      highlighted instead. If children have this exception too, the process
      is applied recursively. Only the main view defined in the presentation
      schema is concerned. Tee exception is ignored for other views.</dd>
  <dt><tt>ExtendedSelection</tt></dt>
    <dd>This exception can only be applied to element types. The selection
      extension command (middle button of the mouse) only add the clicked
      element (if it has that exception) to the current selection, without
      selecting other elements between the current selection and the clicked
      element.</dd>
  <dt><code>SelectParent</code></dt>
    <dd>This exception can only be applied to element types. When the user
      clicks on an element of that type, the parent of the element is
      selected instead of the element itself.</dd>
  <dt><code>ClickableSurface</code></dt>
    <dd>This exception can only be applied to element types. When the user
      clicks within a child of an element of that type, this child is
      selected even if it is a graphic leaf that is not filled.</dd>
  <dt><tt>ParagraphBreak</tt></dt>
    <dd>This exception can only be applied to element types. When the caret
      is within an element of a type to which this exception is applied, it
      is that element that will be split when the user hits the Return
    key.</dd>
  <dt><code>IsBreak</code></dt>
    <dd>This exception can only be applied to element types. When an element
      with this exception is selected, pressing the Return key breaks the
      enclosing element (typically a paragraph) into two pieces.</dd>
  <dt><tt>ReturnCreateNL</tt></dt>
    <dd>This exception can only be applied to element types. When the caret
      is within an element of a type to which this exception is applied, the
      Return key simply inserts a New line character (code \212) at the
      current position. The Return key does not create a new element; it does
      not split the current element either.</dd>
  <dt><tt>ReturnCreateWithin</tt></dt>
    <dd>This exception can only be applied to element types. When the caret
      is within an element of a type to which this exception is applied, the
      Return key will create a new element within that element, not a sibling
      after that element.</dd>
  <dt><tt>NoBreakByReturn</tt></dt>
    <dd>This exception can only be applied to element types. When the caret
      is in an empty element, child of an element of a type to which this
      exception is applied, the Return key will not split the element, but
      will create a new empty element after the current empty element.</dd>
  <dt><tt>ImportLine</tt></dt>
    <dd>This exception can only be applied to element types. It indicates
      that elements of this type should receive the content of imported text
      files. An element is created for each line of the imported file. A
      structure schema cannot contain several exceptions <tt>ImportLine</tt>
      and, if it contains one, it should not contain any exception
      <tt>ImportParagraph</tt>.</dd>
  <dt><tt>ImportParagraph</tt></dt>
    <dd>This exception can only be applied to element types. It indicates
      that elements of this type should receive the content of imported text
      files. An element is created for each paragraph of the imported file. A
      paragraph is a sequence of lines without any empty line. A structure
      schema cannot contain several exceptions <tt>ImportParagraph</tt> and,
      if it contains one, it should not contain any exception
      <tt>ImportLine</tt>.</dd>
  <dt><tt>GraphCreation</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>EmptyGraphic</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>IsDraw</tt>, <tt>IsGroup</tt>, <tt>IsTable</tt>, <tt>IsRow</tt>,
  <tt>IsColHead</tt>, <tt>IsCell</tt></dt>
    <dd>These exceptions can only be applied to element types. Elements of a
      type to which these exceptions are applied are identified as Draws,
      Tables, Colheads, Rows or Cells and specific processing are applied to
      them.</dd>
  <dt><tt>ColRef</tt></dt>
    <dd>This exception can only be applied to attributes of the reference
      type. It indicates that this attribute refers to the column head (see
      exception IsColHead) which the element belongs to.</dd>
  <dt><tt>ColSpan</tt>, <tt>RowSpan</tt></dt>
    <dd>These exceptions can only be applied to numeric attributes of cells.
      They indicate that attribute values give how many columns or rows the
      element spans.</dd>
  <dt><tt>CssBackground</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>CssClass</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>CssId</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>CssPseudoClass</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>NoShowBox</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>SetWindowBackground</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>Shadow</tt></dt>
    <dd>This exception can only be applied to element types. Text of elements
      of a type to which this exception is applied are displayed and printed
      as a set of stars ('*').</dd>
  <dt><tt>EventAttr</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>SpacePreserve</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>IsPlaceholder</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>StartCounter</tt></dt>
    <dd>@@@@</dd>
  <dt><tt>SetCounter</tt></dt>
    <dd>@@@@</dd>
</dl>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Consider a structure schema for object-style graphics which defines the
  Graphic_object element type with the associated Height and Weight numeric
  attributes. Suppose that we want documents of this class to have the
  following qualities:</p>
  <ul>
    <li>Whenever the width or height of an object is changed using the mouse,
      the new values are stored in the object's Width and Height
    attributes.</li>
    <li>The user should not be able to change the values of the Width and
      Height attributes via the Attributes menu of the Thot editor.</li>
  </ul>

  <p>The following exceptions will produce this effect.</p>
  <pre>STRUCT
...
   Graphics_object (ATTR Height = Integer; Width = Integer)
       = GRAPHICS with Height ?= 10, Width ?= 10;
...
EXCEPT
   Height: NewHeight, Invisible;
   Width: NewWidth, Invisible;</pre>
</blockquote>
</div>
</div>

<div class="section">
<h2><a name="sectb33" id="sectb33">Some examples</a></h2>

<p>In order to illustrate the principles of the document model and the syntax
of the S language, this section presents two examples of structure schemas.
One defines a class of documents, the other defines a class of objects.</p>

<div class="subsection">
<h3><a name="sectc331" id="sectc331">A class of documents: articles</a></h3>

<p>This example shows a possible structure for articles published in a
journal. Text between braces is comments.</p>
<pre>STRUCTURE Article;  { This schema defines the Article class }
DEFPRES ArticleP;   { The default presentation schema is
                      ArticleP }
ATTR                { Global attribute definitions }
   WordType = Definition, IndexWord, DocumentTitle;
   { A single global attribute is defined, with three values }
STRUCT              { Definition of the generic structure }
   Article = BEGIN  { The Article class has an aggregate
                      structure }
             Title = BEGIN   { The title is an aggregate }
                     French_title = 
                         Text WITH Language='Fran\347ais';
                     English_title =
                         Text WITH Language='English';
                     END;
             Authors = 
               LIST OF (Author
                 (ATTR Author_type=principal,secondary)
                 { The Author type has a local attribute }
                 = BEGIN
                   Author_name = Text;
                   Info = Paragraphs ;
                   { Paragraphs is defined later }
                   Address    = Text;
                   END
                 );
             Keywords = Text;
             { The journal's editor introduces the article
               with a short introduction, in French and
               in English }
             Introduction = 
                 BEGIN
                 French_intr  = Paragraphs WITH
                                Language='Fran\347ais';
                 English_intr = Paragraphs WITH
                                Language='English';
                 END;
             Body = Sections; { Sections are defined later }
                   { Appendixes are only created on demand }
           ? Appendices = 
                 LIST OF (Appendix =
                          BEGIN
                          Appendix_Title    = Text;
                          Appendix_Contents = Paragraphs;
                          END
                         );
           ? Figures = LIST OF (Figure);
           ? Bibliography = LIST OF (Biblio_citation);
           ? Notes = LIST OF (Note);
             END;      { End of the Article aggregate }

    Sections = LIST [2..*] OF (
                 Section = { At least 2 sections }
                 BEGIN
                 Section_title   = Text;
                 Section_contents =
                   BEGIN
                   Paragraphs;
                   Sections; { Sections at a lower level }
                   END;
                 END
                 );

    Paragraphs = LIST OF (Paragraph = CASE OF
                               Enumeration = 
                                   LIST [2..*] OF
                                       (Item = Paragraphs);
                               Isolated_formula = Formula;
                               LIST OF (UNIT);
                               END
                          );

   Figure = BEGIN
            Figure_caption  = Text;
            Illustration   = NATURE;
            END;

   Biblio_citation = CASE OF
                        Ref_Article =
                           BEGIN
                           Authors_Bib   = Text;
                           Article_Title = Text;
                           Journal       = Text;
                           Page_Numbers  = Text;
                           Date          = Text;
                           END;
                        Ref_Livre =
                           BEGIN
                           Authors_Bib; { Defined above }
                           Book_Title   = Text;
                           Editor       = Text;
                           Date;        { Defined above }
                           END;
                       END;

   Note =  Paragraphs - (Ref_note);

UNITS      { Elements which can be used in objects }

   Ref_note    = REFERENCE (Note);
   Ref_biblio  = REFERENCE (Biblio_citation);
   Ref_figure  = REFERENCE (Figure);
   Ref_formula = REFERENCE (Isolated_formula);

EXPORT     { Skeleton elements }

   Title,
   Figure with Figure_caption,
   Section With Section_title;

END           { End of the structure schema }</pre>

<p>This schema is very complete since it defines both paragraphs and
bibliographic citations. These element types could just as well be defined in
other structure schemas, as is the case with the <tt>Formula</tt> class. All
sorts of other elements can be inserted into an article, since a paragraph
can contain any type of unit. Similarly, figures can be any class of document
or object that the user chooses.</p>

<p>Generally, an article doesn't contain appendices, but it is possible to
add them on explicit request: this is the effect of the question mark before
the word Appendices.</p>

<p>Various types of cross-references can be put in paragraphs. They can also
be placed the objects which are part of the article, since the
cross-references are defined as units (<tt>UNITS</tt>).</p>

<p>There is a single restriction to prevent the creation of Ref_note elements
within notes.</p>

<p>It is worth noting that the S language permits the definition of recursive
structures like sections: a section can contain other sections (which are
thus at the next lower level of the document tree). Paragraphs are also
recursive elements, since a paragraph can contain an enumeration in which
each element (<tt>Item</tt>) is composed of paragraphs.</p>
</div>

<div class="subsection">
<h3><a name="sectc332" id="sectc332">A class of objects: mathematical
formulas</a></h3>

<p>The example below defines the <tt>Formula</tt> class which is used in
Article documents. This class represents mathematical formulas with a rather
simple structure, but sufficient to produce a correct rendition on the screen
or printer. To support more elaborate operations (formal or numeric
calculations), a finer structure should be defined. This class doesn't use
any other class and doesn't define any units.</p>
<pre>STRUCTURE Formula;
DEFPRES FormulaP;

ATTR
   String_type = Function_name, Variable_name;

STRUCT
   Formula      = Expression;
   Expression   = LIST OF (Construction);
   Construction = CASE OF
                  TEXT;         { Simple character string }
                  Index    = Expression;
                  Exponent = Expression;
                  Fraction =
                        BEGIN
                        Numerator   = Expression;
                        Denominator = Expression;
                        END;
                  Root = 
                        BEGIN
                      ? Order = TEXT;
                        Root_Contents = Expression;
                        END;
                  Integral =
                        BEGIN
                        Integration_Symbol = SYMBOL;
                        Lower_Bound        = Expression;
                        Upper_Bound        = Expression;
                        END;
                  Triple =
                        BEGIN
                        Princ_Expression = Expression;
                        Lower_Expression = Expression;
                        Upper_Expression = Expression;
                        END;
                  Column = LIST [2..*] OF 
                              (Element = Expression);
                  Parentheses_Block =
                        BEGIN
                        Opening  = SYMBOL;
                        Contents = Expression;
                        Closing  = SYMBOL;
                        END;
                  END;       { End of Choice Constructor }
END                          { End of Structure Schema }</pre>

<p>This schema defines a single global attribute which allows functions and
variables to be distinguished. In the presentation schema, this attribute can
be used to choose between roman (for functions) and italic characters (for
variables).</p>

<p>A formula's structure is that of a mathematical expression, which is
itself a sequence of mathematical constructions. A mathematical construction
can be either a simple character string, an index, an exponent, a fraction, a
root, etc. Each of these mathematical constructions has a sensible structure
which generally includes one or more expressions, thus making the formula
class's structure definition recursive.</p>

<p>In most cases, the roots which appear in the formulas are square roots and
their order (2) is not specified. This is why the Order component is marked
optional by a question mark. When explicitly requested, it is possible to add
an order to a root, for example for cube roots (order = 3).</p>

<p>An integral is formed by an integration symbol, chosen by the user (simple
integral, double, curvilinear, etc.), and two bounds. A more fine-grained
schema would add components for the integrand and the integration variable.
Similarly, the Block_Parentheses construction leaves the choice of opening
and closing symbols to the user. They can be brackets, braces, parentheses,
etc.</p>
</div>
</div>
<hr />
</div>

<div class="chapter">
<h1><a name="sect4" id="sect4">The P Language</a></h1>

<div class="section">
<h2><a name="sectb41" id="sectb41">Document presentation</a></h2>

<p>Because of the model adopted for Thot, the presentation of documents is
clearly separated from their structure and content. After having presented
the logical structure of documents, we now detail the principles implemented
for their presentation. The concept of <em>presentation</em> encompasses what
is often called the page layout, the composition, or the document style. It
is the set of operations which display the document on the screen or print it
on paper. Like logical structure, document presentation is defined
generically with the help of a language, called P.</p>

<div class="subsection">
<h3><a name="sectc411" id="sectc411">Two levels of presentation</a></h3>

<p>The link between structure and presentation is clear: the logical
organization of a document is used to carry out its presentation, since the
purpose of the presentation is to make evident the organization of the
document. But the presentation is equally dependent on the device used to
render the document. Certain presentation effects, notably changes of font or
character set, cannot be performed on all printers or on all screens. This is
why Thot uses a two-level approach, where the presentation is first described
in abstract terms, without taking into account each particular device, and
then the presentation is realized within the constraints of a given
device.</p>

<p>Thus, presentation is only described as a function of the structure of the
documents and the image that would be produced on an idealized device. For
this reason, presentation descriptions do not refer to any device
characteristics: they describe <em>abstract presentations</em> which can be
concretized on different devices.</p>

<p>A presentation description also defines a <em>generic presentation</em>,
since it describes the appearance of a class of documents or objects. This
generic presentation must also be applied to document and object instances,
each conforming to its generic logical structure, but with all the allowances
that were called to mind above: missing elements, constructed elements with
other logical structures, etc.</p>

<p>In order to preserve the homogeneity between documents and objects,
presentation is described with a single set of tools which support the layout
of a large document as well as the composition of objects like a graphical
figure or mathematical formula. This unity of presentation description tools
contrasts with the traditional approach, which focuses more on documents than
objects and thus is based on the usual typographic conventions, such as the
placement of margins, indentations, vertical spaces, line lengths,
justification, font changes, etc.</p>
</div>

<div class="subsection">
<h3><a name="sectc412" id="sectc412">Boxes</a></h3>

<p>To assure the homogeneity of tools, all presentation in Thot, for
documents as well as for the objects which they contain, is based on the
notion of the <em>box</em>, such as was implemented in
T<sub><big>E</big></sub>X.</p>

<p>Corresponding to each element of the document is a box, which is the
rectangle enclosing the element on the display device (screen or sheet of
paper); the outline of this rectangle is not visible, except when a <a
href="#sectc4230a"><tt>ShowBox</tt> rule</a> applies to the element. The
sides of the box are parallel to the sides of the screen or the sheet of
paper. By way of example, a box is associated with a character string, a line
of text, a page, a paragraph, a title, a mathematical formula, or a table
cell.</p>

<p>Whatever element it corresponds to, each box possesses four sides and four
axes, which we designate as follows (<a href="#boxes">see figure</a>):</p>
<dl>
  <dt><tt>Top</tt></dt>
    <dd>the upper side,</dd>
  <dt><tt>Bottom</tt></dt>
    <dd>the lower side,</dd>
  <dt><tt>Left</tt></dt>
    <dd>the left side,</dd>
  <dt><tt>Right</tt></dt>
    <dd>the right side,</dd>
  <dt><tt>VMiddle</tt></dt>
    <dd>the vertical axis passing through the center of the box,</dd>
  <dt><tt>HMiddle</tt></dt>
    <dd>the horizontal axis passing through the center of the box,</dd>
  <dt><tt>VRef</tt></dt>
    <dd>the vertical reference axis,</dd>
  <dt><tt>HRef</tt></dt>
    <dd>the horizontal reference axis.</dd>
</dl>

<div class="figure">
<hr />
<pre>        Left   VRef  VMiddle        Right
                 :      :
    Top   -----------------------------
          |      :      :             |
          |      :      :             |
          |      :      :             |
          |      :      :             |
          |      :      :             |
HMiddle ..|...........................|..
          |      :      :             |
          |      :      :             |
   HRef ..|...........................|..
          |      :      :             |
          |      :      :             |
  Bottom  -----------------------------
                 :      :</pre>

<p align="center"><em><a name="boxes" id="boxes">The sides and axes of
boxes</a><em></em></em></p>
<hr />
</div>

<p>The principal role of boxes is to set the extent and position of the
images of the different elements of a document with respect to each other on
the reproduction device. This is done by defining relations between the boxes
of different elements which give relative extents and positions to these
boxes.</p>

<p>There are three types of boxes:</p>
<ul>
  <li>boxes corresponding to structural elements of the document,</li>
  <li>presentation boxes,</li>
  <li>page layout boxes.</li>
</ul>

<p><strong>Boxes corresponding to structural elements of the
document</strong> are those which linked to each of the elements (base or
structured) of the logical structure of the document. Such a box contains all
the contents of the element to which it corresponds (there is an exception:
see <a href="#sectc4220">rules <tt>VertOverflow</tt> and
<tt>HorizOverflow</tt></a>). These boxes form a tree-like structure,
identical to that of the structural elements to which they correspond. This
tree expresses the inclusion relationships between the boxes: a box includes
all the boxes of its subtree. On the other hand, there are no predefined
rules for the relative positions of the included boxes. If they are at the
same level, they can overlap, be contiguous, or be disjoint. The rules
expressed in the generic presentation specify their relative positions.</p>

<p><strong>Presentation boxes</strong> represent elements which are not found
in the logical structure of the document but which are added to meet the
needs of presentation. These boxes are linked to the elements of the logical
structure that are best suited to bringing them out. For example, they are
used to add the character string ``Summary:'' before the summary in the
presentation of a report or to represent the fraction bar in a formula, or
also to make the title of a field in a form appear. These elements have no
role in the logical structure of the document: the presence of a Summary
element in the document does not require the creation of another structural
object to hold the word ``Summary''. Similarly, if a Fraction element
contains both a Numerator element and a Denominator element, the fraction bar
has no purpose structurally. On the other hand, these elements of the
presentation are important for the reader of the reproduced document or for
the user of an editor. This is why they must appear in the document's image.
It is the generic presentation which specifies the presentation boxes to add
by indicating their content (a base element for which the value is specified)
and the position that they must take in the tree of boxes. During editing,
these boxes cannot be modified by the user.</p>

<p><strong>Page layout boxes</strong> are boxes created implicitly by the
page layout rules. These rules indicate how the contents of a structured
element must be broken into lines and pages. In contrast to presentation
boxes, these line and page boxes do not depend on the logical structure of
the document, but rather on the physical constraints of the output devices:
character size, height and width of the window on the screen or of the sheet
of paper.</p>
</div>

<div class="subsection">
<h3><a name="sectc413" id="sectc413">Views and visibility</a></h3>

<p>One of the operations that one might wish to perform on a document is to
view it is different ways. For this reason, it is possible to define several
<em>views</em> for the same document, or better yet, for all documents of the
same class. A view is not a different presentation of the document, but
rather a filter which only allows the display of certain parts of the
document. For example, it might be desirable to see only the titles of
chapters and sections in order to be able to move rapidly through the
document. Such a view could be called a ``table of contents''. It might also
be desirable to see only the mathematical formulas of a document in order to
avoid being distracted by the non-mathematical aspects of the document. A
``mathematics'' view could provide this service.</p>

<p>Views, like presentation, are based on the generic logical structure. Each
document class, and each generic presentation, can be provided with views
which are particularly useful for that class or presentation. For each view,
the <em>visibility</em> of elements is defined, indicated whether or not the
elements must be presented to the user. The visibility is calculated as a
function of the type of the elements or their hierarchical position in the
structure of the document. Thus, for a table of contents, all the ``Chapter
Title'' and ``Section Title'' elements are made visible. However, the
hierarchical level could be used to make the section titles invisible below a
certain threshold level. By varying this threshold, the granularity of the
view can be varied. In the ``mathematics'' view, only Formula elements would
be made visible, no matter what their hierarchical level.</p>

<p>Because views are especially useful for producing a synthetic image of the
document, it is necessary to adapt the presentation of the elements to the
view in which they appear. For example, it is inappropriate to have a page
break before every chapter title in the table of contents. Thus, generic
presentations take into account the possible views and permit each element
type's presentation to vary according the view in which its image appears.</p>
</div>

<div class="subsection">
<h3><a name="sectc414" id="sectc414">Pages</a></h3>

<p>Presentation schemas can be defined which display the document as a long
scroll, without page breaks. This type of schema is particularly well-suited
to the initial phase of work on a document, where jumps from page to page
would hinder composing and reading the document on a screen. But, once the
document is written, it may be desirable to display the document on the
screen in the same manner in which it will be printed. So, the presentation
schema must define pages.</p>

<p>The P language permits the specification of the dimensions of pages as
well as their composition. It is possible to generate running titles, page
numbers, zones at the bottom of the page for notes, etc. The editor follows
this model and inserts page break marks in the document which are used during
printing, insuring that the pages on paper are the same as on the screen.</p>

<p>Once a document has been edited with a presentation schema defining pages,
it contains page marks. But it is always possible to edit the document using
a schema without pages. In this case, the page marks are simply ignored by
the editor. They are considered again as soon as a schema with pages is used.
Thus, the user is free to choose between schemas with and without pages.</p>

<p>Thot treats the page break, rather than the page itself, as a box. This
page break box contains all the elements of one page's footer, a rule marking
the edge of this page, and all the elements of the next page's header. The
elements of the header and footer can be running titles, page number, notes,
etc. All these elements, as well as their content and graphical appearance,
are defined by the generic presentation.</p>
</div>

<div class="subsection">
<h3><a name="sectc415" id="sectc415">Numbering</a></h3>

<p>Many elements are numbered in documents: pages, chapters, sections,
formulas, theorems, notes, figures, bibliographic references, exercises,
examples, lemmas, etc. Because Thot has a notion of logical structure, all of
these numbers (with the exception of pages) are redundant with information
implicit in the logical structure of the document. Such numbers are simply a
way to make the structure of the document more visible. So, they are part of
the document's presentation and are calculated by the editor from the logical
structure. The structure does not contain numbers as such; it only defines
relative structural positions between elements, which serve as ordering
relations on these elements.</p>

<p>If the structure schema defines the body of a document as a sequence of at
least two chapters:</p>
<pre>Body = LIST [2..*] OF Chapter;</pre>

<p>the sequence defined by the list constructor is ordered and each chapter
can be assigned a number based on its rank in the Body list. Therefore, all
elements contained in lists a the structure of a document can be numbered,
but they are not the only ones. The tree structure induced by the aggregate,
list, and choice constructors (excluding references) defines a total order on
the elements of the document's primary structure. So, it is possible to
define a numbering which uses this order, filtering elements according to
their type so that only certain element types are taken into account in the
numbering. In this way, it possible to number all the theorems and lemmas of
a chapter in the same sequence of numbers, even when they are not part of the
same list constructor and appear at different levels of the document's tree.
By changing the filter, they can be numbered separately: one sequence of
numbers for theorems, another for the lemmas.</p>

<p>Since they are calculated from the document's logical structure and only
for the needs of the presentation, numbers are presentation elements,
described by presentation boxes, just like the fraction bar or the word
``Summary''. Nevertheless, numbers differ from these other boxes because
their content varies from instance to instance, even though they are of the
same type, whereas all fraction bars are horizontal lines and the same word
``Summary'' appears at the head of every document's summary.</p>
</div>

<div class="subsection">
<h3><a name="sectc416" id="sectc416">Presentation properties</a></h3>

<p>The principal properties which determine document presentation are the
<em>positions</em> and <em>dimensions</em> of boxes, the <em>font</em>, the
<em>style</em>, the <em>size</em>, the <em>underlining</em> and the
<em>color</em> of their content. From these properties, and some others of
less importance, it is possible to represent the usual typographic properties
for the textual parts of the document. These same properties can be used to
describe the geometry of the non-textual elements, even though they are
two-dimensional elements unlike the text, which is linear.</p>

<p>As we have already seen, the positions of the boxes always respect the
rule of enclosure: a box in the tree encloses all the boxes of the next lower
level which are attached to it. The positional properties permit the
specification of the position of each box in relation to the enclosing box or
to its sibling boxes (boxes directly attached to the same enclosing box in
the tree of boxes).</p>

<p>The presentation properties also provide control over the dimensions of
the boxes. The dimensions of a box can depend either on its content or on its
context (its sibling boxes and the enclosing box). Each dimension (height or
width) can be defined independently of the other.</p>

<p>Because of the position and dimension properties, it is possible to do the
same things that are normally done in typography by changing margins, line
lengths, and vertical or horizontal skips. This approach can also align or
center elements and groups of elements.</p>

<p>In contrast to the position and dimension properties, the font, style,
size, underlining, and color do not concern the box itself (the rectangle
delimiting the element), but its content. These properties indicate the
typographic attributes which must be applied to the text contained in the
box, and by extension, to all base elements.</p>

<p>For text, the font property is used to change the family of characters
(Times, Helvetica, Courier, etc.); the style is used to obtain italic or
roman, bold or light characters; the size determines the point size of the
characters; underlining defines the type and thickness of the lines drawn
above, below, or through the characters.</p>

<p>For graphics, the line style property can be either solid, dotted, or
dashed; the line thickness property controls the width of the lines; the fill
pattern property determines how closed geometric figures must be filled.</p>

<p>While some of the properties which determine the appearance of a box's
contents make sense only for one content type (text or graphic), other
properties apply to all content types: these are the color properties. These
indicate the color of lines and the background color.</p>
</div>
</div>

<div class="section">
<h2><a name="sectb42" id="sectb42">Presentation description language</a></h2>

<p>A generic presentation defines the values of presentation properties (or
the way to calculate those values) for a generic structure, or more
precisely, for all the element types and all the global and local attributes
defined in that generic structure. This definition of the presentation
properties is made with the P language. A program written in this language,
that is a generic presentation expressed in P, is call a <em>presentation
schema</em>. This section describes the syntax and semantics of the language,
using the same <a href="#sectc321">meta-language</a> as was used for the
definition of the S language.</p>

<p>Recall that it is possible to write many different presentation schemas
for the same class of documents or objects. This allows users to choose for a
document the graphical appearance which best suits their type of work or
their personal taste.</p>

<div class="subsection">
<h3><a name="sectc421" id="sectc421">The organization of a presentation
schema</a></h3>

<p>A presentation schema begins with the word <tt>PRESENTATION</tt> and ends
with the word <tt>END</tt>. The word <tt>PRESENTATION</tt> is followed by the
name of the generic structure to which the presentation will be applied. This
name must be the same as that which follows the keyword <tt>STRUCTURE</tt> in
the structure schema associated with the presentation schema.</p>

<p>After this declaration of the name of the structure, the following
sections appear (in order):</p>
<ul>
  <li>Declarations of
    <ul>
      <li>all views,</li>
      <li>printed views,</li>
      <li>counters,</li>
      <li>presentation constants,</li>
      <li>variables,</li>
    </ul>
  </li>
  <li>default presentation rules,</li>
  <li>presentation box and page layout box definitions,</li>
  <li>presentation rules for structured elements,</li>
  <li>presentation rules for attributes,</li>
  <li>rules for transmitting values to attributes of included documents.</li>
</ul>

<p>Each of these sections is introduced by a keyword which is followed by a
sequence of declarations. Every section is optional.</p>
<pre>     SchemaPres ='PRESENTATION' ElemID ';'
               [ 'VIEWS' ViewSeq ]
               [ 'PRINT' PrintViewSeq ]
               [ 'COUNTERS' CounterSeq ]
               [ 'CONST' ConstSeq ]
               [ 'VAR' VarSeq ]
               [ 'DEFAULT' ViewRuleSeq ]
               [ 'BOXES' BoxSeq ]
               [ 'RULES' PresentSeq ]
               [ 'ATTRIBUTES' PresAttrSeq ]
               [ 'TRANSMIT' TransmitSeq ]
                 'END' .
     ElemID     = NAME .</pre>
</div>

<div class="subsection">
<h3><a name="sectc422" id="sectc422">Views</a></h3>

<p>Each of the possible views must be declared in the presentation schema. As
has <a href="#views">already been described</a>, the presentation rules for
an element type can vary according to the view in which the element appears.
The name of the view is used to designate the view to which the presentation
rules apply (see the <a href="#inkeyword"><tt>IN</tt> instruction</a>). The
definition of the view's contents are dispersed throughout the presentation
rules attached to the different element types and attributes. The
<tt>VIEWS</tt> section is simply a sequence of view names separated by commas
and terminated by a semi-colon.</p>

<p>One of the view names (and only one) can be followed by the keyword
<tt>EXPORT</tt>. This keyword identifies the view which presents the members
of the document class in <a href="#sectc3213">skeleton form</a>. The
graphical appearance and the content of this view is defined just as with
other views, but it is useless to specify presentation rules concerning this
view for the elements which are not loaded in the skeleton form.</p>

<p>It is not necessary to declare any views; in this case there is a single
unnamed view. If many views are declared, the first view listed is considered
the principal view. The principal view is the one to which all rules that are
not preceded by an indication of a view will apply (see the <a
href="#inkeyword">instruction <tt>IN</tt></a>).</p>

<p>The principal view is the the one which the editor presents on the screen
when the user asks to create or edit a document. Thus, it makes sense to put
the most frequently used view at the head of the list. But if the structure
schema contains <a href="#sectc3213">skeleton elements</a> and is loaded in
its skeleton form, the view whose name is followed by the keyword
<tt>EXPORT</tt> will be opened and no other views can be opened.</p>
<pre>                      'VIEWS' ViewSeq
     ViewSeq         = ViewDeclaration
                       &lt; ',' ViewDeclaration &gt; ';' .
     ViewDeclaration = ViewID [ 'EXPORT' ] .
     ViewID          = NAME .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>When editing a report, it might be useful have views of the table of
  contents and of the mathematical formulas, in addition to the principal
  view which shows the document in its entirety. To achieve this, a
  presentation schema for the Report class would have the following
  <tt>VIEWS</tt> section:</p>
  <pre>VIEWS
     Full_text, Table_of_contents, Formulas;</pre>

  <p>The contents of these views are specified in the presentation rules of
  the schema.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc423" id="sectc423">Print Views</a></h3>

<p>When editing a document, each view specified by the <tt>VIEWS</tt>
instruction is presented in a different window.</p>

<p>When printing a document, it is possible to print any number of views,
chosen from among all the views which the editor can display. Print views, as
well as the order in which they must be printed, are indicated by the
<tt>PRINT</tt> instruction. It appears after the <tt>VIEWS</tt> instruction
and is formed of the keyword <tt>PRINT</tt> followed by the ordered list of
print view names. The print view names are separated by commas and followed
by a semi-colon. A print view name is a view name declared in the
<tt>VIEWS</tt> instruction.</p>
<pre>                    'PRINT' PrintViewSeq
     PrintViewSeq = PrintView &lt; ',' PrintView &gt; ';' .
     PrintView    = ViewID .</pre>

<p>If the <tt>PRINT</tt> instruction is absent, the printing program will
print only the principal view (the first view specified by the <tt>VIEWS</tt>
instruction or the single, unnamed view when there is no <tt>VIEWS</tt>
instruction).</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Consider a Report presentation using the view declarations from the
  preceding example. Suppose we want to print the full text and table of
  contents views, but not the Formulas view, which is only useful when
  editing. A sensible printing order would be to print the full text followed
  by the table of contents. To obtain this result when printing, the
  presentation schema would say:</p>
  <pre>PRINT
     Full_text, Table_of_contents;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc424" id="sectc424">Counters</a></h3>

<p>A presentation has a <em>counter</em> for each type of number in the
presentation. All counters, and therefore all types of numbers, used in the
schema must be declared after the <tt>COUNTERS</tt> keyword.</p>

<p>Each counter declaration is composed of a name identifying the counter
followed by a colon and the counting function to be applied to the counter.
The counter declaration ends with a semi-colon.</p>

<p>The counting function indicates how the counter values will be calculated.
Three types of counting functions are available. The first type is used to
count the elements of a list or aggregate: it assigns to the counter the rank
of the element in the list or aggregate. More precisely, the function</p>
<pre>RANK OF ElemID [ LevelAsc ] [ INIT AttrID ]
        [ 'REINIT' AttrID ]</pre>

<p>indicates that when an element creates, by a creation rule (see the <a
href="#sectc4232"><tt>Create</tt> instructions</a>), a presentation box
containing the counter value, this value is the rank of the creating element,
if it is of type <tt>ElemID</tt>, otherwise the rank of the first element of
type <tt>ElemID</tt> which encloses the creating element in the logical
structure of the document.</p>

<p>The type name can be preceded by a star in the special case where the
structure schema defines an element of whose <tt>ElemID</tt> is the same as
that of an <a href="#sectd3284">inclusion</a> without expansion or with
partial expansion. To resolve this ambiguity, the <tt>ElemID</tt> alone
refers to the type defined in the structure schema while the <tt>ElemID</tt>
preceded by a star refers to the included type.</p>

<p>The type name <tt>ElemID</tt> can be followed by an integer. That number
represents the relative level, among the ancestors of the creating element,
of the element whose rank is asked. If that relative level <i>n</i> is
unsigned, the <i>n</i><sup>th</sup> element of type <tt>ElemID</tt>
encountered when travelling the logical structure from the root to the
creating element is taken into account. If the relative level is negative,
the logical structure is travelled in the other direction, from the creating
element to the root.</p>

<p>The function can end with the keyword <tt>INIT</tt> followed by the name
of a numeric attribute (and only a numeric attribute). Then, the rank of the
first element of the list or aggregate is considered to be the value of this
attribute, rather than the default value of 1, and the rank of the other
elements is shifted accordingly. The attribute which determines the initial
value is searched on the element itself and on its ancestors.</p>

<p>The function can end with the keyword <tt>REINIT</tt> followed by the name
of a numeric attribute (and only a numeric attribute). Then, if an element to
be counted has this attribute, the counter value for this element is the
attribute value and the following elements are numbered starting from this
value.</p>

<p>When the <tt>RANK</tt> function is written</p>
<pre>RANK OF Page [ ViewID ] [ INIT AttrID ]</pre>

<p>(<tt>Page</tt>is a keyword of the P language), the counter takes as its
value the number of the page on which the element which creates the
presentation box containing the number appears. This is done as if the pages
of the document form a list for each view. The counter only takes into
account the pages of the relevant view, that is the view displaying the
presentation box whose contents take the value of the number. However, if the
keyword <tt>Page</tt> is followed by the name of a view (between
parentheses), it is the pages of that view that are taken into account. As in
the preceding form, the <tt>RANK</tt> function applied to pages can end with
the <tt>INIT</tt> keyword followed by the name of a numeric attribute which
sets the value of the first page's number. This attribute must be a local
attribute of the document itself, and not of one of its components.</p>

<p>The second counting function is used to count the occurrences of a certain
element type in a specified context. The instruction</p>
<pre>SET n ON Type1 ADD m ON Type2 [ INIT AttrID ]</pre>

<p>says that when the document is traversed from beginning to end (in the
order induced by the logical structure), the counter is assigned the value
<tt>n</tt> each time an element of type <tt>Type1</tt> is encountered, no
matter what the current value of the counter, and the value <tt>m</tt> is
added to the current value of the counter each time an element of type
<tt>Type2</tt> is encountered.</p>

<p>As with the <tt>RANK</tt> function, the type names can be preceded by a
star to resolve the ambiguity of included elements.</p>

<p>If the function ends with the keyword <tt>INIT</tt> followed by the name
of an attribute and if the document possesses this attribute, the value of
this attribute is used in place of <tt>n</tt>. The attribute must be numeric.
It is searched on the element itself and on its ancestors.</p>

<p>This function can also be used with the <tt>Page</tt> keyword in the place
of <tt>Type1</tt> or <tt>Type2</tt>. In the first case, the counter is
reinitialized on each page with the value <tt>n</tt>, while in the second
case, it is incremented by <tt>m</tt> on each page. As with the preceding
counting function, the word <tt>Page</tt> can be followed by a name between
parentheses. In this case, the name specifies a view whose pages are taken
into account.</p>

<p>The definition of a counter can contain several <tt>SET</tt> functions and
several <tt>ADD</tt> functions, each with a different value. The total number
of counting functions must not be greater than 6.</p>

<p>The third counting function is used to count the elements of a certain
type encountered when travelling from the creating element to the root of the
logical structure. The creating element is included if it is of that type.
That function is written</p>
<pre>RLEVEL OF Type</pre>

<p>where <tt>Type</tt> represents the type of the elements to be counted.</p>

<p>The formal definition of counter declarations is:</p>
<pre>                    'COUNTERS' CounterSeq
     CounterSeq   = Counter &lt; Counter &gt; .
     Counter      = CounterID ':' CounterFunc ';' .
     CounterID    = NAME .
     CounterFunc  = 'RANK' 'OF' TypeOrPage [ SLevelAsc ]
                    [ 'INIT' AttrID ] [ 'REINIT' AttrID ] /
                    SetFunction &lt; SetFunction &gt;
                    AddFunction &lt; AddFunction &gt;
                    [ 'INIT' AttrID ] /
                    'RLEVEL' 'OF' ElemID .
     SLevelAsc    = [ '-' ] LevelAsc .
     LevelAsc     =  NUMBER .
     SetFunction  = 'SET' CounterValue 'ON' TypeOrPage .
     AddFunction  = 'ADD' CounterValue 'ON' TypeOrPage .
     TypeOrPage   = 'Page' [ '(' ViewID ')' ] / 
                    [ '*' ] ElemID .
     CounterValue = NUMBER .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If the body of a chapter is defined as a sequence of sections in the
  structure schema:</p>
  <pre>Chapter_body = LIST OF (Section = 
                            BEGIN
                            Section_Title = Text;
                            Section_Body  = Paragraphs;
                            END
                         );</pre>

  <p>the section counter is declared:</p>
  <pre>SectionCtr : RANK OF Section;</pre>

  <p>and the display of the section number before the section title is
  obtained by a <a href="#sectc4232"><tt>CreateBefore</tt> rule</a> attached
  the <tt>Section_Title</tt> type, which creates a presentation box whose
  content is the value of the <tt>SectionCtr</tt> counter (see the <a
  href="#sectc4231"><tt>Content</tt> instruction</a>).</p>

  <p>In order to number the formulas separately within each chapter, the
  formula counter is declared:</p>
  <pre>FormulaCtr : SET 0 ON Chapter ADD 1 ON Formula;</pre>

  <p>and the display of the formula number in the right margin, alongside
  each formula, is obtained by a <tt>CreateAfter</tt> instruction attached to
  the <tt>Formula</tt> type, which creates a presentation box whose content
  is the value of the <tt>FormulaCtr</tt> counter.</p>

  <p>To number the page chapter by chapter, with the first page of each
  chapter having the number 1, the counter definition would be</p>
  <pre>ChapterPageCtr : SET 0 ON Chapter ADD 1 ON Page;</pre>

  <p>If there is also a chapter counter</p>
  <pre>ChapterCtr : RANK OF Chapter;</pre>

  <p>the <a href="#sectc4231">content</a> of a presentation box created at
  the top of each page could be defined as:</p>
  <pre>Content : (VALUE(ChapterCtr, URoman) TEXT '-'
           VALUE(ChapterPageCtr, Arabic));</pre>

  <p>Thus, the presentation box contains the number of the chapter in
  upper-case roman numerals followed by a hyphen and the number of the page
  within the chapter in arabic numerals.</p>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To count tables and figures together in a document of the chapter type,
  a counter could be defined using:</p>
  <pre>CommonCtr : SET 0 ON Chapter ADD 1 ON Table
            ADD 1 ON Figure;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc425" id="sectc425">Presentation constants</a></h3>

<p>Presentation constants are used in the definition of the content of
presentation boxes. This content is used in <a href="#sectc426">variable
definitions</a> and in the <a href="#sectc4231"><tt>Content</tt> rule</a>.
The only presentation constants which can be used are character strings,
mathematical symbols, graphical elements, and pictures, that is to say, base
elements.</p>

<p>Constants can be defined directly in the variables or presentation boxes
(<tt>Content</tt> rule) which use them. But it is only necessary them to
declare once, in the constant declaration section, even though they are used
in many variables or boxes. Thus, each declared constant has a name, which
allows it to be designated whenever it is used, a type (one of the four base
types) and a value (a character string or a single character for mathematical
symbols and graphical elements).</p>

<p>The constant declarations appear after the keyword <tt>CONST</tt>. Each
declaration is composed of the name of the constant, an equals sign, a
keyword representing its type (<tt>Text</tt>, <tt>Symbol</tt>,
<tt>Graphics</tt> or <tt>Picture</tt>) and the string representing its value.
A semi-colon terminates each declaration.</p>

<p>In the case of a character string, the keyword <tt>Text</tt> can be
followed by the name of an script (for example, <tt>Greek</tt> or
<tt>Latin</tt>) in which the constant's text should be expressed. If the
script name is absent, the Latin script is used. When the script name is
present, only the first letter of the script name is interpreted. Thus, the
words <tt>Greek</tt> and <tt>Grec</tt> designate the same script. In current
versions of Thot, only the Greek and Latin scripts are available.</p>
<pre>                 'CONST' ConstSeq
     ConstSeq   = Const &lt; Const &gt; .
     Const      = ConstID '=' ConstType ConstValue ';' .
     ConstID    = NAME .
     ConstType  ='Text' [ Script ] / 'Symbol' /
                 'Graphics' / 'Picture' .
     ConstValue = STRING .
     Script   = NAME .</pre>

<p>For character strings in the Latin script (ISO Latin-1 character set),
characters having codes higher than 127 (decimal) are represented by their
code in octal.</p>

<p>In the case of a symbol or graphical element, the value only contains a
single character, between apostrophes, which indicates the form of the
element which must be drawn in the box whose content is the constant. The
symbol or graphical element takes the dimensions of the box, which are
determined by the <tt>Height</tt> and <tt>Width</tt> rules. See <a
href="#sectb72">table of codes</a> for the symbols and graphical elements.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The constants ``Summary:'' and fraction bar, which were described
  earlier, are declared:</p>
  <pre>CONST
     SummaryConst = Text 'Summary:';
     Bar          = Graphics 'h';</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc426" id="sectc426">Variables</a></h3>

<p>Variables permit the definition of computed content for presentation
boxes. A variable is associated with a presentation box by a <tt>Content</tt>
rule; but before being used in a <tt>Content</tt> rule, a variable can be
defined in the <tt>VAR</tt> section. It is also possible to define a variable
at the time of its use in a <tt>Content</tt> rule, as can be done with a
constant.</p>

<p>A variable has a name and a value which is a character string resulting
from the concatenation of the values of a sequence of functions. Each
variable declaration is composed of the variable name followed by a colon and
the sequence of functions which produces its value, separated by spaces. Each
declaration is terminated by a semi-colon.</p>
<pre>                  'VAR' VarSeq
     VarSeq      = Variable &lt; Variable &gt; .
     Variable    = VarID ':' FunctionSeq ';' .
     VarID       = NAME .
     FunctionSeq = Function &lt; Function &gt; .</pre>

<p>Several functions are available. The first two return, in the form of a
character string, the current date. <tt>DATE</tt> returns the date in
English, while <tt>FDATE</tt> returns the date in french.</p>

<p>Two other functions, <tt>DocName</tt> and <tt>DirName</tt>, return the
document name and the directory where the document is stored.</p>

<p>Function <tt>ElemName</tt> returns the name of the element which created
the presentation box whose contents are the variable.</p>

<p>Function <tt>AttributeName</tt> returns the name of the attribute which
created the presentation box whose contents are the variable. The
presentation box must be created by an attribute.</p>

<p>Function <tt>AttributeValue</tt> returns the value of the attribute which
created the presentation box whose contents are the variable. The
presentation box must be created by an attribute.</p>

<p>Another function simply returns the value of a presentation constant. For
any constant declared in the <tt>CONST</tt> section, it is sufficient to give
the name of the constant. Otherwise, the type and value of the constant must
be given, using the same form as in a <a href="#sectc425">constant
declaration</a>. If the constant is not of type text, (types <tt>Symbol</tt>,
<tt>Graphics</tt> or <tt>Picture</tt>), it must be alone in the variable
definition; only constants of type <tt>Text</tt> can be mixed with other
functions.</p>

<p>It is also possible to obtain the value of an attribute, simply by
mentioning the attribute's name. The value of this function is the value of
the attribute for the element which created the presentation box whose
contents are the variable. If the creating element does not have the
indicated attribute, the value is an empty string. In the case of a numeric
attribute, the attribute is translated into a decimal number in arabic
numerals. If another form is desired, the <tt>VALUE</tt> function must be
used.</p>

<p>The last available function returns, as a character string, the value of a
counter, an attribute or a page number. This value can be presented in
different styles. The keyword <tt>VALUE</tt> is followed (between
parentheses) by the name of the counter, the name of the attribute, or the
keyword <tt>PageNumber</tt> and the desired style, the two parameters being
separated by a comma. The style is a keyword which indicates whether the
value should be presented in arabic numerals (<tt>Arabic</tt>,
<tt>Decimal</tt> or <tt>DecimalLeadingZero</tt>), lower-case roman numerals
(<tt>LRoman</tt> or <tt>LowerRoman</tt>), upper-case roman numerals
(<tt>URoman</tt> or <tt>UpperRoman</tt>), upper-case latin letter
(<tt>Uppercase</tt> or <tt>UpperLatin</tt>), lower-case latin letter
(<tt>Lowercase</tt> or <tt>LowerLatin</tt>), uppercase greek letter
(<tt>UpperGreek</tt>) or lowercase greek letter (<tt>LowerGreek</tt>).</p>

<p>For a page counter, the keyword <tt>PageNumber</tt> can be followed,
between parentheses, by the name of the view from which to obtain the page
number. By default, the first view declared in the <tt>VIEWS</tt> section is
used. The value obtained is the number of the page on which is found the
element that is using the variable in a <tt>Content</tt> rule.</p>

<p>For an ordinary counter, the name of the counter can be preceded by the
keyword <tt>MaxRangeVal</tt> or <tt>MinRangeVal</tt>. These keywords mean
that the value returned by the function is the maximum (minimum resp.) value
taken by the counter in the whole document, not the value for the element
concerned by the function.</p>
<pre>     Function     = 'DATE' / 'FDATE' /
                    'DocName' / 'DirName' /
                    'ElemName' / 'AttributeName' / 'AttributeValue' /
                     ConstID / ConstType ConstValue /
                     AttrID /
                    'VALUE' '(' PageAttrCtr ','
                                CounterStyle ')' .
     PageAttrCtr  = 'PageNumber' [ '(' ViewID ')' ] /
                     [ MinMax ] CounterID / AttrID .
     CounterStyle = 'Arabic' / 'Decimal' / 'DecimalLeadingZero' /
                    'URoman' /  'UpperRoman' / 'LRoman' / 'LowerRoman' /
                    'Uppercase' / 'UpperLatin' / 'Lowercase' / 'LowerLatin' /
                    'LowerGreek' / 'UpperGreek' .
     MinMax       = 'MaxRangeVal' / 'MinRangeVal' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To make today's date appear at the top of the first page of a report, a
  <a href="#sectc4232"><tt>CREATE</tt> rule</a> associated with the
  Report_Title element type generates a presentation box whose content
  (specified by the <tt>Content</tt> rule of that presentation box) is the
  variable:</p>
  <pre>VAR
     Todays_date : TEXT 'Version of ' DATE;</pre>

  <p>To produce, before each section title, the chapter number (in upper-case
  roman numerals) followed by the section number (in arabic numerals), two
  counters must be defined:</p>
  <pre>COUNTERS
     ChapterCtr : RANK OF Chapter;
     SectionCtr : RANK OF Section;</pre>

  <p>and the Section_Title element must create a presentation box whose
  content is the variable</p>
  <pre>VAR
     SectionNum : VALUE (ChapterCtr, URoman) TEXT '-'
                  VALUE (SectionCtr, Arabic);</pre>

  <p>In order to make the page number on which each section begins appear in
  the table of contents view next to the section title, each Section_Title
  element must create a presentation box, visible only in the table of
  contents view, whose content is the variable:</p>
  <pre>VAR
     TitlePageNume :
           VALUE (PageNumber(Full_text), Arabic);</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc427" id="sectc427">Default presentation rules</a></h3>

<p>In order to avoid having to specify, for each element type defined in the
structure schema, values for every one of the numerous presentation
properties, the presentation schema allows the definition of a set of default
presentation rules. These rules apply to all the boxes of the elements
defined in the structure schema and to the presentation boxes and page layout
boxes defined in the presentation schema. Only rules which differ from these
default need to be specified in other sections of the presentation schema.</p>

<p>For the primary view, the default rules can define every presentation
property, but not the <a href="#presfunct">presentation functions</a> or the
<a href="#sectc4223">linebreaking conditions</a> (the <tt>NoBreak1</tt>,
<tt>NoBreak2</tt>, and <tt>Gather</tt> rules).</p>

<p>In a presentation schema, the default presentation rules section is
optional; in this case, the <tt>DEFAULT</tt> keyword is also absent and the
following rules are considered to be the default rules:</p>
<pre>   Visibility:        Enclosing =;
   VertRef:           * . Left;
   HorizRef:          Enclosed . HRef;
   Height:            Enclosed . Height;
   Width:             Enclosed . Width;
   VertPos:           Top = Previous . Bottom;
   HorizPos:          Left = Enclosing . Left;
   Float:             None;
   Clear:             None;
   MarginTop:         0;
   MarginRight:       0;
   MarginBottom:      0;
   MarginLeft:        0;
   PaddingTop:        0;
   PaddingRight:      0;
   PaddingBottom:     0;
   PaddingLeft:       0;
   BorderTopWidth:    0;
   BorderRightWidth:  0;
   BorderBottomWidth: 0;
   BorderLeftWidth:   0;
   BorderTopColor:    Foreground;
   BorderRightColor:  Foreground;
   BorderBottomColor: Foreground;
   BorderLeftColor:   Foreground;
   BorderTopStyle:    None;
   BorderRightStyle:  None;
   BorderBottomStyle: None;
   BorderLeftStyle:   None;
   VertOverflow:      No;
   HorizOverflow:     No;
   Size:              Enclosing =;
   Style:             Enclosing =;
   Weight:            Enclosing =;
   Font:              Enclosing =;
   Underline:         Enclosing =;
   Thickness:         Enclosing =;
   Indent:            Enclosing =;
   LineSpacing:       Enclosing =;
   Adjust:            Enclosing =;
   Hyphenate:         Enclosing =;
   Direction:         Enclosing =;
   UnicodeBidi:       Enclosing =;
   PageBreak:         Yes;
   LineBreak:         Yes;
   InLine:            Yes;
   Depth:             0;
   LineStyle:         Enclosing =;
   LineWeight:        Enclosing =;
   FillPattern:       Enclosing =;
   Background:        Enclosing =;
   Foreground:        Enclosing =;
   Opacity:           Enclosing =;
   FillOpacity:       Enclosing =;
   StrokeOpacity:     Enclosing =;</pre>

<p>If other values are desired for the default rules, they must be defined
explicitly in the default rules section. In fact, it is only necessary to
define those default rules which differ from the ones above, since the rules
above will be used whenever a rule is not explicitly named.</p>

<p>Default rules for views other than the primary view can also be specified.
Otherwise, the default rules for the primary views are applied to the other
views.</p>

<p>Default rules are expressed in the same way as <a
href="#sectc4215">explicit rules for document elements</a>.</p>
</div>

<div class="subsection">
<h3><a name="sectc428" id="sectc428">Presentation and page layout
boxes</a></h3>

<p>The presentation process uses elements which are not part of the logical
structure of the document, such as pages (which are the page layout boxes) or
alternatively, rules, numbers, or words introducing certain parts of the
document, such as ``Summary'', ``Appendices'', ``Bibliography'', etc. (which
are presentation boxes).</p>

<p>After the word <tt>BOXES</tt>, each presentation or page layout box is
defined by its name and a sequence of presentation rules which indicate how
they must be displayed. These rules are the same as those which define the
boxes associated with element of the logical structure of the document, with
a single exception, the <a href="#sectc4231"><tt>Content</tt> rule</a> which
is used only to specify the content of presentation boxes. The content of
boxes associated with elements of the document structure is defined in each
document or object and thus is not specified in the presentation schema,
which applies to all documents or objects of a class.</p>

<p>Among the rules which define a presentation box, certain ones can refer to
another presentation box (for example, in their positional rules). If the
designated box is defined after the box which designates it, a
<tt>FORWARD</tt> instruction followed by the name of the designated box must
appear before the designation.</p>
<pre>             'BOXES' BoxSeq
     BoxSeq = Box &lt; Box &gt; .
     Box    ='FORWARD' BoxID ';' /
              BoxID ':' ViewRuleSeq .
     BoxID  = NAME .</pre>
</div>

<div class="subsection">
<h3><a name="sectc429" id="sectc429">Presentation of structured
elements</a></h3>

<p>After the words <tt>RULES</tt>, the presentation schema gives the
presentation rules that apply to the elements whose types are defined in the
structure schema. Only those rules which differ from the <a
href="#sectc427">default</a> must be specified in the <tt>RULES</tt>
section.</p>

<p>The rule definitions for each element type are composed of the name of the
element type (as specified in the structure schema) followed by a colon and
the set of rules specific to that type.</p>

<p>The type name can be preceded by a star in the special case where the
structure schema defines an <a href="#sectd3284">inclusion</a> without
expansion (or with partial expansion) of a type with the same name as an
element of defined in the structure schema.</p>

<p>In the case where the element is a <a href="#sectd3285">mark pair</a>, but
only in this case, the type name can be preceded by the keywords
<tt>First</tt> or <tt>Second</tt>. These keywords indicate whether the rules
that follow apply to the first or second mark of the pair.</p>
<pre>                 'RULES' PresentSeq
     PresentSeq = Present &lt; Present &gt; .
     Present    = [ '*' ] [ FirstSec ] ElemID ':'
                  ViewRuleSeq .
     FirstSec   = 'First' / 'Second' .</pre>

<p>A presentation schema can define presentation rules for base elements,
which are defined implicitly in the structure schemas. In the English version
of the presentation schema compiler, the base type names are the same as in
the S language, but they are terminated by the <tt>_UNIT</tt> suffix:
<tt>TEXT_UNIT</tt>, <tt>PICTURE_UNIT</tt>, <tt>SYMBOL_UNIT</tt>,
<tt>GRAPHICS_UNIT</tt>. The base type names are written in upper-case
letters.</p>
</div>

<div class="subsection">
<h3><a name="sectc4210" id="sectc4210">Logical attribute presentation</a></h3>

<p>After the keyword <tt>ATTRIBUTES</tt>, all attributes which are to have
some effect on the presentation of the element to which they are attached
must be mentioned, along with the corresponding presentation rules. This is
true for both global attributes (which can be attached to all element types)
and local attributes (which can only be attached to certain element
types).</p>

<p>Also mentioned in this section are attributes which imply an effect on
elements in the subtree of the element to which they are attached. The
presentation of these descendants can be modified as a function of the value
of the attribute which they inherit, just as if it was attached to them
directly.</p>

<p>The specification for each attribute includes the attribute's name,
followed by an optional value specification and, after a colon, a set of
rules. The set of rules must contain at least one rule.</p>

<p>When there is no value specification, the rules are applied to all
elements which carry the attribute, no matter what their value. When the
rules must only apply when the attribute has certain values, these values
must be specified. Thus, the same attribute can appear in the
<tt>ATTRIBUTES</tt> section several times, with each appearance having a
different value specification. However, reference attributes never have a
value specification and, as a result, can only appear once in the
<tt>ATTRIBUTES</tt> section.</p>

<p>To specify that the presentation rules apply to some of the descendants of
the element having the attribute, the name of the affected element type is
given, between parentheses, after the attribute name. If the element type
name is followed by a '<tt>*</tt>', the rules also apply to the element
itself (i.e. the element that has the specified type and has the specified
attribute). In the case where the element type is a <a href="#sectd3285">mark
pair</a>, but only in this case, the type name can be preceded by the
keywords <tt>First</tt> or <tt>Second</tt>. These keywords indicate whether
the rules that follow apply to the first or second mark of the pair. If the
rule must apply to several different element types, the specification must be
repeated for each element type.</p>

<p>The specification of values for which the presentation rules will be
applied varies according to the type of the attribute:</p>
<dl>
  <dt>numeric attribute</dt>
    <dd>If the rules are to apply for one value of the attribute, then the
      attribute name is followed by an equals sign and this value. If the
      rules are to apply for all values less than (or greater than) a
      threshold value, non-inclusive, the attribute name followed by a '&lt;'
      sign (or a '&gt;' sign, respectively) and the threshold value. If the
      rules must apply to a range of values, the attribute name is followed
      by the word '<tt>IN</tt>' and the two bounds of the range, enclosed in
      brackets and separated by two periods ('<tt>..</tt>'). In the case of
      ranges, the values of the bounds are included in the range.
      <p>The threshold value in the comparisons can be the value of an
      attribute attached to an ancestor element. In this case, the attribute
      name is given instead of a constant value.</p>
      <p>It is also possible to write rules which apply only when a
      comparison between two different attributes of the element's ancestors
      is true. In this case, the first attribute name is followed by a
      comparison keyword and the name of the second attribute. The comparison
      keywords are <tt>EQUAL</tt> (simple equality), <tt>LESS</tt>
      (non-inclusive less than), and <tt>GREATER</tt> (non-inclusive greater
      than).</p>
    </dd>
  <dt>text attribute</dt>
    <dd>If the rules are to apply for one value of the attribute, then the
      attribute name is followed by an equals sign and this value.</dd>
  <dt>reference attribute</dt>
    <dd>There is never a value specification; the rules apply no matter what
      element is designated by the attribute.</dd>
  <dt>enumerated attribute</dt>
    <dd>If the rules are to apply for one value of the attribute, then the
      attribute name is followed by an equals sign and this value.</dd>
</dl>

<p>The order in which the rules associated with a numeric attribute are
defined is important. When multiple sets of rules can be applied, the first
set declared is the one used.</p>

<p>Rules for attributes have priority over both default rules and rules
associated with element types. The attribute rules apply to the element to
which the attribute is attached. It is the rules which apply to the
surrounding elements (and especially to the descendants) which determine the
effect of the attribute rules on the environment ( and especially on the
terminal elements of the structure).</p>
<pre>                    'ATTRIBUTES' PresAttrSeq
     PresAttrSeq  = PresAttr &lt; PresAttr &gt; .
     PresAttr     = AttrID [ '(' [ FirstSec ] ElemID [ '*' ] ')' ]
                    [ AttrRelation ] ':' ViewRuleSeq .
     AttrID       = NAME .
     AttrRelation ='=' AttrVal /
                    '&gt;' [ '-' ] MinValue /
                    '&lt;' [ '-' ] MaxValue /
                    'IN' '[' [ '-' ] LowerBound '..'
                    [ '-' ] UpperBound ']' /
                    'GREATER' AttrID /
                    'EQUAL' AttrID /
                    'LESS' AttrID .
     AttrVal      = [ '-' ] EqualNum / EqualText /
                    AttrValue .
     MinValue     = NUMBER .
     MaxValue     = NUMBER .
     LowerBound   = NUMBER .
     UpperBound   = NUMBER.
     EqualNum     = NUMBER .
     EqualText    = STRING .
     AttrValue    = NAME .</pre>

<p>In presentation rules associated with a numeric attribute (and only in
such rules), the attribute name can be used in place of a numeric value. In
this case, the value of the attribute is used in the application of the rule.
Thus, the attribute can represent a relation between the size of two boxes,
the height and width of a box, the height of an area where page breaks are
prohibited, the distance between two boxes, the position of the reference
axis of a box, the interline spacing, the indentation of the first line, the
visibility, the depth (z-order), or the character set.</p>

<p>The presentation rules associated with reference attributes, it is
possible to use the element designated by the attribute as a reference box in
a positional or extent rule. This element is represented in the <a
href="#sectc4218">position</a> or <a href="#sectc4219">extent</a> rule by the
keyword <tt>Referred</tt>.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>In all structure schemas, there is a global Language attribute defined
  as follows:</p>
  <pre>ATTR
     Language = TEXT;</pre>

  <p>The following rules would make French text be displayed in roman
  characters and English text be displayed in italics:</p>
  <pre>ATTRIBUTES
     Language = 'French' :
                Style : Roman;
     Language = 'English' :
                Style : Italics;</pre>

  <p>Using these rules, when the user puts the Language attribute with the
  value 'English' on the summary of a document, every character string
  (terminal elements) contained in the summary are displayed in italics. See
  the <a href="#sectd42252"><tt>Style</tt> rule</a>.</p>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>A numeric attribute representing the importance of the part of the
  document to which it is attached can be defined:</p>
  <pre>ATTR
     Importance = INTEGER;</pre>

  <p>In the presentation schema, the importance of an element is reflected in
  the choice of character size, using the following rules.</p>
  <pre>ATTRIBUTES
     Importance &lt; 2 :
              Size : 1;
     Importance IN [2..4] :
              Size : Importance;
     Importance = 10 :
              Size : 5;
     Importance &gt; 4 :
              Size : 4;</pre>

  <p>Thus, the character size corresponds to the value of the Importance
  attribute; its value is</p>
  <ul>
    <li>the value of the Importance attribute when the value is between 2 and
      4 (inclusive),</li>
    <li>1, when the value of the Importance attribute is less than 2,</li>
    <li>4, when the value of the Importance attribute is greater than 4,</li>
    <li>5, when the value of the Importance attribute is 10.</li>
  </ul>

  <p>The last case (value 5) must be defined before the case which handles
  all Importance values greater than 4, because the two rules are not
  disjoint and the first one defined will have priority. Otherwise, when the
  Importance attribute has value 10, the font size will be 4.</p>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose the structure defines a list element which can have an attribute
  defining the type of list (numbered or not):</p>
  <pre>STRUCT
    list (ATTR list_type = enumeration, dash)
         = LIST OF (list_item = TEXT);</pre>

  <p>Then, the presentation schema could use the attribute placed on the list
  element to put either a dash or a number before the each element of the
  list:</p>
  <pre>ATTRIBUTES
   list_type (list_item) = enumeration :
        CreateBefore (NumberBox);
   list_type (list_item) = dash :
        CreateBefore (DashBox);</pre>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that two attributes are defined in the structure schema. The
  first is a numeric global attribute called ``version''. The other is a
  local attribute defined on the root of the document called
  ``Document_version'':</p>
  <pre>STRUCTURE Document
ATTR
    version = INTEGER;
STRUCT
    Document (ATTR Document_version = INTEGER) =
        BEGIN
        SomeElement ;
        ...
        SomeOtherElement ;
        END ;
...</pre>

  <p>These attributes can be used in the presentation schema to place change
  bars in the margin next to elements whose version attribute has a value
  equal to the Document_version attribute of the root and to place a star in
  margin of elements whose version attribute is less than the value of the
  root's Document_version attribute:</p>
  <pre>ATTRIBUTES
    version EQUAL Document_version :
        CreateBefore (ChangeBarBox) ;
    version LESS Document_version :
        CreateBefore (StarBox) ;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4212" id="sectc4212">Value transmission rules</a></h3>

<p>The last section of a presentation schema, which is optional, serves to
defines the way in which a document transmits certain values to its
sub-documents. A sub-document is an document <a
href="#inclusion">included</a> without expansion or with partial expansion.
The primary document can transmit to its sub-documents the values of certain
counters or the textual content of certain of its elements, as a function of
their type.</p>

<p>The sub-documents receive these values in attributes which must be defined
in their structure schema as local attributes of the root element. The types
of these attributes must correspond to the type of the value which they
receive: numeric attributes for receiving the value of a counter, textual
attributes for receiving the content of an element.</p>

<p>In the structure schema of the primary document, there appears at the end,
after the <tt>TRANSMIT</tt> keyword, a sequence of transmission rules. Each
rule begins with the name of the counter to transmit or of the element type
whose textual content will be transmitted. This name is followed by the
keyword <tt>To</tt> and the name of the attribute of the sub-document to
which the value is transmitted. The sub-document class is indicated between
parentheses after the name of the attribute. The transmission rule ends with
a semicolon.</p>
<pre>     TransmitSeq   =  Transmit &lt; Transmit &gt; .
     Transmit      =  TypeOrCounter 'To' ExternAttr
                      '(' ElemID ')' ';' .
     TypeOrCounter =  CounterID / ElemID .
     ExternAttr    =  NAME .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Consider a Book document class which includes instances of the Chapter
  document class. These classes might have the following schemas:</p>
  <pre>STRUCTURE Book
STRUCT
   Book = BEGIN
          Title = Text;
          Body  = LIST OF (Chapter INCLUDED);
          END;
   ...

STRUCTURE Chapter
STRUCT
   Chapter (ATTR FirstPageNum = Integer;
                 ChapterNum = Integer;
                 CurrentTitle   = Text) =
          BEGIN
          ChapterTitle = Text;
          ...
          END;
   ...</pre>

  <p>Then the presentation schema for books could define chapter and page
  counters. The following transmission rules in the book presentation schema
  would transmit values for the three attributes defined at the root of each
  chapter sub-document.</p>
  <pre>PRESENTATION Book;
VIEWS
   Full_text;
COUNTERS
   ChapterCtr: Rank of Chapter;
   PageCtr: Rank of Page(Full_text);
...
TRANSMIT
   PageCtr TO FirstPageNum(Chapter);
   ChapterCtr TO ChapterNum(Chapter);
   Title TO CurrentTitle(Chapter);
END</pre>

  <p>Thus, each chapter included in a book can number its pages as a function
  of the number of pages preceding it in the book, can make the chapter's
  number appear before the number of each of its sections, or can place the
  title of the book at the top of each page.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4213" id="sectc4213">Presentation rules</a></h3>

<p>Whether defining the appearance of a presentation or page layout box, an
element type, or an attribute value, the set of presentation rules that apply
is always defined in the same way.</p>

<p>Normally, a set of presentation rules is placed between the keywords
<tt>BEGIN</tt> and <tt>END</tt>, the keyword <tt>END</tt> being followed by a
semicolon. The first section of this block defines the rules that apply to
the primary view, if the <a href="#sectc427">default rules</a> are not
completely suitable. Next comes the rules which apply to specific other
views, with a rule sequence for each view for which the default rules are not
satisfactory. If the default rules are suitable for the non-primary views,
there will not be any specific rules for these views. If there is only one
rule which applies to all views then the keywords <tt>BEGIN</tt> and
<tt>END</tt> need not appear.</p>

<p>For each view, it is only necessary to specify those rules which differ
from the default rules for the view, so that for certain views (or even all
views), there may be no specific rules.</p>

<p>The specific rules for a non-primary view are introduced by the <a
name="inkeyword" id="inkeyword"><tt>IN</tt> keyword</a>, followed by the view
name. The rules for that view follow, delimited by the keywords
<tt>BEGIN</tt> and <tt>END</tt>, or without these two keywords when there is
only one rule.</p>

<p><strong>Note:</strong> the view name which follows the <tt>IN</tt> keyword
must not be the name of the primary view, since the rules for that view are
found before the rules for the other views.</p>

<p>Within each block concerning a view, other blocks can appear, delimited by
the same keywords <tt>BEGIN</tt> and <tt>END</tt>. Each of these blocks
gathers the presentation rules that apply, for a given view, only when a
given condition is satisfied. Each block is preceded by a condition
introduced by the <tt>IF</tt> keyword. If such a conditional block contains
only one rule, the keywords <tt>BEGIN</tt> and <tt>END</tt> can be
omitted.</p>

<p>Although the syntax allows any presentation rule to appear in a
conditional block, only <a href="#sectc4232">creation rules</a> are allowed
after any condition; other rules are allowed only after conditions
<tt>Within</tt> and ElemID. In addition, the following rules cannot be
conditional: <tt>PageBreak, LineBreak, Inline, Gather</tt>.</p>

<p>For a given view, the rules that apply without any condition must appear
before the first conditional block. If some rules apply only when none of the
specified condition holds, they are grouped in a block preceded by the
keyword <tt>Otherwise</tt>, and that block must appear after the last
conditionnal block concerning the same view.</p>
<pre>     ViewRuleSeq  = 'BEGIN' &lt; RulesAndCond &gt; &lt; ViewRules &gt;
                    'END' ';' /
                    ViewRules / CondRules / Rule .
     RulesAndCond = CondRules / Rule .
     ViewRules    = 'IN' ViewID CondRuleSeq .
     CondRuleSeq  = 'BEGIN' &lt; RulesAndCond &gt; 'END' ';' /
                    CondRules / Rule .
     CondRules    = CondRule &lt; CondRule &gt;
                    [ 'Otherwise' RuleSeq ] .
     CondRule     = 'IF' ConditionSeq RuleSeq .
     RulesSeq     = 'BEGIN' Rule &lt; Rule &gt; 'END' ';' /
                    Rule .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following rules for a report's title make the title visible in the
  primary view and invisible in the table of contents and in the formula
  views (see the <a href="#sectc4224"><tt>Visibility</tt> rule</a>).</p>
  <pre>Title : BEGIN
        Visibility : 1;
        ...    {Other rules for the primary view}
        IN Table_of_contents
           Visibility : 0;
        IN Formulas
           Visibility : 0;
        END;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4214" id="sectc4214">Conditions applying to presentation
rules</a></h3>

<p>Many conditions can be applied to presentation rules. Conditions allow
certain presentation rules to apply only in certain cases. These conditions
can be based on the structural position of the element. They can be based on
whether the element has references, and what type of references, whether the
element has attributes, possibly with certains values, whether the element is
empty or not, whether the element is the root of its document or not. They
can also be based on the value of a counter.</p>

<p>It is possible to specify several conditions which must all be true for
the rules to apply.</p>

<p>A set of conditions is specified by the <tt>IF</tt> keyword. This keyword
is followed by the sequence of conditions, separated by the <tt>AND</tt>
keyword. Each condition is specified by a keyword which defines the condition
type. In some cases, the keyword is followed by other data, which specify the
condition more precisely. The keyword is not present if the condition depends
on the element type or an attribute associated with the element.</p>

<p>An elementary condition can be negative; it is then preceded by the
<tt>NOT</tt> keyword.</p>

<p>When the presentation rule(s) controlled by the condition apply to a
reference element or a reference attribute, an elementary condition can also
apply to element referred by this reference. The <tt>Target</tt> keyword is
used for that purpose. It must appear before the keyword defining the
condition type.</p>
<pre>     CondRule      ='IF' ConditionSeq RuleSeq .
     ConditionSeq  = Condition &lt; 'AND' Condition &gt; .
     Condition     = [ 'NOT' ] [ 'Target' ] ConditionElem .
     ConditionElem ='First' / 'Last' /
                     [ 'Immediately' ] 'Within' [ NumParent ]
                                       ElemID [ ExtStruct ] /
                     ElemID /
                    'Referred' / 'FirstRef' / 'LastRef' /
                    'ExternalRef' / 'InternalRef' / 'CopyRef' /
                     [ 'Inherited' ] AttrID [ '=' Value ] /
                    'AnyAttributes' / 'FirstAttr' / 'LastAttr' /
                    'UserPage' / 'StartPage' / 'ComputedPage' /
                    'Empty' / 'Root' /
                    '(' [ MinMax ] CounterName CounterCond ')' /
                     CondPage '(' CounterID ')' .
     NumParent     = [ GreaterLess ] NParent .
     GreaterLess   ='&gt;' / '&lt;' .
     NParent       = NUMBER.
     ExtStruct     ='(' ElemID ')' .
     Value         = [ '-' ] IntegerVal / TextVal / AttrValue .
     CounterCond   ='&lt;' MaxCtrVal / '&gt;' MinCtrVal /
                    '=' EqCtrVal / 
                    'IN' '[' ['-'] MinCtrBound '.' '.'
                     ['-'] MaxCtrBound ']' .
     PageCond      ='Even' / 'Odd' / 'One' .
     MaxCtrVal     = NUMBER .
     MinCtrVal     = NUMBER .
     EqCtrVal      = NUMBER .
     MaxCtrBound   = NUMBER .
     MinCtrBound   = NUMBER .</pre>

<div class="subsubsection">
<h4><a name="sectd42141" id="sectd42141">Conditions based on the logical
position of the element</a></h4>

<p>The condition can be on the position of the element in the document's
logical structure tree. It is possible to test whether the element is the
first (<tt>First</tt>) or last (<tt>Last</tt>) among its siblings or if it is
not the first (<tt>NOT First</tt>) or not the last (<tt>NOT Last</tt>). These
conditions can be associated only with <a href="#sectc4232">creation
rules</a>.</p>

<p>It is possible to test if the element is the root of its document (keyword
<code>Root</code>).</p>

<p>It is also possible to test if the element is contained in an element of a
given type (<tt>Within</tt>) or if it is not (<tt>NOT Within</tt>). The type
is indicated after the keyword <tt>Within</tt>. If that element type is
defined in a structure schema which is not the one which corresponds to the
presentation schema, the type name of this element must be followed, between
parentheses, by the name of the structure schema which defines it.</p>

<p>If the keyword <tt>Within</tt> is preceded by <tt>Immediately</tt>, the
condition is satisfied only if the <em>parent</em> element has the type
indicated. If the word <tt>Immediately</tt> is missing, the condition is
satisfied if any <em>ancestor</em> has the type indicated.</p>

<p>An integer <i>n</i> can appear between the keyword <tt>Within</tt> and the
type. It specifies the number of ancestors of the indicated type that must be
present for the condition to be satisfied. If the keyword
<tt>Immediately</tt> is also present, the <i>n</i> immediate ancestors of the
element must have the indicated type. The integer <i>n</i> must be positive
or zero. It can be preceded by <tt>&lt;</tt> or <tt>&gt;</tt> to indicate a
maximum or minimum number of ancestors. If these symbols are missing, the
condition is satisfied only if it exists exactly <i>n</i> ancestors. When
this number is missing, it is equivalent to &gt; 0.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd421411" id="sectd421411">Conditions based on the element
type</a></h4>

<p>If the condition applies to presentation rules associated with an
attribute, in the <tt>ATTRIBUTES</tt> section of the presentation schema, the
condition can be simply an element name. Presentation rules are then executed
only if the attribute is attached to an element of that type. The keyword
<tt>NOT</tt> before the element name indicates that the presentation rules
must be executed only if the element is not of the type indicated.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42142" id="sectd42142">Conditions on references</a></h4>

<p>References may be taken into account in conditions, which can be based on
the fact that the element, or one of its ancestors, is designated by a at
least one reference (<tt>Referred</tt>) or by none (<tt>NOT
Referred</tt>).</p>

<p>If the element or attribute to which the condition is attached is a
reference, the condition can be based on the fact that it acts as the first
reference to the designated element (<tt>FirstRef</tt>), or as the last
(<tt>LastRef</tt>), or as a reference to an element located in another
document (<tt>ExternalRef</tt>) or in the same document
(<tt>InternalRef</tt>).</p>

<p>The condition can also be based on the fact that the element is an <a
href="#inclusion">inclusion</a>. This is noted (<tt>CopyRef</tt>).</p>

<p>Like all conditions, conditions on references can be inverted by the
<tt>NOT</tt> keyword. These conditions can be associated only with <a
href="#sectc4232">creation rules</a>.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42143" id="sectd42143">Conditions on logical
attributes</a></h4>

<p>The condition can be based on the presence or absence of attributes
associated with the element, no matter what the attributes or their values.
The <tt>AnyAttributes</tt> keyword expresses this condition.</p>

<p>A condition can also be based on the presence or absence of a given
attribute associated with the element. This condition is simply expressed by
the name of the attribute. The condition may also be based on the presence of
a given attribute associated with a parent of the element. This condition is
expressed by the <code>Inherited</code> keyword, followed by the name of the
attribute.</p>

<p>The condition can be based on the value of a given attribute. It is then
expressed by the name of the attribute, followed by the '=' sign and the
value to be tested. Depending on the type of attribute, the value is simply
an integer (possibly negative), the name of one of the possible values of the
attribute or a quoted character string. If the attribute with the specified
value has to be checked on the ancestors of the element, this condition
starts with the keyword <code>Inherited.</code></p>

<p>If the condition appears in the presentation rules of an attribute, the
<tt>FirstAttr</tt> and <tt>LastAttr</tt> keywords can be used to indicate
that the rules must only be applied if this attribute is the first attribute
for the element or if it is the last (respectively). These conditions can
also be inverted by the <tt>NOT</tt> keyword. These conditions can be
associated only with <a href="#sectc4232">creation rules</a>.</p>

<p>It is also possible to apply certain presentation rules only when the
element being processed or one of its ancestors has a certain attribute,
perhaps with a certain value. This can be done in the <a
href="#sectc4210"><tt>ATTRIBUTES</tt> section</a>.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42144" id="sectd42144">Conditions on page breaks</a></h4>

<p>The page break base type (and only this type) can use the following
conditions: <tt>ComputedPage</tt>, <tt>StartPage</tt>, and <tt>UserPage</tt>.
The <tt>ComputedPage</tt> condition indicates that the presentation rule(s)
should apply if the page break was created automatically by Thot; the
<tt>StartPage</tt> condition is true if the page break is generated before
the element by the <tt>Page</tt> rule; and the <tt>UserPage</tt> condition
applies if the page break was inserted by the user.</p>

<p>These conditions can be associated only with <a href="#sectc4232">creation
rules</a>.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42145" id="sectd42145">Conditions on the element's
content</a></h4>

<p>The condition can be based on whether or not the element is empty. An
element which has no children or whose leaves are all empty is considered to
be empty itself. This condition is expressed by the <tt>Empty</tt> keyword,
optionally preceded by the <tt>NOT</tt> keyword. This condition can be
associated only with <a href="#sectc4232">creation rules</a>.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42146" id="sectd42146">Conditions on counters</a></h4>

<p>Presentation rules can apply when the counter's value is one, is even or
odd, is equal, greater than or less than a given value or falls in a range of
values. This is particularly useful for creating header and footer boxes.
These conditions can be associated only with <a href="#sectc4232">creation
rules</a>.</p>

<p>To compare the value of a counter to a given value, a comparison is given
between parentheses. The comparison is composed of the counter name followed
by an equals, greater than, or less than sign and the value to which the
counter will be compared. A test for whether or not a counter's value falls
in a range also appears within parentheses. In this case, the counter name is
followed by the <tt>IN</tt> keyword and the range definition within brackets.
The <tt>Even</tt>, <tt>Odd</tt> and <tt>One</tt> are used to test a counter's
value and are followed by the counter name between parentheses.</p>

<p>The list of possible conditions on counters is:</p>
<dl>
  <dt><tt>Even (Counter)</tt></dt>
    <dd>the box is created only if the counter has an even value.</dd>
  <dt><tt>Odd (Counter)</tt></dt>
    <dd>the box is created only if the counter has an odd value.</dd>
  <dt><tt>One (Counter)</tt></dt>
    <dd>the box is created only the counter's value is 1.</dd>
  <dt><tt>NOT One (Counter)</tt></dt>
    <dd>the box is created, unless the counter's value is 1.</dd>
  <dt><tt>(Counter &lt; Value)</tt></dt>
    <dd>the box is created only if the counter's value is less than
    Value.</dd>
  <dt><tt>(Counter &gt; Value)</tt></dt>
    <dd>the box is created only if the counter's value is greater than
    Value.</dd>
  <dt><tt>(Counter = Value)</tt></dt>
    <dd>the box is created only if the counter's value is equal to Value.</dd>
  <dt><tt>NOT (Counter = Value)</tt></dt>
    <dd>the is created only if the counter's value is different than
    Value.</dd>
  <dt><tt>(Counter IN [MinValue..MaxValue])</tt></dt>
    <dd>the box is created only if the counter's value falls in the range
      bounded by MinValue and MaxValue (inclusive).</dd>
  <dt><tt>NOT (Counter IN [MinValue..MaxValue])</tt></dt>
    <dd>the box is created only if the value of the counter does not fall in
      the range bounded by MinValue and MaxValue (inclusive).</dd>
</dl>

<p><strong>Note:</strong> the <tt>NOT Even</tt> and <tt>NOT Odd</tt>
conditions are syntactically correct but can be expressed more simply by
<tt>Odd</tt> and <tt>Even</tt>, respectively.</p>
</div>
</div>

<div class="subsection">
<h3><a name="sectc4215" id="sectc4215">A presentation rule</a></h3>

<p>A presentation rule defines either a presentation property or presentation
function. The properties are:</p>
<ul>
  <li>the position of the vertical and horizontal reference axes of the
  box,</li>
  <li>the position of the box in relation to other boxes,</li>
  <li>the height or width of the box, with overflow exceptions,</li>
  <li>the margins, padding and borders of the box,</li>
  <li>the style and position of list item markers,</li>
  <li>the characteristics of the lines contained in the box: linespacing,
    indentation of the first line, hyphenation, writing direction</li>
  <li>the conditions for breaking the box across pages,</li>
  <li>the characteristics of the characters contained in the box: size, font,
    style, underlining,</li>
  <li>the depth of the box among overlapping boxes (often called stacking
    order),</li>
  <li>the characteristics of graphic elements contained in the box: style and
    thickness of lines, fill pattern for closed objects,</li>
  <li>the colors in text, graphics, pictures, and symbols contained in the
    box are displayed or printed,</li>
  <li>the opacity of the element,</li>
  <li>for presentation boxes only, the contents of the box.</li>
</ul>

<p>The <a name="presfunct" id="presfunct">presentation functions</a> are:</p>
<ul>
  <li>the creation of a presentation box</li>
  <li>the line-breaking or page-breaking style,</li>
  <li>the copying of another box,</li>
  <li>the display of the box background and border,</li>
  <li>the display of a background picture and its aspect.</li>
</ul>

<p>For each box and each view, every presentation property is defined once
and only once, either explicitly or by the <a href="#sectc427">default
rules</a>. In contrast, presentation functions are not obligatory and can
appear many times for the same element. for example an element can create
many presentation boxes. Another element may not use any presentation
functions.</p>

<p>Each rule defining a presentation property begins with a keyword followed
by a colon. The keyword indicates the property which is the subject of the
rule. After the keyword and the colon, the remainder of the rule varies. All
rules are terminated by a semicolon.</p>
<pre>     Rule      = Property ';' / PresFunc ';' .
     Property  ='VertRef' ':'       HorizPosition /
                'HorizRef' ':'      VertPosition /
                'VertPos' ':'       VPos /
                'HorizPos' ':'      HPos /
                'Float' ':'         FloatInherit /
                'Clear' ':'         ClearInherit /
                'Height' ':'        Dimension /
                'Width' ':'         Dimension /
                'VertOverflow' ':'  Boolean /
                'HorizOverflow' ':' Boolean /
                'MarginTop' ':'     MarginWidth /
                'MarginRight' ':'   MarginWidth /
                'MarginBottom' ':'  MarginWidth /
                'MarginLeft' ':'    MarginWidth /
                'PaddingTop' ':'    PaddingWidth /
                'PaddingRight' ':'  PaddingWidth /
                'PaddingBottom' ':' PaddingWidth /
                'PaddingLeft' ':'   PaddingWidth /
                'BorderTopWidth' ':' BorderWidth /
                'BorderRightWidth' ':' BorderWidth /
                'BorderBottomWidth' ':' BorderWidth /
                'BorderLeftWidth' ':' BorderWidth /
                'BorderTopColor' ':' BorderColor /
                'BorderRightColor' ':' BorderColor /
                'BorderBottomColor' ':' BorderColor /
                'BorderLeftColor' ':' BorderColor /
                'BorderTopStyle' ':' BorderStyle /
                'BorderRightStyle' ':' BorderStyle /
                'BorderBottomStyle' ':' BorderStyle /
                'BorderLeftStyle' ':' BorderStyle /
                'ListStyleType' ':' ListStyleType /
                'ListStyleImage' ':' ListStyleImage /
                'ListStylePosition' ':' ListStylePosition /
                'LineSpacing' ':'   DistanceInherit /
                'Indent' ':'        DistanceInherit /
                'Adjust' ':'        AdjustInherit /
                'Hyphenate' ':'     BoolInherit /
                'Direction' ':'     DirInherit /
                'UnicodeBidi' ':'   BidiInherit /
                'PageBreak' ':'     Boolean /
                'LineBreak' ':'     Boolean /
                'InLine' ':'        Boolean /
                'NoBreak1' ':'      AbsDist /
                'NoBreak2' ':'      AbsDist /
                'Gather' ':'        Boolean /
                'Visibility' ':'    NumberInherit /
                'Size'  ':'         SizeInherit /
                'Font' ':'          NameInherit /
                'Style' ':'         StyleInherit /
                'Weight' ':'        WeightInherit /
                'Underline' ':'     UnderLineInherit /
                'Thickness' ':'     ThicknessInherit /
                'Depth' ':'         NumberInherit /
                'LineStyle' ':'     LineStyleInherit /
                'LineWeight' ':'    DistanceInherit /
                'FillPattern' ':'   NameInherit /
                'Background' ':'    NameInherit /
                'Foreground' ':'    NameInherit /
                'Opacity' ':'       OpacityInherit /
                'FillOpacity' ':'   OpacityInherit /
                'StrokeOpacity' ':' OpacityInherit /
                'Content' ':'       VarConst .
     PresFunc = Creation '(' BoxID ')' /
                'Line' /
                'NoLine' /
                'Display' ':' DisplayVal /
                'Page' '(' BoxID ')' /
                'Copy' '(' BoxTypeToCopy ')' /
                'ShowBox' /
                'BackgroundPicture' ':' FileName /
                'PictureMode' ':'   PictMode /</pre>
</div>

<div class="subsection">
<h3><a name="sectc4216" id="sectc4216">Box axes</a></h3>

<p>The position of the middle axes <tt>VMiddle</tt> and <tt>HMiddle</tt> in
relation to their box is always calculated automatically as a function of the
height and width of the box and is not specified by the presentation rules.
In the presentation schema, these middle axes are used only to position their
box with respect to another by specifying the distance between the middle
axis and an axis or a side of another box (see the <a
href="#sectc4218">relative position</a>).</p>

<p>The reference axes of a box are also used to position their box in
relation to another, but in contrast to the middle axes, the presentation
schema must make their position explicit, either in relation to a side or the
middle axis of the box itself, or in relation to an axis of an enclosed
box.</p>

<p>Only boxes of base elements have predefined reference axes. For character
string boxes, the horizontal reference axis is the baseline of the characters
(the line which passes immediately under the upper-case letters, ignoring the
letter Q) and the vertical reference axis is at the left edge of the first
character of the string.</p>

<p>The positions of a box's reference axes are defined by the
<tt>VertRef</tt> and <tt>HorizRef</tt> rules which specify the <a
href="#distance">distance</a> between the reference axis and an axis or
parallel side of the same box or of an enclosed box.</p>
<pre>               'VertRef'  ':' HorizPosition
               'HorizRef' ':' VertPosition</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If, in the structure schema for mathematical formulas, the fraction
  element is defined by</p>
  <pre>Fraction = BEGIN
           Numerator   = Expression;
           Denominator = Expression;
           END;</pre>

  <p>then the horizontal reference axis of the fraction can be positioned on
  top of the denominator by the rule:</p>
  <pre>Fraction :
     BEGIN
     HorizRef : Enclosed Denominator . Top;
     ...
     END;</pre>

  <p>To put the horizontal reference axis of a column at its middle:</p>
  <pre>Column :
     BEGIN
     HorizRef : * . HMiddle;
     ...
     END;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4217" id="sectc4217">Distance units</a></h3>

<p>Some distances and dimensions appear in many rules of a presentation
schema, especially in position rules (<tt>VertPos, HorizPos</tt>), in extent
rules for boxes (<tt>Height, Width</tt>), in rules defining lines
(<tt>LineSpacing, Indent</tt>), in rules controlling pagination
(<tt>NoBreak1, NoBreak2</tt>) and in rules specifying the thickness of
strokes (<tt>LineWeight</tt>).</p>

<p>In all these rules, the distance or extent can be expressed</p>
<ul>
  <li>either in relative units, which depend on the size of the characters in
    the current font: height of the element's font or height of the letter
    'x',</li>
  <li>or in absolute units: centimeter, millimeter, inch, typographer's
    point, pica or pixel.</li>
</ul>

<p>Units can be chosen freely. Thus, it is possible to use relative units in
one rule, centimeters in the next rule, and typographer's points in
another.</p>

<p>Absolute units are used to set rigid rules for the appearance of
documents. In contrast, relative units allow changes of scale. The editor
lets the value of relative units be changed dynamically. Such changes affect
every box using relative units simultaneously and in the same proportion.
Changing the value of the relative units affects the size of the characters
and graphical elements, and the size of the boxes and the distances between
them.</p>

<p>A <a name="distance" id="distance">distance</a> or extent is specified by
a number, which may be followed by one or more spaces and a units keyword.
When there is no units keyword, the number specifies the number of relative
units, where a relative unit is the height of a character in the current font
(an em). When the number is followed by a units keyword, the keyword
indicates the type of absolute units:</p>
<ul>
  <li><tt>em</tt> : height of the element's font,</li>
  <li><tt>ex</tt> : height of the letter 'x',</li>
  <li><tt>cm</tt> : centimeter,</li>
  <li><tt>mm</tt> : millimeter,</li>
  <li><tt>in</tt> : inch (1 in = 2.54 cm),</li>
  <li><tt>pt</tt> : point (1 pt = 1/72 in),</li>
  <li><tt>pc</tt> : pica (1 pc = 12 pt),</li>
  <li><tt>px</tt> : pixel.</li>
</ul>

<p>Whatever the chosen unit, relative or absolute, the number is not
necessarily an integer and may be expressed in fixed point notation (using
the American convention of a period to express the decimal point).</p>

<p>If the distance appears in a presentation rule for a numeric attribute,
the number can be replaced by the name of an attribute. In this case, the
value of the attribute is used. Obviously, the attribute name cannot be
followed by a decimal point and a fractional part, but it can be followed a
units keyword. However, the choice of units is limited to em, ex, pt and
px.</p>
<pre>     Distance      = [ Sign ] AbsDist .
     Sign          ='+' / '-' .
     AbsDist       = IntegerOrAttr [ '.' DecimalPart ]
                     [ Unit ].
     IntegerOrAttr = IntegerPart / AttrID .
     IntegerPart   = NUMBER .
     DecimalPart   = NUMBER .
     Unit          ='em' / 'ex' / 'cm' / 'mm' / 'in' / 'pt' /
                    'pc' / 'px' / '%' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following rules specify that a box has a height of 10.5 centimeters
  and a width of 5.3 ems:</p>
  <pre>Height : 10.5 cm;
Width  : 5.3;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4218" id="sectc4218">Relative positions</a></h3>

<p>The positioning of boxes uses the eight axes and sides, the sides
generally being used to define the juxtapositioning (vertical or horizontal)
of boxes, the middle axes being used to define centering, and the reference
axes being used for alignment.</p>

<p>Two rules allow a box to be placed relative to other boxes. The
<tt>VertPos</tt> rule positions the box vertically. The <tt>HorizPos</tt>
rule positions the box horizontally. It is possible that a box's position
could be entirely determined by other boxes positioned relative to it. In
this case, the position is implicit and the word <tt>nil</tt> can be used to
specify that no position rule is needed. Otherwise, an explicit rule must be
given by indicating the axis or side which defines the position of the box,
followed by an equals sign and the distance between between this axis or side
and a parallel axis or side of another box, called the reference box. The box
for which the rule is written will be positioned relative to the reference
box.</p>
<pre>                 'VertPos' ':' VPos
                 'HorizPos' ':' HPos
     HPos      = 'nil' / VertAxis '=' HorizPosition
                 [ 'UserSpecified' ].
     VPos      = 'nil' / HorizAxis '=' VertPosition
                 [ 'UserSpecified' ].
     VertAxis  = 'Left' / 'VMiddle' / 'VRef' / 'Right' .
     HorizAxis = 'Top' / 'HMiddle' / 'HRef' / 'Bottom' .</pre>

<p>The reference box is an adjacent box: enclosing, enclosed or adjacent.
When a rule is associated with a reference type attribute (and only in this
case), it can be a box of the element designated by the attribute. The
reference box can be either a presentation box previously defined in the
<tt>BOXES</tt> section of the schema and created by a creation function, or
the box associated with a structured element.</p>

<p>The structural position of the reference box (relative to the box for
which the rule is being written) is indicated by a keyword:
<tt>Enclosing</tt>, <tt>Enclosed</tt>, or, for sibling boxes,
<tt>Previous</tt> or <tt>Next</tt>. The reference attributes, or presentation
boxes created by a reference attribute, the <tt>Referred</tt> keyword may be
used to designate the element which the reference points to. The keyword
<tt>Creator</tt> can be used in rules for presentation boxes to designate the
box of the element which created the presentation box. Finally, the
<tt>Root</tt> keyword can be used to designate the root of the document.</p>

<p>When the keyword is ambiguous, it is followed by the name of an element
type or presentation box which resolves the ambiguity (the <tt>Creator</tt>
and <tt>Root</tt> keywords are never ambiguous). If this name is not given,
then the first box encountered is used as the reference box. It is also
possible to use just the name of an element type or presentation box without
an initial keyword. In this case, a sibling having that name will be used. If
the name is preceded by the keyword <tt>NOT</tt>, then the reference box will
be the first box whose type is not the named one.</p>

<p>In place of the box or type name, the keywords <tt>AnyElem</tt>,
<tt>AnyBox</tt> and <tt>ElemWithAttr</tt> can be used, representing
respectively, any structured element box, any presentation box, and the box
corresponding to any structured element having a particular attribute,
whatever its value; the name of this attribute must follow the keyword
<tt>ElemWithAttr</tt>.</p>

<p>A type name may be preceded by a star in order to resolve the ambiguity in
the special case where the structure schema defines an <a
href="#sectd3284">inclusion</a> without expansion (or with partial expansion)
of the same type as an element of the scheme. For mark pairs (and only for <a
href="#sectd3285">mark pairs</a>) the type name <em>must</em> be preceded by
the <tt>First</tt> or <tt>Second</tt> keyword, which indicates which of the
two marks of the pair should be used as the reference box.</p>

<p>The star character ('<tt>*</tt>') used alone designates the box to which
the rule applies (in this case, it is obviously useless to specify the type
of the reference box).</p>

<p>The keywords <tt>Enclosing</tt> and <tt>Enclosed</tt> can be used no
matter what constructor defines the type to which the rule applies. When
applied to the element which represents the entire document,
<tt>Enclosing</tt> designates the window or page in which the document's
image is displayed for the view to which the rule applies. A box or type name
without a keyword is used for aggregate elements and designates another
element of the same aggregate. It can also be used to designate a
presentation or page layout box. The keywords <tt>Previous</tt> and
<tt>Next</tt> are primarily used to denote list elements, but can also be
used to denote elements of an aggregate.</p>

<p>In the position rule, the structural position relative to the reference
box is followed, after a period, by the name of an axis or side. The rule
specifies its node's position as being some distance from this axis or side
of the reference box. If this distance is zero, then the distance does not
appear in the rule. Otherwise, it does appear as a positive or negative
number (the sign is required for negative numbers). The sign takes into
account the orientation of the coordinate axes: for top to bottom for the
vertical axis and from left to right for the horizontal axis. Thus, a
negative distance in a vertical position indicates that the side or axis
specified in the rule is above the side or axis of the reference box.</p>

<p>The distance can be followed by the <tt>UserSpecified</tt> keyword (even
if the distance is nil and does not appear, the <tt>UserSpecified</tt>
keyword can be used). It indicates that when the element to which the rule
applies is being created, the editor will ask the user to specify the
distance himself, using the mouse. In this case, the distance specified in
the rule is a default distance which is suggested to the user but can be
modified. The <tt>UserSpecified</tt> keyword can be used either in the
vertical position rule, the horizontal position rule, or both.</p>
<pre>     VertPosition  = Reference '.' HorizAxis [ Distance ] .
     HorizPosition = Reference '.' VertAxis [ Distance ] .
     Reference     ='Enclosing' [ BoxTypeNot ] /
                    'Enclosed' [ BoxTypeNot ] /
                    'Previous' [ BoxTypeNot ] /
                    'Next' [ BoxTypeNot ] /
                    'Referred' [ BoxTypeNot ] /
                    'Creator' /
                    'Root' /
                    '*' /
                     BoxOrType .
     BoxOrType     = BoxID /
                     [ '*' ] [ FirstSec ] ElemID /
                    'AnyElem' / 'AnyBox' /
                    'ElemWithAttr' AttrID .
     BoxTypeNot    = [ 'NOT' ] BoxOrType .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If a <a name="expos1" id="expos1">report</a> is defined by the following
  structure schema:</p>
  <pre>Report = BEGIN
         Title  = Text;
         Summary = Text;
         Keywords = Text;
         ...
         END;</pre>

  <p>then the presentation schema could contain the rules:</p>
  <pre>Report : BEGIN
         VertPos  : Top = Enclosing . Top;
         HorizPos : Left = Enclosing . Left;
         ...
         END;</pre>

  <p>These rules place the <a name="reportexample"
  id="reportexample">report</a> in the upper left corner of the enclosing
  box, which is the window in which the document is being edited.</p>
  <pre>Title :  BEGIN
         VertPos  : Top = Enclosing . Top + 1;
         HorizPos : VMiddle = Enclosing . VMiddle;
         ...
         END;</pre>

  <p>The top of the title is one line (a line has the height of the
  characters of the title) from the top of the report, which is also the top
  of the editing window. The title is centered horizontally in the window
  (see <a href="#posdim">figure</a>).</p>
  <pre>Summary : BEGIN
          VertPos  : Top = Title . Bottom + 1.5;
          HorizPos : Left = Enclosing . Left + 2 cm;
          ...
          END;</pre>

  <p>The top of the summary is place a line and a half below the bottom of
  the title and is shifted two centimeters from the side of the window.</p>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose there is a <a name="expos2" id="expos2">Design</a> logical
  structure which contains graphical elements:</p>
  <pre>Design = LIST OF (ElemGraph = GRAPHICS);</pre>

  <p>The following rules allow the user to freely choose the position of each
  element when it is created:</p>
  <pre>ElemGraph =
   BEGIN
   VertPos : Top = Enclosing . Top + 1 cm UserSpecified;
   HorizPos: Left = Enclosing . Left UserSpecified;
   ...
   END;</pre>

  <p>Thus, when a graphical element is created, its default placement is at
  the left of the window and 1 cm from the top, but the user can move it
  immediately, simply by moving the mouse.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="Floats" id="Floats">Floats</a></h3>

<p>Another way to set the position of a box is to make it a floating box. The
notion of a floating box is the same as in CSS2. Refer to the <a
href="http://www.w3.org/TR/REC-CSS2/visuren.html#floats">relevant section of
the CSS2 Recommendation</a> for the details. The <code>Float</code> and
<code>Clear</code> rules allow to control how floating boxes behave. The
values of these rules are the same as in CSS2. Inheritance is indicated by
<code>Enclosing =</code></p>
<pre>                    'Float' ':' FloatInherit
                    'Clear' ':' ClearInherit
     FloatInherit = Link '=' / 'Left' / 'Right' / 'None' .
     ClearInherit = Link '=' / 'None' / 'Left' / 'Right' / 'Both' .</pre>
</div>

<div class="subsection">
<h3><a name="sectc4219" id="sectc4219">Box extents</a></h3>

<p>The extents (height and width) of each box are defined by the two rules
<tt>Height</tt> and <tt>Width</tt>. There are three types of extents: fixed,
relative, and elastic.</p>

<div class="subsubsection">
<h4><a name="sectd42191" id="sectd42191">Fixed extents</a></h4>

<p>A fixed dimension sets the height or width of the box independently of all
other boxes. It is expressed in <a href="#sectc4217">distance units</a>. The
extent can be followed by the <tt>UserSpecified</tt> keyword which indicates
that when the element to which the rule applies is being created, the editor
will ask the user to specify the extent himself, using the mouse. In this
case, the extent specified in the rule is a default extent which is suggested
to the user but can be modified. The <tt>UserSpecified</tt> keyword can be
used either in the <tt>Height</tt> rule, the <tt>Width</tt> rule, or both.</p>

<p>A fixed extent rule can be ended by the <tt>Min</tt> keyword, which
signifies that the indicated value is a minimum, and that, if the contents of
the box require it, a larger extent is possible.</p>
<pre>                'Height' ':' Dimension
                'Width' ':' Dimension
     Dimension = AbsDist [ 'UserSpecified' ]  [ 'Min' ] /
                 ...</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Continuing with the <a href="#expos2">previous example</a>, it is
  possible to allow the user to choose the size of each graphical element as
  it is created:</p>
  <pre>ElemGraph : BEGIN
            Width :  2 cm UserSpecified;
            Height : 1 cm UserSpecified;
            ...
            END;</pre>

  <p>Thus, when a graphical element is create, it is drawn by default with a
  width of 2 cm and a height of 1 cm, but the user is free to resize it
  immediately with the mouse.</p>
  <pre>Summary :  BEGIN
           Height : 5 cm Min;
           ...
           END;
Keywords : BEGIN
           VertPos : Top = Summary . Bottom;
           ...
           END;</pre>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd42192" id="sectd42192">Relative extents</a></h4>

<p>A relative extent determines the extent as a function of the extent of
another box, just as a relative position places a box in relation to another.
The reference box in an extent rule is designated using the same syntax as is
used in a relative position rule. It is followed by a period and a
<tt>Height</tt> or <tt>Width</tt> keyword, depending on the extent being
referred to. Next comes the relation between the extent being defined and the
extent of the reference box. This relation can be either a percentage or a
difference.</p>

<p>A percentage is indicated by a star (the multiplication symbol) followed
by the numeric percentage value (which may be greater than or less than 100)
and the percent (`%') character. A difference is simply indicated by a signed
difference.</p>

<p>If the rule appears in the presentation rules of a numeric attribute, the
percentage value can be replaced by the name of the attribute. This attribute
is then used as a percentage. The attribute can also be used as part of a <a
href="#distance">difference</a>.</p>

<p>Just as with a fixed extent, a relative extent rule can end with the
<tt>Min</tt> keyword, which signifies that the extent is a minimum and that,
if the contents of the box require it, a larger extent is possible.</p>

<p>A special case of relative extent rules is:</p>
<pre>Height : Enclosed . Height;</pre>

<p>or</p>
<pre>Width  : Enclosed . Width;</pre>

<p>which specifies that the box has a height (or width) such that it encloses
all the boxes which it contains, excluding boxes having a rule
<tt>VertOverflow: Yes;</tt> or <tt>HorizOverflow: Yes;</tt>.</p>

<p><strong>Note:</strong> character strings (type <tt>TEXT_UNIT</tt>)
generally must use the sum of the widths of the characters which compose them
as their width, which is expressed by the rule:</p>
<pre>TEXT_UNIT :
     Width : Enclosed . Width;</pre>

<p>If this rule is not the default <tt>Width</tt> rule, it must be given
explicitly in the <tt>RULES</tt> section which defines the presentation rules
of the logical elements.</p>
<pre>                  'Height' ':' Extent
                  'Width' ':' Extent
     Extent      = Reference '.' HeightWidth [ Relation ]
                   [ 'Min' ] / ...
     HeightWidth ='Height' / 'Width' .
     Relation    ='*' ExtentAttr '%' / Distance .
     ExtentAttr  = ExtentVal / AttrID .
     ExtentVal   = NUMBER .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Completing the <a href="#expos1">above example</a>, it is possible to
  specify that the report takes its width from the editing window and its
  height from the size of its contents (this can obviously be greater than
  that of the window):</p>
  <pre>Report :  BEGIN
          Width : Enclosing . Width;
          Height : Enclosed . Height;
          ...
          END;</pre>

  <p>Then, the following rules make the title occupy 60% of the width of the
  report (which is that of the window) and is broken into centered lines of
  this width (see the <a href="#sectc4222"><tt>Line</tt> rule</a>).</p>
  <pre>Title :   BEGIN
          Width : Enclosing . Width * 60%;
          Height : Enclosed . Height;
          Line;
          Adjust : VMiddle;
          ...
          END;</pre>

  <p>The summary occupy the entire width of the window, with the exception of
  a 2 cm margin reserved by the horizontal position rule:</p>
  <pre>Summary : BEGIN
          Width : Enclosing . Width - 2 cm;
          Height : Enclosed . Height;
          ...
          END;</pre>

  <p>This set of rules, plus the <a href="#reportexample">position rules
  given above</a>, produce the layout of boxes shown in the following<a
  href="#posdim">figure</a>.</p>

  <div class="figure">
  <hr />
  <pre>-------------------------------------------------------------
| Window and Report           ^                             |
|                             | 1 line                      |
|                             v                             |
|           -------------------------------------           |
|           |                                   |           |
:    20%    :               Title               :    20%    :
:&lt;---------&gt;:                                   :&lt;---------&gt;:
:           :                60%                :           :
:           :&lt;---------------------------------&gt;:           :
|           |                                   |           |
|           -------------------------------------           |
|                             ^                             |
|                             | 1.5 line                    |
|                             |                             |
|                             v                             |
|        ---------------------------------------------------|
|  2 cm  |                                                  |
|&lt;------&gt;|                    Summary                       |
:        :                                                  :</pre>

  <p align="center"><em><a name="posdim" id="posdim">Box position and
  extent</a><em></em></em></p>
  <hr />
  </div>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd42193" id="sectd42193">Elastic extents</a></h4>

<p>The last type of extent is the elastic extent. Either one or both extents
can be elastic. A box has an elastic extent when two opposite sides are
linked by distance constraints to two sides or axes of other boxes.</p>

<p>One of the sides of the elastic box is linked by a position rule
(<tt>VertPos</tt> or <tt>HorizPos</tt>) to a neighboring box. The other side
is link to another box by a <tt>Height</tt> or <tt>Width</tt> rule, which
takes the same form as the position rule. For the elastic box itself, the
notions of sides (left or right, top or bottom) are fuzzy, since the movement
of either one of the two reference boxes can, for example, make the left side
of the elastic box move to the right of its right side. This is not
important. The only requirement is that the two sides of the elastic box used
in the position and extent rule are opposite sides of the box.</p>
<pre>             'Height' ':' Extent
             'Width' ':' Extent
     Extent = HPos / VPos / ...</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose we want to draw an elastic arrow or line between the middle of
  the bottom side of box A and the upper left corner of box B. To do this, we
  would define a graphics box whose upper left corner coincides with the
  middle of the bottom side of A (a position rule) and whose lower right
  corner coincides with with the upper left corner of B (dimension rules):</p>
  <pre>LinkedBox :
   BEGIN
   VertPos  : Top = A .Bottom;
   HorizPos : Left = A . VMiddle;
   Height   : Bottom = B . Top;
   Width    : Right = B . Left;
   END;</pre>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The element SectionTitle creates a presentation box called SectionNum
  which contains the number of the section. Suppose we want to align the
  SectionNum and SectionTitle horizontally, have the SectionNum take its
  width from its contents (the section number), have the SectionTitle box
  begin 0.5 cm to the right of the SectionNum box and end at the right edge
  of its enclosing box. This would make the SectionTitle box elastic, since
  its width is defined by the position of its left and right sides. The
  following rules produce this effect:</p>
  <pre>SectionNum :
   BEGIN
   HorizPos : Left = Enclosing . Left;
   Width : Enclosed . Width;
   ...
   END;

SectionTitle :
   BEGIN
   HorizPos : Left = SectionNum . Right + 0.5 cm;
   Width : Right = Enclosing . Right;
   ...
   END;</pre>
</blockquote>
</div>
</div>

<div class="subsection">
<h3><a name="sectc4220" id="sectc4220">Overflow</a></h3>

<p>A box corresponding to a structural element normally contain all boxes
corresponding to the elements of its subtree. However, in some cases, it
could be necessary to allow a box to jut out from its parent box. Two
presentation rules indicate that such an overflow is allowed, one for
horizontal overflow, one for vertical overflow.</p>

<p>Each of these rules is expressed by a keyword followed by a colon and the
keyword <tt>Yes</tt> or <tt>No</tt>.</p>
<pre>               'VertOverflow' ':' Boolean /
               'HorizOverflow' ':' Boolean .
     Boolean = 'Yes' / 'No' .</pre>
</div>

<div>
<h3><a name="Margins" id="Margins">Margins, Padding and Borders</a></h3>

<p>Boxes (element boxes and presentation boxes as well) may have margins,
padding and borders, exactly as in CSS. A set of presentation rules allow to
control the width of margins, padding and borders along the four edges of
boxes. Other rules determine the color and style of borders. Refer to the
CSS2 specification for more details.</p>
<pre>                'MarginTop' ':' MarginWidth /
                'MarginRight' ':' MarginWidth /
                'MarginBottom' ':' MarginWidth /
                'MarginLeft' ':' MarginWidth /
                'PaddingTop' ':' PaddingWidth /
                'PaddingRight' ':' PaddingWidth /
                'PaddingBottom' ':' PaddingWidth /
                'PaddingLeft' ':' PaddingWidth /
                'BorderTopWidth' ':' BorderWidth /
                'BorderRightWidth' ':' BorderWidth /
                'BorderBottomWidth' ':' BorderWidth /
                'BorderLeftWidth' ':' BorderWidth /
                'BorderTopColor' ':' BorderColor /
                'BorderRightColor' ':' BorderColor /
                'BorderBottomColor' ':' BorderColor /
                'BorderLeftColor' ':' BorderColor /
                'BorderTopStyle' ':' BorderStyle /
                'BorderRightStyle' ':' BorderStyle /
                'BorderBottomStyle' ':' BorderStyle /
                'BorderLeftStyle' ':' BorderStyle .

MarginWidth   = InheritParent / 'Auto' / Distance .
PaddingWidth  = InheritParent / Distance .
BorderWidth   = InheritParent / 'Thin' / 'Medium' / 'Thick' / Distance .
BorderColor   = InheritParent / 'Transparent' / 'Foreground' /
                ColorName .
BorderStyle   = InheritParent /
                'None' / 'Hidden' / 'Dotted' / 'Dashed' / 'Solid' /
                'Double' / 'Groove' / 'Ridge' / 'Inset' / 'Outset' .
InheritParent = 'Enclosing' '=' / 'Creator' '=' .
ColorName     =  NAME .</pre>
</div>

<div class="subsection">
<h3><a name="sectc4221" id="sectc4221">Inheritance</a></h3>

<p>A presentation property can be defined by reference to the same property
of another box in the tree of boxes. These structural links are expressed by
kinship. The reference box can be that of the element immediately above in
the structure (<tt>Enclosing</tt>), two levels above (<tt>GrandFather</tt>),
immediately below (<tt>Enclosed</tt>) or immediately before
(<tt>Previous</tt>). In the case of a presentation box, and only in that
case, the reference box may be the element which created the presentation box
(<tt>Creator</tt>).</p>

<p>Kinship is expressed in terms of the logical structure of the document and
not in terms of the tree of boxes. The presentation box cannot transmit any
of their properties by inheritance; only structured element boxes can do so.
As an example, consider an element B which follows an element A in the
logical structure. The element B creates a presentation box P in front of
itself, using the <tt>CreateBefore</tt> rule (see the <a
href="#sectc4232">creation rules</a>). If element B's box inherits its
character style using the <tt>Previous</tt> kinship operation, it gets its
character style from A's box, not from P's box. Inheritance works differently
for positions and extents, which can refer to presentation boxes.</p>

<p>The inherited property value can be the same as that of the reference box.
This is indicated by an equals sign. However, for numeric properties, a
different value can be obtained by adding or subtracting a number from the
reference box's property value. Addition is indicated by a plus sign before
the number, while subtraction is specified with a minus sign. The value of a
property can also be given a maximum (if the sign is a plus) or minimum (if
the sign is a minus).</p>

<p>If the rule is being applied to a numeric attribute, the number to add or
subtract can be replaced by the attribute name. The value of a maximum or
minimum may also be replaced by an attribute name. In these cases, the value
of the attribute is used.</p>
<pre>  Inheritance    = Kinship  InheritedValue .
  Kinship        ='Enclosing' / 'GrandFather' / 'Enclosed' /
                  'Previous' / 'Creator' .
  InheritedValue ='+' PosIntAttr [ 'Max' maximumA ] /
                  '-' NegIntAttr [ 'Min' minimumA ] /
                  '=' .
  PosIntAttr     = PosInt / AttrID .
  PosInt         = NUMBER .
  NegIntAttr     = NegInt / AttrID .
  NegInt         = NUMBER .
  maximumA       = maximum / AttrID .
  maximum        = NUMBER .
  minimumA       = minimum / AttrID .
  minimum        = NUMBER .</pre>

<p>The properties which can be obtained by inheritance are hyphenation,
writing direction, Unicode-bidi, interline spacing, character font (font
family), font style, font size, visibility, indentation, underlining,
alignment of text, stacking order of objects, the style and thickness of
lines, fill pattern and the colors of lines and characters.</p>
</div>

<div class="subsection">
<h3><a name="sectc4222" id="sectc4222">Line breaking</a></h3>

<p>The <tt>Line</tt> rule specifies that the contents of the box should be
broken into lines: the boxes included in the box to which this rule is
attached are displayed one after the other, from left to right, with their
horizontal reference axes aligned so that they form a series of lines. The
length of these lines is equal to the width of the box to which the
<tt>Line</tt> rule is attached.</p>

<p>When an included box overflows the current line, it is either carried
forward to the next line, broken, or left the way it is. The <a
href="#sectc4223"><tt>LineBreak</tt> rule</a> is used to allow or prevent the
breaking of included boxes. If the included box is not breakable but is
longer than the space remaining on the line, it is left as is. When a
character string box is breakable, the line is broken between words or, if
necessary, by <a href="#sectd42225">hyphenating a word</a>. When a compound
box is breakable, the box is transparent in regard to line breaking. The
boxes included in the compound box are treated just like included boxes which
have the <tt>LineBreak</tt> rule. Thus, it is possible to traverse a complete
subtree of boxes to line break the text leaves of a complex structure.</p>

<p>The relative position rules of the included boxes are ignored, since the
boxes will be placed according to the line breaking rules.</p>

<p>The <tt>Line</tt> rule does not have a parameter. The characteristics of
the lines that will be constructed are determined by the
<tt>LineSpacing</tt>, <tt>Indent</tt>, <tt>Adjust</tt>, <tt>Hyphenate</tt>,
<code>Direction</code> and <code>UnicodeBidi</code> rules. Moreover, the <a
href="#insectd42226"><tt>Inline</tt> rule</a> permits the exclusion of
certain elements from the line breaking process.</p>

<p>When the <tt>Line</tt> rule appears in the rules sequence of a non-primary
view, it applies only to that view, but when the <tt>Line</tt> rule appears
in the rules sequence of the primary view, it also applies to the other views
by default, except for those views which explicitly invoke the
<tt>NoLine</tt> rule. Thus, the <tt>NoLine</tt> rule can be used in a
non-primary view to override the primary view's <tt>Line</tt> rule. The
<tt>NoLine</tt> rule must not be used with the primary view because the
absence of the <tt>Line</tt> rule has the same effect. Like the <tt>Line</tt>
rule, the <tt>NoLine</tt> rule does not take any parameters.</p>

<p id="compatibil">For compatibility with CSS, langiage P also provides the
<tt>Display</tt> rule which accepts the following values: <tt>Inline</tt>,
<tt>Block</tt>, <tt>ListItem</tt>, <tt>RunIin</tt>, <tt>InlineBlock</tt>, and
<tt>None</tt>, plus <tt>Enclosing =</tt> for inheritance. These values play
the same role as in CSS. Notice that the effect of value <tt>ListItem</tt>
depends on other rules related to lists: <tt>ListStyleType</tt>,
<tt>ListStyleImage</tt> and <tt>ListStylePosition</tt>.</p>
<pre>                  'Line'
                  'NoLine'
                  'Display' ':' DisplayVal /
     DisplayVal = 'Inline' / 'Block' / 'ListItem' / 'RunIin' /
                  'InlineBlock' / 'None' / 'Enclosing' '=' .</pre>

<div class="subsubsection">
<h4><a name="sectd42221" id="sectd42221">Line spacing</a></h4>

<p>The <tt>LineSpacing</tt> rule defines the line spacing to be used in the
line breaking process. The line spacing is the distance between the baselines
(horizontal reference axis) of the successive lines produced by the
<tt>Line</tt> rule. The value of the line spacing can be specified as a
constant or by inheritance. It is expressed in any of the available <a
href="#sectc4217">distance units</a>.</p>

<p>Inheritance allows the value to be obtained from a relative in the
structure tree, either without change (an equals sign appears after the
inheritance keyword), with a positive difference (a plus sign), or a negative
difference (a minus sign). When the rule uses a difference, the value of the
difference follows the sign and is expressed as a <a
href="#sectc4217">distance</a>.</p>
<pre>                     'LineSpacing' ':' DistOrInherit
     DistOrInherit =  Kinship InheritedDist / Distance .
     InheritedDist = '=' / '+' AbsDist / '-' AbsDist .</pre>

<p>When the line spacing value (or its difference from another element) is
expressed in relative units, it changes with the size of the characters.
Thus, when a larger font is chosen for a part of the document, the line
spacing of that part expands proportionally. In contrast, when the line
spacing value is expressed in absolute units (centimeters, inches,
typographer's points), it is independent of the characters, which permits the
maintenance of a consistent line spacing, whatever the character font. Either
approach can be taken, depending on the desired effect.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd42222" id="sectd42222">First line indentation</a></h4>

<p>The <tt>Indent</tt> rule is used to specify the indentation of the first
line of the elements broken into lines by the <tt>Line</tt> function. The
indentation determines how far the first line of the element is shifted with
respect to the other lines of the same element. It can be specified as a
constant or by inheritance. The constant value is a positive integer (shifted
to the right; the sign is optional), a negative integer (shifted to the left)
or zero (no shift). All available <a href="#sectc4217">units</a> can be
used.</p>

<p>Indentation can be defined for any box, regardless of whether the box is
line broken, and transmitted by inheritance to elements that are line broken.
The size of the indentation is specified in the same manner as the <a
href="#sectd42221">line spacing</a>.</p>
<pre>              'Indent' ':' DistOrInherit</pre>
</div>

<div class="subsubsection">
<h4><a name="sectd42223" id="sectd42223">Alignment</a></h4>

<p>The alignment style of the lines constructed during line breaking is
defined by the <tt>Adjust</tt> rule. The alignment value can be a constant or
inherited. A constant value is specified by a keyword:</p>
<ul>
  <li><tt>Left</tt> : at the left edge,</li>
  <li><tt>Right</tt> : at the right edge,</li>
  <li><tt>VMiddle</tt> : centered</li>
  <li><tt>Justify</tt> : justified</li>
  <li><tt>LeftWithDots</tt> : at the left edge with a dotted line filling out
    the last line up to the right edge of the line breaking box.</li>
</ul>

<p>An inherited value can only be the same as that of the reference box and
is specified by a kinship keyword followed by an equals sign.</p>
<pre>                      'Adjust' ':' AlignOrInherit
     AlignOrInherit = Kinship '=' / Alignment .
     Alignment      = 'Left' / 'Right' / 'VMiddle' / 'Justify' /
                      'LeftWithDots' .</pre>
</div>

<div class="subsubsection">
<h4><a name="sectd42225" id="sectd42225">Hyphenation</a></h4>

<p>The <tt>Hyphenate</tt> rule indicates whether or not words should be
broken by hyphenation at the end of lines. It affects the lines produced by
the <tt>Line</tt> rule and contained in the box carrying the
<tt>Hyphenate</tt> rule.</p>

<p>The hyphenation property takes a boolean value, which can be either
constant or inherited. A constant boolean value is expressed by either the
<tt>Yes</tt> or the <tt>No</tt> keyword. An inherited value can only be the
same as that of the reference box and is specified by a kinship keyword
followed by an equals sign.</p>
<pre>                   'Hyphenate' ':' BoolInherit
     BoolInherit = Boolean / Kinship '=' .
     Boolean     = 'Yes' / 'No' .</pre>
</div>

<div class="subsubsection">
<h4><a name="sectd422251" id="sectd422251">Writing direction</a></h4>

<p>The <tt>Direction</tt> rule indicates the directionality of text: from
left to right, as for latin scripts, or from right to left, as for the Arabic
or Hebrew scripts. This is used by the Unicode bidirectional algorithm.</p>

<p>The writing direction property takes either a constant value
(<code>ltr</code> for left to right, or <code>rtl</code> for right to left)
or it is inherited. If it is inherited, it can only be the same as that of
the reference box and is specified by a kinship keyword followed by an equals
sign.</p>
<pre>                   'Direction' ':' DirInherit
     DirInherit =  'ltr' / 'rtl' / Kinship '=' .</pre>
</div>

<p>The <code>UnicodeBidi</code> rule is the equivalent of the CSS2
<code>unicode-bidi</code> property. It takes the same values and acts in the
same way.</p>
<pre>                   'Direction' ':' BidiInherit
     BidiInherit = 'Normal' / 'Embed' / 'Override' / Kinship '=' .</pre>

<div class="subsubsection">
<h4><a name="sectd42226" id="sectd42226">Avoiding line breaking</a></h4>

<p>The <tt>InLine</tt> rule is used to specify that a box that would
otherwise participate in line breaking asked for by the <tt>Line</tt> rule of
an enclosing box, instead avoids the line breaking process and positions
itself according to the <tt>HorizPos</tt> and <tt>VertPos</tt> rules that
apply to it. When the <tt>InLine</tt> rule applies to a box which would not
be line broken, it has no effect.</p>

<p>The rule is expressed by the <tt>InLine</tt> keyword followed by a colon
and the keyword <tt>Yes</tt>, if the box should participate in line breaking,
or the keyword <tt>No</tt>, if it should not. This is the only form possible:
this rule cannot be inherited. Moreover, it can only appear in the rules of
the primary view and applies to all views defined in the presentation
schema.</p>
<pre>               'InLine' ':' Boolean .
     Boolean = 'Yes' / 'No' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose the structure schema defines a logical attribute called
  <tt>New</tt> which is used to identify the passages in a document which
  were recently modified. It would be nice to have the presentation schema
  make a bar appear in the left margin next to each passage having the
  <tt>New</tt> attribute. A new passage can be an entire element, such as a
  paragraph or section, or it can be some words in the middle of a paragraph.
  To produce the desired effect, the <tt>New</tt> attribute is given a
  creation rule which generates a <tt>VerticalBar</tt> presentation box.</p>

  <p>When the <tt>New</tt> attribute is attached to a character string which
  is inside a line broken element (inside a paragraph, for example), the bar
  is one of the elements which participates in line breaking and it is placed
  normally in the current line, at the end of the character string which has
  the attribute. To avoid this, the <tt>InLine</tt> rule is used in the
  following way:</p>
  <pre>BOXES
  VerticalBar:
     BEGIN
     Content: Graphics 'l';
     HorizPos: Left = Root . Left;
     VertPos: Top = Creator . Top;
     Height: Bottom = Creator . Bottom;
     Width: 1 pt;
     InLine: No;
     ...
     END;
...
ATTRIBUTES
  Nouveau:
     BEGIN
     CreateAfter(VerticalBar);
     END;</pre>
</blockquote>
</div>
</div>

<div class="subsection">
<h3><a name="sectc4223" id="sectc4223">Page breaking and line breaking
conditions</a></h3>

<p>Pages are constructed by the editor in accordance with the model specified
by a <a href="#sectc4233"><tt>Page</tt> rule</a>. The page model describes
only the composition of the pages but does not give any rules for breaking
different element types across pages. Now, it is possible that certain
elements must not be cut by page breaks, while others can be cut anywhere.
The <tt>PageBreak</tt>, <tt>NoBreak1</tt>, and <tt>NoBreak2</tt> rules are
used to specify the conditions under which each element type can be cut.</p>

<p>The <tt>PageBreak</tt> rule is used to indicate whether or not the box can
be cut during the construction of pages. If cutting is authorized, the box
can be cut, with one part appearing at the bottom of a page and the other
part appearing at the top of the next page. The rule is formed by the
<tt>PageBreak</tt> keyword followed by a colon and a constant boolean value
(<tt>Yes</tt> or <tt>No</tt>). This is the only form possible: this rule
cannot be inherited. Moreover, it can only appear in the rules of the primary
view and applies to all views defined in the presentation schema.</p>

<p>Whether objects can be cut by line breaks can be controlled in a similar
way using the <tt>LineBreak</tt> rule. This rule allows the specification of
whether or not the box can be cut during the construction of lines. If
cutting is authorized, the box can be cut, with one part appearing at the end
of a line and the other part appearing at the beginning of the next line. The
rule is formed by the <tt>LineBreak</tt> keyword followed by a colon and a
constant boolean value (<tt>Yes</tt> or <tt>No</tt>). This is the only form
possible: this rule cannot be inherited. Moreover, it can only appear in the
rules of the primary view and applies to all views defined in the
presentation schema.</p>
<pre>               'PageBreak' ':' Boolean .
               'LineBreak' ':' Boolean .
     Boolean = 'Yes' / 'No' .</pre>

<p>When a box can be cut by a page break, it is possible that a page break
will fall an inappropriate spot, creating, for example, a widow or orphan, or
separating the title of a section from the first paragraph of the section.
The <tt>NoBreak1</tt> and <tt>NoBreak2</tt> rules are used to avoid this.
They specify that the box of the element to which they apply cannot be cut
within a certain zone at the top (<tt>NoBreak1</tt> rule) or at the bottom
(<tt>NoBreak2</tt> rule). These two rules specify the height of the zones in
which page breaks are prohibited.</p>

<p>The <tt>NoBreak1</tt> and <tt>NoBreak2</tt> rules give the height of the
zone in which page breaking is prohibited. The height is given as a constant
value using any of the <a href="#sectc4217">available units</a>, absolute or
relative. The value may not be inherited.</p>
<pre>                   'NoBreak1' ':' AbsDist .
                   'NoBreak2' ':' AbsDist .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following rules prevent widows and orphans in a paragraph:</p>
  <pre>Paragraph :
   BEGIN
   NoBreak1 : 2;
   NoBreak2 : 2;
   END;</pre>

  <p>This rule prevents a section title from becoming separated from the
  first paragraph of the section by prohibiting page breaks at the beginning
  of the section rule:</p>
  <pre>Section :
   NoBreak1 : 1.5 cm;</pre>

  <p>Finally, this rule prevents a figure from being page broken in any
  way:</p>
  <pre>Figure :
   PageBreak : No;</pre>
</blockquote>

<p>The Thot editor constructs the document images displayed on the screen
dynamically. As the user moves in the document or makes the document scroll
in a window, the editor constructs the image to be displayed in little bits,
filling the gaps which are produced in the course of these operations. It
stops filling in the image when an element reaches the edge of the window in
which the gap appears. If the appearance of the document is complex, it is
possible that the image in incomplete, even though the edge of the window was
reached. For example, an element might need to be presented to the side of
the last element displayed, but its image was not constructed. The user will
not know whether the element is really absent or if its image has simply not
been constructed.</p>

<p>The <tt>Gather</tt> rule is used to remedy this problem. When the rule
<tt>Gather : Yes;</tt> is associated with an element type, the image of such
elements is constructed as a block by the editor: it is never split up.</p>

<p>The <tt>Gather</tt> rule may not appear in the <a href="#sectc427">default
rules</a>. Elements which do not have the <tt>Gather</tt> rule are considered
susceptible to being split up during display. Thus, it is not necessary to
use the <tt>Gather : No;</tt> form. This rule must be used prudently and only
for those elements which truly need it. If used incorrectly, it can
pointlessly increase the size of the image constructed by the editor and lead
to excessive memory consumption by the editor.</p>

<p>Like the <tt>PageBreak</tt> and <tt>LineBreak</tt> rules, the
<tt>Gather</tt> rule can only appear in rules of the primary view and applies
to all views defined in the presentation schema.</p>
<pre>                   'Gather' ':' Boolean .</pre>
</div>

<div class="subsection">
<h3 id="Controllin">Controlling style of lists</h3>

<p>To present an element as a list item, rule <tt>Display</tt> with value
<tt>ListItem</tt> must apply to that element. The type and the position of
the marker generated by this rule are determined by three other rules:
<tt>ListStyleType</tt>, <tt>ListStyleImage</tt> and
<tt>ListStylePosition</tt>.</p>

<h4 id="litype">List item type</h4>

<p>This rule defines the type of maker that must be created for a list item.
It is equivalent to the CSS property <tt>list-style-type</tt>, and accepts
the same values.</p>
<pre>                     'ListStyleType' ':' ListStyleType
     ListStyleType = 'Disc' / 'Circle' / 'Square' / 'Decimal' /
                     'DecimalLeadingZero' / 'LowerRoman' / 'UpperRoman' / 
                     'LowerGreek' / 'LowerLatin' / 'UpperLatin' / 'None' /
                     'Enclosing' '=' .</pre>

<h4 id="liimage">List item image</h4>

<p>This rule defines the image that must be created as a merker for a list
item. It is equivalent to the CSS property <tt>list-style-image</tt>. The URL
of the image is simply a character string.</p>
<pre>                         'ListStyleImage' ':' ListStyleImage
     ListStyleImage    = 'None' / 'Enclosing' '=' / ListStyleImageURI .
     ListStyleImageURI = STRING .</pre>
</div>

<h4 id="liposition">List item position</h4>

<p>This rule defines the position of the marker: inside the list item or
outside. It is equivalent to the CSS property <tt>list-style-position</tt>,
and accepts the same values.</p>
<pre>                         'ListStylePosition' ':' ListStylePosition
     ListStylePosition = 'Inside' / 'Outside' / 'Enclosing' '=' .</pre>

<div class="subsection">
<h3><a name="sectc4224" id="sectc4224">Visibility</a></h3>

<p>The visibility property is used to control which elements should or should
not be displayed, based on context. An element can have different
visibilities in different views. If an element's visibility is zero for a
view, that element is not displayed in that view and does not occupy any
space (its extents are zero).</p>

<p>Visibility takes non-negative integer values (positive or zero). If values
greater than 1 are used, they allow the user to choose a degree of visibility
and, thus, to see only those boxes whose visibility property exceeds a
certain threshold. This gives the user control over the granularity of the
displayed pictures.</p>

<p>The visibility property can be defined as a constant or by inheritance. If
defined by inheritance, it cannot be based on the value of the next or
previous box. Visibility can only be inherited from above.</p>

<p>If it is a numeric attribute's presentation rule, the visibility can be
specified by the attribute's name, in which case the value of the attribute
is used.</p>
<pre>                   'Visibility' ':' NumberInherit
     NumberInherit = Integer / AttrID / Inheritance .
     Integer       = NUMBER .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that only <tt>Formula</tt> elements should be displayed in the
  <tt>MathView</tt> view. Then, the default rules should include:</p>
  <pre>DEFAULT
     IN MathView Visibility:0;</pre>

  <p>which makes all elements invisible in the <tt>MathView</tt> view.
  However, the <tt>Formula</tt> element also has a <tt>Visibility</tt>
  rule:</p>
  <pre>Formula :
     IN MathView Visibility:5;</pre>

  <p>which makes formulas, and only formulas, visible.</p>
</blockquote>
</div>

<div class="subsection">
<p>Notice that rule <a href="#compatibil"><tt>Display</tt></a> with value
<tt>None</tt> is equivalent to rule <tt>Visibility</tt> with value
<tt>0</tt>.</p>

<h3><a name="sectc4225" id="sectc4225">Character style properties</a></h3>

<p>Four properties are used to determine which characters are used to display
text. They are size, font, style, and underlining.</p>

<div class="subsubsection">
<h4><a name="sectd42251" id="sectd42251">Character size</a></h4>

<p>The size property has two effects. First, it is used to specify the actual
size and distance units for boxes defined in <a href="#sectc4217">relative
units</a>. Second, it defines the size of the characters contained in the
box.</p>

<p>As a distance or length, the size can be expressed in abstract or absolute
units. It can also be inherited. If it is not inherited, it is expressed
simply as an integer followed by the <tt>pt</tt> keyword, which indicates
that the size is expressed in typographer's points. The absence of the
<tt>pt</tt> keyword indicates that it is in abstract units in which the value
1 represents the smallest size while the value 16 is the largest size. The
relationship between these abstract sizes and the real character sizes is
controlled by a table which can be modified statically or even dynamically
during the execution of the Thot editor.</p>

<p>If the <tt>Size</tt> rule is a numeric attribute's presentation rule, the
value of the size property can be specified by the attribute's name, in which
case the value of the attribute is used.</p>

<p><strong>Note:</strong> the only unit available for defining an absolute
size is the typographer's point. Centimeters and inches may not be used.</p>

<p>If the size is inherited, the rule must specify the relative from which to
inherit and any percentage or difference from that relative's value. A
percentage is indicated by a <tt>*</tt> followed by the value of the
percentage and a <tt>%</tt>. A difference can be expressed in either
typographer's points or in abstract units and the maximum or minimum size can
be specified, but without specifying the unit: it is the same as was
specified for the difference.</p>

<p>In a numeric attribute's presentation rule, the difference in size or the
percentage can be indicated by the attribute's name instead of the numeric
value, which means that the attribute's value should be used as the
difference or percentage. The attribute can also be used as the minimum or
maximum size for a difference.</p>
<pre>                      'Size' ':' SizeInherit
     SizeInherit     = SizeAttr [ 'pt' ] /
                       Kinship InheritedSize .
     InheritedSize   ='+' SizeAttr [ 'pt' ]
                       [ 'Max' MaxSizeAttr ] /
                      '-' SizeAttr [ 'pt' ]
                       [ 'Min' MinSizeAttr ] /
                      '*' PercentSizeAttr '%' /
                      '=' .
     SizeAttr        = Size / AttrID .
     Size            = NUMBER .
     MaxSizeAttr     = MaxSize / AttrID .
     MaxSize         = NUMBER .
     MinSizeAttr     = MinSize / AttrID .
     MinSize         = NUMBER .
     PercentSizeAttr = PercentSize / AttrID .
     PercentSize     = NUMBER .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The rule</p>
  <pre>Size : Enclosing - 2 pt Min 7;</pre>

  <p>states that the character size is 2 points less than that of the
  enclosing box, but that it may not be less than 7 points, whatever the
  enclosing box's value.</p>

  <p>The following rules make the text of a report be displayed with
  medium-sized characters (for example, size 5), while the title is displayed
  with larger characters and the summary is displayed with smaller
  characters:</p>
  <pre>Report :
     Size : 5;
Title :
     Size : Enclosing + 2;
Summary :
     Size : Enclosing - 1;</pre>

  <p>Thus, the character sizes in the entire document can be changed by
  changing the size property of the Report element, while preserving the
  relationships between the sizes of the different elements.</p>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd42252" id="sectd42252">Font and character style</a></h4>

<p>The <tt>Font</tt> rule determines the font family to be used to display
the characters contained in the box, while the <tt>Style</tt> rule determines
their style and the <tt>Weight</tt> rule determines their weight. Thot
recognizes three character fonts (Times, Helvetica, and Courier), three
styles: Roman, Italics, and Oblique, and two weights: Normal and Bold.</p>

<p>The font family, style and weight can be specified by a named constant or
can be inherited. For the name of the font family only the first character is
used.</p>

<p>Only identical inheritance is allowed: the box takes the same font, style
or weight as the box from which it inherits. This is indicated by an equals
sign after the kinship specification.</p>
<pre>               'Font' ':'          NameInherit /
               'Style' ':'         StyleInherit /
               'Weight' ':'        WeightInherit /

NameInherit   = Kinship '=' / FontName .
FontName      = NAME .
StyleInherit  = Kinship '=' /
                'Roman' / 'Italics' / 'Oblique' .
WeightInherit = Kinship '=' /
                'Normal' / 'Bold' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To specify that the summary uses the font family of the rest of the
  document, but in the italic style, the following rules are used:</p>
  <pre>Summary :
   BEGIN
   Font : Enclosing =;
   Style : Italics;
   END;</pre>
</blockquote>
</div>

<div class="subsubsection">
<h4><a name="sectd42253" id="sectd42253">Underlining</a></h4>

<p>The <tt>Underline</tt> rule is used to specify if the characters contained
in a box should have lines drawn on or near them. There are four underlining
styles: <tt>Underlined</tt>, <tt>Overlined</tt>, <tt>CrossedOut</tt>, and
<tt>NoUnderline</tt>. The <tt>Thickness</tt> rule specifies the thickness of
the line, <tt>Thin</tt> or <tt>Thick</tt>.</p>

<p>As with font family and style, only identical inheritance is allowed: the
box has the same underlining type as the box from which it inherits the
value. This is indicated by an equals sign after the kinship
specification.</p>
<pre>                   'Underline' ':' UnderLineInherit /
                   'Thickness' ':' ThicknessInherit /

UnderLineInherit = Kinship '=' / 'NoUnderline' /
                   'Underlined' / 
                   'Overlined' / 'CrossedOut' .
ThicknessInherit = Kinship '=' / 'Thick' / 'Thin' .</pre>
</div>
</div>

<div class="subsection">
<h3><a name="sectc4226" id="sectc4226">Stacking order</a></h3>

<p>The <tt>Depth</tt> rule is used to define the stacking order of terminal
boxes when multiple boxes at least partially overlap. This rule defines how
the depth property, which is zero or a positive integer, is calculated. The
depth property has a value for all boxes. For terminal boxes in the structure
and for presentation boxes, the depth value is used during display and
printing: the boxes with the lowest value overlap those with higher depths.
For non-terminal boxes, the depth is not interpreted during display, but it
is used to calculate the depth of terminal boxes by inheritance.</p>

<p>Like most other rules, the depth rule is defined in the <a
href="#sectc427">default rules</a> of each presentation schema. Thus, there
is always a depth value, even when it is not necessary because there is no
overlapping. To avoid useless operations, a zero value can be given to the
depth property, which signifies that overlapping is never a problem.</p>

<p>The depth rule has the same form as the <a href="#sectc4224">visibility
rule</a>. It can be defined by inheritance or by a constant numeric value.
When the rule is attached to a numeric attribute, it can take the value of
that attribute.</p>
<pre>                'Depth' ':' NumberInherit</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>For a purely textual document, in which overlapping never poses a
  problem, a single default <tt>Depth</tt> rule in the presentation schema is
  sufficient:</p>
  <pre>DEFAULT
    Depth : 0;
    ...</pre>

  <p>To make the text of examples appear on a light blue background, a
  presentation box is defined:</p>
  <pre>BOXES
   BlueBG :
      BEGIN
      Content : Graphics 'R';
      Background : LightBlue3;
      FillPattern: backgroundcolor;
      Depth : 2;
      ...
      END;</pre>

  <p>and is created by the <tt>Example</tt> element, which has the rules:</p>
  <pre>RULES
   Example :
      BEGIN
      CreateFirst (BlueBG);
      Depth : 1;
      ...
      END;</pre>

  <p>In this way, the text of an example (if it inherits its depth from its
  ancestor) will be superimposed on a light blue background, and not the
  reverse).</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4227" id="sectc4227">Line style</a></h3>

<p>The <tt>LineStyle</tt> rule determines the style of line which should be
used to draw all the elements contained in the box and the box itself, if it
has a <a href="#sectc4230a"><tt>ShowBox</tt> rule</a>. The line style can be
indicated by a name (<tt>Solid</tt>, <tt>Dashed</tt>, <tt>Dotted</tt>) or it
can be inherited. All elements of the graphic base type are affected by this
rule, but it can be attached to any box and transmitted by inheritance to the
graphic elements. The border of elements having a <a
href="#sectc4230a"><tt>ShowBox</tt> rule</a> is drawn according to the line
style specified by this rule.</p>

<p>Only identical inheritance is allowed: the box takes the same line style
as the box from which it inherits. This is indicated by an equals sign after
the kinship specification.</p>
<pre>                      'LineStyle' ':' LineStyleInherit
     LineStyleInherit = Kinship '=' /
                      'Solid' / 'Dashed' / 'Dotted' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To specify that, in Figures, the graphical parts should be drawn in
  solid lines, the Figure element is given a rule using the <tt>Solid</tt>
  name:</p>
  <pre>Figure :
   LineStyle : Solid;</pre>

  <p>and the elements composing figures are given an inheritance rule:</p>
  <pre>   LineStyle : Enclosing =;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4228" id="sectc4228">Line thickness</a></h3>

<p>The <tt>LineWeight</tt> rule determines the thickness of the lines of all
graphical elements which appear in the box, no matter what their line style.
Line thickness can be specified by a constant value or by inheritance. A
constant value is a positive number followed by an optional unit
specification (which is absent when using relative units). All available <a
href="#sectc4217">distance units</a> can be used. Line thickness is expressed
in the same way as <a href="#sectd42221">line spacing</a>.</p>
<pre>                 'LineWeight' ':' DistOrInherit</pre>

<p>All elements of the graphic base type are affected by this rule, but it
can be attached to any box and transmitted by inheritance to the graphic
elements. The border of element having a <a
href="#sectc4230a"><tt>ShowBox</tt> rule</a> is also drawn according to the
thickness specified by this rule.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To specify that, in Figures, the graphical parts should be drawn with
  lines 0.3 pt thick, the Figure element is given this rule:</p>
  <pre>Figure :
   LineWeight : 0.3 pt;</pre>

  <p>and the elements composing figures are given an inheritance rule:</p>
  <pre>   LineWeight : Enclosing =;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4229" id="sectc4229">Fill pattern</a></h3>

<p>The <tt>FillPattern</tt> rule determines the pattern used to fill closed
graphical elements (circles, rectangles, etc.) which appear in the box. This
rule also specifies the pattern used to fill the box associated with elements
having a <a href="#sectc4230a"><tt>ShowBox</tt> rule</a><a>. This pattern can
be indicated by a named constant or by inheritance. The named constant
identifies one of the patterns available in Thot. The names of the available
patterns are: nopattern, foregroundcolor, backgroundcolor, gray1, gray2,
gray3, gray4, gray5, gray6, gray7, horiz1, horiz2, horiz3, vert1, vert2,
vert3, left1, left2, left3, right1, right2, right3, square1, square2,
square3, lozenge, brick, tile, sea, basket.</a></p>

<p>Like the other rules peculiar to graphics, <tt>LineStyle</tt> and
<tt>LineWeight</tt>, only elements of the graphic base type are affected by
the <tt>FillPattern</tt> rule, but the rule can be attached to any box and
transmitted by inheritance to the graphic elements. As with the other rules
specific to graphics, only identical inheritance is allowed.</p>

<p>The <tt>FillPattern</tt> rule can also be used to determine whether or not
text characters, symbols and pictures should be colored. For these element
types (text, symbols, and pictures), the only valid values are
<tt>nopattern</tt>, <tt>foregroundcolor</tt>, and <tt>backgroundcolor</tt>.
When <tt>FillPattern</tt> has the value <tt>backgroundcolor</tt>, text
characters, symbols, and bitmaps are given the color specified by the <a
href="#sectc4230"><tt>Background</tt> rule</a> which applies to these
elements. When <tt>FillPattern</tt> has the value <tt>foregroundcolor</tt>,
these same elements are given the color specified by the <a
href="#sectc4230"><tt>Foreground</tt> rule</a> which applies to these
elements. In all other case, text characters are not colored.</p>
<pre>                 'FillPattern' ':' NameInherit</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To specify that, in Figures, the closed graphical elements should be
  filled with a pattern resembling a brick wall, the Figure element is given
  this rule:</p>
  <pre>Figure :
   FillPattern : brick;</pre>

  <p>and the elements composing figures are given an inheritance rule:</p>
  <pre>   FillPattern : Enclosing =;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4230" id="sectc4230">Colors</a></h3>

<p>The <tt>Foreground</tt> and <tt>Background</tt> rules determine the
foreground and background colors of the base elements which appear in the
box. They also control the color of boxes associated with elements having a
<a href="#sectc4230a"><tt>ShowBox</tt> rule</a>. These colors can be
specified with a named constant or by inheritance. The named constants
specify one of the available colors in Thot. The available color names can be
found in the file <tt>thot.color</tt>. In addition to those names, you can
use the keyword <code>Transparent</code>, to not draw anything.</p>

<p>The color rules affect the same way all base elements and elements having
a <a href="#sectc4230a"><tt>ShowBox</tt> rule</a>, no matter what their type
(text, graphics, pictures, symbols). The color rules can be associated with
any box and can be transmitted by inheritance to the base elements or the
elements having a <a href="#sectc4230a"><tt>ShowBox</tt> rule</a>. Like the
preceding rules, only inheritance of the same value is allowed.</p>
<pre>                 'Foreground' ':' Color
                 'Background' ':' Color
      Color = 'Transparent' / Link '=' / FontColorName .</pre>

<p><strong>Note:</strong> text colors only appear for text elements whose <a
href="#sectc4229">fill pattern</a> does not prevent the use of color.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To specify that, in Figures, everything must be drawn in blue on a
  background of yellow, the Figure element is given these rules:</p>
  <pre>Figure :
   BEGIN
   Foreground : Blue;
   Background : Yellow;
   Fillpattern : backgroundcolor;
   END;</pre>

  <p>and the elements composing figures are given inheritance rules:</p>
  <pre>   Foreground : Enclosing =;
   Background : Enclosing =;
   FillPattern : Enclosing =;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4230a" id="sectc4230a">Background color and border</a></h3>

<p>Boxes associated with structural elements are normally not visible, but it
is possible to draw their border and/or to paint their area when it is
needed. This is achieved by associating the <tt>ShowBox</tt> rule with the
concerned element. This rule has no parameter and no value. It is simply
written <tt>Showbox;</tt>. It is not inherited nor transmitted to any other
element. It applies only to the element with which it is associated.</p>
<pre>                 'ShowBox'</pre>

<p>When an element has a <tt>ShowBox</tt> rule, the border is drawn only if
the <tt>LineWeight</tt> rule that applies to that element has a non-zero
value (this value can be inherited). The color, style and thickness of the
border are defined by the <tt>Foreground</tt>, <tt>LineStyle</tt>, and
<tt>LineWeight</tt> rules that apply to the element.</p>

<p>When an element has a <tt>ShowBox</tt> rule, the background of this
element is paint only if the value of the <tt>FillPattern</tt> rule that
applies to that element is not <tt>nopattern</tt>. The pattern and color(s)
of the background are defined by the <tt>FillPattern</tt>,
<tt>Background</tt>, and <tt>Foreground</tt> rules that apply to the
element.</p>
</div>

<div class="subsection">
<h3><a name="sectc4230b" id="sectc4230b">Background pictures</a></h3>

<p>The <tt>BackgroundPicture</tt> rule allows to display a picture as the
background of an element. It has a single parameter, the file name of the
picture. This is a string delimited by single quotes. If the first character
in this string is '/', it is considered as an absolute path, otherwise the
file is searched for along the schema directory path. This file may contain a
picture in any format accepted by Thot (xbm, xpm, gif, jpeg, png, etc.)</p>

<p>The <tt>BackgroundPicture</tt> and <tt>PictureMode</tt> rules apply only
to the element with which they are associated. They are not inherited nor
transmitted to children elements.</p>

<p>The background picture has not always the same size as the element's box.
There are diffrent ways to fill the element box with the picture. This is
specified by the <tt>PictureMode</tt> rule, which should be associated to the
same element. This rule may take one of the following values:</p>
<dl>
  <dt><tt>NormalSize</tt></dt>
    <dd>The picture is centered in the box, and clipped if it is too
    large.</dd>
  <dt><tt>Scale</tt></dt>
    <dd>The picture is zoomed to fit the box size.</dd>
  <dt><tt>RepeatX</tt></dt>
    <dd>The picture is repeated horizontally to fit the box width.</dd>
  <dt><tt>RepeatY</tt></dt>
    <dd>The picture is repeated vertically to fit the box height.</dd>
  <dt><tt>RepeatXY</tt></dt>
    <dd>The picture is repeated both horizontally and vertically to fill the
      box.</dd>
</dl>

<p>If an element has a <tt>BackgroundPicture</tt> rule and no
<tt>PictureMode</tt> rule, the <tt>NormalSize</tt> value is assumed.</p>
<pre>                 'BackgroundPicture' ':' FileName /
                 'PictureMode' ':' PictMode .
 
      FileName = STRING .
      PictMode = 'NormalSize' / 'Scale' / 'RepeatXY' / 'RepeatX' / 'RepeatY' .</pre>

<p>The <tt>BackgroundPicture</tt> and <tt>PictureMode</tt> rules apply only
to the element with which they are associated. They are not inherited nor
transmitted to children elements.</p>
</div>

<div class="subsection">
<h3><a name="sectc4230c" id="sectc4230c">Opacity</a></h3>

<p>The <tt>Opacity</tt>, <tt>FillOpacity</tt> and <tt>StrokeOpacity</tt>
rules allow to set the opacity of the element(s) to which they apply. The
<code>FillOpacity</code> rule controls the way the interior of the element is
paint, while the <code>StrokeOpacity</code> rule concerns the outline. The
<code>Opacity</code> rule concerns both the interior and the outline at the
same time.</p>

<p>In the three rules, opacity is expressed as a percentage. It must be
comprised between 0 (fully transparent) and 100% (fully opaque). In these
rules, the opacity can be expressed as an integer (from 0 to 100) followed by
the <code>%</code> character. It can also be expressed as the name of a
numeric attribute. In that case, the attribute's value is interpreted as a
percentage. It should then be comprised between 0 and 100 included. Finally,
the opacity can be inherited from the parent element.</p>
<pre>                  'Opacity' ':' OpacityInherit
                  'FillOpacity' ':' OpacityInherit
                  'StrokeOpacity' ':' OpacityInherit
OpacityInherit  = OpPercent '%' / AttrID / Inheritance .
OpPercent       = NUMBER .</pre>
</div>

<div class="subsection">
<h3><a name="sectc4231" id="sectc4231">Presentation box content</a></h3>

<p>The <tt>Content</tt> rule applies to presentation boxes. It indicates the
content given to a box. This content is either a variable's value or a
constant value.</p>

<p>If the content is a constant, it can be specified, as in a variable
declaration, either by the name of a constant declared in the <tt>CONST</tt>
section or by direct specification of the type and value of the box's
content.</p>

<p>Similarly, if it is a variable, the name of a variable declared in
<tt>VAR</tt> section can be given or the variable may be defined within
parentheses. The content inside the parentheses has the same syntax as a <a
href="#sectc426">variable declaration</a>.</p>
<pre>               'Content' ':' VarConst
     VarConst = ConstID / ConstType ConstValue /
                VarID / '(' FunctionSeq ')' .</pre>

<p>A presentation box can have only one <tt>Content</tt> rule, which means
that the content of a presentation box cannot vary from view to view.
However, such an effect can be achieved by creating several presentation
boxes, each with different content and visible in different views.</p>

<p>The <tt>Content</tt> rule also applies to elements defined as references
in the structure schema. In this case, the content defined by the rule must
be a constant. It is this content which appears on the screen or paper to
represent references of the type to which the rule applies. A reference can
have a <tt>Content</tt> rule or a <a href="#sectc4234"><tt>Copy</tt> rule</a>
for each view. If neither of these rules appears, the reference is displayed
as <tt>[*]</tt>, which is equivalent to the rule:</p>
<pre>     Content: Text '[*]';</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The content of the presentation box created to make the chapter number
  and section number appear before each section title can be defined by:</p>
  <pre>BOXES
     SectionNumBox :
          BEGIN
          Content : NumSection;
          ...
          END;</pre>

  <p>if the <tt>NumSection</tt> variable has been defined in the variable
  definition section of the presentation schema. Otherwise the
  <tt>Content</tt> would be written:</p>
  <pre>BOXES
     SectionNumBox :
          BEGIN
          Content : (VALUE (ChapterCtr, Roman) TEXT '.'
                     VALUE (SectionCtr, Arabic));
          ...
          END;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4232" id="sectc4232">Presentation box creation</a></h3>

<p>A creation rule specifies that a presentation box should be created when
an element of the type to which the rule is attached appears in the
document.</p>

<p>A keyword specifies the position, relative to the creating box, at which
the created box will be placed in the structure:</p>
<dl>
  <dt><tt>CreateFirst</tt></dt>
    <dd>specifies that the box should be created as the first box of the next
      lower level, before any already existing boxes, and only if the
      beginning of the creating element is visible;</dd>
  <dt><tt>CreateLast</tt></dt>
    <dd>specifies that the box should be created as the last box of the next
      lower level, after any existing boxes, and only if the end of the
      creating element is visible;</dd>
  <dt><tt>CreateBefore</tt></dt>
    <dd>specifies that the box should be created before the creating box, on
      the same level as the creating box, and only if the beginning of the
      creating element is visible;</dd>
  <dt><tt>CreateAfter</tt></dt>
    <dd>specifies that the box should be created after the creating box, on
      the same level as the creating box, and only if the beginning of the
      creating element is visible;</dd>
  <dt><tt>CreateEnclosing</tt></dt>
    <dd>specifies that the box should be created at the upper level
      relatively to the creating box, and that it must contain that creating
      box and all presentation boxes created by the same creating box.</dd>
</dl>

<p>This keyword can be followed by the <tt>Repeated</tt> keyword to indicate
that the box must be created for each part of the creating element. These
parts result from the division of the element by page breaks or column
changes. If the <tt>Repeated</tt> keyword is missing, the box is only created
for the first part of the creating element (<tt>CreateFirst</tt> and
<tt>CreateBefore</tt> rules) or for the last part (<tt>CreateLast</tt> and
<tt>CreateAfter</tt> rules).</p>

<p>The type of presentation to be created is specified at the end of the rule
between parentheses.</p>

<p>Creation rules cannot appear in the <a href="#sectc427">default
presentation rules</a>. The boxes being created should have a
<tt>Content</tt> rule which indicates their <a
href="#sectc4231">content</a>.</p>

<p>Creation rules can only appear in the block of rules for the primary view;
creation is provoked by a document element for all views. However, for each
view, the presentation box is only created if the creating element is itself
a box in the view. Moreover, the visibility property of the presentation box
can be adjusted to control the creation of the box on a view-by-view
basis.</p>
<pre>                     Creation '(' BoxID ')'
     Creation      = Create [ 'Repeated' ] .
     Create        ='CreateFirst' / 'CreateLast' /
                    'CreateBefore' / 'CreateAfter' /
                    'CreateEnclosing' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Let us define an object type, called Table, which is composed of a
  sequence of columns, all having the same fixed width, where the columns are
  separated by vertical lines. There is a line to the left of the first
  column and one to the right of the last. Each column has a variable number
  of cells, placed one on top of the other and separated by horizontal lines.
  There are no horizontal lines above the first cell or below the last cell.
  The text contained in each cell is broken into lines and these lines are
  centered horizontally in the cell. The logical structure of this object is
  defined by:</p>
  <pre>Table   = LIST OF (Column);
Column  = LIST OF (Cell = Text);</pre>

  <div class="figure">
  <hr />
  <pre>|                |                |               |
|  xx xxxx xxxx  |x xxxx xxx xxxxx|  x xxx x xxx  |
| xxx xxx xxxx x |   x xx x xxx   | xxxxx xxxx xx |
|   xxxxx xxxx   |----------------|  xxx xxxxx x  |
| xxxxx xxx xxxx | xxxx xx xx xxx |     xx xx     |
| xxx xxxx x xxx |  xxxx x xxx x  |---------------|
|----------------| xxx xxxx xxxxx |  xxxxx xxxxx  |
| xxx xxx xxxxxx |----------------| xxx xxxx xxxx |
|  xxxx xxxx xx  |  xxxx xx x xx  |  xxx xx x xx  |
|----------------| xxx xxxxx xxxx | xxxx xxxx xxx |
| xxxxx xxx xxxx |  xxxx xx x xx  |   xxxxx xxx   |
|xxxx xx x xxxxxx| xxxx xx xxxxxx |  xxxxx xxxxx  |</pre>

  <p align="center"><em><a name="table" id="table">The design of a
  table</a></em></p>
  <hr />
  </div>

  <p>The presentation of the table should resemble the design of the above <a
  href="#table">figure</a>. It is defined by the following presentation
  schema fragment:</p>
  <pre>BOXES
     VertLine : BEGIN
                Width : 0.3 cm;
                Height : Enclosing . Height;
                VertPos : Top = Enclosing . Top;
                HorizPos : Left = Previous . Right;
                Content : Graphics 'v';
                END;

     HorizLine: BEGIN
                Width : Enclosing . Width;
                Height : 0.3 cm;
                VertPos : Top = Previous . Bottom;
                HorizPos : Left = Enclosing . Left;
                Content : Graphics 'h';
                END;

RULES
     Column   : BEGIN
                CreateBefore (VertLine);
                IF LAST CreateAfter (VertLine);
                Width : 2.8 cm;
                Height : Enclosed . Height;
                VertPos : Top = Enclosing . Top;
                HorizPos : Left = Previous . Right;
                END;

     Cell     : BEGIN
                IF NOT FIRST CreateBefore (HorizLine);
                Width : Enclosing . Width;
                Height : Enclosed . Height;
                VertPos : Top = Previous . Bottom;
                HorizPos : Left = Enclosing . Left;
                Line;
                Adjust : VMiddle;
                END;</pre>

  <p>It is useful to note that the horizontal position rule of the first
  vertical line will not be applied, since there is no preceding box. In this
  case, the box is simply placed on the left side of the enclosing box.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc4233" id="sectc4233">Page layout</a></h3>

<p>The page models specified in the <tt>Page</tt> rule are defined by boxes
declared in the <tt>BOXES</tt> section of the presentation schema. Pages are
not described as frames which will be filled by the document's text, but as
element are inserted in the flow of the document and which mark the page
breaks. Each of these page break elements contains presentation boxes which
represent the footer boxes of a page followed by header boxes of the next
page. The page box itself is the simple line which separates two pages on the
screen. Both the footer and header boxes placed themselves with respect to
this page box, with the footer being placed above it and the header boxes
being placed above it.</p>

<p>The boxes created by a page box are headers and footers and can only place
themselves vertically with respect to the page box itself (which is in fact
the separation between two pages). Besides, it is their vertical position
rule which determines whether they are header or footer boxes. Header and
footer boxes must have an explicit vertical position rule (they must not use
the default rule).</p>

<p>Footer boxes must have an absolute height or inherit the height of their
contents:</p>
<pre>Height : Enclosed . Height;</pre>

<p>A page box must have height and width rules and these two rules must be
specified with constant values, expressed in centimeters, inches, or
typographer's points. These two rules are interpreted in a special way for
page boxes: they determine the width of the page and the vertical distance
between two page separators, which is the height of the page and its header
and footer together.</p>

<p>A page box should also have vertical and horizontal position rules and
these two rules should specify the position on the sheet of paper of the
rectangle enclosing the page's contents. These two rules must position the
upper left corner of the enclosing rectangle in relation to the upper left
corner of the sheet of paper, considered to be the enclosing element. In both
rules, distances must be expressed in fixed units: centimeters (<tt>cm</tt>),
inches (<tt>in</tt>), or typographer's points (<tt>pt</tt>). Thus, rules
similar to the following should be found in the rules for a page box:</p>
<pre>BOXES
   ThePage :
      BEGIN
      VertPos : Top = Enclosing . Top + 3 cm;
      HorizPos : Left = Enclosing . Left + 2.5 cm;
      Width : 16 cm;
      Height : 22.5 cm;
      END;</pre>

<p>When a document must be page broken, the page models to be constructed are
defined in the <tt>BOXES</tt> section of the presentation schema by declaring
page boxes and header and footer boxes. Also, the <tt>Page</tt> rule is used
to specify to which parts of the document and to which views each model
should be applied.</p>

<p>The <tt>Page</tt> rule has only one parameter, given between parentheses
after the <tt>Page</tt> keyword. This parameter is the name of the box which
must serve as the model for page construction. When a <tt>Page</tt> rule is
attached to an element type, each time such an element appears in a document,
a page break takes place and the page model indicated in the rule is applied
to all following pages, until reaching the next element which has a
<tt>Page</tt> rule.</p>

<p>The <tt>Page</tt> rule applies to only one view; if it appears in the
primary view's block of rules, a <tt>Page</tt> rule applies only to that
view. Thus, different page models can be defined for the full document and
for its table of contents, which is another view of the same document. Some
views can be specified with pages, and other views of the same document can
be specified without pages.</p>
<pre>                   'Page' '(' BoxID ')'</pre>
</div>

<div class="subsection">
<h3><a name="sectc4234" id="sectc4234">Box copies</a></h3>

<p>The <tt>Copy</tt> rule can be used for an element which is defined as a
reference in the structure schema. In this case, the rule specifies, between
parenthesis, the name of the box (declared in the <tt>BOXES</tt> section)
which must be produced when this reference appears in the structure of a
document. The box produced is a copy (same contents, but possible different
presentation) of the box type indicated by the parameter between parentheses,
and which is in the element designated by the reference. The name of a box
can be replaced by type name. Then what is copied is the contents of the
element of this type which is inside the referenced element.</p>

<p>Whether a box name or type name is given, it may be followed by the name
of a structure schema between parentheses. This signifies that the box or
type is defined in the indicated structure schema and not in the structure
schema with which the rule's presentation schema is associated.</p>

<p>The <tt>Copy</tt> rule can also be applied to a presentation box. If the
presentation box was created by a reference attribute, the rule is applied as
in the case of a reference element: the contents of the box having the
<tt>Copy</tt> rule are based on the element designated by the reference
attribute. For other presentation boxes, the <tt>Copy</tt> rule takes a type
name parameter which can be followed, between parentheses, by the name of the
structure schema in which the type is defined, if it is not defined in the
same schema. The contents of the box which has this rule are a copy of the
element of this type which is in the element creating the presentation box,
or by default, the box of this type which precedes the presentation box. This
last facility is used, for example, to define the running titles in headers
or footers.</p>
<pre>                  'Copy' '(' BoxTypeToCopy ')' .
  BoxTypeToCopy = BoxID [ ExtStruct ] /
                  ElemID [ ExtStruct ] .
  ExtStruct     = '(' ElemID ')' .</pre>

<p>Like the creation rules, the <tt>Copy</tt> rule cannot appear in the <a
href="#sectc427">default presentation rules</a>. Moreover, this rule can only
appear in the primary view's block of rules; the copy rule is applied to all
views.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If the following definitions are in the structure schema:</p>
  <pre>Body = LIST OF (Chapter =
                     BEGIN
                     ChapterTitle = Text;
                     ChapterBody = SectionSeq;
                     END);
RefChapter = REFERENCE (Chapter);</pre>

  <p>then the following presentation rules (among many other rules in the
  presentation schema) can be specified:</p>
  <pre>COUNTERS
   ChapterCtr : RANK OF Chapter;
BOXES
   ChapterNumber :
      BEGIN
      Content : (VALUE (ChapterCtr, URoman));
      ...
      END;
RULES
   Chapter :
      BEGIN
      CreateFirst (ChapterNumber);
      ...
      END;
   RefChapter :
      BEGIN
      Copy (ChapterNumber);
      ...
      END;</pre>

  <p>which makes the number of the chapter designated by the reference appear
  in uppercase roman numerals, in place of the reference to a chapter itself.
  Alternatively, the chapter title can be made to appear in place of the
  reference by writing this <tt>Copy</tt>rule:</p>
  <pre>      Copy (ChapterTitle);</pre>

  <p>To define a header box, named <tt>RunningTitle</tt>, which contains the
  title of the current chapter, the box's contents are defined in this
  way:</p>
  <pre>BOXES
   RunningTitle :
      Copy (ChapterTitle);</pre>
</blockquote>
</div>
</div>
<hr />
</div>

<div class="chapter">
<h1><a name="sect5" id="sect5">The T language</a></h1>

<div class="section">
<h2><a name="sectb51" id="sectb51">Document translation</a></h2>

<p>Because of its document model, Thot can produce documents in a high-level
abstract form. This form, called the <em>canonical form</em> is specific to
Thot; it is well suited to the editor's manipulations, but it does not
necessarily suit other operations which might be applied to documents.
Because of this, the Thot editor offers the choice of saving documents in its
own form (the canonical form) or a format defined by the user. In the latter
case, the Thot document is transformed by the translation program. This
facility can also be used to export documents from Thot to systems using
other formalisms.</p>

<div class="subsection">
<h3><a name="sectc511" id="sectc511">Translation principles</a></h3>

<p>Document translation allows the export of documents to other systems which
do not accept Thot's canonical form. Translation can be used to export
document to source-based formatters like T<sub><big>E</big></sub>X,
L<sup>A</sup>T<sub><big>E</big></sub>X, and <tt>troff</tt>. It can also be
used to translate documents into interchange formats like SGML or HTML. To
allow the widest range of possible exports, Thot does not limit the choice of
translations, but rather allows the user to define the formalisms into which
documents can be translated.</p>

<p>For each document or object class, a set of translation rules can be
defined, specifying how the canonical form should be transformed into a given
formalism. These translation rules are grouped into <em>translation
schemas</em>, each schema containing the rules necessary to translate a
generic logical structure (document or object structure) into a particular
formalism. The same generic logical structure can have several different
translation schemas, each defining translation rules for a different
formalism.</p>

<p>Like presentation schemas, translation schemas are generic. Thus, they
apply to an entire object or document class and permit translation of all
documents or objects of that class.</p>
</div>

<div class="subsection">
<h3><a name="sectc512" id="sectc512">Translation procedure</a></h3>

<p>The translator works on the specific logical structure of the document
being translated. It traverses the primary tree of this logical structure in
pre-order and, at each node encountered, it applies the corresponding
translation rules defined in the translation schema. Translation can be
associated:</p>
<ul>
  <li>with element types defined in the structure schema,</li>
  <li>with global or local attributes defined in the structure schema,</li>
  <li>with specific presentation rules,</li>
  <li>with the content of the leaves of the structure (characters, symbols
    and graphical elements)</li>
</ul>

<p>Thus, for each node, the translator applies all rules associated with the
element type, all rules associated with each attribute (local or global)
carried by the element, and if the element is a leaf of the tree, it also
applies translation rules for characters, symbols, or graphical elements,
depending on the type of the leaf.</p>

<p>Rules associated with the content of leaves are different from all other
rules: they specify only how to translate character strings, symbols, and
graphical elements. All other rules, whether associated with element types,
with specific presentation rules or with attributes, are treated similarly.
These rules primarily allow:</p>
<ul>
  <li>generation of a text constant or variable before or after the contents
    of an element,</li>
  <li>modification of the order in which elements appear after
  translation,</li>
  <li>removal of an element in the translated document,</li>
  <li>and writing messages on the user's terminal during translation.</li>
</ul>
</div>
</div>

<div class="section">
<h2><a name="sectb52" id="sectb52">Translation definition language</a></h2>

<p>Translation schemas are written in a custom language, called T, which is
described in the rest of this chapter. The grammar of T is specified using
the same <a href="#sectc321">meta-language</a> as was used for the S and P
languages and the translation schemas are written using the same conventions
as the structure and presentation schemas. In particular, the keywords of the
T language (the stings between apostrophes in the following syntax rules) can
be written in any combination of upper-case and lower-case letters, but
identifiers created by the programmer must always be written in the same
way.</p>

<div class="subsection">
<h3><a name="sectc521" id="sectc521">Organization of a translation
schema</a></h3>

<p>A translation schema is begun by the <tt>TRANSLATION</tt> keyword and is
terminated by the <tt>END</tt> keyword. The <tt>TRANSLATION</tt> keyword is
followed by the name of the generic structure for which a translation is
being defined and a semicolon. This name must be identical to the name which
appears after the <tt>STRUCTURE</tt> keyword in the corresponding structure
schema.</p>

<p>After this declaration of the structure, the following material appears in
order:</p>
<ul>
  <li>the length of lines produced by the translation,</li>
  <li>the character delimiting the end of the line,</li>
  <li>the character string which the translator will insert if it must
    line-break the translated text,</li>
  <li>declarations of
    <ul>
      <li>buffers,</li>
      <li>counters,</li>
      <li>constants,</li>
      <li>variables,</li>
    </ul>
  </li>
  <li>translation rules associated with element types,</li>
  <li>translation rules associated with attributes,</li>
  <li>translation rules associated with specific presentation rules,</li>
  <li>translation rules associated with characters strings, symbols and
    graphical elements.</li>
</ul>

<p>Each of these sections is introduced by a keyword followed by a sequence
of declarations. All of these sections are optional, expect for the
translation rules associated with element types. Many <tt>TEXTTRANSLATE</tt>
sections can appear, each defining the rules for translating character
strings of a particular script.</p>
<pre>     TransSchema ='TRANSLATION' ElemID ';'
                [ 'LINELENGTH' LineLength ';' ]
                [ 'LINEEND' CHARACTER ';' ]
                [ 'LINEENDINSERT' STRING ';' ]
                [ 'BUFFERS' BufferSeq ]
                [ 'COUNTERS' CounterSeq ]
                [ 'CONST' ConstSeq ]
                [ 'VAR' VariableSeq ]
                  'RULES' ElemSeq
                [ 'ATTRIBUTES' AttrSeq ]
                [ 'PRESENTATION' PresSeq ]
                &lt; 'TEXTTRANSLATE' TextTransSeq &gt;
                [ 'SYMBTRANSLATE' TransSeq ]
                [ 'GRAPHTRANSLATE' TransSeq ]
                  'END' .</pre>
</div>

<div class="subsection">
<h3><a name="sectc522" id="sectc522">Line length</a></h3>

<p>If a <tt>LINELENGTH</tt> instruction is present after the structure
declaration, the translator divides the text it produces into lines, each
line having a length less than or equal to the integer which follows the
<tt>LINELENGTH</tt> keyword. This maximum line length is expressed as a
number of characters. The end of the line is marked by the character defined
by the <tt>LINEEND</tt> instruction. When the translator breaks the lines on
a space character in generated text, this space will be replaced by the
character string defined by the <tt>LINEENDINSERT</tt> instruction.</p>

<p>If the <tt>LINEEND</tt> instruction is not defined then the linefeed
character (octal code 12) is used as the default line end character. If the
<tt>LINEENDINSERT</tt> instruction is not defined, the linefeed character is
inserted at the end of the produced lines. If there is no <tt>LINELENGTH</tt>
instruction, the translated text is not divided into lines. Otherwise, if the
translation rules generate line end marks, these marks remain in the
translated text, but the length of the lines is not controlled by the
translator.</p>
<pre>     LineLength = NUMBER .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To limit the lines produced by the translator to a length of 80
  characters, the following rule is written at the beginning of the
  translation schema.</p>
  <pre>LineLength 80;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc523" id="sectc523">Buffers</a></h3>

<p>A buffer is a unit of memory managed by the translator, which can either
contain text read from the terminal during the translation (see the <a
href="#sectc5212"><tt>Read</tt> rule</a>), or the name of the last picture
(bit-map) encountered by the translator in its traversal of the document, or
a character string set by program. Remember the pictures are stored in files
that are separate for the document files and that the canonical form contains
only the names of the files in which the pictures are found.</p>

<p>Thus, there are three types of buffers: buffers for reading from the
terminal (filled by the <tt>Read</tt> rule), the buffer of picture names
(containing the name of the last picture encountered) and buffer filled by
programs (see function <code>SetVariableBuffer</code> in the code) also
called <em>variable buffers</em>. A translation schema can use all types of
buffers, one or several read buffers, one (and only one) picture name buffer,
and one or several variable buffers.</p>

<p>If any buffers are used, the <tt>BUFFERS</tt> keyword must be present,
followed by declarations of every buffer used in the translation schema. Each
buffer declaration is composed of the name of the buffer, chosen freely by
the programmer, followed by a keyword between parentheses to define the type
of the buffer (read buffers do not require any keyword, as they are the
default type). The picture name buffer is identified by the <tt>Picture</tt>
keyword, between parentheses, following the buffer name. The <tt>Picture</tt>
keyword may only appear once. A variable buffer is identified by the
<tt>Variable</tt> keyword, between parentheses, following the buffer name.
Each buffer declaration is terminated by a semicolon.</p>
<pre>     BufferSeq  = Buffer &lt; Buffer &gt; .
     Buffer     = BufferID [ '(' BufferType ')' ] ';' .
     BufferID   = NAME .
     BufferType = 'Picture' / 'Variable' .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following buffer declarations create a picture name buffer named
  <tt>pictureName</tt> and a read buffer named <a name="destname"
  id="destname"><tt>DestName</tt></a>:</p>
  <pre>BUFFERS
     pictureName (Picture); DestName;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc524" id="sectc524">Counters</a></h3>

<p>Certain translation rules generate text that varies according to the
context of the element to which the rules apply. Variable text is defined
either in the <a href="#sectc526"><tt>VAR</tt> section</a> of the translation
schema or in the rule itself (see the <tt>Create</tt> and <tt>Write</tt>
rules). Both types of definition rely on counters for the calculation of
variable material.</p>

<p>There are two types of counter: counters whose value is explicitely
computed by applying <a href="#sectc5221"><tt>Set</tt> and <tt>Add</tt>
rules</a>, and counters whose value is computed by a function associated with
the counter. Those functions allow the same calculations as can be used in
presentation schemas. As in a presentation schema, counters must be defined
in the <tt>COUNTERS</tt> section of the translation schema before they are
used.</p>

<p>When counters are used in a translation schema, the <tt>COUNTERS</tt>
keyword is followed by the declarations of every counter used. Each
declaration is composed of the counter's name possibly followed by a colon
and the counting function to be used for the counter. The declaration is
terminated by a semi-colon. If the counter is explicitely computed by
<tt>Set</tt> and <tt>Add</tt> rules, no counting function is indicated. If a
counting function is indicated, <tt>Set</tt> and <tt>Add</tt> rules cannot be
applied to that counter.</p>

<p>The counting function indicates how the counter's value will be computed.
Three functions are available: <tt>Rank</tt>, <tt>Rlevel</tt>, and
<tt>Set</tt>.</p>
<ul>
  <li><tt>Rank of ElemID</tt> indicates that the counter's value is the rank
    of the element of type <tt>ElemID</tt> which encloses the element for
    which the counter is being evaluated. For the purposes of this function,
    an element of type <tt>ElemID</tt> is considered to enclose itself. This
    function is primarily used when the element of type <tt>ElemID</tt> is
    part of an aggregate or list, in which case the counter's value is the
    element's rank in its list or aggregate. Note that, unlike the
    <tt>Rank</tt> function for presentation schemas, the <tt>Page</tt>
    keyword cannot be used in place of the <tt>ElemID</tt>.
    <p>The type name <tt>ElemID</tt> can be followed by an integer. That
    number represents the relative level, among the ancestors of the
    concerned element, of the element whose rank is asked. If that relative
    level <i>n</i> is unsigned, the <i>n<sup>th</sup></i> element of type
    <tt>ElemID</tt> encountered when travelling the logical structure from
    the root to the concerned element is taken into account. If the relative
    level is negative, the logical structure is travelled in the other
    direction, from the concerned element to the root.</p>
  </li>
  <li><tt>Rlevel of ElemID</tt> indicates that the counter's values is the
    relative level in the tree of the element for which the counter is being
    evaluated. The counter counts the number of elements of type
    <tt>ElemID</tt> which are found on the path between the root of the
    document's logical structure tree and the element (inclusive).</li>
  <li><tt>Set n on Type1 Add m on Type2</tt> indicates that the counter's
    value is calculated as follows: in traversing the document from the
    beginning to the element for which the counter is being evaluated, the
    counter is set to the value <tt>n</tt> each time a <tt>Type1</tt> element
    is encountered and is incremented by the amount <tt>m</tt> each time a
    <tt>Type2</tt> element is encountered. The initial value <tt>n</tt> and
    the increment <tt>m</tt> are integers.</li>
</ul>

<p>As in a presentation schema, the <tt>Rank</tt> and <tt>Set</tt> functions
can be modified by a numeric attribute which changes their initial value.
This is indicated by the <tt>Init</tt> keyword followed by the numeric
attribute's name. The <tt>Set</tt> function takes the value of the attribute
instead of the <tt>InitValue</tt> (<tt>n</tt>). For the <tt>Rank</tt>
function, the value of the attribute is considered to be the rank of the
first element of the list (rather than the normal value of 1). Subsequent
items in the list have their ranks shifted accordingly. In both cases, the
attribute must be numeric and must be a local attribute of the root of the
document itself.</p>
<pre>     CounterSeq  = Counter &lt; Counter &gt; .
     Counter     = CounterID [ ':' CounterFunc ] ';' .
     CounterID   = NAME .
     CounterFunc = 'Rank' 'of' ElemID [ SLevelAsc ]
                   [ 'Init' AttrID ] /
                   'Rlevel' 'of' ElemID /
                   'Set' InitValue 'On' ElemID
                         'Add' Increment 'On' ElemID
                         [ 'Init' AttrID ] .
     SLevelAsc   = [ '-' ] LevelAsc .
     LevelAsc    =  NUMBER .
     InitValue   = NUMBER .
     Increment   = NUMBER .
     ElemID      = NAME .
     AttrID      = NAME .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>If the body of a chapter is defined in the structure schema by:</p>
  <pre>Chapter_Body = LIST OF
         (Section = BEGIN
                    Section_Title = Text;
                    Section_Body  = BEGIN
                                    Paragraphs;
                                    Section;
                                    END;
                    END
         );</pre>

  <p>(sections are defined recursively), a counter can be defined giving the
  <a name="sectnum" id="sectnum">number of a section</a> within its level in
  the hierarchy:</p>
  <pre>COUNTERS
   SectionNumber : Rank of Section;</pre>

  <p>A counter holding the hierarchic level of a section:</p>
  <pre>   SectionLevel : Rlevel of Section;</pre>

  <p>A <a name="uniquenum" id="uniquenum">counter</a> which sequentially
  numbers all the document's sections, whatever their hierarchic level:</p>
  <pre>   UniqueSectNum : Set 0 on Document Add 1 on Section;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc525" id="sectc525">Constants</a></h3>

<p>A common feature of translation rules is the generation of constant text.
This text can be defined in the rule that generates it (see for example the
<a href="#sectc5210"><tt>Create</tt></a> and <a
href="#sectc5211"><tt>Write</tt></a> rules); but it can also be defined once
in the constant declaration section and used many times in different rules.
The latter option is preferable when the same text is used in several rules
or several <a href="#sectc526">variables</a>.</p>

<p>The <tt>CONST</tt> keyword begins the constant declaration section of the
translation schema. It must be omitted if no constants are declared. Each
constant declaration is composed of the constant name, an equals sign, and
the constant's value, which is a character string between apostrophes. A
constant declaration is terminated by a semicolon.</p>
<pre>     ConstSeq   = Const &lt; Const &gt; .
     Const      = ConstID '=' ConstValue ';' .
     ConstID    = NAME .
     ConstValue = STRING .</pre>

<blockquote class="example">
  <p><strong><a name="levelexample"
  id="levelexample">Example:</a></strong></p>

  <p>The following rule assigns the name <tt>TxtLevel</tt> to the character
  string ``Level'':</p>
  <pre>CONST
     TxtLevel = 'Level';</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc526" id="sectc526">Variables</a></h3>

<p>Variables allow to define variable text which is generated by the
<tt>Create</tt> and <tt>Write</tt> rules. They are also used to define file
names which are used in the <tt>Create</tt>, <tt>ChangeMainFile</tt>,
<tt>RemoveFile</tt>, and <tt>Indent</tt> rules. Variables can be defined
either in the <tt>VAR</tt> section of the translation schema or directly in
the rules which use them. Variables that define file names must be declared
in the <tt>VAR</tt> section, and when the same variable is used several times
in the translation schema, it makes sense to define it globally in the
<tt>VAR</tt> section. This section is only present if at least one variable
is defined globally.</p>

<p>After the <tt>VAR</tt> keyword, each global variable is defined by its
name, a colon separator and a sequence of functions (at least one function).
Each variable definition is terminated by a semicolon. Functions determine
the different parts which together give the value of the variable. The value
is obtained by concatenating the strings produced by each of the functions.
Seven types of functions are available. Each variable definition may use any
number of functions of each type.</p>
<ul>
  <li>The function <tt>Value(Counter)</tt>returns a string representing the
    value taken by the counter when it is evaluated for the element in whose
    rule the variable is used. The counter must have been declared in the
    <tt>COUNTERS</tt> section of the translation schema. When the counter is
    expressed in arabic numerals, the counter name can be followed by a colon
    and an integer indicating a minimum length (number of characters) for the
    string; if the counter's value is normally expressed with fewer
    characters than the required minimum, zeroes are added to the front of
    the string to achieve the minimum length.
    <p>By default, the counter value is written in arabic digits. If another
    representation of that value is needed, the counter name must be followed
    by a comma and one of the following keywords:</p>
    <ul>
      <li><tt>Arabic</tt> : arabic numerals (default value),</li>
      <li><tt>LRoman</tt> : lower-case roman numerals,</li>
      <li><tt>URoman</tt> : upper-case roman numerals,</li>
      <li><tt>Uppercase</tt> : upper-case letter,</li>
      <li><tt>Lowercase</tt> : lower-case letter.</li>
    </ul>
  </li>
  <li>The function <tt>FileDir</tt>, without parameter, returns a string
    representing the name of the directory of the output file that has been
    given as a parameter to the translation program. The string includes a
    character '/' at the end.</li>
  <li>The function <tt>FileName</tt>, without parameter, returns a string
    representing the name of the output file that has been given as a
    parameter to the translation program. The file extension (the character
    string that terminate the file name, after a dot) is not part of that
    string.</li>
  <li>The function <tt>Extension</tt>, without parameter, returns a string
    representing the extension of the file name. That string is empty if the
    file name that has been given as a parameter to the translation program
    has no extension. If there is an extension, its first character is a
  dot.</li>
  <li>The function <tt>DocumentName</tt>, without parameter, returns a string
    representing the name of the document being translated.</li>
  <li>The function <tt>DocumentDir</tt>, without parameter, returns a string
    representing the directory containing the document being translated.</li>
  <li>The function formed by the name of a constant returns that constant's
    value.</li>
  <li>The function formed by a character string between apostrophes returns
    that string.</li>
  <li>The function formed by the name of a buffer returns the contents of
    that buffer. If the named buffer is the picture buffer, then the name of
    the last picture encountered is returned. Otherwise, the buffer is a read
    buffer and the value returned is text previously read from the terminal.
    If the buffer is empty (no picture has been encountered or the
    <tt>Read</tt> rule has not been executed for the buffer), then the empty
    string is returned.</li>
  <li>The function formed by an attribute name takes the value of the
    indicated attribute for the element to which the variable applies. If the
    element does not have that attribute, then the element's ancestor are
    searched toward the root of the tree. If one of the ancestors does have
    the attribute then its value is used. If no ancestors have the attribute,
    then the value of the function is the empty string.</li>
</ul>
<pre>     VariableSeq = Variable &lt; Variable &gt; .
     Variable    = VarID ':' Function &lt; Function &gt; ';' .
     VarID       = NAME .
     Function    ='Value' '(' CounterID [ ':' Length ]
                            [ ',' CounterStyle ] ')' /
                  'FileDir' / 'FileName' / 'Extension' /
                  'DocumentName' / 'DocumentDir' /
                   ConstID / CharString / 
                   BufferID / AttrID .
     Length      = NUMBER .
     CounterStyle= 'Arabic' / 'LRoman' / 'URoman' /
                   'Uppercase' / 'Lowercase' .
     CharString  = STRING .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To create, at the beginning of each section of the translated document,
  text composed of the string ``Section'' followed by the section number, the
  following <a name="varsectexample" id="varsectexample">variable
  definition</a> might be used:</p>
  <pre>VAR
     SectionVar : 'Section' Value(SectionNumber);</pre>

  <p>(see the definition of <a
  href="#sectnum"><tt>SectionNumber</tt></a>).</p>

  <p>The following variable definition can be used to create, at the
  beginning of each section, the text ``Level'' followed by the hierarchical
  level of the section. It used the constant defined above.</p>
  <pre>     LevelVar : TxtLevel Value(SectionLevel);</pre>

  <p>(see the definitions of <a href="#sectnum"><tt>SectionLevel</tt></a> and
  of <a href="#levelexample"><tt>TxtLevel</tt></a>).</p>

  <p>To generate the translation of each section in a different file (see <a
  href="#sectc5220">rule <tt>ChangeMainFile</tt></a>), the name of these
  files might be defined by the following variable:</p>
  <pre>     VarOutpuFile : FileName Value(SectionNumber)
                    Extension;</pre>

  <p>If <tt>output.txt</tt> is the name of the <a name="varoutputfile"
  id="varoutputfile">output file</a> specified when starting the translation
  program, translated sections are written in files <tt>output1.txt</tt>,
  <tt>output2.txt</tt>, etc.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc527" id="sectc527">Translating structure elements</a></h3>

<p>The <tt>RULES</tt> keyword introduces the translation rules which will be
applied to the various structured element types. Translation rules can be
specified for each element type defined in the structure schema, including
the base types defined implicitly, whose names are <tt>TEXT_UNIT</tt>,
<tt>PICTURE_UNIT</tt>, <tt>SYMBOL_UNIT</tt>, <tt>GRAPHIC_UNIT</tt> and
<tt>PAGE_UNIT</tt>. But it is not necessary to specify rules for every
defined type.</p>

<p>If there are no translation rules for an element type, the elements that
it contains (and which may have rules themselves) will still be translated,
but the translator will produce nothing for the element itself. To make the
translator completely ignore the content of an element the <a
href="#sectc5217"><tt>Remove</tt> rule</a> must be used.</p>

<p>The translation rules for an element type defined in the structure schema
are written using the name of the type followed by a colon and the list of
applicable rules. When the element type is a <a href="#sectd3285">mark
pair</a>, but only in this case, the type name must be preceded by the
<tt>First</tt> or <tt>Second</tt> keyword. This keyword indicates whether the
rules that follow apply to the first or second mark of the pair.</p>

<p>The list of rules can take several forms. It may be a simple
non-conditional rule. It can also be formed by a condition followed by one or
more simple rules. Or it can be a block of rules beginning with the
<tt>BEGIN</tt> keyword and ending with the <tt>END</tt> keyword and a
semicolon. This block of rules can contain one or more simple rules and/or
one or more conditions, each followed by one or more simple rules.</p>
<pre>     ElemSeq        = TransType &lt; TransType &gt; .
     TransType      = [ FirstSec ] ElemID ':' RuleSeq .
     FirstSec       = 'First' / 'Second' .
     RuleSeq        = Rule / 'BEGIN' &lt; Rule &gt; 'END' ';' .
     Rule           = SimpleRule / ConditionBlock .
     ConditionBlock = 'IF' ConditionSeq SimpleRuleSeq .
     SimpleRuleSeq  = 'BEGIN' &lt; SimpleRule &gt; 'END' ';' / 
                      SimpleRule .</pre>
</div>

<div class="subsection">
<h3><a name="sectc528" id="sectc528">Conditional rules</a></h3>

<p>In a translation schema, the translation rules are either associated with
element types or with attribute values or with a specific presentation. They
are applied by the translator each time an element of the corresponding type
is encountered in the translated document or each time the attribute value is
carried by an element or also, each time the specific translation is attached
to an element. This systematic application of the rules can be relaxed: it is
possible to add a condition to one or more rules, so that these rules are
only applied when the condition is true.</p>

<p>A condition begins with the keyword <tt>IF</tt>, followed by a sequence of
elementary conditions. Elementary conditions are separated from each other by
the <tt>AND</tt> keyword. If there is only one elementary condition, this
keyword is absent. The rules are only applied if all the elementary
conditions are true. The elementary condition can be negative; it is then
preceded by the <tt>NOT</tt> keyword.</p>

<p>When the translation rule(s) controlled by the condition apply to a
reference element or a reference attribute, an elementary condition can also
apply to element referred by this reference. The <tt>Target</tt> keyword is
used for that purpose. It must appear before the keyword defining the
condition type.</p>

<p>Depending on their type, some conditions may apply either to the element
with which they are associated, or to one of its ancestor. In the case of an
ancestor, the key word <tt>Ancestor</tt> must be used, followed by</p>
<ul>
  <li>either an integer which represents the number of levels in the tree
    between the element and the ancestor of interest,</li>
  <li>or the type name of the ancestor of interest. If that type is defined
    in a separate structure schema, the name of that schema must follow
    between parentheses.</li>
</ul>

<p>There is a special case for the parent element, which can be simply
written <tt>Parent</tt> instead of <tt>Ancestor 1</tt>.</p>

<p>Only conditions <tt>First</tt>, <tt>Last</tt>, <tt>Referred</tt>,
<tt>Within</tt>, <tt>Attributes</tt>, <tt>Presentation</tt>, and those
concerning an attribute or a specific presentation can apply to an ancestor.
Conditions <tt>FirstRef</tt>, <tt>LastRef</tt>, <tt>ExternalRef</tt>,
<tt>Script</tt>, <tt>FirstAttr</tt>, <tt>LastAttr</tt>,
<tt>ComputedPage</tt>, <tt>StartPage</tt>, <tt>UserPage</tt>,
<tt>ReminderPage</tt>, <tt>Empty</tt>, <tt>Root</tt> cannot be preceded by
keywords <tt>Parent</tt> or <tt>Ancestor</tt>.</p>

<p>In condition <tt>Referred</tt> and in the condition that applies to a
named attribute, a symbol '<tt>*</tt>' can indicate that the condition is
related only to the element itself. If this symbol is not present, not only
the element is considered, but also its ancestor, at any level.</p>

<p>The form of an elementary condition varies according to the type of
condition.</p>

<div class="subsubsection">
<h4><a name="sectd5281" id="sectd5281">Conditions based on the logical
position of the element</a></h4>

<p>The condition can be on the position of the element in the document's
logical structure tree. It is possible to test whether the element is the
first (<tt>First</tt>) or last (<tt>Last</tt>) among its siblings or if it is
not the first (<tt>NOT First</tt>) or not the last (<tt>NOT Last</tt>).</p>

<p>It is possible to test if the element is the root of its document (keyword
<code>Root</code>).</p>

<p>It is also possible to test if the element is contained in an element of a
given type (<tt>Within</tt>) or if it is not (<tt>NOT Within</tt>). If that
element type is defined in a structure schema which is not the one which
corresponds to the translation schema, the type name of this element must be
followed, between parentheses, by the name of the structure schema which
defines it.</p>

<p>If the keyword <tt>Within</tt> is preceded by <tt>Immediately</tt>, the
condition is satisfied only if the <em>parent</em> element has the type
indicated. If the word <tt>Immediately</tt> is missing, the condition is
satisfied if any <em>ancestor</em> has the type indicated.</p>

<p>An integer <i>n</i> can appear between the keyword <tt>Within</tt> and the
type. It specifies the number of ancestors of the indicated type that must be
present for the condition to be satisfied. If the keyword
<tt>Immediately</tt> is also present, the <i>n</i> immediate ancestors of the
element must have the indicated type. The integer <i>n</i> must be positive
or zero. It can be preceded by <tt>&lt;</tt> or <tt>&gt;</tt> to indicate a
maximum or minimum number of ancestors. If these symbols are missing, the
condition is satisfied only if it exists exactly <i>n</i> ancestors. When
this number is missing, it is equivalent to &gt; 0.</p>

<p>If the condition applies to translation rules associated with an
attribute, i.e. if it is in the <tt>ATTRIBUTES</tt> section of the
presentation schema, the condition can be simply an element name. Translation
rules are then executed only if the attribute is attached to an element of
that type. The keyword <tt>NOT</tt> before the element name indicates that
the translation rules must be executed only if the element is not of the type
indicated.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5282" id="sectd5282">Conditions on references</a></h4>

<p>References may be taken into account in conditions, which can be based on
the fact that the element, or one of its ancestors (unless symbol <tt>*</tt>
is present), is designated by a at least one reference (<tt>Referred</tt>) or
by none (<tt>NOT Referred</tt>). If the element or attribute to which the
condition is attached is a reference, the condition can be based on the fact
that it acts as the first reference to the designated element
(<tt>FirstRef</tt>), or as the last (<tt>LastRef</tt>), or as a reference to
an element located in another document (<tt>ExternalRef</tt>). Like all
conditions, conditions on references can be inverted by the <tt>NOT</tt>
keyword.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5284" id="sectd5284">Conditions on the scripts</a></h4>

<p>The character string base type (and only this type) can use the condition
<tt>Script = a</tt> which indicates that the translation rule(s) should only
apply if the script of the character string is the one whose name appears
after the equals sign (or is not, if there is a preceding <tt>NOT</tt>
keyword). This condition cannot be applied to translation rules of an
attribute.</p>

<p>In the current implementation of Thot, the available scripts are the
<tt>Latin</tt> script and the <tt>Greek</tt> script.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5285" id="sectd5285">Conditions on page breaks</a></h4>

<p>The page break base type (and only this type) can use the following
conditions: <tt>ComputedPage</tt>, <tt>StartPage</tt>, <tt>UserPage</tt>, and
<tt>ReminderPage</tt>. The <tt>ComputedPage</tt> condition indicates that the
translation rule(s) should apply if the page break was created automatically
by Thot; the <tt>StartPage</tt> condition is true if the page break is
generated before the element by the <tt>Page</tt> rule of the P language; the
<tt>UserPage</tt> condition applies if the page break was inserted by the
user; and the <tt>ReminderPage</tt> is applied if the page break is a
reminder of page breaking.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5286" id="sectd5286">Conditions on the element's
content</a></h4>

<p>The condition can be based on whether or not the element is empty. An
element which has no children or whose leaves are all empty is considered to
be empty itself. This condition is expressed by the <tt>Empty</tt> keyword,
optionally preceded by the <tt>NOT</tt> keyword.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5288" id="sectd5288">Conditions on the presence of specific
presentation rules</a></h4>

<p>The condition can be based on the presence or absence of specific
presentation rules associated with the translated element, whatever the
rules, their value or their number. This condition is expressed by the
keyword <tt>Presentation</tt>, optionally preceded by the <tt>NOT</tt>
keyword.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd5289" id="sectd5289">Conditions on the presence of logical
attributes</a></h4>

<p>In the same way, the condition can be based on the presence or absence of
attributes associated with the translated elements, no matter what the
attributes or their values. The <tt>Attributes</tt> keyword expresses this
condition.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd52810" id="sectd52810">Conditions on logical
attributes</a></h4>

<p>If the condition appears in the translation rules of an attribute, the
<tt>FirstAttr</tt> and <tt>LastAttr</tt> keywords can be used to indicate
that the rules must only be applied if this attribute is the first attribute
for the translated element or if it is the last (respectively). These
conditions can also be inverted by the <tt>NOT</tt> keyword.</p>

<p>Another type of condition can only be applied to the translation rules
when the element being processed (or one of its ancestors if symbol
<tt>*</tt> is missing) has a certain attribute, perhaps with a certain value
or, in contrast, when the element does not have this attribute with this
value. The condition is specified by writing the name of the attribute after
the keyword <tt>IF</tt> or <tt>AND</tt>. The <tt>NOT</tt> keyword can be used
to invert the condition. If the translation rules must be applied to any
element which has this attribute (or does not have it, if the condition is
inverted) no matter what the attribute's value, the condition is complete.
If, in contrast, the condition applies to one or more values of the
attribute, these are indicated after the name of the attribute, except for
reference attributes which do not have values.</p>

<p>The representation of the values of an <a name="relattr"
id="relattr">attribute</a> in a condition depends on the attribute's type.
For attributes with enumerated or textual types, the value (a name or
character string between apostrophes, respectively) is simply preceded by an
equals sign. For numeric attributes, the condition can be based on a single
value or on a range of values. In the case of a unique value, this value (an
integer) is simply preceded by an equals sign. Conditions based on ranges of
values have several forms:</p>
<ul>
  <li>all values less than a given value (the value is preceded by a ``less
    than'' sign).</li>
  <li>all values greater than a given value (the value is preceded by a
    ``greater than'' sign).</li>
  <li>all values falling in an interval, bounds included. The range of values
    is then specified <tt>IN [</tt>Minimum <tt>..</tt>Maximum<tt>]</tt>,
    where Minimum and Maximum are integers.</li>
</ul>

<p>All numeric values may be negative. The integer is simply preceded by a
minus sign.</p>

<p>Both local and global attributes can be used in conditions.</p>
</div>

<div class="subsubsection">
<h4><a name="sectd52811" id="sectd52811">Conditions on specific presentation
rules</a></h4>

<p>It is possible to apply translation rules only when the element being
processed has or does not have a specific presentation rule, possibly with a
certain value. The condition is specified by writing the name of the
presentation rule after the keyword <tt>IF</tt> or <tt>AND</tt>. The
<tt>NOT</tt> keyword can be used to invert the condition. If the translation
rules must be applied to any element which has this presentation rule (or
does not have it, if the condition is inverted) no matter what the rule's
value, the condition is complete. If, in contrast, the condition applies to
one or more values of the rule, these are indicated after the name of the
attribute.</p>

<p>The representation of presentation rule values in a condition is similar
to that for attribute values. The representation of these values depend on
the type of the presentation rule. There are three categories of presentation
rules:</p>
<ul>
  <li>those taking numeric values (<tt>Size, Indent, LineSpacing,
    LineWeight</tt>),</li>
  <li>those with values taken from a predefined list (<tt>Adjust, Hyphenate,
    Direction, UnicodeBidi, Style, Weight, Font, UnderLine, Thickness,
    LineStyle</tt>),</li>
  <li>those whose value is a name (<tt>FillPattern, Background,
    Foreground</tt>).</li>
</ul>

<p>For presentation rules which take numeric values, the condition can take a
unique value or a range of values. In the case of a unique value, this value
(an integer) is simply preceded by an equals sign. Conditions based on ranges
of values have several forms:</p>
<ul>
  <li>all values less than a given value (the value is preceded by a ``less
    than'' sign).</li>
  <li>all values greater than a given value (the value is preceded by a
    ``greater than'' sign).</li>
  <li>all values falling in an interval, bounds included. The range of values
    is then specified <tt>IN [</tt>Minimum <tt>..</tt>Maximum<tt>]</tt>,
    where Minimum and Maximum are integers.</li>
</ul>

<p>Values for the <tt>Indent</tt>rule may be negative. The integer is then
simply preceded by a minus sign and represents how far the first line starts
to the left of the other lines.</p>

<p>For presentation rules whose values are taken from predefined lists, the
value which satisfies the condition is indicated by an equals sign followed
by the name of the value.</p>

<p>For presentation rule whose values are names, the value which satisfies
the condition is indicated by the equals sign followed by the value's name.
The names of fill patterns (the <tt>FillPattern</tt> rule) and of colors (the
<tt>Foreground</tt> and <tt>Background</tt> rules) known to Thot are the same
as in the P language.</p>

<p>The syntax of conditions based on the specific presentation is the same as
the syntax used to express the <a href="#sectc5224">translation of specific
presentation rules</a>.</p>

<p>When a condition has only one rule, the condition is simply followed by
that rule. If it has several rules, they are placed after the condition
between the keywords <tt>BEGIN</tt> and <tt>END</tt>.</p>
<pre>   ConditionSeq = Condition [ 'AND' Condition ] .
   Condition    = [ 'NOT' ] [ 'Target' ] Cond .
   Cond         = CondElem / CondAscend .
   CondElem     ='FirstRef' / 'LastRef' /
                 'ExternalRef' /
                 'Script' '=' Script /
                 'ComputedPage' / 'StartPage' / 
                 'UserPage' / 'ReminderPage' /
                 'Empty' / 'Root' /
                  ElemID /
                 'FirstAttr' / 'LastAttr' .
   CondAscend   = [ Ascend ] CondOnAscend .
   Ascend       = '*' / 'Parent' / 'Ancestor' LevelOrType .
   LevelOrType  = CondRelLevel / ElemID [ ExtStruct ] .
   CondRelLevel = NUMBER .
   CondOnAscend ='First' / 'Last' /
                 'Referred' / 
                  [ 'Immediately' ] 'Within' [ NumParent ]
                                    ElemID [ ExtStruct ] /
                 'Attributes' /
                  AttrID [ RelatAttr ] /
                 'Presentation' /
                  PresRule .
   NumParent    = [ GreaterLess ] NParent .
   GreaterLess  = '&gt;' / '&lt;' .
   NParent      = NUMBER.
   ExtStruct    = '(' ElemID ')' .
   Script     = NAME .
   RelatAttr    ='=' Value /
                 '&gt;' [ '-' ] Minimum /
                 '&lt;' [ '-' ] Maximum /
                 'IN' '[' [ '-' ] MinInterval '..'
                          [ '-' ] MaxInterval ']' .
   Value        = [ '-' ] IntegerVal / TextVal / AttrValue .
   Minimum      = NUMBER .
   Maximum      = NUMBER .
   MinInterval  = NUMBER .
   MaxInterval  = NUMBER .
   IntegerVal   = NUMBER .
   TextVal      = STRING .
   AttrValue    = NAME .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that after each element of type Section_Title it is useful to
  produce the text <tt>\label{SectX}</tt> where <tt>X</tt> represents the
  section number, but only if the section is designated by one or more
  references in the document. The following conditional rule produces this
  effect:</p>
  <pre>RULES
  Section_Title :
    IF Referred
      Create ('\label{Sect' Value(UniqueSectNum) '}\12') After;</pre>

  <p>(the declaration of the <a href="#sectc5224"><tt>UniqueSectNum</tt>
  counter</a> is given above). The string <tt>\12</tt> represents a line
  break.</p>
</blockquote>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that for elements of the Elmnt type it would be useful to
  produce a character indicating the value of the numeric attribute Level
  associated with the element: an ``A'' for all values of Level less than 3,
  a ``B'' for values between 3 and 10 and a ``C'' for values greater than 10.
  This can be achieved by writing the following rules for the Elmnt type:</p>
  <pre>RULES
  Elmnt :
    BEGIN
    IF Level &lt; 3
      Create 'A';
    IF Level IN [3..10]
      Create 'B';
    IF Level &gt; 10
      Create 'C';
    END;</pre>
</blockquote>
</div>
</div>

<div class="subsection">
<h3><a name="sectc529" id="sectc529">Translation rules</a></h3>

<p>Fifteen types of translation rules can be associated with element types
and attribute values. They are the <tt>Create</tt>, <tt>Write</tt>,
<tt>Read</tt>, <tt>Include</tt>, <tt>Get</tt>, <tt>Copy</tt>, <tt>Use</tt>,
<tt>Remove</tt>, <tt>Ignore</tt>, <tt>NoTranslation</tt>,
<tt>NoLineBreak</tt>, <tt>ChangeMainFile</tt>, <tt>RemoveFile</tt>,
<tt>Set</tt>, <tt>Add</tt>, <tt>Indent</tt>, rules. Each rule has its own
syntax, although they are all based on very similar models.</p>
<pre>     SimpleRule = 'Create' [ 'IN' VarID ] Object
                        [ Position ] ';' /
                  'Write' Object [ Position ] ';' /
                  'Read' BufferID [ Position ] ';' /
                  'Include' File [ Position ] ';' /
                  'Get' [ RelPosition ] ElemID 
                        [ ExtStruct ] 
                        [ Position ] ';' /
                  'Copy' [ RelPosition ] ElemID 
                        [ ExtStruct ] 
                        [ Position ] ';' /
                  'Use' TrSchema [ 'For' ElemID ] ';' /
                  'Remove' ';' /
                  'Ignore' ';' /
                  'NoTranslation' ';' /
                  'NoLineBreak' ';' /
                  'ChangeMainFile' VarID [ Position ] ';' /
                  'RemoveFile' VarID [ Position ] ';' /
                  'Set' CounterID InitValue [ Position ] ';' /
                  'Add' CounterID Increment [ Position ] ';' /
                  'Indent' [ 'IN' VarID ] Indent [ Position ] ';' .</pre>
</div>

<div class="subsection">
<h3><a name="sectc5210" id="sectc5210">The <tt>Create</tt> rule</a></h3>

<p>The most frequently used rule is undoubtedly the <tt>Create</tt> rule,
which generates fixed or variable text (called an <em>object</em>) in the
output file. The generated text can be made to appear either before or after
the content of the element to which the rule applies. The rule begins with
the <tt>Create</tt> keyword, followed by a specifier for the object and a
keyword (<tt>Before</tt> or <tt>After</tt>) indicating the position of the
generated text (<a href="#sectc5222">before or after</a> the element's
content). If the position is not indicated, the object will be generated
before the element's content. This rule, like all translation rules, is
terminated by a semicolon.</p>

<p>The <tt>Create</tt> keyword can be followed by the <tt>IN</tt> keyword and
by the name of a variable. This means that the text generated by the rule
must not be written in the main output file, but in the file whose name is
specified by the variable.</p>

<p>This allows the translation program to generate text in different files
during the same run. These files do not need to be explicitely declared or
opened. They do not need to be closed either, but if they contain temporary
data, they can be removed (see the <a href="#sectc5220a"><tt>RemoveFile</tt>
rule</a>). As soon as the translation program executes a <tt>Create</tt> rule
for a file that is not yet open, it opens the file. These files are closed
when the translation is finished.</p>
<pre>               'Create' [ 'IN' VarID ] Object
                        [ Position ] ';'
     Object   = ConstID / CharString /
                BufferID /
                VarID /
               '(' Function &lt; Function &gt; ')' /
                [ 'Translated' ] AttrID /
               'Value' /
               'Content' /
               'Attributes' /
               'Presentation' /
               'RefId' /
               'PairId' /
               'FileDir' /
               'FileName' /
               'Extension' /
               'DocumentName' /
               'DocumentDir' /
                [ 'Referred' ] ReferredObject .
     Position ='After' / 'Before' .

     ReferredObject = VarID /
                ElemID [ ExtStruct ] /
               'RefId' /
               'DocumentName' /
               'DocumentDir' .</pre>

<p>The object to be generated can be:</p>
<ul>
  <li>a constant string, specified by its name if it is declared in the
    schema's <tt>CONST</tt> section, or given directly as a value between
    apostrophes;</li>
  <li>the contents of a buffer, designated by the name of the buffer;</li>
  <li>a variable, designated by its name if it is declared in the translation
    schema's <tt>VAR</tt> section, or given directly between parentheses. The
    text generated is the value of that variable evaluated for the element to
    which the rule applies.</li>
  <li>the value of an attribute, if the element being translated has this
    attribute. The attribute is specified by its name. If it's a text
    attribute, it can be preceded by the <code>Translated</code> keyword,
    which causes the attribute value to be recoded using the text translation
    table defined by section <code><a
    href="#sectc5225">TEXTTRANSLATE</a></code>;</li>
  <li>the value of a specific presentation rule. This object can only be
    generated if the translation rule is for a <a href="#prestransl">specific
    presentation rule</a>. It is specified by the <tt>Value</tt> keyword;</li>
  <li>the element's content. That is, the content of the leaves of the
    subtree of the translated element. This is specified by the
    <tt>Content</tt> keyword;</li>
  <li>the translation of all attributes of the element (which is primarily
    used to apply the attribute translation rules <a
    href="#sectc5222">before</a> those of the element type). This is
    specified by the <tt>Attributes</tt> keyword.</li>
  <li>the translation of all of the element's specific presentation rules
    (which is primarily used to apply the translation rules for the specific
    presentation rules <a href="#sectc5222">before</a> those of the element
    or its attributes). This option is specified by the <tt>Presentation</tt>
    keyword;</li>
  <li>The value of the reference's identifier.<br />
    Thot associates a unique identifier with each element in a document. This
    identifier (called <em>reference's identifier</em> or <em>label</em>) is
    a character string containing the letter `L' followed by digits. Thot
    uses it in references for identifying the referred element.<br />
    The <tt>RefId</tt> keyword produces the reference's identifier of the
    element to which the translation rule is applied, or the reference's
    identifier of its first ancestor that is referred by a reference or that
    can be referred by a reference.</li>
  <li>the value of a mark pair's unique identifier. This may only be used for
    <a href="#sectd3285">mark pairs</a> and is indicated by the
    <tt>PairId</tt> keyword.</li>
  <li>the directory containing the file being generated (this string includes
    an ending '/', if it is not empty). This is indicated by the
    <tt>FileDir</tt> keyword.</li>
  <li>the name of the file being generated (only the name, without the
    directory and without the extension). This is indicated by the
    <tt>FileName</tt> keyword.</li>
  <li>the extension of the file being generated (this string starts with a
    dot, if it is not empty). This is indicated by the <tt>Extension</tt>
    keyword.</li>
  <li>the name of the document being translated. This is indicated by the
    <tt>DocumentName</tt> keyword.</li>
  <li>the directory containing the document being translated. This is
    indicated by the <tt>DocumentDir</tt> keyword.</li>
</ul>

<p>When the rule applies to a reference (an element or an attribute defined
as a reference in the structure schema), it can generate a text related to
the element referred by that reference. The rule name is then followed by the
<tt>Referred</tt> keyword and a specification of the object to be generated
for the referred element. This specification can be:</p>
<ul>
  <li>the name of a variable. The rule generates the value of that variable,
    computed for the referred element.</li>
  <li>an element type. The rule generates the translation of the element of
    that type, which is in the subtree of the referred element. If this
    element is not defined in the structure schema which corresponds to the
    translation schema (that is, an object defined in another schema), the
    element's type name must be followed by the name of its structure schema
    between parentheses.</li>
  <li>the <tt>RefId</tt> keyword. The rule generates the reference's
    identifier of the referred element.</li>
  <li>the <tt>DocumentName</tt> keyword. The rule generates the name of the
    document to which the referred element belongs.</li>
  <li>the <tt>DocumentDir</tt> keyword. The rule generates the name of the
    directory that contains the document of the referred element.</li>
</ul>
</div>

<div class="subsection">
<h3><a name="sectc5211" id="sectc5211">The <tt>Write</tt> rule</a></h3>

<p>The <tt>Write</tt> has the same syntax as the <tt>Create</tt> rule. It
also produces the same effect, but the generated text is displayed on the
user's terminal during the translation of the document, instead of being
produced in the translated document. This is useful for helping the user keep
track of the progress of the translation and for prompting the user on the
terminal for input required by the <tt>Read</tt> rule.</p>
<pre>               'Write' Object [ Position ] ';'</pre>

<p>Notice: if the translator is launched by the editor (by the ``Save as''
command), messages produced by the <tt>Write</tt> rule are not displayed.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To make the translator display the number of each section being
  translated on the user's terminal, the following rule is specified for the
  <tt>Section</tt> element type:</p>
  <pre>Section : BEGIN
          Write VarSection;
          ...
          END;</pre>

  <p>(see <a href="#varsectexample">above</a> for the definition of the
  <tt>VarSection</tt> variable).</p>

  <p>To display text on the terminal before issuing a read operation with the
  <tt>Read</tt> rule, the following rule is used:</p>
  <pre>BEGIN
Write 'Enter the name of the destination: ';
...
END;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5212" id="sectc5212">The <tt>Read</tt> rule</a></h3>

<p>The <tt>Read</tt> rule reads text from the terminal during the translation
of the document and saves the text read in one of the buffers declared in the
<tt>BUFFERS</tt> section of the schema. The buffer to be used is indicated by
its name, after the <tt>READ</tt> keyword. This name can be followed, as in
the <tt>Create</tt> and <tt>Write</tt> rules, by a keyword indicating if the
read operation must be performed <tt>Before</tt> or <tt>After</tt> the
translation of the element's content. If this keyword is absent, the read
operation is done beforehand. The text is read into the buffer and remains
there until a rule using the same buffer - possibly the same rule - is
applied.</p>
<pre>               'Read' BufferID [ Position ] ';'</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The following set of rules tells the user that the translator is waiting
  for the entry of some text, reads this text into a buffer and copies the
  text into the translated document.</p>
  <pre>BEGIN
Write 'Enter the name of the destination: ';
Read DestName;
Create DestName;
...
END;</pre>

  <p>(see <a href="#destname">above</a> the definition of
  <tt>DestName</tt>).</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5213" id="sectc5213">The <tt>Include</tt> rule</a></h3>

<p>The <tt>Include</tt> rule, like the <tt>Create</tt> rule, is used to
produce text in the translated document. It inserts constant text which is
not defined in the translation schema, but is instead taken from a file. The
file's name is specified after the <tt>Include</tt> keyword, either directly
as a character string between apostrophes or as the name of one of the
buffers declared in the <tt>BUFFERS</tt> section of the schema. In the latter
case, the buffer is assumed to contain the file's name. This can be used when
the included file's name is known only at the moment of translation. This
only requires that the <tt>Include</tt> rule is preceded by a <tt>Read</tt>
rule which puts the name of the file desired by the user into the buffer.</p>

<p>Like the other rules, it is possible to specify whether the inclusion will
occur before or after the element's content, with the default being before.
The file inclusion is only done at the moment of translation, not during the
compilation of the translation schema. Thus, the file to be included need not
exist during the compilation, but it must be accessible at the time of
translation. Its contents can also be modified between two translations, thus
producing different results, even if neither the document or the translation
schema are modified.</p>

<p>During translation, the file to be included is searched for along the
schema directory path (indicated by the environment variable
<tt>THOTSCH</tt>). The file name is normally only composed of a simple name,
without specification of a complete file path. However, if the filename
starts with a '/', it is considered as an absolute path.</p>
<pre>                'Include' File [ Position ] ';'
     File     = FileName / BufferID .
     FileName = STRING .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that it is desirable to print documents of the Article class
  with a formatter which requires a number of declarations and definitions at
  the beginning of the file. The <tt>Include</tt>rule can be used to achieve
  this. All the declarations and definitions a replaced in a file called
  <tt>DeclarArt</tt> and then the <tt>Article</tt> element type is given the
  following rule:</p>
  <pre>Article : BEGIN
          Include 'DeclarArt' Before;
          ...
          END;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5214" id="sectc5214">The <tt>Get</tt> rule</a></h3>

<p>The <tt>Get</tt> rule is used to change the order in which the elements
appear in the translated document. More precisely, it produces the
translation of a specified element before or after the translation of the
content of the element to which the rule applies. The <tt>Before</tt> and
<tt>After</tt> keywords are placed at the end of the rule to specify whether
the operation should be performed before or after translation of the rule's
element (the default is before). The type of the element to be moved must be
specified after the <tt>Get</tt> keyword, optionally preceded by a keyword
indicating where the element will be found in the logical structure of the
document:</p>
<dl>
  <dt><tt>Included</tt></dt>
    <dd>The element to be moved is the first element of the indicated type
      which is found inside the element to which the rule applies.</dd>
  <dt><tt>Referred</tt></dt>
    <dd>This keyword can only be used if the rule applies to a reference
      element. The element to be moved is either the element designated by
      the reference (if that element is of the specified type), or the first
      element of the desired type contained within the element designated by
      the reference.</dd>
  <dt>no keyword</dt>
    <dd><p>The translator takes the first element of the indicated type from
      among the siblings of the rule's element. This is primarily used to
      change the order of the components of an aggregate.</p>
    </dd>
</dl>

<p>If the element to be moved is defined in a structure schema which is not
the one which corresponds to the translation schema (in the case of an
included object with a different schema), the type name of this element must
be followed, between parentheses, by the name of the structure schema which
defines it.</p>
<pre>                   'Get' [ RelPosition ] ElemID 
                         [ ExtStruct ]
                         [ Position ] ';' /
     RelPosition = 'Included' / 'Referred' .
     ExtStruct   = '(' ElemID ')' .</pre>

<p>The <tt>Get</tt> rule has no effect if the element which it is supposed to
move has already been translated. Thus, the element will not be duplicated.
It is generally best to associate the rule with the first element which will
be encountered by the translator in its traversal of the document. Suppose an
aggregate has two elements <tt>A</tt> and <tt>B</tt>, with <tt>A</tt>
appearing first in the logical structure. To permute these two elements, a
<tt>Get B before</tt> rule should be associated with the <tt>A</tt> element
type, not the inverse. Similarly, a rule of the form <tt>Get Included X
After</tt>, even though syntactically correct, makes no sense since, by the
time it will be applied, after the translation of the contents of the element
to which it is attached, the <tt>X</tt> element will already have been
translated.</p>
</div>

<div class="subsection">
<h3><a name="sectc5215" id="sectc5215">The <tt>Copy</tt> rule</a></h3>

<p>Like the <tt>Get</tt> rule, the <tt>Copy</tt> rule generates the
translation of a specified element, but it acts even if the element has
already been translated and it allows to copy it or to translate it later.
Both rules have the same syntax.</p>
<pre>              'Copy' [ RelPosition ] ElemID 
                     [ ExtStruct ] [ Position ] ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5216" id="sectc5216">The <tt>Use</tt> rule</a></h3>

<p>The <tt>Use</tt> rule specifies the translation schema to be applied to
objects of a certain class that are part of the document. This rule only
appears in the rules for the root element of the document (the first type
defined after the <tt>STRUCT</tt> keyword in the structure schema) or the
rules of an element defined by an external structure (by another structure
schema). Also, the <tt>Use</tt> rule cannot be conditional.</p>

<p>If the rule is applied to an element defined by an external structure, the
<tt>Use</tt> keyword is simply followed by the name of the translation schema
to be used for element constructed according to that external structure. If
the rule is applied to the document's root element, it is formed by the
<tt>Use</tt> keyword followed by the translation schema's name, the
<tt>For</tt> keyword and the name of the external structure to which the
indicated translation schema should be applied.</p>
<pre>               'Use' TrSchema [ 'For' ElemID ] ';'
     TrSchema = NAME .</pre>

<p>If no <tt>Use</tt> rule defines the translation schema to be used for an
external structure which appears in a document, the translator asks the user,
during the translation process, which schema should be used. Thus, it is not
necessary to give the translation schema a <tt>Use</tt> rule for every
external structure used, especially when the choice of translation schemas is
to be left to the user.</p>

<p>Notice: if the translator is launched by the editor (by the ``Save as''
command), prompts are not displayed.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The <tt>Article</tt> structure schema uses the <tt>Formula</tt> external
  structure, defined by another structure schema, for mathematical
  formulas:</p>
  <pre>STRUCTURE Article;
   ...
STRUCT
   Article = ...
   ...
   Formula_in_text  = Formula;
   Isolated_formula = Formula;
   ...
END</pre>

  <p>Suppose that it would be useful to use the <tt>FormulaT</tt> translation
  schema for the formulas of an article. This can be expressed in two
  different ways in the <tt>Article</tt> class translation schema, using the
  rules:</p>
  <pre>RULES
    Article :
       Use FormulaT for Formula;</pre>

  <p>or:</p>
  <pre>RULES
    ...
    Formula :
       Use FormulaT;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5217" id="sectc5217">The <tt>Remove</tt> rule</a></h3>

<p>The <tt>Remove</tt> rule indicates that nothing should be generated, in
the translated document, for the content of the element to which the rule
applies. The content of that element is simply ignored by the translator.
This does not prevent the generation of text for the element itself, using
the <tt>Create</tt> or <tt>Include</tt> rules, for example.</p>

<p>The <tt>Remove</tt> rule is simply written with the <tt>Remove</tt>
keyword. It is terminated, like all rules, by a semicolon.</p>
<pre>               'Remove' ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5217a" id="sectc5217a">The <tt>Ignore</tt> rule</a></h3>

<p>The <tt>Ignore</tt> rule indicates that nothing should be generated, in
the translated document, for the element to which the rule applies. The whole
element is simply ignored by the translator.</p>

<p>The <tt>Ignore</tt> rule is simply written with the <tt>Ignore</tt>
keyword. It is terminated, like all rules, by a semicolon.</p>
<pre>               'Ignore' ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5218" id="sectc5218">The <tt>NoTranslation</tt>
rule</a></h3>

<p>The <tt>NoTranslation</tt> rule indicates to the translator that it must
not translate the content of the leaves of the element to which it applies.
In contrast to the <tt>Remove</tt> rule, it does not suppress the content of
the element, but it inhibits the translation of character strings, symbols,
and graphical elements contained in the element. These are retrieved so that
after the translation of the document, the rules of the <a
href="#sectc5225"><tt>TEXTTRANSLATE</tt>, <tt>SYMBTRANSLATE</tt> and
<tt>GRAPHTRANSLATE</tt> sections</a> will not be applied to them.</p>

<p>The <tt>NoTranslation</tt> rule is written with the <tt>NoTranslation</tt>
keyword followed by a semicolon.</p>
<pre>               'NoTranslation' ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5219" id="sectc5219">The <tt>NoLineBreak</tt> rule</a></h3>

<p>The <tt>NoLineBreak</tt> rule indicates to the translator that it must not
generate additional line breaks in the output produced for the element to
which it applies. This is as if it was an <a href="#sectc522">instruction
<tt>LINELENGTH 0;</tt></a> at the beginning of the translation schema, but
only for the current element.</p>

<p>The <tt>NoLineBreak</tt> rule is written with the <tt>NoLineBreak</tt>
keyword followed by a semicolon.</p>
<pre>               'NoLineBreak' ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5220" id="sectc5220">The <tt>ChangeMainFile</tt>
rule</a></h3>

<p>When the translation program starts, it opens a main output file, whose
name is given as a parameter of the translator. All <a
href="#sectc5210"><tt>Create</tt> rules</a> without explicit indication of
the output file write sequentially in this file. When a
<tt>ChangeMainFile</tt> rule is executed, the main output file is closed and
it is replaced by a new one, whose name is specified in the
<tt>ChangeMainFile</tt> rule. The <tt>Create</tt> rules without indication of
the output file that are then executed write in this new file. Several
<tt>ChangeMainFile</tt> rules can be executed during the same translation,
for dividing the main output into several files.</p>

<p>This rule is written with the <tt>ChangeMainFile</tt> keyword followed by
the name of a variable that specifies the name of the new main file. The
keyword <tt>Before</tt> or <tt>After</tt> can be placed at the end of the
rule to specify whether the operation should be performed before or after
translation of the rule's element (the default is before). This rule, like
all translation rules, is terminated by a semicolon.</p>
<pre>               'ChangeMainFile' VarID [ Position ] ';'</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>To generate the translation of each section in a different file, the
  following rule can be associated with type <tt>Section</tt>. That rule uses
  the <a href="#varoutputfile"><tt>VarOutpuFile</tt> variable</a> defined
  above.</p>
  <pre>     Section:
         ChangeMainFile VarOutpuFile Before;</pre>

  <p>If <tt>output.txt</tt> is the name of the output file specified when
  starting the translation program, translated sections are written in files
  <tt>output1.txt</tt>, <tt>output2.txt</tt>, etc.</p>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5220a" id="sectc5220a">The <tt>RemoveFile</tt> rule</a></h3>

<p>Files may be used for storing temporary data that are no longer needed
when the translation of a document is complete. These files may be removed by
the <tt>RemoveFile</tt> rule.</p>

<p>This rule is written with the <tt>RemoveFile</tt> keyword followed by the
name of a variable that specifies the name of the file to be removed. The
keyword <tt>Before</tt> or <tt>After</tt> can be placed at the end of the
rule to specify whether the operation should be performed before or after
translation of the rule's element (the default is before). This rule, like
all translation rules, is terminated by a semicolon.</p>
<pre>               'RemoveFile' VarID [ Position ] ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5221" id="sectc5221">The <tt>Set</tt> and <tt>Add</tt>
rules</a></h3>

<p>The <tt>Set</tt> and <tt>Add</tt> rules are used for modifying the value
of counters that have no <a href="#sectc524">counting function</a>. Only this
type of counter can be used in the <tt>Set</tt> and <tt>Add</tt> rules.</p>

<p>Both rules have the same syntax: after the keyword <tt>Set</tt> or
<tt>Add</tt> appear the counter name and the value to assign to the counter
(<tt>Set</tt> rule) or the value to be added to the counter (<tt>Add</tt>
rule). The keyword <tt>Before</tt> or <tt>After</tt> can follow that value to
indicate when the rule must be applied: before or after the element's content
is translated. By default, <tt>Before</tt> is assumed. A semicolon terminates
the rule.</p>
<pre>               'Set' CounterID InitValue [ Position ] ';' /
               'Add' CounterID Increment [ Position ] ';'</pre>
</div>

<div class="subsection">
<h3><a name="sectc5221a" id="sectc5221a">The <tt>Indent</tt> rule</a></h3>

<p>The <tt>Indent</tt> rule is used to modify the value of text indentation
in the output files.</p>

<p>Each time the translator creates a new line in an output file, it
generates a variable number of space characters at the beginning of the new
line. By default, the number of these characters (the indentation value) is
0. It can be changed with the <tt>Indent</tt> rule.</p>

<p>In its simple form, the rule begins with the <tt>Indent</tt> keyword,
followed by the indentation sign (optional) and value and a keyword
<tt>Before</tt> or <tt>After</tt> indicating that the indentation should be
changed <a href="#sectc5222">before or after</a> the element's content is
generated. If the position is not indicated, the indentation is changed
before the element's content is generated. This rule, like all translation
rules, is terminated by a semicolon.</p>

<p>The indentation value is indicated by an integer, which is the number of
space characters to be generated at the beginning of each new line. A sign
(<tt>+</tt> or <tt>-</tt>) can appear before the integer to indicate that the
value is relative: the current value of indentation is incremented (if sign
is <tt>+</tt>) or decremented (if sign is <tt>-</tt>) by the specified
value.</p>

<p>Keyword <tt>Suspend</tt> or <tt>Resume</tt> can appear instead of the
(possibly signed) identation value. <tt>Suspend</tt> means that the new
indentation value to be used is zero until another <tt>Indent</tt> rule is
executed and changes the indentation value. <tt>Resume</tt> means that the
indentation value that was used before the last <tt>Indent Suspend</tt> was
executed becomes the new value. Only one <tt>Suspend</tt> can be used before
a <tt>Resume</tt>; <tt>Supend</tt>-<tt>Resume</tt> pairs can not be
nested.</p>

<p>Like the <a href="#sectc5210"><tt>Create</tt> rule</a>, the
<tt>Indent</tt> keyword can be followed by the <tt>IN</tt> keyword and by the
name of a <a href="#sectc526">variable</a>. This means that the rule must not
change indentation in the main output file, but in the file whose name is
specified by the variable (by default, indentation is changed in the main
output file).</p>
<pre>               'Indent' [ 'IN' VarID ] Indent [ Position ] ';' .

Indent        = 'Suspend' / 'Resume' / [ IndentSign ] IndentValue .
IndentSign    = '+' / '-' .
IndentValue   = NUMBER .</pre>
</div>

<div class="subsection">
<h3><a name="sectc5222" id="sectc5222">Rule application order</a></h3>

<p>The translator translates the elements which comprise the document in the
order induced by the tree structure, except when the <tt>Get</tt> rule is
used to change the order of translation. For each element, the translator
first applies the rules specified for the element's type that must be applied
before translation of the element's content (rules ending with the
<tt>Before</tt> keyword or which have no position keyword). If several rules
meet these criteria, the translator applies them in the order in where they
appear in the translation schema.</p>

<p>It then applies all <a href="#sectc5223">rules for the attributes</a>
which the element has and which must be applied before the translation of the
element's content (rules ending with the <tt>Before</tt> keyword or which
have no position keyword). For one attribute value, the translator applies
the rules in the order in which they are defined in the translation
schema.</p>

<p>The same procedure is followed with translation rules for specific
presentations.</p>

<p>Next, the element's content is translated, as long as a <tt>Remove</tt> or
<code>Ignore</code> rule does not apply.</p>

<p>In the next step, the translator applies rules for the specific
presentation of the element that are to be applied after translation of the
content (rules which end with the <tt>After</tt> keyword). The rules for each
type of presentation rule or each value are applied in the order in which the
translation appear in the schema.</p>

<p>Then, the same procedure is followed for translation rules for attributes
of the element.</p>

<p>Finally, the translator applies rules for the element which must be
applied after translation of the element's content. These rules are applied
in the order that they appear in the translation schema. When the translation
of an element is done, the translator procedes to translate the following
element.</p>

<p>This order can be changed with the <tt>Attributes</tt> and
<tt>Presentation</tt> options of the <a href="#sectc5210"><tt>Create</tt>
rule</a>.</p>
</div>

<div class="subsection">
<h3><a name="sectc5223" id="sectc5223">Translation of logical
attributes</a></h3>

<p>After the rules for the element types, the translation schema defines
rules for attribute values. This section begins with the <tt>ATTRIBUTES</tt>
keyword and is composed of a sequence of rule blocks each preceded by an
attribute name and an optional value or value range.</p>

<p>If the attribute's name appears alone before the rule block, the rule are
applied to all element which have the attribute, no matter what value the
attribute has. In this case, the attribute name is followed by a colon before
the beginning of the rule block.</p>

<p>The attribute's name can be followed by the name of an element type
between parentheses. This says, as in presentation schemas, that the rule
block which follows applies not to the element which has the attribute, but
to its descendants of the type indicated between the parentheses.</p>

<p>If values are given after the attribute name (or after the name of the
element type), the rules are applied only when the attribute has the
indicated values. The same attribute can appear several times, with different
values and different translation rules. Attribute values are indicated in the
same way as in <a href="#sectc528">conditions</a> and are followed by a colon
before the block of rules.</p>

<p>The rule block associated with an attribute is either a simple rule or a
sequence of rules delimited by the <tt>BEGIN</tt> and <tt>END</tt> keywords.
Note that rules associated with attribute values cannot be conditional.</p>

<p>Translation rules are not required for all attributes (or their values)
defined in a structure schema. Only those attributes for which a particular
action must be performed by the translator must have such rules. The rules
that can be used are those described above, from <a
href="#sectc5210"><tt>Create</tt></a> to <a
href="#sectc5218"><tt>NoTranslation</tt></a>.</p>
<pre>     AttrSeq       = TransAttr &lt; TransAttr &gt; .
     TransAttr     = AttrID [ '(' ElemID ')' ] 
                     [ RelatAttr ] ':' RuleSeq .
     AttrID        = NAME .
     ElemID        = NAME .</pre>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>The structure defined the ``Language'' attribute which can take the
  values ``French'' and ``English''. To have the French parts of the original
  document removed and prevent the translation of the leaves of the English
  parts, the following rules would be used:</p>
  <pre>ATTRIBUTES
   Language=French :
      Remove;
   Language=English :
      NoTranslation;</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5224" id="sectc5224">Translation of specific
presentations</a></h3>

<p>After the rules for attributes, the translation schema defines rules for
the specific presentation. This section begins with the <tt>PRESENTATION</tt>
keyword and is composed of a sequence of translation rule blocks each
preceded by a presentation rule name, optionally accompanied by a part which
depends on the particular presentation rule.</p>

<p>Each of these translation rule blocks is applied when the translator
operates on an element which has a specific presentation rule of the type
indicated at the head of the block. Depending on the type of the specific
presentation rule, it is possible to specify values of the presentation rule
for which the translation rule block should be applied.</p>

<p>There are three categories of the presentation rules:</p>
<ul>
  <li>rules taking numeric values: <tt>Size</tt>, <tt>Indent</tt>,
    <tt>LineSpacing</tt>, <tt>LineWeight</tt>,</li>
  <li>rules whose values are taken from a predefined list (i.e. whose type is
    an enumeration): <tt>Adjust</tt>, <tt>Hyphenate,Direction, UnicodeBidi,
    <tt>Style</tt>, <tt>Weight</tt>, <tt>Font</tt>, <tt>UnderLine</tt>,
    <tt>Thickness</tt>, <tt>LineStyle</tt>,</tt></li>
  <li>rules whose value is a name: <tt>FillPattern</tt>, <tt>Background</tt>,
    <tt>Foreground</tt>.</li>
</ul>

<p>For presentation rules of the first category, the values which provoke
application of the translation rules are indicated in the same manner as for
<a href="#relattr">numeric attributes</a>. This can be either a unique value
or range of values. For a unique value, the value (an integer) is simply
preceded by an equals sign. Value ranges can be specified in one of three
ways:</p>
<ul>
  <li>all values less than a given value (this value is preceded by a ``less
    than'' sign '<tt>&lt;</tt>'),</li>
  <li>all values greater than a given value (this value is preceded by a`
    `greater than'' sign '<tt>&gt;</tt>'),</li>
  <li>all values falling in an interval, bounds included. The range of values
    is then specified <tt>IN [</tt>Minimum<tt>..</tt>Maximum<tt>]</tt>, where
    Minimum and Maximum are integers.</li>
</ul>

<p>All numeric values can be negative, in which case the integer is preceded
by a minus sign. All values must be given in typographers points.</p>

<p>For presentation rules whose values are taken from a predefined list, the
value which provokes application of the translation rules is simply indicated
by the equals sign followed by the name of the value.</p>

<p>For presentation rules whose values are names, the value which provokes
the application of translation rules is simply indicated by the equals sign
followed by the name of the value. The names of the fill patterns (the
<tt>FillPattern</tt> rule) and of the colors (the <tt>Foreground</tt> and
<tt>Background</tt> rules) used in Thot are the same as in the P language.</p>
<pre>     PresSeq        = PresTrans &lt; PresTrans &gt; .
     PresTrans      = PresRule ':' RuleSeq .
     PresRule       = 'Size' [ PresRelation ] /
                      'Indent' [ PresRelation ] /
                      'LineSpacing' [ PresRelation ] /
                      'Adjust' [ '=' AdjustVal ] /
                      'Hyphenate' [ '=' BoolVal ] /
                      'Style' [ '=' StyleVal ] /
                      'Weight' [ '=' WeightVal ] /
                      'Font' [ '=' FontVal ] /
                      'UnderLine' [ '=' UnderLineVal ] /
                      'Thickness' [ '=' ThicknessVal ] /
                      'LineStyle' [ '=' LineStyleVal ] /
                      'LineWeight' [ PresRelation ] /
                      'FillPattern' [ '=' Pattern ] /
                      'Background' [ '=' Color ] /
                      'Foreground' [ '=' Color ] .

     PresRelation   = '=' PresValue /
                      '&gt;' [ '-' ] PresMinimum /
                      '&lt;' [ '-' ] PresMaximum /
                      'IN' '[' [ '-' ] PresIntervalMin '..'
                              [ '-' ] PresIntervalMax ']' .
     AdjustVal      = 'Left' / 'Right' / 'VMiddle' / 'Justify' /
                      'LeftWithDots' .
     BoolVal        = 'Yes' / 'No' .
     StyleVal       = 'Roman' / 'Italics' / 'Oblique' .
     WeightVal      = 'Normal' / 'Bold' .
     FontVal        = 'Times' / 'Helvetica' / 'Courier' .
     UnderLineVal   = 'NoUnderline' / 'UnderLined' /
                      'OverLined' / 'CrossedOut' .
     ThicknessVal   = 'Thick' / 'Thin' .
     LineStyleVal   = 'Solid' / 'Dashed' / 'Dotted' .
     Pattern        = NAME .
     Color          = NAME .
     PresMinimum    = NUMBER .
     PresMaximum    = NUMBER .
     PresIntervalMin= NUMBER .
     PresIntervalMax= NUMBER .
     PresValue      = [ '-' ] PresVal .
     PresVal        = NUMBER .</pre>

<p>The <a name="prestransl" id="prestransl">translation rules associated with
specific presentation rules</a> can use the value of the specific
presentation rule that causes them to be applied. This behavior is designated
by the keyword <tt>Value</tt>. For numerically-valued presentation rules, the
numeric value is produced. For other presentation rules, the name of the
value is produced.</p>

<p>It should be noted that modifications to the layout of the document's
elements that are made using the combination of the control key and a mouse
button will have no effect on the translation of the document.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>Suppose that it is desirable to use the same font sizes as in the
  specific presentation, but the font size must be between 10 and 18
  typographer's points. If font size is set in the translated document by the
  string <tt>pointsize=n</tt> where <tt>n</tt> is the font size in
  typographer's points then the following rules will suffice:</p>
  <pre>PRESENTATION
   Size &lt; 10 :
        Create 'pointsize=10';
   Size in [10..18] :
        BEGIN
        Create 'pointsize=';
        Create Value;
        END;
   Size &gt; 18 :
        Create 'pointsize=18';</pre>
</blockquote>
</div>

<div class="subsection">
<h3><a name="sectc5225" id="sectc5225">Recoding of characters, symbols and
graphics</a></h3>

<p>The coding of characters, graphical elements and symbols as defined in
Thot does not necessarily correspond to what is required by an application to
which a Thot document must be exported. Because of this the translator can
recode these terminal elements of the documents structure. The last sections
of a translation schema are intended for this purpose, each specifying the
recoding rules for one type of terminal element.</p>

<p>The recoding rules for character strings are grouped by scripts. There is
a group of rules for each script of the Thot document that must be
translated. Each such group of rules begins with the <tt>TEXTTRANSLATE</tt>
keyword, followed by the specification of the script to translate and the
recoding rules, between the <tt>BEGIN</tt> and <tt>END</tt> keywords unless
there is only one recoding rule for the script. The specification of the
script is not required: by default it is assumed to the Latin script (the ISO
Latin-1 character set).</p>

<p>Each recoding rule is formed by a source string between apostrophes and a
target string, also between apostrophes, the two strings being separated by
the arrow symbol (<tt>-&gt;</tt>), formed by the ``minus'' and ``greater
than'' characters. The rule is terminated by a semi-colon.</p>
<pre>     TextTransSeq = [ Script ] TransSeq .
     Script     = NAME .
     TransSeq     ='BEGIN' &lt; Translation &gt; 'END' ';' /
                    Translation .
     Translation  = Source [ '-&gt;' Target ] ';' .
     Source       = STRING .
     Target       = STRING .</pre>

<p>One such rule signifies that when the source string appears in a text leaf
of the document being translated, the translator must replace it, in the
translated document, with the target string. The source string and the target
string can have different lengths and the target string can be empty. In this
last case, the translator simply suppresses every occurrence of the source
string in the translated document.</p>

<p>For a given script, the order of the rules is not important and has no
significance because the T language compiler reorders the rules in ways that
speed up the translator's work. The total number of recoding rules is limited
by the compiler as is the maximum length of the source and target strings.</p>

<p>The recoding rules for symbols and graphical elements are written in the
same manner as the recoding rules for character strings. They are preceded,
respectively, by the <tt>SYMBTRANSLATE</tt> and <tt>GRAPHTRANSLATE</tt> and
so not require a specification of the script. Their source string is limited
to one character, since, in Thot, each symbol and each graphical element is
represented by a single character. The symbol and graphical element codes are
defined along with the <a href="#sect7">non-standard character codes</a>.</p>

<blockquote class="example">
  <p><strong>Example:</strong></p>

  <p>In a translation schema producing documents destined for use with the
  L<sup>A</sup>T<sub><big>E</big></sub>X formatter, the Latin characters``é''
  (octal code 351 in Thot) and ``è'' (octal code 350 in Thot) must be
  converted to their representation in
  L<sup>A</sup>T<sub><big>E</big></sub>X:</p>
  <pre>TEXTTRANSLATE Latin
     BEGIN
     '\350' -&gt; '\`{e}';    { e grave }
     '\351' -&gt; '\''{e}';   { e acute }
     END;</pre>
</blockquote>
</div>
</div>
<hr />
</div>

<div class="chapter">
<h1><a name="sect6" id="sect6">Language grammars</a></h1>

<p>This chapter gives the complete grammars of the languages of Thot. The
grammars were presented and described in the preceding chapters, which also
specify the semantics of the languages. This section gives only the
syntax.</p>

<div class="section">
<h2><a name="sectb61" id="sectb61">The M meta-language</a></h2>

<p>The language grammars are all expressed in the same formalism, the M
meta-language, which is defined in this section.</p>
<pre>{ Any text between braces is a comment. }
Grammar      = Rule &lt; Rule &gt; 'END' .
               { The &lt; and &gt; signs indicate zero }
               { or more repetitions. }
               { END marks the end of the grammar. }
Rule         = Ident '=' RightPart '.' .
               { The period indicates the end of a rule }
RightPart    = RtTerminal / RtIntermed .
               { The slash indicates a choice }
RtTerminal   ='NAME' / 'STRING' / 'NUMBER' .
               { Right part of a terminal rule }
RtIntermed   = Possibility &lt; '/' Possibility &gt; .
               { Right part of an intermediate rule }
Possibility  = ElemOpt &lt; ElemOpt &gt; .
ElemOpt      = Element / '[' Element &lt; Element &gt; ']' /
              '&lt;' Element &lt; Element &gt; '&gt;'  .
               { Brackets delimit optional parts }
Element      = Ident / KeyWord .
Ident        = NAME .
               { Identifier, sequence of characters
KeyWord      = STRING .
               { Character string delimited by apostrophes }
END</pre>
</div>

<div class="section">
<h2><a name="sectb62" id="sectb62">The S language</a></h2>

<p>The S language is used to write structure schemas, which contain the
generic logical structures of document and object classes. It is described
here in the M meta-language.</p>
<pre>StructSchema   = 'STRUCTURE' [ 'EXTENSION' ] ElemID ';'
                 'DEFPRES' PresID ';'
               [ 'ATTR' AttrSeq ]
               [ 'STRUCT' RulesSeq ]
               [ 'EXTENS' ExtensRuleSeq ]
               [ 'UNITS' RulesSeq ]
               [ 'EXPORT' SkeletonSeq ]
               [ 'EXCEPT' ExceptSeq ]
                 'END' .

ElemID         = NAME .
PresID         = NAME .

AttrSeq        = Attribute &lt; Attribute &gt; .
Attribute      = AttrID '=' AttrType ';' .
AttrType       = 'INTEGER' / 'TEXT' /
                 'REFERENCE' '(' RefType ')' /
                 ValueSeq .
RefType        = 'ANY' /
                 [ FirstSec ] ElemID [ ExtStruct ] .
ValueSeq       = AttrVal &lt; ',' AttrVal &gt; .
AttrID         = NAME .
FirstSec       = 'First' / 'Second' .
ExtStruct      = '(' ElemID ')' .
AttrVal        = NAME .

RulesSeq       = Rule &lt; Rule &gt; .
Rule           = ElemID [ LocAttrSeq ] '='
                 DefWithAttr ';' .
LocAttrSeq     = '(' 'ATTR' LocalAttr
                      &lt; ';' LocalAttr &gt; ')' .
LocalAttr      = [ '!' ] AttrID [ '=' AttrType ] .
DefWithAttr    = Definition
                 [ '+' '(' ExtensionSeq ')' ]
                 [ '-' '(' RestrictSeq ')' ]
                 [ 'WITH' FixedAttrSeq ] .
ExtensionSeq   = ExtensionElem &lt; ',' ExtensionElem &gt; .
ExtensionElem  = ElemID / 'TEXT' / 'GRAPHICS' /
                 'SYMBOL' / 'PICTURE' .
RestrictSeq    = RestrictElem &lt; ',' RestrictElem &gt; .
RestrictElem   = ElemID / 'TEXT' / 'GRAPHICS' /
                 'SYMBOL' / 'PICTURE' .
FixedAttrSeq   = FixedAttr &lt; ',' FixedAttr &gt; .
FixedAttr      = AttrID [ FixedOrModifVal ] .
FixedOrModifVal= [ '?' ] '=' FixedValue .
FixedValue     = [ '-' ] NumValue / TextValue / AttrVal .
NumValue       = NUMBER .
TextValue      = STRING .

Definition     = BaseType [ LocAttrSeq ] / Constr /
                 Element .
BaseType       = 'TEXT' / 'GRAPHICS' / 'SYMBOL' /
                 'PICTURE' / 'UNIT' / 'NATURE' .
Element        = ElemID [ ExtOrDef ] .
ExtOrDef       = 'EXTERN' / 'INCLUDED' /
                 [ LocAttrSeq ] '=' Definition .

Constr         = 'LIST' [ '[' min '..' max ']' ] 'OF'
                        '(' DefWithAttr ')' /
                 'BEGIN' DefOptSeq 'END' /
                 'AGGREGATE' DefOptSeq 'END' /
                 'CASE' 'OF' DefSeq 'END' /
                 'REFERENCE' '(' RefType ')' /
                 'PAIR' .

min            = Integer / '*' .
max            = Integer / '*' .
Integer        = NUMBER .

DefOptSeq      = DefOpt ';' &lt; DefOpt ';' &gt; .
DefOpt         = [ '?' ] DefWithAttr .

DefSeq         = DefWithAttr ';' &lt; DefWithAttr ';' &gt; .

SkeletonSeq    = SkeletonElem &lt; ',' SkeletonElem &gt; ';' .
SkeletonElem   = ElemID [ 'WITH' Contents ] .
Contents       = 'Nothing' / ElemID [ ExtStruct ] .

ExceptSeq      = Except ';' &lt; Except ';' &gt; .
Except         = [ 'EXTERN' ] [ FirstSec ] ExcTypeOrAttr ':'
                 ExcValSeq .
ExcTypeOrAttr  = ElemID / AttrID .
ExcValSeq      = ExcValue &lt; ',' ExcValue &gt; .
ExcValue       = 'NoCut' / 'CanCut' / 'NoCreate' / 'NoReplicate' /
                 'NoHMove' / 'NoVMove' / 'NoMove' /
                 'NoHResize' / 'NoVResize' / 'NoResize' /
                 'MoveResize' /
                 'NewWidth' / 'NewHeight' / 'NewPercentWidth' /
                 'NewHPos' / 'NewVPos' /
                 'Invisible' / 'Hidden' /
                 'PageBreak' / 'PageBreakAllowed' / 'PageBreakPlace' /
                 'PageBreakRepetition' / 'PageBreakRepBefore' /
                 'NoPaginate' / 'NoSpellCheck' /
                 'ActiveRef' /  'NoSelect' /
                 'HighlightChildren' / 'ExtendedSelection' /
                 'SelectParent' / 'ClickableSurface' /
                 'ParagraphBreak' / 'IsBreak' /
                 'ReturnCreateNL' / 'ReturnCreateWithin' / 'NoBreakByReturn' /
                 'ImportLine' / 'ImportParagraph' /
                 'GraphCreation' / 'IsDraw' / 'IsGroup' / 'EmptyGraphic' /
                 'IsTable' / 'IsRow' / 'IsColHead' / 'IsCell' /
                 'ColRef' / 'ColSpan' / 'RowSpan' /
                 'CssBackground' / 'CssClass' / 'CssId' / 'CssPseudoClass' /
                 'NoShowBox' / 'SetWindowBackground' /
                 'Shadow' / 'EventAttr' / 'SpacePreserve' /
                 'IsPlaceholder' / 'StartCounter' / 'SetCounter' /
                 ExceptNum .
ExceptNum =      NUMBER .

ExtensRuleSeq  = ExtensRule ';' &lt; ExtensRule ';' &gt; .
ExtensRule     = RootOrElem [ LocAttrSeq ]
                 [ '+' '(' ExtensionSeq ')' ]
                 [ '-' '(' RestrictSeq ')' ]
                 [ 'WITH' FixedAttrSeq ] .
RootOrElem     = 'Root' / ElemID .

END</pre>
</div>

<div class="section">
<h2><a name="sectb63" id="sectb63">The P language</a></h2>

<p>The P language is used to write presentation schemas, which define the
graphical presentation rules to be applied to different classes of documents
and objects. It is described here in the M meta-language.</p>
<pre>PresSchema      = 'PRESENTATION' ElemID ';'
                [ 'VIEWS' ViewSeq ]
                [ 'PRINT' PrintViewSeq ]
                [ 'COUNTERS' CounterSeq ]
                [ 'CONST' ConstSeq ]
                [ 'VAR' VarSeq ]
                [ 'DEFAULT' ViewRuleSeq ]
                [ 'BOXES' BoxSeq ]
                [ 'RULES' PresentSeq ]
                [ 'ATTRIBUTES' PresAttrSeq ]
                [ 'TRANSMIT' TransmitSeq ]
                  'END' .

ElemID          = NAME .

ViewSeq         = ViewDeclaration
                  &lt; ',' ViewDeclaration &gt; ';' .
ViewDeclaration = ViewID [ 'EXPORT' ] .
ViewID          = NAME .

PrintViewSeq    = PrintView &lt; ',' PrintView &gt; ';' .
PrintView       = ViewID .

CounterSeq      = Counter &lt; Counter &gt; .
Counter         = CounterID ':' CounterFunc ';' .
CounterID       = NAME .
CounterFunc     = 'RANK' 'OF' TypeOrPage [ SLevelAsc ]
                  [ 'INIT' AttrID ] [ 'REINIT' AttrID ] /
                  SetFunction &lt; SetFunction &gt;
                  AddFunction &lt; AddFunction &gt;
                  [ 'INIT' AttrID ] /
                  'RLEVEL' 'OF' ElemID .
SLevelAsc       = [ '-' ] LevelAsc .
LevelAsc        = NUMBER .
SetFunction     = 'SET' CounterValue 'ON' TypeOrPage .
AddFunction     = 'ADD' CounterValue 'ON' TypeOrPage .
TypeOrPage      = 'Page' [ '(' ViewID ')' ] /
                  [ '*' ] ElemID .
CounterValue    = NUMBER .

ConstSeq        = Const &lt; Const &gt; .
Const           = ConstID '=' ConstType ConstValue ';' .
ConstID         = NAME .
ConstType       = 'Text' [ Script ] / 'Symbol' /
                  'Graphics' / 'Picture' .
ConstValue      = STRING .
Script        = NAME .

VarSeq          = Variable &lt; Variable &gt; .
Variable        = VarID ':' FunctionSeq ';' .
VarID           = NAME .
FunctionSeq     = Function &lt; Function &gt; .
Function        = 'DATE' / 'FDATE' /
                  'DocName' / 'DirName' /
                  'ElemName' / 'AttributeName' / 'AttributeValue' /
                  ConstID / ConstType ConstValue /
                  AttrID /
                  'VALUE' '(' PageAttrCtr ','
                  CounterStyle ')' .
PageAttrCtr     = 'PageNumber' [ '(' ViewID ')' ] /
                  [ MinMax ] CounterID / AttrID .
CounterStyle    = 'Arabic' / 'Decimal' / 'DecimalLeadingZero' /
                  'URoman' /  'UpperRoman' / 'LRoman' / 'LowerRoman' /
                  'Uppercase' / 'UpperLatin' / 'Lowercase' / 'LowerLatin' /
                  'LowerGreek' / 'UpperGreek' .
MinMax          = 'MaxRangeVal' / 'MinRangeVal' .

BoxSeq          = Box &lt; Box &gt; .
Box             = 'FORWARD' BoxID ';' /
                  BoxID ':' ViewRuleSeq .
BoxID           = NAME .

PresentSeq      = Present &lt; Present &gt; .
Present         = [ '*' ] [ FirstSec ] ElemID ':'
                  ViewRuleSeq .
FirstSec        = 'First' / 'Second' .

PresAttrSeq     = PresAttr &lt; PresAttr &gt; .
PresAttr        = AttrID [ '(' [ FirstSec ] ElemID [ '*' ] ')' ] 
                  [ AttrRelation ] ':' ViewRuleSeq .
AttrID          = NAME .
AttrRelation    = '=' AttrVal /
                  '&gt;' [ '-' ] MinValue /
                  '&lt;' [ '-' ] MaxValue /
                  'IN' '[' [ '-' ] LowerBound '..' 
                  [ '-' ] UpperBound ']' /
                  'GREATER' AttrID /
                  'EQUAL' AttrID /
                  'LESS' AttrID .
AttrVal         = [ '-' ] EqualNum / EqualText / AttrValue .
MinValue        = NUMBER .
MaxValue        = NUMBER .
LowerBound      = NUMBER .
UpperBound      = NUMBER.
EqualNum        = NUMBER .
EqualText       = STRING .
AttrValue       = NAME .

ViewRuleSeq     = 'BEGIN' &lt; RulesAndCond &gt; &lt; ViewRules &gt;
                  'END' ';' /
                  ViewRules / CondRules / Rule .
RulesAndCond    = CondRules / Rule .
ViewRules       = 'IN' ViewID CondRuleSeq .
CondRuleSeq     = 'BEGIN' &lt; RulesAndCond &gt; 'END' ';' /
                  CondRules / Rule .
CondRules       = CondRule &lt; CondRule &gt;
                  [ 'Otherwise' RuleSeq ] .
CondRule        = 'IF' ConditionSeq RuleSeq .
RulesSeq        = 'BEGIN' Rule &lt; Rule &gt; 'END' ';' / Rule .

ConditionSeq    = Condition &lt; 'AND' Condition &gt; .
Condition       = [ 'NOT' ] [ 'Target' ] ConditionElem .
ConditionElem   = 'First' / 'Last' /
                  [ 'Immediately' ] 'Within' [ NumParent ]
                                     ElemID [ ExtStruct ] /
                   ElemID /
                  'Referred' / 'FirstRef' / 'LastRef' /
                  'ExternalRef' / 'InternalRef' / 'CopyRef' /
                   [ 'Inherited' ] AttrID [ '=' Value ] /
                  'AnyAttributes' / 'FirstAttr' / 'LastAttr' /
                  'UserPage' / 'StartPage' / 'ComputedPage' /
                  'Empty' / 'Root' /
                  '(' [ MinMax ] CounterName CounterCond ')' /
                  CondPage '(' CounterID ')' .
NumParent       = [ GreaterLess ] NParent .
GreaterLess     = '&gt;' / '&lt;' .
NParent         = NUMBER.
CounterCond     = '&lt;' MaxCtrVal / '&gt;' MinCtrVal /
                  '=' EqCtrVal / 
                  'IN' '[' ['-'] MinCtrBound '..' 
                  ['-'] MaxCtrBound ']' .
PageCond        = 'Even' / 'Odd' / 'One' .
MaxCtrVal       = NUMBER .
MinCtrVal       = NUMBER .
EqCtrVal        = NUMBER .
MaxCtrBound     = NUMBER .
MinCtrBound     = NUMBER .

Rule            = Property ';' / PresFunc ';' .
Property        = 'VertRef' ':' HorizPosition /
                  'HorizRef' ':' VertPosition /
                  'VertPos' ':' VPos /
                  'HorizPos' ':' HPos /
                  'Float' ':' FloatInherit /
                  'Clear' ':' ClearInherit /
                  'Height' ':' Extent /
                  'Width' ':' Extent /
                  'VertOverflow' ':' Boolean /
                  'HorizOverflow' ':' Boolean /
                  'MarginTop' ':' MarginWidth /
                  'MarginRight' ':' MarginWidth /
                  'MarginBottom' ':' MarginWidth /
                  'MarginLeft' ':' MarginWidth /
                  'PaddingTop' ':' PaddingWidth /
                  'PaddingRight' ':' PaddingWidth /
                  'PaddingBottom' ':' PaddingWidth /
                  'PaddingLeft' ':' PaddingWidth /
                  'BorderTopWidth' ':' BorderWidth /
                  'BorderRightWidth' ':' BorderWidth /
                  'BorderBottomWidth' ':' BorderWidth /
                  'BorderLeftWidth' ':' BorderWidth /
                  'BorderTopColor' ':' BorderColor /
                  'BorderRightColor' ':' BorderColor /
                  'BorderBottomColor' ':' BorderColor /
                  'BorderLeftColor' ':' BorderColor /
                  'BorderTopStyle' ':' BorderStyle /
                  'BorderRightStyle' ':' BorderStyle /
                  'BorderBottomStyle' ':' BorderStyle /
                  'BorderLeftStyle' ':' BorderStyle /
                  'ListStyleType' ':' ListStyleType /
                  'ListStyleImage' ':' ListStyleImage /
                  'ListStylePosition' ':' ListStylePosition /
                  'LineSpacing' ':' DistOrInherit /
                  'Indent' ':' DistOrInherit /
                  'Adjust' ':' AlignOrInherit /
                  'Hyphenate' ':' BoolInherit /
                  'Direction' ':' DirInherit /
                  'UnicodeBidi' ':' BidiInherit /
                  'PageBreak' ':' Boolean /
                  'LineBreak' ':' Boolean /
                  'InLine' ':' Boolean /
                  'NoBreak1' ':' AbsDist /
                  'NoBreak2' ':' AbsDist /
                  'Gather' ':' Boolean /
                  'Visibility' ':' NumberInherit /
                  'Size'  ':' SizeInherit /
                  'Font' ':' NameInherit /
                  'Style' ':' StyleInherit /
                  'Weight' ':' WeightInherit /
                  'Underline' ':' UnderLineInherit /
                  'Thickness' ':' ThicknessInherit /
                  'Depth' ':' NumberInherit /
                  'LineStyle' ':' LineStyleInherit /
                  'LineWeight' ':' DistOrInherit /
                  'FillPattern' ':' NameInherit /
                  'Background' ':' Color /
                  'Foreground' ':' Color /
                  'Opacity' ':' OpacityInherit /
                  'FillOpacity' ':' OpacityInherit /
                  'StrokeOpacity' ':' OpacityInherit /
                  'Content' ':' VarConst .
PresFunc        = Creation '(' BoxID ')' /
                  'Line' /
                  'NoLine' /
                  'Display' ':' DisplayVal /
                  'Page' '(' BoxID ')' /
                  'Copy' '(' BoxTypeToCopy ')' /
                  'ShowBox' /
                  'BackgroundPicture' ':' FileName /
                  'PictureMode' ':' PictMode .

DisplayVal      = 'Inline' / 'Block' / 'ListItem' / 'RunIin' /
                  'InlineBlock' / 'None' / 'Enclosing' '=' .
BoxTypeToCopy   = BoxID [ ExtStruct ] /
                   ElemID [ ExtStruct ] .
ExtStruct       = '(' ElemID ')' .

Distance        = [ Sign ] AbsDist .
Sign            = '+' / '-' .
AbsDist         = IntegerOrAttr [ '.' DecimalPart ]
                  [ Unit ] .
IntegerOrAttr   = IntegerPart / AttrID .
IntegerPart     = NUMBER .
DecimalPart     = NUMBER .
Unit            = 'em' / 'ex' / 'cm' / 'mm' / 'in' / 'pt' /
                  'pc' / 'px' / '%' .

HPos            = 'nil' / VertAxis '=' HorizPosition 
                  [ 'UserSpecified' ] .
VPos            = 'nil' / HorizAxis '=' VertPosition 
                  [ 'UserSpecified' ] .
VertAxis        = 'Left' / 'VMiddle' / 'VRef' / 'Right' .
HorizAxis       = 'Top' / 'HMiddle' / 'HRef' / 'Bottom' .

VertPosition    = Reference '.' HorizAxis [ Distance ] .
HorizPosition   = Reference '.' VertAxis [ Distance ] .
Reference       = 'Enclosing' [ BoxTypeNot ] /
                  'Enclosed' [ BoxTypeNot ] /
                  'Previous' [ BoxTypeNot ] /
                  'Next' [ BoxTypeNot ] /
                  'Referred' [ BoxTypeNot ] /
                  'Creator' /
                  'Root' /
                  '*' /
                  BoxOrType .
BoxOrType       = BoxID /
                  [ '*' ] [ FirstSec ] ElemID /
                  'AnyElem' / 'AnyBox' /
                  'ElemWithAttr' AttrID .
BoxTypeNot      = [ 'NOT' ] BoxOrType .

FloatInherit    = Link '=' / 'Left' / 'Right' / 'None' .
ClearInherit    = Link '=' / 'None' / 'Left' / 'Right' / 'Both' .

Extent          = Reference '.' HeightWidth
                  [ Relation ] [ 'Min' ] /
                  AbsDist [ 'UserSpecified' ] [ 'Min' ] /
                  HPos / VPos .
HeightWidth     = 'Height' / 'Width' .
Relation        = '*' ExtentAttr '%' / Distance .
ExtentAttr      = ExtentVal / AttrID .
ExtentVal       = NUMBER .

MarginWidth     = InheritParent / 'Auto' / Distance .
PaddingWidth    = InheritParent / Distance .
BorderWidth     = InheritParent / 'Thin' / 'Medium' / 'Thick' / Distance .
BorderColor     = InheritParent / 'Transparent' / 'Foreground' /
                  ColorName .
BorderStyle     = InheritParent /
                  'None' / 'Hidden' / 'Dotted' / 'Dashed' / 'Solid' /
                  'Double' / 'Groove' / 'Ridge' / 'Inset' / 'Outset' .

ListStyleType   = 'Disc' / 'Circle' / 'Square' / 'Decimal' /
                  'DecimalLeadingZero' / 'LowerRoman' / 'UpperRoman' / 
                  'LowerGreek' / 'LowerLatin' / 'UpperLatin' / 'None' /
                  'Enclosing' '=' .
ListStyleImage  = 'None' / 'Enclosing' '=' / ListStyleImageURI .
ListStyleImageURI = STRING .
ListStylePosition = 'Inside' / 'Outside' / 'Enclosing' '=' .

InheritParent   = 'Enclosing' '=' / 'Creator' '=' .
ColorName       = NAME .

Inheritance     = Kinship  InheritedValue .
Kinship         = 'Enclosing' / 'GrandFather'/ 'Enclosed' /
                  'Previous' / 'Creator' .
InheritedValue  = '+' PosIntAttr [ 'Max' maximumA ] /
                  '-' NegIntAttr [ 'Min' minimumA ] /
                  '=' .
PosIntAttr      = PosInt / AttrID .
PosInt          = NUMBER .
NegIntAttr      = NegInt / AttrID .
NegInt          = NUMBER .
maximumA        = maximum / AttrID .
maximum         = NUMBER .
minimumA        = minimum / AttrID .
minimum         = NUMBER .

AlignOrInherit  = Kinship '=' / Alignment .
Alignment       = 'Left' / 'Right' / 'VMiddle' /
                  'LeftWithDots' .

DirInherit      = 'ltr' / 'rtl' / Kinship '=' .
BidiInherit     = 'Normal' / 'Embed' / 'Override' / Kinship '=' .

DistOrInherit   = Kinship InheritedDist / Distance .
InheritedDist   = '=' / '+' AbsDist / '-' AbsDist .

BoolInherit     = Boolean / Kinship '=' .
Boolean         = 'Yes' / 'No' .

NumberInherit   = Integer / AttrID / Inheritance .
Integer         = NUMBER .

LineStyleInherit= Kinship '=' / 'Solid' / 'Dashed' /
                  'Dotted' .

SizeInherit     = SizeAttr [ 'pt' ] / Kinship InheritedSize .
InheritedSize   = '+' SizeAttr [ 'pt' ]
                      [ 'Max' MaxSizeAttr ] /
                  '-' SizeAttr [ 'pt' ]
                      [ 'Min' MinSizeAttr ] /
                  '*' PercentSizeAttr '%' /
                  '=' .
SizeAttr        = Size / AttrID .
Size            = NUMBER .
MaxSizeAttr     = MaxSize / AttrID .
MaxSize         = NUMBER .
MinSizeAttr     = MinSize / AttrID .
MinSize         = NUMBER .
PercentSizeAttr = PercentSize / AttrID .
PercentSize     = NUMBER .

NameInherit     = Kinship '=' / FontName .
FontName        = NAME .
Color           = 'Transparent' / Kinship '=' / FontName .
OpacityInherit  = OpPercent '%' / AttrID / Inheritance .
OpPercent       = NUMBER .
StyleInherit    = Kinship '=' /
                  'Roman' / 'Italics' / 'Oblique' .
WeightInherit   = Kinship '=' /
                  'Normal' / 'Bold' .
UnderLineInherit= Kinship '=' /
                  'NoUnderline' / 'Underlined' / 
                  'Overlined' / 'CrossedOut' .
ThicknessInherit= Kinship '=' / 'Thick' / 'Thin' .

FileName =        STRING .
PictMode =        'NormalSize' / 'Scale' /
                  'RepeatXY' / 'RepeatX' / 'RepeatY' .

VarConst        = ConstID / ConstType ConstValue /
                  VarID / '(' FunctionSeq ')' /
                  ElemID .

Creation        = Create [ 'Repeated' ] .
Create          = 'CreateFirst' / 'CreateLast' /
                  'CreateBefore' / 'CreateAfter' /
                  'CreateEnclosing' .

TransmitSeq     = Transmit &lt; Transmit &gt; .
Transmit        = TypeOrCounter 'To' ExternAttr
                  '(' ElemID ')' ';' .
TypeOrCounter   = CounterID / ElemID .
ExternAttr      = NAME .

END</pre>
</div>

<div class="section">
<h2><a name="sectb64" id="sectb64">The T language</a></h2>
<pre>TransSchema   = 'TRANSLATION' ElemID ';'
              [ 'LINELENGTH' LineLength ';' ]
              [ 'LINEEND' CHARACTER ';' ]
              [ 'LINEENDINSERT' STRING ';' ]
              [ 'BUFFERS' BufferSeq ]
              [ 'COUNTERS' CounterSeq ]
              [ 'CONST' ConstSeq ]
              [ 'VAR' VariableSeq ]
                'RULES' ElemSeq
              [ 'ATTRIBUTES' AttrSeq ]
              [ 'PRESENTATION' PresSeq ]
              &lt; 'TEXTTRANSLATE' TextTransSeq &gt;
              [ 'SYMBTRANSLATE' TransSeq ]
              [ 'GRAPHTRANSLATE' TransSeq ]
                'END' .

LineLength    = NUMBER .

BufferSeq     = Buffer &lt; Buffer &gt; .
Buffer        = BufferID [ '(' BufferType ')' ] ';' .
BufferID      = NAME .
BufferType    = 'Picture' / 'Variable' .

CounterSeq    = Counter &lt; Counter &gt; .
Counter       = CounterID [ ':' CounterFunc ] ';' .
CounterID     = NAME .
CounterFunc   = 'Rank' 'of' ElemID [ SLevelAsc ]
                [ 'Init' AttrID ] /
                'Rlevel' 'of' ElemID /
                'Set' InitValue 'On' ElemID
                      'Add' Increment 'On' ElemID
                      [ 'Init' AttrID ] .
SLevelAsc     = [ '-' ] LevelAsc .
LevelAsc      =  NUMBER .
InitValue     = NUMBER .
Increment     = NUMBER .
ElemID        = NAME .
AttrID        = NAME .

ConstSeq      = Const &lt; Const &gt; .
Const         = ConstID '=' ConstValue ';' .
ConstID       = NAME .
ConstValue    = STRING .

VariableSeq   = Variable &lt; Variable &gt; .
Variable      = VarID ':' Function &lt; Function &gt; ';' .
VarID         = NAME .
Function      = 'Value' '(' CounterID [ ':' Length ]
                          [ ',' CounterStyle ]  ')' /
                'FileDir' / 'FileName' / 'Extension' /
                'DocumentName' / 'DocumentDir' /
                ConstID / CharString / 
                BufferID / AttrID .
Length        = NUMBER .
CounterStyle=   'Arabic' / 'LRoman' / 'URoman' /
                'Uppercase' / 'Lowercase' .
CharString    = STRING .

ElemSeq       = TransType &lt; TransType &gt; .
TransType     = [ FirstSec ] ElemID ':' RuleSeq .
FirstSec      = 'First' / 'Second' .
RuleSeq       = Rule / 'BEGIN' &lt; Rule &gt; 'END' ';' .
Rule          = SimpleRule / ConditionBlock .
ConditionBlock= 'IF' ConditionSeq SimpleRuleSeq .
SimpleRuleSeq = 'BEGIN' &lt; SimpleRule &gt; 'END' ';' / 
                SimpleRule .

ConditionSeq  = Condition [ 'AND' Condition ] .
Condition     = [ 'NOT' ] [ 'Target' ] Cond .
Cond          = CondElem / CondAscend .
CondElem      = 'FirstRef' / 'LastRef' /
                'ExternalRef' /
                'Script' '=' Script /
                'ComputedPage' / 'StartPage' / 
                'UserPage' / 'ReminderPage' /
                'Empty' / 'Root' /
                ElemID /
                'FirstAttr' / 'LastAttr' .
CondAscend    = [ Ascend ] CondOnAscend .
Ascend        = '*' / 'Parent' / 'Ancestor' LevelOrType .
LevelOrType   = CondRelLevel / ElemID [ ExtStruct ] .
CondRelLevel  = NUMBER .
CondOnAscend  = 'First' / 'Last' /
                'Referred' / 
                [ 'Immediately' ] 'Within' [ NumParent ]
                                  ElemID [ ExtStruct ] /
                'Attributes' /
                AttrID [ RelatAttr ] /
                'Presentation' /
                PresRule .
NumParent     = [ GreaterLess ] NParent .
GreaterLess   = '&gt;' / '&lt;' .
NParent       = NUMBER.
Script      = NAME .
RelatAttr     = '=' Value /
                 '&gt;' [ '-' ] Minimum /
                 '&lt;' [ '-' ] Maximum /
                 'IN' '[' [ '-' ] MinInterval '..'
                          [ '-' ] MaxInterval ']' .
Value         = [ '-' ] IntegerVal / TextVal / AttrValue .
Minimum       = NUMBER .
Maximum       = NUMBER .
MinInterval   = NUMBER .
MaxInterval   = NUMBER .
IntegerVal    = NUMBER .
TextVal       = STRING .
AttrValue     = NAME .

SimpleRule    = 'Create' [ 'IN' VarID ] Object
                       [ Position ] ';' /
                'Write' Object [ Position ] ';' /
                'Read' BufferID [ Position ] ';' /
                'Include' File [ Position ] ';' /
                'Get'  [ RelPosition ] ElemID 
                       [ ExtStruct ] 
                       [ Position ] ';' /
                'Copy' [ RelPosition ] ElemID 
                       [ ExtStruct ] 
                       [ Position ] ';' /
                'Use' TrSchema [ 'For' ElemID ] ';' /
                'Remove' ';' /
                'Ignore' ';' /
                'NoTranslation' ';' /
                'NoLineBreak' ';' /
                'ChangeMainFile' VarID [ Position ] ';' /
                'RemoveFile' VarID [ Position ] ';' /
                'Set' CounterID InitValue [ Position ] ';' /
                'Add' CounterID Increment [ Position ] ';' /
                'Indent' [ 'IN' VarID ] Indent [ Position ] ';' .

Indent        = 'Suspend' / 'Resume' / [ IndentSign ] IndentValue .
IndentSign    = '+' / '-' .
IndentValue   = NUMBER .

Object        = ConstID / CharString /
                BufferID /
                VarID /
                '(' Function &lt; Function &gt; ')' /
                 [ 'Translated' ] AttrID /
                'Value' /
                'Content' /
                'Attributes' /
                'Presentation' /
                'RefId' /
                'PairId' /
                'FileDir' / 'FileName' / 'Extension' /
                'DocumentName' / 'DocumentDir' /
                [ 'Referred' ] ReferredObject .
Position      = 'After' / 'Before' .

ReferredObject= VarID /
                ElemID [ ExtStruct ] /
                'RefId' /
                'DocumentName' / 'DocumentDir' .                

File          = FileName / BufferID .
FileName      = STRING .

RelPosition   = 'Included' / 'Referred' .
ExtStruct     = '(' ElemID ')' .

TrSchema      = NAME .

AttrSeq       = TransAttr &lt; TransAttr &gt; .
TransAttr     = AttrID [ '(' ElemID ')' ] 
                [ RelatAttr ] ':' RuleSeq .

PresSeq       = PresTrans &lt; PresTrans &gt; .
PresTrans     = PresRule ':' RuleSeq .
PresRule      = 'Size' [ PresRelation ] /
                'Indent' [ PresRelation ] /
                'LineSpacing' [ PresRelation ] /
                'Adjust' [ '=' AdjustVal ] /
                'Hyphenate' [ '=' BoolVal ] /
                'Style' [ '=' StyleVal ] /
                'Weight' [ '=' WeightVal ] /
                'Font' [ '=' FontVal ] /
                'UnderLine' [ '=' UnderLineVal ] /
                'Thickness' [ '=' ThicknessVal ] /
                'LineStyle' [ '=' LineStyleVal ] /
                'LineWeight' [ PresRelation ] /
                'FillPattern' [ '=' Pattern ] /
                'Background' [ '=' Color ] /
                'Foreground' [ '=' Color ] .

PresRelation  = '=' PresValue /
                '&gt;' [ '-' ] PresMinimum /
                '&lt;' [ '-' ] PresMaximum /
                'IN' '[' [ '-' ] PresIntervalMin '..'
                         [ '-' ] PresIntervalMax ']' .
AdjustVal     = 'Left' / 'Right' / 'VMiddle' / 'Justify' /
                'LeftWithDots' .
BoolVal       = 'Yes' / 'No' .
StyleVal      = 'Roman' / 'Italics' / 'Oblique' .
WeightVal     = 'Normal' / 'Bold' .
FontVal       = 'Times' / 'Helvetica' / 'Courier' .
UnderLineVal  = 'NoUnderline' / 'UnderLined' /
                'OverLined' / 'CrossedOut' .
ThicknessVal  = 'Thick' / 'Thin' .
LineStyleVal  = 'Solid' / 'Dashed' / 'Dotted' .
Pattern       = NAME .
Color         = NAME .
PresMinimum   = NUMBER .
PresMaximum   = NUMBER .
PresIntervalMin= NUMBER .
PresIntervalMax= NUMBER .
PresValue     = [ '-' ] PresVal .
PresVal       = NUMBER .

TextTransSeq  = [ Script ] TransSeq .
Script        = NAME .
TransSeq      = 'BEGIN' &lt; Translation &gt; 'END' ';' /
                Translation .
Translation   = Source [ '-&gt;' Target ] ';' .
Source        = STRING .
Target        = STRING .</pre>
</div>
<hr />
</div>

<div class="chapter">
<h1><a name="sect7" id="sect7">Character coding</a></h1>

<div class="section">
<h2><a name="sectb71" id="sectb71">Characters</a></h2>

<p>The characters of the Latin script follow the encoding defined in the ISO
8859-1 (ISO Latin-1) standard. The characters of the Greek script follow the
encoding defined by Adobe for its Symbol font (Adobe FontSpecific).</p>

<p>Characters whose octal code is greater than 0200 are written in the form
of their octal code preceded by a backslash character (``\''). For example,
the French word 'Résumé' is written <tt>R\351sum\351</tt>.</p>

<p>To the ISO 8859-1 encoding four characters with the following codes have
been added:<br />
<tt>212</tt>: line break<br />
<tt>240</tt>: sticky space<br />
<tt>201</tt>: thin space<br />
<tt>202</tt>: en space</p>

<p>The <tt>212</tt> character is a ``line break'' character which forces a
line break. The <tt>240</tt> character is a ``sticky space'', which cannot be
replaced by a line break.</p>
</div>

<div class="section">
<h2><a name="sectb72" id="sectb72">Symbols</a></h2>

<p>The table below gives the codes for the symbols of Thot. Symbols can be
used in presentation schemas constants and in transcoding rules of
translation schemas. Each symbol is represented by a single character.</p>
<ul>
  <li><tt>r</tt> : a radical</li>
  <li><tt>i</tt> : a simple integral</li>
  <li><tt>c</tt> : a curvilinear integral</li>
  <li><tt>d</tt> : a double integral</li>
  <li><tt>t</tt> : a triple integral</li>
  <li><code>o</code>: an over brace</li>
  <li><code>u</code>: an under brace</li>
  <li><tt>S</tt> : the summation symbol</li>
  <li><tt>P</tt> : the product symbol</li>
  <li><tt>U</tt> : the union symbol</li>
  <li><tt>I</tt> : the intersection symbol</li>
  <li><tt>R</tt> : a right arrow</li>
  <li><tt>L</tt> : a left arrow</li>
  <li><tt>&lt;</tt> : an opening pointy bracket</li>
  <li><tt>&gt;</tt> : a closing pointy bracket</li>
  <li><tt>^</tt> : an up arrow</li>
  <li><tt>V</tt> : a down arrow</li>
  <li><tt>(</tt> : an opening parenthesis</li>
  <li><tt>)</tt> : a closing parenthesis</li>
  <li><tt>{</tt> : an opening brace</li>
  <li><tt>}</tt> : a closing brace</li>
  <li><tt>[</tt> : an opening square bracket</li>
  <li><tt>]</tt> : a closing square bracket</li>
</ul>
</div>

<div class="section">
<h2><a name="sectb73" id="sectb73">Graphical elements</a></h2>

<p>The table below gives the codes for the graphical elements of Thot. These
elements can be used in presentation schemas constants and in transcoding
rules of translation schemas. Each graphical element is represented by a
single character.</p>
<ul>
  <li>a: a circle</li>
  <li><p><tt>A</tt>: an open curve with an arrow head at the end</p>
  </li>
  <li><tt>b</tt> : a horizontal line along the lower side of the box</li>
  <li><tt>B</tt> : an open curve</li>
  <li><tt>c</tt> : an ellipse inscribed in the box</li>
  <li><tt>C</tt> : a rectangle with rounded corners</li>
  <li><tt>D</tt> : an open curve with two arrow heads</li>
  <li><tt>e</tt> : The northwest/southeast diagonal of the box with an
    arrowhead at the bottom</li>
  <li><tt>E</tt> : The southwest/northeast diagonal of the box with an
    arrowhead at the top</li>
  <li><tt>F</tt> : an open curve with an arrow head at start</li>
  <li><tt>g</tt> : a line from the origin of the box to its opposite
  corner</li>
  <li><tt>h</tt> : a horizontal line as wide as the box and placed in its
    middle</li>
  <li><tt>l</tt> : a vertical line on the left side of the box</li>
  <li><tt>L</tt> : a lozenge</li>
  <li><tt>M</tt> : an open broken line with two arrow heads</li>
  <li><tt>N</tt> : an open broken line with an arrow head at start</li>
  <li><tt>o</tt> : The southwest/northeast diagonal of the box with an
    arrowhead at the bottom</li>
  <li><tt>O</tt> : The northwest/southeast diagonal of the box with an
    arrowhead at the top</li>
  <li><tt>p</tt> : a polygon</li>
  <li><tt>P</tt> : a rectangle with round corners and a horizontal bar at the
    top</li>
  <li><tt>Q</tt> : an ellipse with a horizontal bar at the top</li>
  <li><tt>r</tt> : a vertical line on the right side of the box</li>
  <li><tt>R</tt> : a rectangle which is the shape of the box</li>
  <li><tt>s</tt> : a closed curve</li>
  <li><tt>S</tt> : an open broken line</li>
  <li><tt>t</tt> : a horizontal line along the upper side of the box</li>
  <li><tt>U</tt> : an open broken line with an arrow head at the end</li>
  <li><tt>v</tt> : a vertical line as tall as the box and placed in its
  middle</li>
  <li><tt>V</tt> : a down arrow as tall as the box and in its middle</li>
  <li>w: a segment (2 points)</li>
  <li><tt>W</tt> : the upper right corner</li>
  <li>x: a segment (2 points) with an arrow head at the end</li>
  <li><tt>X</tt> : the lower right corner</li>
  <li>y: a segment (2 points) with an arrow head at the end</li>
  <li><tt>Y</tt> : the lower left corner</li>
  <li>z: a segment (2 points) with an arrow head at the end</li>
  <li><tt>Z</tt> : the upper left corner</li>
  <li><tt>space</tt> : a transparent element</li>
  <li><tt>^</tt> : an up arrow as tall as the box and in its middle</li>
  <li><tt>&gt;</tt> : a right arrow as long as the box's width and in its
    middle</li>
  <li><tt>&gt;</tt> : a left arrow as long as the box's width and in its
    middle</li>
  <li><tt>/</tt> : The southwest/northeast diagonal of the box</li>
  <li><tt>\</tt> : the northwest/southeast diagonal of the box</li>
</ul>
<hr />
</div>
</div>
</body>
</html>
