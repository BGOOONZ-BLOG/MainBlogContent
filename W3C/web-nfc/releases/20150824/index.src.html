<!DOCTYPE html>
<html>
<head>
  <title>Web NFC API</title>
  <meta charset="UTF-8">
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
          class='remove'>
  </script>
  <script class="remove">
    var respecConfig = {
          specStatus:           "CG-DRAFT",
          shortName:            "web-nfc",
          noLegacyStyle:        true,
          publishDate:          "",
          previousPublishDate:  "",
          previousMaturity:     "",
          edDraftURI:           "http://w3c.github.io/web-nfc/",
          crEnd:                "",
          editors: [
            { name: "Kenneth Rohde Christiansen", company: "Intel",
                    companyURL: "http://www.intel.com/" },
            { name: "Zoltan Kis", company: "Intel",
                    companyURL: "http://www.intel.com/" },
          ],
          inlineCSS:    true,
          noIDLIn:      true,
          // extraCSS:     ["../ReSpec.js/css/respec.css"],
          wg:           "Web NFC Community Group",
          wgURI:        "https://www.w3.org/community/web-nfc/",
          wgPublicList: "public-web-nfc",
          otherLinks: [
            {
              key: "Repository",
              data: [{
                    value: "We are on Github.",
                    href: "https://github.com/w3c/web-nfc"
                }, {
                    value: "File a bug.",
                    href: "https://github.com/w3c/web-nfc/issues"
                }, {
                    value: "Commit history.",
                    href: "https://github.com/w3c/web-nfc/commits/gh-pages"
                }, {
                    value: "Usage scenarios",
                    href: "http://w3c.github.io/web-nfc/use-cases.html"
                }
              ]
            },
          ],
          localBiblio: {
            "NFC_SECURITY": {
              href: "https://github.com/w3c/web-nfc/security-privacy.html",
              title: "Web NFC Security and Privacy",
              publisher: "W3C",
              date: "25 April 2015",
            },
            "NFC_USECASES": {
              href: "https://github.com/w3c/web-nfc/use-cases.html",
              title: "Web NFC Use Cases",
              publisher: "W3C",
              date: "25 April 2015",
            },
          },

    };
  </script>
  <style>
    table.simple {
        border: 1px solid #000;
    } 
    table.simple td {
        border-right: 1px solid #000;
    }
  </style>
</head>

<body>

<!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
<section id="abstract">
  <p>
    Near Field Communication (NFC) enables wireless communication between two
    devices at close proximity, usually less than a few centimeters.
    NFC is an international standard (ISO/IEC 18092) defining an interface and
    protocol for simple wireless interconnection of closely coupled devices
    operating at 13.56 MHz
    (see <a href="http://www.nfc-forum.org/specs/spec_list/">
    http://www.nfc-forum.org/specs/spec_list/</a>).
  </p>
  <p>
    This specification defines an API to manage selected NFC use-cases from web
    pages, and to enable new use-cases based on NFC technology.
  </p>
</section>

<!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
<section id="sotd">
  <p>
    Implementors need to be aware that this specification is considered unstable.
    Implementors who are not taking part in the discussions will find the
    specification changing out from under them in incompatible ways. Vendors
    interested in implementing this specification before it eventually reaches
    the Candidate Recommendation phase should subscribe to the repository on
    GitHub and take part in the discussions.
  </p>
  <p>
    Significant changes to this document since last publication are
    documented in the <a href="#Changes">Changes section</a>.
  </p>
</section>

<!-- - - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
<section id="conformance">
  <p>
    This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces
    it contains.
  </p>
  <p>
    Implementations that use ECMAScript to implement the APIs defined in
    this specification MUST implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
    this specification uses that specification and terminology.
  </p>
</section>

<!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
<section> <h2>Terminology</h2>
  <p>
    The
    <a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">
    <code><dfn>EventHandler</dfn></code></a> interface represents a callback
    used for event handlers as defined in [[!HTML5]].
  </p>
  <p>
    The concepts
    <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">
      <dfn>queue a task</dfn></a> and
    <a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">
    <dfn>fire a simple event</dfn></a> are defined in [[!HTML5]].
  </p>
  <p>
    The terms
    <a href="http://dev.w3.org/html5/spec/webappapis.html#event-handlers">
      <dfn>event handler</dfn></a> and
    <a href="http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">
    <dfn>event handler event types</dfn></a> are defined in [[!HTML5]].
  </p>
  <p>
    <a href='http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'>
      <code><dfn>Promise</dfn></code></a>, and
    <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-json.parse">
      <code><dfn>JSON.parse</dfn></code></a> are defined in [[!ECMASCRIPT]].
  </p>
  <p>
    The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode">
    <dfn>utf-8 encode</dfn></a>, and
    <a href="http://www.w3.org/TR/encoding/#utf-8-decode">
    <dfn>utf-8 decode</dfn></a> are defined in [[!ENCODING]].
  </p>
  <p>
    <a href="http://www.w3.org/TR/dom/#eventinit">
      <dfn>EventInit</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#domexception">
      <dfn>DOMException</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#aborterror">
      <dfn>AbortError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#syntaxerror">
      <dfn>SyntaxError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#notsupportederror">
      <dfn>NotSupportedError</dfn></a>,
    <a href="http://www.w3.org/TR/dom/#notfounderror">
      <dfn>NotFoundError</dfn></a>, and
    <a href="http://www.w3.org/TR/dom/#securityerror">
      <dfn>SecurityError</dfn></a>
    are defined in [[!DOM4]].
  </p>
  <p>
    The term <dfn>web app</dfn> refers to a Web application, i.e. an application
    implemented using Web technologies, and executing within the context of a
    Web <a>user agent</a>, e.g. a Web browser or other Web-based runtime
    environments.
  </p>
  <p>
    The term <dfn>expressed permission</dfn> refers to an act by the user, e.g.
    via user interface or host device platform features, via which the user
    approves the permission of a <a>web app</a> to access the Web NFC API.
  </p>
  <p>
    The term <dfn>obtain permission</dfn> for a certain operation refers to
    obtain <a>expressed permission</a> or to ensure the existence of a
    prearranged trust relationship.
  </p>
  <p>
    <code><a href="http://www.w3.org/TR/url-1/"><dfn>URL</dfn></a>
    </code> is defined in [[!URL]].
  </p>
  <p>
    <code><a href="http://www.w3.org/TR/FileAPI/#blob"><dfn>Blob</dfn></a>
    </code> is defined in [[!FILEAPI]].
  </p>
  <p>
    <a href="http://heycam.github.io/webidl/#idl-DOMString">
      <code><dfn>DOMString</dfn></code></a>,
    <a href="http://heycam.github.io/webidl/#idl-ArrayBuffer">
      <code><dfn>ArrayBuffer</dfn></code></a>,
    <a href="http://heycam.github.io/webidl/#common-BufferSource">
      <code><dfn>BufferSource</dfn></code></a> and
    <a href="http://www.w3.org/TR/WebIDL/#idl-any">
      <code><dfn>any</dfn></code></a>
    are defined in [[!WEBIDL]].
  </p>
  <p>
    <b>NFC</b> stands for Near Field Communications, short-range wireless
    technology operating at 13.56 MHz which enables communication between
    devices at a distance less than 10 cm. The NFC communications protocols and
    data exchange formats, and are based on existing radio-frequency
    identification (RFID) standards, including ISO/IEC 14443 and FeliCa.
    The NFC standards include ISO/IEC 18092[5] and those defined by the NFC
    Forum. See http://www.nfc-forum.org/specs/spec_list/ for a complete listing.
  </p>
  <p>
    An <dfn>NFC adapter</dfn> is the software entity in the underlying
    platform which provides access to NFC functionality implemented in a
    given hardware element (NFC chip). A device may have multiple NFC
    adapters, for instance a built-in one, and one attached via USB.
  </p>
  <p>
    An <dfn>NFC tag</dfn> is a passive, unpowered NFC device.
    The <a>NFC tag</a> is powered by magnetic induction when an active NFC
    device is in proximity range. An <a>NFC tag</a> contains a single
    <a>NDEF message</a>.
    <p class="note">
      The way of reading the message may happen through proprietary
      technologies, which require the reader and the tag to be of the same
      manufacturer. Implementations are expected to encapsulate this.
    </p>
  </p>
  <p>
    An <dfn>NFC peer</dfn> is another device, which can interact with other
    devices in order to exchange data using NFC.
  </p>
  <p>
    An <dfn>NDEF message</dfn> encapsulates one or more application-defined
    <a>NDEF record</a>s. <dfn>NDEF</dfn> stands for NFC Forum Data Exchange
    Format, a lightweight binary message format. NDEF messages can be stored on
    a <a>NFC tag</a> or exchanged between NFC-enabled devices.
  </p>
  <p>
    An <dfn>NDEF record</dfn> has a maximum payload of 2^32-1 bytes. The record
    also contains information about the payload size, type, and an optional
    identifier. NFC Forum standardized a small set of useful data types to be
    used in <a>NDEF record</a>s, for instance text, URL, media. In addition,
    there are record types designed for more complex interactions, such as
    Smart Poster, and handover records.
  </p>
  <p>
    Part of the <a>NDEF record</a> is the <dfn>TNF</dfn> field, standing for
    Type Name Format. It can take binary values representing the following
    types:
    <table class="simple">
      <tr>
        <th><strong>TNF value</strong></th>
        <th><strong>NDEF record type</strong></th>
      </tr>
      <tr>
        <td>0</td>
        <td><dfn>Empty</dfn></td>
      </tr>
      <tr>
        <td>1</td>
        <td>NFC Forum <dfn>Well-Known Type</dfn>
        </td>
      </tr>
      <tr>
        <td>2</td>
        <td><dfn>Media Type</dfn></td>
      </tr>
      <tr>
        <td>3</td>
        <td><dfn>Absolute URI</dfn></td>
      </tr>
      <tr>
        <td>4</td>
        <td>NFC Forum <dfn>External Type</dfn></td>
      </tr>
      <tr>
        <td>5</td>
        <td><dfn>Unknown</dfn></td>
      </tr>
      <tr>
        <td>6</td>
        <td><dfn>Unchanged</dfn></td>
      </tr>
      <tr>
        <td>7</td>
        <td><dfn>Reserved</dfn></td>
      </tr>
    </table>
    <br>
    NFC Forum <a>Well-Known Type</a> includes record types <i>text</i>,
    <i>URI</i>, <i>Smart Poster</i> (containing a URI or other
    data and possible actions).
  </p>
  <p>
    A <dfn>Web NFC message</dfn> is an <a>NDEF message</a> which contains at
    least one <a>Web NFC record</a>.
  </p>
  <p>
    A <dfn>Web NFC record</dfn> is an <a>NDEF record</a> with <a>TNF</a>=4
    (External Type Record), and  the <var>type</var> field set to
    <code>"urn:nfc:ext:w3.org:webnfc"</code>. Further formatting details are
    described <a href="#web-nfc-payload">Data Types</a>.
  </p>
  <p>An <dfn>NFC handover</dfn> defines NFC Forum Well Known Types and the
    corresponding message structure that allows negotiation and activation of
    an alternative communication carrier, such as Bluetooth or WiFi.
    The negotiated communication carrier would then be used (separately) to
    perform certain activities between the two devices, such as sending photos
    to the other device, printing to a Bluetooth printer or streaming video to
    a television set.
  </p>
  <p>
    The term <dfn>sufficient permission</dfn> in this document means that a
    <a>web app</a> which is invoking the methods of this API has been checked to
    comply with the security policies set by the underlying platform and API
    implementation in the moment and context of invoking the API method.
    Further details are described in <a href="#security">
    Security and Privacy</a>.
  </p>
  <p>
    The term
    <a href="http://www.w3.org/TR/2011/WD-html5-20110113/urls.html#document-base-url">
    <dfn>document base URL</dfn></a> is defined in [[!HTML5]].
  </p>
  <p>
    The term <dfn>URL scope</dfn> is introduced in this document for NFC
    operations as a sub-domain match to the <a>web app</a>'s
    document URL, which includes the domain of the calling <a>web app</a>.
  </p>
</section> <!-- Terminology -->

<!-- - - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Introduction</h2>
  <p>
    There are three groups of user scenarios for NFC:
    <ul>
      <li>
        Hold a device close to a passive wireless tag (which could be in the
        form of a plastic card) to read and write or overwrite data (in the
        case the tag is not read-only, and it is empty or contains a
        <a>Web NFC message</a>.
      </li>
      <li>
        Hold two powered devices, e.g. phones or tablets, close to each other
        in order to push a <a>Web NFC message</a> from one to the other, or to
        initiate a connection using another wireless carrier such as Bluetooth
        or WiFi.
      </li>
      <li>Card emulation
       <ol>
        <li>
          With a secure element: for payments by holding your phone close to a
          point-of-sales terminal, instead of swiping a payment card.
        </li>
        <li>With host card emulation: for allowing use-cases like using a phone
          as a hotel room key card.
        </li>
       </ol>
      </li>
    </ul>
  </p>
  <p>
    NFC works using magnetic induction, meaning that the reader will emit a
    small electric charge which then creates a magnetic field. This field powers
    the passive device which turns it into electrical impulses to communicate
    data. Thus, when the devices are within range, a read is always performed
    (see NFC Analog Specification and NFC Digital Protocol, NFC Forum, 2006).
    The peer-to-peer connection works in a similar way, as the device
    periodically switches into a so-called initiator mode in order to scan for
    targets, then later to fall back into target mode. If a target is found, the
    data is read the same way as for tags.
  </p>
  <p>
    As NFC is based on existing RFID standards, many NFC chipsets support
    reading RFIDs tags, but many of these are only supported by single
    vendors and not part of the NFC standards. Though certain devices support
    reading and writing to these, it is not a goal of this specification to
    support proprietary tags or support interoperability with legacy systems.
  </p>
  <p>
    The NFC Forum has mandated the support of four different tag types to be
    operable with NFC devices. The same is required on operating systems such as
    Android.
    <ol>
      <li>
        <b>NFC Forum Type 1</b>: This tag is based on the ISO/IEC 14443-3A
        (also known as NFC-A,  as defined in ISO/IEC 14443-3:2011, Part 3:
        Initialization and anticollision). The tags are rewritable and can be
        configured to become read-only. Memory size can be between 96 bytes and
        2 Kbytes. Communication speed is 106 kbit/sec.
      </li>
      <li><b>NFC Forum Type 2</b>: This tag is also based on the
        ISO/IEC 14443-3A (NFC-A). The tags are rewritable and can be configured
        to become read-only. Memory size can be between 48 bytes and 2 Kbytes.
        Communication speed is 106 kbit/sec. In contrast to Type 1, Type 2 has
        anti-collision protection for dealing with multiple tags within the NFC
        field.
      </li>
      <li><b>NFC Forum Type 3</b>: This tag is based on the Japanese Industrial
        Standard (JIS) X 6319-4, commonly known as FeliCa. The tags are
        preconfigured to be either rewritable or read-only. Memory availability
        is variable, theoretical memory limit is 1MByte per service.
        Communication speed is 106 kbit/sec.  Like Type 2, it supports
        anti-collision protection.
      </li>
      <li><b>NFC Forum Type 4</b> (November 2010): This tag is based on the
        ISO/IEC 14443 like Type 1 and 2, but it support either NFC-A or NFC-B
        for communication. On top of that the tag may support the Data Exchange
        Protocol (aka ISO-DEP) defined in ISO/IEC 14443 (ISO/IEC 14443-4:2008
        Part 4: Transmission protocol). Like Type 3, the tags are preconfigured
        to be either rewritable or read-only. Variable memory, up to 32 KB per
        service. Supports three different communication speeds 106 or 212 or
        424 Kbits/s.
      </li>
    </ol>
  </p>
  <p>
    In addition to data types standardized for <a>NDEF record</a>s by the NFC
    Forum, many commercial products, e.g. bus cards, door openers etc, use
    different card specific data and protocol extensions which require specific
    NFC chips (same vendor of card and reader) in order to work.
  </p>
  <p>
    Card emulation mode capabilities also depend on the NFC chip in the device.
    For payments, a Secure Element is often needed.
  </p>
  <section class="informative"> <h3>Use Cases</h3>
    <p>
      A few Web NFC user scenarios are described in
      <a href="http://w3c.github.io/web-nfc/use-cases.html">this</a> document.
      These user scenarios can be grouped along
      criteria based on security, privacy and feature categories, resulting in
      generic flows as follows.
    </p>
    <section> <h3>Reading <a>NFC tag</a>s</h3>
      <ol>
        <li>
          Reading arbitrary tags when no web site is open:
          when the user touches a device to an <a>NFC tag</a> when no web site
          is currently open, the <a>user agent</a> can open a website to handle
          that tag. If multiple websites can handle the tag, a choice is
          presented to the user to pick the preferred web site for handling the
          tag.
          Optionally, web sites have a programmatic means to tell the
          <a>user agent</a> they are able and interested to handle
          <a>NFC tag</a>s of certain type.
        </li>
        <li>
          Reading arbitrary tags when a website is currently open:
          if the user has a website open and that website has indicated that
          it's able to read a set of tags, it might be fine to allow that
          website to read a read-only tag that the user taps without presenting
          any permission or security dialog to the user.
        </li>
      </ol>
    </section>
    <section> <h3>Writing <a>NFC tag</a>s</h3>
      <ol>
        <li>
          Writing to arbitrary writable tags: the user opens a web page which
          can write an <a>NFC tag</a>. This use case SHOULD be restricted or
          bound to user permissions for security and privacy reasons.
        </li>
        <li>
          Writing to <a>NFC tag</a>s already containing a
          <a>Web NFC message</a>: the <a>user agent</a>s MAY allow web sites
          to write to the tag with using appropriate security dialogs.
        </li>
      </ol>
    </section>
    <section> <h3>Sending data to <a>NFC peer</a>s</h3>
      <p>
        In general, sending data to another Web NFC capable device requires that
        on the initiating device the user would first have to navigate to a web
        site. The user would then touch the device against another Web NFC
        equipped device, and data transfer would occur. On the receiving device
        the <a>user agent</a> will dispatch the content to a web site registered
        to handle the content and in case of multiple such web sites, the one
        chosen by the second user.
      </p>
    </section>
    <section> <h3>Handover to another wireless connection type</h3>
      <p>
        NFC supports handover protocols to Bluetooth or WiFi connectivity for
        the purpose of larger volume data transfer. The user touches another
        NFC capable device, and as a result configuration data is sent for a
        new Bluetooth or WiFi connection, which is then established between the
        devices.
      </p>
    </section>
    <!--section> <h3>Payment scenarios</h3>
      <p>
        The user buys goods in a store, and payments options include NFC.
        In general, touching the device to the point of sales terminal receiver
        area will result in a transaction between the secure element from the
        device and the point of sales terminal. With the Web NFC API, if the
        user navigates to a web site before paying, there may be interaction
        with that site regarding the payment, e.g. the user could get points and
        discounts, or get delivered application or service specific data (e.g.
        tickets, keys, etc) to the device.
      </p>
    </section-->
  </section> <!-- Use Cases -->

  <section> <h3>Features</h3>
    <p>High level features for the Web NFC specification include the following:
      <ol>
        <li>Support devices with single or multiple NFC adapters.</li>
        <li>Support communication with active (powered devices such as readers,
          phones) and passive (smart cards, tags, etc) devices.</li>
        <li>Allow users to act on (e.g. read, write or transceive) discovered
          NFC devices (passive and active) as well as access the NDEF records
          which were read in the process.</li>
        <li>Allow the user to write a payload via NDEF records to compatible
          devices, such as writeable tags, when they come in range.</li>
        <li>[future] Allow manual connection for various technologies such as
          NFC-A and NFC-F depending on secondary device.</li>
        <li>[future] Allow <a>NFC handover</a> to Bluetooth or WiFi.</li>
        <li>[future] Allow card emulation with secure element or host card
          emulation.
        </li>
      </ol>
    </p>
    <p>
      NFC is usually deeply integrated into device platforms (e.g. Android,
      Windows, etc), because end-to-end user experience implications (e.g.
      users need to be presented platform specific dialogs for selecting
      applications and actions). Also, privacy and security related issues
      require platform specific solutions.
    </p>
    <p>
      The various integrated technologies, wide variety of use cases, and
      platform integration issues make standardization of NFC for the web a
      challenge.
      Therefore this specification makes a few simplifications in what use cases
      and data types are possible to handle by users of this API:
      <ul>
        <li>Expose data types already known to web browsers as MIME types.</li>
        <li>Use the web security model.</li>
        <li>Implementations encapsulate <a>NDEF record</a> handling and the API
          exposes only data and control events.
        </li>
      </ul>
    </p>
  </section> <!-- Features-->

  <section> <h3>Technical requirements</h3>
    <p>The following high level technical requirements result from the
      enumerated use cases and high level features. With this version of the
      API, web pages should be able to:
      <ol>
        <li>
          Request an NFC adapter. If there are multiple adapters present, then
          the <a>user agent</a> MAY display a dialog for selecting one of them.
        </li>
        <li>
          Get notified about NDEF message available from tag or peer
          device.
        </li>
        <li>
          Set a data payload that the user can push or write to another
          device when within range.
        </li>
      </ol>
    </p>
  </section> <!-- Technical requirements -->
</section> <!-- Introduction -->

<!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
<section> <h2 id="security">Security and Privacy</h2>
  <p>
    The <a href="http://www.w3.org/TR/permissions/">Permissions API</a> SHOULD
    be supported by <a>user agent</a>s for implementing NFC related
    [[permissions]]. The required
    <a href="https://w3c.github.io/permissions/#idl-def-PermissionName">
    permission name</a> is <code>"nfc"</code>.
  </p>
  <p>
    <a title="user agent">User agents</a> MUST NOT provide Web NFC API access
    to <a>web app</a>s without the <a>expressed permission</a> of the user.
    User agents must acquire consent for [[permissions]] for each call to the
    methods of this API, unless a prearranged trust relationship applies.
  </p>
  <p class="note">
    Considering adding the following:
    User agents MUST implement the WebNFC API to be HTTPS-only. SSL-only support
    provides better protection for the user against man-in-the-middle attacks
    intended to obtain push registration data. Browsers may ignore this rule
    for development purposes only.
  </p>
  <p>
    Permissions that are preserved beyond the current browsing session MUST be
    revocable.
  </p>
  <p class="note">
    The <a href="http://www.w3.org/TR/permissions/">Permissions API</a> does
    not yet address the issue of revoking permissions. When it will be
    addressed, this section will be updated.
  </p>
  <p>
    <a title="user agent">User agents</a> MUST implement the following policies:
    <ol>
      <li>
        In order to use NFC, a website MUST be visible and in focus. For
        web pages in background, receiving and sending NFC data MUST be
        suspended.
      </li>
      <li>
        Writing to an <a>NFC tag</a>, including locking the tag to read-only
        MUST always <a>obtain permission</a>.
      </li>
      <li>
        Sending data to an <a>NFC peer</a> MUST always <a>obtain permission</a>.
      </li>
      <li>
        Listening to <a>NDEF message</a>s MUST always <a>obtain permission</a>.
      </li>
      <li>
        In addition to the previous, only websites with a schema starting with
        <code>"https://"</code> SHOULD be able to read <a>NFC tag</a>s that is
        not empty or does not contain a <a>Web NFC message</a>s.
      </li>
    </ol>
  </p>
</section> <!-- Security and Privacy  -->

<!-- - - - - - - - - - - - - Data types and content - - - - - - - - - - - -->
<section> <h3>Data Types</h3>
  <p>
    Web NFC implementations SHOULD use <a>Web NFC message</a>s, which SHOULD
    be sufficiently differentiated in order to avoid accidental matching with
    a generic <a>NDEF message</a> used in regular <a>NFC tag</a>s or between
    <a>NFC peer</a>s. This is achieved by using an additional
    <a>Web NFC record</a>, and in rest using normal <a>NDEF record</a>s in
    order to compose the <a>NDEF message</a>.
  </p>
  <section> <h3 id="web-nfc-record-format">The format of a Web NFC record</h3>
  <p>
    The format of a <a>Web NFC record</a> is the following.
    <ul>
      <li>
        Uses NFC Forum External Type record (<a>TNF</a>=4) with the External
        Type field set to <code>urn:nfc:ext:w3.org:webnfc</code>.
      </li>
      <li>
        The <var>id</var> field contains the
        <a href="https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin">
        ASCII serialized origin</a> which has written the payload.
      </li>
      <li>
        The payload MAY be empty, or MAY contain implementation specific
        contextual data encoded as Base64 ([[RFC4648]]), for instance tokens,
        authentication keys etc.
      </li>
    </ul>
 </p>
 </section>
  <section> <h3 id="web-nfc-payload">Web NFC message payload</h3>
  <p>
    The payload of a <a>Web NFC message</a> is represented by using normal
    <a>NDEF record</a>s.
    The following types can be used as payload, i.e. when writing to
    <a>NFC tag</a>s, sending data to <a>NFC peer</a>s, and when reading
    <a>NDEF message</a>s.
  </p>
  <dl class="idl"
      title = "typedef (DOMString or URL or Blob or JSON) NFCData">
  </dl>
  <p>
    <dfn>NFCData</dfn> denotes the data types
    supported as <a>NDEF record</a> payload in read and send operations in
    this API.
  </p>
  <p>
    The mapping from supported <code>NFCData</code> to
    <a>NDEF record</a> types, as used in the <code><a>send</a>()</code>
    method is as follows:
  </p>
  <table class="simple">
    <tr>
      <th>NFCData</th>
      <th>NDEF record type</th>
    </tr>
    <tr>
      <td><strong>DOMString</strong></td>
      <td>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>Text</i></td>
    </tr>
    <tr>
      <td><strong>URL</strong></td>
      <td><ul>
        <li>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>URI</i></li>
        <li>NFC Forum Well Known Type (<a>TNF</a>=1) with type
          <i>Smart Poster</i>
        </li>
        <li>Absolute URI as defined in [[RFC3986]] (<a>TNF</a>=3)</li>
      </ul></td>
    </tr>
    <tr>
      <td><strong>JSON</strong></td>
      <td>Media-type as defined in [[RFC2046]] (<a>TNF</a>=2) with associated
        <i>MIME type</i> <code>"application/json"</code>
      </td>
    </tr>
    <tr>
      <td><strong>Blob</strong> with MIME type</td>
      <td>Media-type as defined in [[RFC2046]] (<a>TNF</a>=2)</td>
    </tr>
    <tr>
      <td><strong>Blob</strong> without MIME type</td>
      <td>NFC Forum External Type (<a>TNF</a>=4)</td>
    </tr>
  </table>
  <p>
    The mapping from <a>NDEF record</a> types to <code><a>NFCData</a></code>,
    as used for incoming <a>NDEF message</a>s exposed by the
    <code><a>NFCMessageEvent</a></code>, is as follows:
  </p>
  <table class="simple">
    <tr>
      <th>NDEF record type</th>
      <th>NFCData</th>
    </tr>
    <tr>
      <td>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>Text</i></td>
      <td><strong>DOMString</strong></td>
    </tr>
    <tr>
      <td>NFC Forum Well Known Type (<a>TNF</a>=1) with type <i>URI</i></td>
      <td><strong>URL</strong> object</td>
    </tr>
    <tr>
      <td>NFC Forum Well Known Type (<a>TNF</a>=1) with type
          <i>Smart Poster</i></td>
      <td><strong>URL</strong> object</td>
    </tr>
    <tr>
      <td>Absolute URI as defined in [[RFC3986]] (<a>TNF</a>=3)</td>
      <td><strong>URL</strong> object</td>
    </tr>
    <tr>
      <td>Media-type as defined in [[RFC2046]] (<a>TNF</a>=2) with associated
        <i>MIME type</i> <code>"application/json"</code>
      </td>
      <td><strong>JSON</strong> object</td>
    </tr>
    <tr>
      <td>Media-type as defined in [[RFC2046]] (<a>TNF</a>=2)</td>
      <td><strong>Blob</strong> object</td>
    </tr>
    <tr>
      <td>NFC Forum External Type (<a>TNF</a>=4) with type other than
        <code>urn:nfc:ext:w3.org:webnfc</code></td>
      <td><strong>Blob</strong> object</td>
    </tr>
    <tr>
      <td>Any other <a>NDEF record</a> type</td>
      <td><strong>Blob</strong> object</td>
    </tr>
  </table>
  <p>
    Note that <a>Web NFC record</a>s are not exposed to client <a>web app</a>s.
  </p>
  </section>
</section> <!-- Data types and content -->

<!-- - - - - - - - - - - Extended interface Navigator - - - - - - - - - - - -->
<section> <h2>Extensions to the <strong>Navigator</strong> interface</h2>
  <p>
    The HTML specification defines a
    <a href="http://www.whatwg.org/specs/web-apps/current-work/#dom-navigator">
    <code>Navigator</code></a> interface [HTML] which this specification
    extends.
  </p>
  <dl title="partial interface Navigator" class="idl">
    <dt>readonly attribute NFC nfc</dt>
  </dl>
  <!-- - - - - - - - - - - - nfc attribute  - - - - - - - - - - - -->
  <section> <h3>The <strong>nfc</strong> attribute</h3>
  <p>
    When getting the <dfn id="widl-Navigator-nfc">nfc</dfn> attribute, the
    <a>user agent</a> MUST return the <a>NFC</a> object, which provides
    NFC related functionality.
  </p>
  </section> <!-- nfc attribute -->
</section> <!-- Navigator -->

<section> <h2>The <strong>NFC</strong> interface</h2>
  <dl title="interface NFC" class="idl">
    <dt>Promise&lt;NFCAdapter&gt; requestAdapter()</dt>
  </dl>
  <p>
    Implementations MAY expose multiple NFC adapters. By using the
    <dfn id="widl-NFC-findAdapters-Promise-sequence-NFCAdapter">
    requestAdapter</dfn>() method, <a>web app</a>s can obtain an adapter object
    providing NFC functionality.
    When this method is invoked, the <a>user agent</a> MUST run the following
    steps:
    <ol id="steps-requestAdapter">
      <li>Let <var>promise</var> be a new <a><code>Promise</code></a> object.
      </li>
      <li>
        Return <var>promise</var> and continue the following steps
        asynchronously.
      </li>
      <li>
        If <a>sufficient permission</a> has not been granted to use this method,
        that is, to use NFC technology from the calling <a>web app</a>,
        then reject <var>promise</var> with <code>"<a>SecurityError</a>"</code>,
        and terminate these steps.
      </li>
      <li>
        If there is no support for <a>NFC adapter</a> handling functionality in
        hardware, software, or due to physical incompatibility,
        then reject <var>promise</var> with
        <code>"<a>NotSupportedError</a>"</code>, and terminate these steps.
      </li>
      <li>
        Make a request to the underlying platform to initialize NFC
        functionality and enumerate available adapters. If the request fails,
        then reject <var>promise</var> with
        <code>"<a>NotSupportedError</a>"</code>, and terminate these steps.
      </li>
      <li>
        If the request is successful, then select one of the adapters based on
        the following algorithm:
        <ol>
          <li>Let <var>adapter</var> be <code>null</code>.</li>
          <li>If there is only one adapter, set <var>adapter</var> to that.</li>
          <li>
            If there are multiple adapters available, and there is a system or
            user setting available with a default adapter being specified, set
            <var>adapter</var> to that.
          </li>
          <li>
            Otherwise, the <a>user agent</a> MAY pop up a user dialog for
            selecting one of the listed adapters, or none of them, and
            set <var>adapter</var> to the selected one, if available.
          </li>
          <li>
            If no adapter is selected, then reject <var>promise</var> with
            <code>"<a>NotFoundError</a>"</code>, and terminate these steps.
          </li>
          <li>
            Otherwise if the dialog is blocked or canceled, then select the
            first built-in adapter.
          </li>
          <li>Otherwise select the first external (e.g. USB) adapter.</li>
        </ol>
      </li>
      <li>
        Resolve <var>promise</var> with <var>adapter</var>.
      </li>
    </ol>
  </p>
</section> <!-- NFC interface -->

<section> <h2>The <strong>NFCAdapter</strong> interface</h2>
  <dl title="interface NFCAdapter : EventHandler" class="idl">
    <dt>attribute EventHandler onmessage</dt>
    <dt>Promise&lt;void&gt; send(NFCMessage message, optional NFCSendOptions options)</dt>
  </dl>
  <p>
    The <code>NFCAdapter</code> interface handles incoming <a>NDEF message</a>s,
    exposed by the <code><a>NFCMessageEvent</a></code> event, either from an
    <a>NFC tag</a> or an <a>NFC peer</a>. By default, listening to this event
    SHOULD be disabled.
  </p>

  <!-- Events -->
  <section> <h3>Events used with the <strong>NFCAdapter</strong> interface</h3>
  <p>
    The following are the event handlers implemented by the
    <code><a>NFCAdapter</a></code> interface.
  </p>
  <table class="simple">
    <tr>
      <th>event handler</th>
      <th>event name   </th>
      <th>event type   </th>
    </tr>
    <tr>
      <td><code><dfn id="widl-NFCAdapter-onmessage">onmessage</dfn></code></td>
      <td><code>message</code></td>
      <td><code><a>NFCMessageEvent</a></code></td>
    </tr>
  </table>

  <section> <h3>The <strong>message</strong> event</h3>
  <p>
    The <code>message</code> event is used for notifying the adapter
    object about an <a>NDEF message</a> dispatched to the <a>web app</a>.
  </p>
  </section>

  <!-- NFCMessageEvent -->
  <section> <h3>The <strong>NFCMessageEvent</strong> interface</h3>
  <p>
    In this specification, <a>NDEF message</a> content is delivered by an
    <a>NFCMessageEvent</a> event.
  </p>
  <dl title="interface NFCMessageEvent : Event" class="idl">
    <dt>readonly attribute NFCMessage message</dt>
  </dl>
  <p>
    The <code><dfn id="widl-NFCMessageEvent-message">message</dfn></code>
    property MUST return the <code><a>NFCMessage</a></code> representing the
    payload data of the <a>NDEF message</a>.
  </p>
  </section> <!-- NFCMessageEvent -->

  <!-- NFCMessage -->
  <section><h3>The <strong>NFCMessage</strong> interface</h3>
    <p>
      The content of the <a>NDEF message</a> is exposed by the following
      interface:
    </p>
    <dl title="[NoInterfaceObject] interface NFCMessage" class="idl">
      <dt>readonly attribute USVString scope</dt>
      <dt>readonly attribute sequence&lt;any&gt; data</dt>
      <dt>  // (DOMString or URL or Blob or JSON) </dt>
    </dl>
    <p>
      The <code><dfn id="widl-NFCMessage-scope">scope</dfn></code>
      property MUST return the <a>URL scope</a> which has written the message.
    </p>
    <p>
      The <code>
      <dfn id="widl-NFCMessage-data">data</dfn></code> property MUST return the
      payload data of the <a>NDEF message</a> as an array of either
      <code>DOMString</code>, or <code>URL</code> object, or <code>Blob</code>
      object, or serializable JSON object as a generic <code>Object</code>.
    </p>
  </section> <!-- NFCMessage interface -->
  </section> <!-- Events -->

  <section><h3>The <strong>send()</strong> method</h3>
    <p>
      The <code>
      <dfn id="widl-NFCAdapter-send-Promise-void--NFCMessage-message-NFCSendOptions-options">
      send</dfn>()</code> method is used for sending an <a>NDEF message</a> to
      either an <a>NFC tag</a> for writing, or to an <a>NFC peer</a> device,
      next time when they get into proximity range.
      When this method is invoked, the <a>user agent</a> MUST run the following
      steps:
      <ol id="steps-setPushMessage">
        <li>
          Let <var>promise</var> be a new <a><code>Promise</code></a> object.
        </li>
        <li>
          Return <var>promise</var> and continue the following steps
          asynchronously.
        </li>
        <li>
          If <a>sufficient permission</a> has not been granted to use this
          method, then reject <var>promise</var> with
          <code>"SecurityError"</code>, and terminate these steps.
        </li>
        <li>
          If there is no support for the functionality of sending data to an
          <a>NFC peer</a> in proximity range, or to write data to an
          <a>NFC tag</a>, then reject <var>promise</var> with
          <code>"NotSupportedError"</code>, and terminate these steps.
        </li>
        <li>
          Parse the argument <var>options</var>. If it is <code>undefined</code>
          or <code>null</code>, then use the default values.
          Otherwise if invalid, then reject <var>promise</var> with
          <code>"SyntaxError"</code>, and terminate these steps.
        </li>
        <li>
          Parse the argument <var>message.scope</var>.
          If the value is <code>undefined</code>, then set <var>scope</var> to
          the <code>DOMString</code> describing the <a>document base URL</a>.
          If it is invalid in the given platform, or if it is not a
          sub-domain match of the <a>document base URL</a>, then reject
          <var>promise</var> with <code>"SyntaxError"</code>, and terminate
          these steps.
        </li>
        <li>
          For each element in the array <var>message.data</var>,
          <a href="#web-nfc-payload">check</a> the type
          to be one of the supported types.
          If the value is invalid on the given platform, then reject
          <var>promise</var> with <code>"<a>SyntaxError</a>"</code>, and
          terminate these steps.
          For each valid element create an <a>NDEF record</a>.
          The implementation choose the best suitable <a>NDEF record</a> format
          for the given platform.
          Each element in the input array given in <var>message.data</var>
          SHOULD map to a separate <a>NDEF record</a> in the <a>NDEF message</a>
          to be sent.
        </li>
        <li>
          Assemble an <a>NDEF message</a> from the <a>NDEF record</a>s and an
          additional <a>Web NFC record</a>, referred to as <var>output</var>.
        </li>
        <li>
          Make a request to the underlying platform to send <var>output</var>
          to the next device which comes in proximity range.
        </li>
        <li>
          If <var>options.target</var> has the value <code>"tag"</code>, then
          the sending should only happen if an <a>NFC tag</a> is tapped within
          a platform specific timeout, otherwise reject <var>promise</var> with
          a <code>"TimeoutError"</code> in the case of timeout, or
          <code>"InvalidAccessError"</code> if an <a>NFC peer</a> is
          tapped instead of a tag.
        </li>
        <li>
          If <var>options.target</var> has the value <code>"peer"</code>, then
          the sending should only happen if an <a>NFC peer</a> is tapped within
          a platform specific timeout, otherwise reject <var>promise</var> with
          a <code>"TimeoutError"</code> in the case of timeout, or
          <code>"InvalidAccessError"</code> if an <a>NFC tag</a> is
          tapped instead of a peer.
        </li>
        <li>
          If <var>options.target</var> has the value <code>"any"</code> (which
          is the default value), then the sending should happen if either an
          <a>NFC peer</a> or an <a>NFC tag</a> is tapped within a platform
          specific timeout, otherwise reject <var>promise</var> with
          <code>"TimeoutError"</code>.
        </li>
        <li>
          If the request is successful, then resolve <var>promise</var>.
        </li>
      </ol>
    </p>

    <section> <h3>The <strong>NFCSendOptions</strong> dictionary</h3>
      <dl class="idl" title="enum NFCTarget">
        <dt>tag</dt>
        <dd>Only <a>NFC tag</a>s are targeted.</dd>

        <dt>peer</dt>
        <dd>Only <a>NFC peer</a>s are targeted.</dd>

        <dt>any</dt>
        <dd>Both <a>NFC tag</a>s and <a>NFC peer</a>s are targeted.</dd>
      </dl>

      <dl title="dictionary NFCSendOptions" class="idl">
        <dt>NFCTarget target</dt>
      </dl>
      <p>
        The <dfn id="widl-NFCSendOptions-target">target</dfn> property
        denotes the intended target for the pending <code>send()</code>
        operation. The default value is <code>"any"</code>.
      </p>
    </section>
  </section> <!-- send() method -->
</section>


<!-- - - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
<section class="informative"> <h2>Examples</h2>
  <p>
    This section shows how developers can make use of the various features of
    this specification.
  </p>
  <pre title="Check permissions for NFC"
       class="example highlight">
    navigator.permissions.query({name: 'nfc'}).then((result) => {
        if (result.status == 'granted') {
          enableNFCUseCase();  // Do things here.
        } else if (result.status == 'prompt') {
          // The user agent will prompt.
        }
        // Otherwise don't do anything since it will fail.
      });
  </pre>
  <pre title="Read and write tag" class="example highlight">
    var adapter = null;
    navigator.nfc.requestAdapter().then((nfcAdapter) => {
      adapter = nfcAdapter;
      adapter.onmessage = onMessage;
    };

    function onMessage(event) {
      console.log("NDEF message received from scope " + event.message.scope);
      var data = event.message.data;

      if (!data) { // empty tag
        writeMessageOnTag({data: “Initializing a passive tag”});
      }

      if (typeof data == ‘string’) {
        console.log(“Data is string: “ + data);
      } else if (data instanceof Blob) {
        processBlob(data);
      } else if (data instanceof URL) {
        console.log(“Data is URL: “ + data.toString());
      } else if (typeof data == ‘object’) {
        processJSON(data);
      }
    };

    function writeMessageOnTag(msg) {
        adapter.send(msg, {target: "tag"})
          .then(() => { console.log("Send was successful")})
          .catch(() => { console.log("Send failed")});
    };

    function processBlob(data) {
        console.log(“Blob size: ” + data.size + “ bytes”);
        console.log(“Blob type: ” + data.type);
        var reader = new FileReader();
        reader.addEventListener(“loadend”, function() {
          console.log(“Blob data: ” + reader.result);
          // Now send a response based on the data.
          adapter.send({data: “Response to blob” })
            .then(() => { console.log("Send was successful")})
            .catch(() => { console.log("Send failed")});
        });
        reader.readAsText(data);
    };

    function processJSON(data) {
      if (myCondition(data.myKnownProperty)) {
        adapter.send({data: “Custom data”});
    };
  </pre>
  <pre title="Save and restore game progress with another device"
       class="example highlight">
    navigator.nfc.requestAdapter().then((adapter) => {
      console.log("Waiting for game state");
      adapter.onmessage = (event) => {
        console.log("Game state received from: " + event.message.scope);
        console.log("Game state: " + event.message.data);
        // Now do some calculations and update the state.
        adapter.send({ scope: event.message.scope,
                       data: [ { level: 3, points: 4500, lives: 3 } ] })
          .then(() => { console.log("Send was successful")})
          .catch(() => { console.log("Send failed")});
      };
    });
  </pre>
</section> <!-- Usage examples -->

<!-- - - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - - -->
<section class="appendix" id="Changes"><h2>Changes</h2>
  <p>
    The following is a list of substantial changes to the document. For a
    complete list of changes, see the <a href=
    "https://github.com/w3c/web-nfc/commits/gh-pages">change log on
    Github</a>. You can also view the <a href=
    "https://github.com/w3c/web-nfc/issues?page=1&amp;state=closed">
    recently closed bugs</a>.
  </p>
  <ul>
    <li>Changed handling of NFC adapters.</li>
    <li>
      Removed watches/filters.
    </li>
    <li>
      Unified handling of peer push and tag writing.
    </li>
    <li>
      Rewritten mapping data types to NDEF records.
    </li>
    <li>
      Added Open Issues section, for summarizing present development topics.
    </li>
  </ul>
</section>

<!-- - - - - - - - - - - - - - - Open issues - - - - - - - - - - - - - - - -->
<section> <h3 class="appendix" id="openissues">Open issues</h3>
  <p>
    The following problems are being discussed and need most attention:
    <ul>
      <li>
        <a href="https://github.com/w3c/web-nfc/issues/2">
        Verify security model.</a>
      </li>
      <li>
        <a href="https://github.com/w3c/web-nfc/issues/3">
        Suggest a permission UI flow.</a>
      </li>
      <li>
        <a href="https://github.com/w3c/web-nfc/issues/17">
        Using service workers and protocol handlers.</a>
      </li>
    </ul>
  </p>
</section>

<!-- - - - - - - - - - - - - - - Acknowledgements - - - - - - - - - - - - - -->
<section> <h2>Acknowledgements</h2>
  <p>
    The editors would like to express their gratitude to the former editors
    Luc Yriarte and Samuel Ortiz, and also to Don Coleman, Jeffrey Yasskin,
    Salvatore Iovene, and Alexander Shalamov for their technical guidance,
    implementation feedback and support.
  </p>
</section>

</body>
</html>
