<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta content="HTML Tidy for HTML5 (experimental) for Mac OS X https://github.com/w3c/tidy-html5/tree/c63cc39" name="generator" />

  <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
<!--
     After making changes to this document in the github repo, run:
      ./publish.sh webrtc.html
    to publish a new editor's draft to the W3C CVS. This assumes your
    CVS checkout is located at ../2011/webrtc, you can specify the location
    as the second argument, for example:
      ./publish.sh webrtc.html ~/path/to/w3/2011/webrtc
  -->


  
  
<style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}


/* --- --- */
ol.algorithm { counter-reset:numsection; list-style-type: none; }
ol.algorithm li { margin: 0.5em 0; }
ol.algorithm li:before { font-weight: bold; counter-increment: numsection; content: counters(numsection, ".") ") "; }

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #005a9c;
}

.simple th {
    background: #005a9c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}
</style><style>/* --- EXAMPLES --- */
div.example-title {
    min-width: 7.5em;
    color: #b9ab2d;
}
div.example-title span {
    text-transform: uppercase;   
}
aside.example, div.example, div.illegal-example {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
div.illegal-example { color: red }
div.illegal-example p { color: black }
aside.example, div.example {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
    border-color: #e0cb52;
    background: #fcfaee;    
}

aside.example div.example {
    border-left-width: .1em;
    border-color: #999;
    background: #fff;
}
aside.example div.example div.example-title {
    color: #999;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title { color: #52e052; }
div.issue-title span, div.note-title span {
    text-transform: uppercase;
}
div.note, div.issue {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .issue > p:first-child { margin-top: 0 }
.issue, .note {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.issue { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note {
    border-color: #52e052;
    background: #e9fbe9;
}


</style><style>/* HIGHLIGHTS */
code.prettyprint {
    color:  inherit;
}

/* this from google-code-prettify */
.pln{color:#000}@media screen{.str{color:#080}.kwd{color:#008}.com{color:#800}.typ{color:#606}.lit{color:#066}.pun,.opn,.clo{color:#660}.tag{color:#008}.atn{color:#606}.atv{color:#080}.dec,.var{color:#606}.fun{color:red}}@media print,projection{.str{color:#060}.kwd{color:#006;font-weight:bold}.com{color:#600;font-style:italic}.typ{color:#404;font-weight:bold}.lit{color:#044}.pun,.opn,.clo{color:#440}.tag{color:#006;font-weight:bold}.atn{color:#404}.atv{color:#060}}ol.linenums{margin-top:0;margin-bottom:0}li.L0,li.L1,li.L2,li.L3,li.L5,li.L6,li.L7,li.L8{list-style-type:none}li.L1,li.L3,li.L5,li.L7,li.L9{background:#eee}
</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #90b8de;
    border-bottom: 1px solid #90b8de;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #90b8de;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #005a9c;
}

.idlSuperclass {
    font-style: italic;
    color:  #005a9c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #005a9c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #005a9c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #005a9c;
}
.idlParamName, .idlDefaultValue {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlConst*/
.idlConstType {
    color:  #005a9c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #005a9c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #005a9c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.attributes dd, .methods dd, .constants dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #90b8de; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #90b8de; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}
</style><link rel="stylesheet" href="http://www.w3.org/StyleSheets/TR/W3C-ED" />
<!--[if lt IE 9]><script src='http://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]-->
</head>

<body><div class="head">
  <p>
    
      <a href="http://www.w3.org/"><img width="72" height="48" alt="W3C" src="http://www.w3.org/Icons/w3c_home" /></a>
    
  </p>
  <h1 id="title" class="title">WebRTC 1.0: Real-time Communication Between Browsers</h1>
  
  <h2 id="w3c-editor-s-draft-12-december-2012"><acronym title="World Wide Web Consortium">W3C</acronym> Editor's Draft 12 December 2012</h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a href="http://dev.w3.org/2011/webrtc/editor/archives/20121212/webrtc.html">http://dev.w3.org/2011/webrtc/editor/archives/20121212/webrtc.html</a></dd>
      <dt>Latest published version:</dt>
      <dd><a href="http://www.w3.org/TR/webrtc/">http://www.w3.org/TR/webrtc/</a></dd>
    
    
      <dt>Latest editor's draft:</dt>
      <dd><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">http://dev.w3.org/2011/webrtc/editor/webrtc.html</a></dd>
    
    
    
    
      
        <dt>Previous editor's draft:</dt>
        <dd><a href="http://dev.w3.org/2011/webrtc/editor/archives/20121115/webrtc.html">http://dev.w3.org/2011/webrtc/editor/archives/20121115/webrtc.html</a></dd>
      
    
    
    
    <dt>Editors:</dt>
    <dd><span>Adam Bergkvist</span>, Ericsson</dd>
<dd><span>Daniel C. Burnett</span>, Voxeo</dd>
<dd><span>Cullen Jennings</span>, Cisco</dd>
<dd><span>Anant Narayanan</span>, Mozilla (until November 2012)</dd>

    
  </dl>
  
  
  
  
    
      <p class="copyright">Initial Author of this Specification was Ian Hickson, Google Inc., with the following copyright statement:<br /> © Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and Opera Software ASA. You are granted a license to use, reproduce and create derivative works of this document.</p> <p class="copyright">All subsequent changes since 26 July 2011 done by the <acronym title="World Wide Web Consortium">W3C</acronym> WebRTC Working Group are under the following <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>:<br />© 2011-2012 <a href="http://www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. <a href="http://www.w3.org/Consortium/Legal/copyright-documents">Document use</a>  rules apply.</p> <p class="copyright">For the entire publication on the <acronym title="World Wide Web Consortium">W3C</acronym> site the <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a> and <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> rules apply.</p>
    
  
  <hr />
</div>
  <section id="abstract" class="introductory"><h2>Abstract</h2>
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow media
    to be sent to and received from another browser or device implementing the
    appropriate set of real-time protocols. This specification is being
    developed in conjunction with a protocol specification developed by the
    IETF RTCWEB group and an API specification to get access to local media
    devices developed by the Media Capture Task Force.</p>
  </section><section class="introductory" id="sotd"><h2>Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication. Other
          documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the latest revision
          of this technical report can be found in the <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> technical reports
          index</a> at http://www.w3.org/TR/.</em>
        </p>
        
    <p>This document is neither complete nor stable, and as such is not yet
    suitable for commercial implementation. However, early experimentation is
    encouraged. The API is based on preliminary work done in the WHATWG. The
    Web Real-Time Communications Working Group expects this specification to
    evolve significantly based on:</p>

    <ul>
      <li>The outcome of ongoing exchanges in the companion RTCWEB group at
      IETF to define the set of protocols that, together with this document,
      will enable real-time communications in Web browsers.</li>

      <li>Privacy issues that arise when exposing local capabilities and local
      streams.</li>

      <li>Technical discussions within the group.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>
  
        <p>
          This document was published by the <a href="http://www.w3.org/2011/04/webrtc/">Web Real-Time Communications Working Group</a> as an Editor's Draft.
          
          If you wish to make comments regarding this document, please send them to 
          <a href="mailto:public-webrtc@w3.org">public-webrtc@w3.org</a> 
          (<a href="mailto:public-webrtc-request@w3.org?subject=subscribe">subscribe</a>,
          <a href="http://lists.w3.org/Archives/Public/public-webrtc/">archives</a>).
          
          
          All feedback is welcome.
        </p>
        
          <p>
            Publication as an Editor's Draft does not imply endorsement by the <acronym title="World Wide Web Consortium">W3C</acronym> Membership.
            This is a draft document and may be updated, replaced or obsoleted by other documents at 
            any time. It is inappropriate to cite this document as other than work in progress.
          </p>
        
        
        <p>
          
            This document was produced by a group operating under the 
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.
          
          
          
            
              <acronym title="World Wide Web Consortium">W3C</acronym> maintains a <a rel="disclosure" href="http://www.w3.org/2004/01/pp-impl/47318/status">public list of any patent disclosures</a> 
            
            made in connection with the deliverables of the group; that page also includes instructions for 
            disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains
            <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the
            information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section
            6 of the <acronym title="World Wide Web Consortium">W3C</acronym> Patent Policy</a>.
          
          
        </p>
        
      
    
  
</section><section id="toc"><h2 class="introductory">Table of Contents</h2><ul class="toc"><li class="tocline"><a href="#intro" class="tocxref"><span class="secno">1. </span>Introduction</a></li><li class="tocline"><a href="#conformance" class="tocxref"><span class="secno">2. </span>Conformance</a></li><li class="tocline"><a href="#terminology" class="tocxref"><span class="secno">3. </span>Terminology</a></li><li class="tocline"><a href="#peer-to-peer-connections" class="tocxref"><span class="secno">4. </span>Peer-to-peer connections</a><ul class="toc"><li class="tocline"><a href="#introduction" class="tocxref"><span class="secno">4.1 </span>Introduction</a></li><li class="tocline"><a href="#configuration" class="tocxref"><span class="secno">4.2 </span>Configuration</a><ul class="toc"><li class="tocline"><a href="#rtcconfiguration-type" class="tocxref"><span class="secno">4.2.1 </span>RTCConfiguration Type</a><ul class="toc"><li class="tocline"><a href="#dictionary-rtcconfiguration-members" class="tocxref"><span class="secno">4.2.1.1 </span>Dictionary <span class="formerLink"><code>RTCConfiguration</code></span> Members</a></li></ul></li><li class="tocline"><a href="#rtciceserver-type" class="tocxref"><span class="secno">4.2.2 </span>RTCIceServer Type</a><ul class="toc"><li class="tocline"><a href="#dictionary-rtciceserver-members" class="tocxref"><span class="secno">4.2.2.1 </span>Dictionary <span class="formerLink"><code>RTCIceServer</code></span> Members</a></li></ul></li></ul></li><li class="tocline"><a href="#rtcpeerconnection-interface" class="tocxref"><span class="secno">4.3 </span>RTCPeerConnection Interface</a><ul class="toc"><li class="tocline"><a href="#operation" class="tocxref"><span class="secno">4.3.1 </span>Operation</a></li><li class="tocline"><a href="#interface-definition" class="tocxref"><span class="secno">4.3.2 </span>Interface Definition</a><ul class="toc"><li class="tocline"><a href="#attributes" class="tocxref"><span class="secno">4.3.2.1 </span>Attributes</a></li><li class="tocline"><a href="#methods" class="tocxref"><span class="secno">4.3.2.2 </span>Methods</a></li></ul></li><li class="tocline"><a href="#garbage-collection" class="tocxref"><span class="secno">4.3.3 </span>Garbage collection</a></li></ul></li><li class="tocline"><a href="#state-definitions" class="tocxref"><span class="secno">4.4 </span>State Definitions</a><ul class="toc"><li class="tocline"><a href="#rtcpeerstate-enum" class="tocxref"><span class="secno">4.4.1 </span>RTCPeerState Enum</a></li><li class="tocline"><a href="#rtcgatheringstate-enum" class="tocxref"><span class="secno">4.4.2 </span>RTCGatheringState Enum</a></li><li class="tocline"><a href="#rtcicestate-enum" class="tocxref"><span class="secno">4.4.3 </span>RTCIceState Enum</a></li></ul></li><li class="tocline"><a href="#callback-definitions" class="tocxref"><span class="secno">4.5 </span>Callback Definitions</a><ul class="toc"><li class="tocline"><a href="#rtcvoidcallback" class="tocxref"><span class="secno">4.5.1 </span>RTCVoidCallback</a></li><li class="tocline"><a href="#rtcpeerconnectionerrorcallback" class="tocxref"><span class="secno">4.5.2 </span>RTCPeerConnectionErrorCallback</a><ul class="toc"><li class="tocline"><a href="#callback-rtcpeerconnectionerrorcallback-parameters" class="tocxref"><span class="secno">4.5.2.1 </span>Callback <span class="formerLink"><code>RTCPeerConnectionErrorCallback</code></span> Parameters</a></li></ul></li></ul></li><li class="tocline"><a href="#error-handling" class="tocxref"><span class="secno">4.6 </span>Error Handling</a><ul class="toc"><li class="tocline"><a href="#general-principles" class="tocxref"><span class="secno">4.6.1 </span>General Principles</a></li><li class="tocline"><a href="#rtcerror" class="tocxref"><span class="secno">4.6.2 </span>RTCError</a><ul class="toc"><li class="tocline"><a href="#attributes-1" class="tocxref"><span class="secno">4.6.2.1 </span>Attributes</a></li></ul></li><li class="tocline"><a href="#rtcsdperror" class="tocxref"><span class="secno">4.6.3 </span>RTCSdpError</a><ul class="toc"><li class="tocline"><a href="#attributes-2" class="tocxref"><span class="secno">4.6.3.1 </span>Attributes</a></li></ul></li><li class="tocline"><a href="#rtcexceptionname" class="tocxref"><span class="secno">4.6.4 </span>RTCExceptionName</a></li><li class="tocline"><a href="#rtcerrorname" class="tocxref"><span class="secno">4.6.5 </span>RTCErrorName</a></li></ul></li><li class="tocline"><a href="#session-description-model" class="tocxref"><span class="secno">4.7 </span>Session Description Model</a><ul class="toc"><li class="tocline"><a href="#rtcsdptype" class="tocxref"><span class="secno">4.7.1 </span>RTCSdpType</a></li><li class="tocline"><a href="#rtcsessiondescription-class" class="tocxref"><span class="secno">4.7.2 </span>RTCSessionDescription Class</a><ul class="toc"><li class="tocline"><a href="#attributes-3" class="tocxref"><span class="secno">4.7.2.1 </span>Attributes</a></li><li class="tocline"><a href="#dictionary-rtcsessiondescriptioninit-members" class="tocxref"><span class="secno">4.7.2.2 </span>Dictionary <span class="formerLink"><code>RTCSessionDescriptionInit</code></span> Members</a></li></ul></li><li class="tocline"><a href="#rtcsessiondescriptioncallback" class="tocxref"><span class="secno">4.7.3 </span>RTCSessionDescriptionCallback</a><ul class="toc"><li class="tocline"><a href="#callback-rtcsessiondescriptioncallback-parameters" class="tocxref"><span class="secno">4.7.3.1 </span>Callback <span class="formerLink"><code>RTCSessionDescriptionCallback</code></span> Parameters</a></li></ul></li></ul></li><li class="tocline"><a href="#interfaces-for-connectivity-establishment" class="tocxref"><span class="secno">4.8 </span>Interfaces for Connectivity Establishment</a><ul class="toc"><li class="tocline"><a href="#rtcicecandidate-type" class="tocxref"><span class="secno">4.8.1 </span>RTCIceCandidate Type</a><ul class="toc"><li class="tocline"><a href="#attributes-4" class="tocxref"><span class="secno">4.8.1.1 </span>Attributes</a></li><li class="tocline"><a href="#dictionary-rtcicecandidateinit-members" class="tocxref"><span class="secno">4.8.1.2 </span>Dictionary <span class="formerLink"><code>RTCIceCandidateInit</code></span> Members</a></li></ul></li><li class="tocline"><a href="#rtcpeerconnectioniceevent" class="tocxref"><span class="secno">4.8.2 </span>RTCPeerConnectionIceEvent</a><ul class="toc"><li class="tocline"><a href="#attributes-5" class="tocxref"><span class="secno">4.8.2.1 </span>Attributes</a></li><li class="tocline"><a href="#dictionary-rtcpeerconnectioniceeventinit-members" class="tocxref"><span class="secno">4.8.2.2 </span>Dictionary <span class="formerLink"><code>RTCPeerConnectionIceEventInit</code></span> Members</a></li></ul></li></ul></li></ul></li><li class="tocline"><a href="#peer-to-peer-data-api" class="tocxref"><span class="secno">5. </span>Peer-to-peer Data API</a><ul class="toc"><li class="tocline"><a href="#rtcdatachannel" class="tocxref"><span class="secno">5.1 </span>RTCDataChannel</a><ul class="toc"><li class="tocline"><a href="#attributes-6" class="tocxref"><span class="secno">5.1.1 </span>Attributes</a></li><li class="tocline"><a href="#methods-1" class="tocxref"><span class="secno">5.1.2 </span>Methods</a></li><li class="tocline"><a href="#dictionary-rtcdatachannelinit-members" class="tocxref"><span class="secno">5.1.3 </span>Dictionary <span class="formerLink"><code>RTCDataChannelInit</code></span> Members</a></li></ul></li><li class="tocline"><a href="#rtcdatachannelevent" class="tocxref"><span class="secno">5.2 </span>RTCDataChannelEvent</a><ul class="toc"><li class="tocline"><a href="#attributes-7" class="tocxref"><span class="secno">5.2.1 </span>Attributes</a></li><li class="tocline"><a href="#dictionary-rtcdatachanneleventinit-members" class="tocxref"><span class="secno">5.2.2 </span>Dictionary <span class="formerLink"><code>RTCDataChannelEventInit</code></span> Members</a></li></ul></li><li class="tocline"><a href="#garbage-collection-1" class="tocxref"><span class="secno">5.3 </span>Garbage Collection</a></li></ul></li><li class="tocline"><a href="#statistics-model" class="tocxref"><span class="secno">6. </span>Statistics Model</a><ul class="toc"><li class="tocline"><a href="#introduction-1" class="tocxref"><span class="secno">6.1 </span>Introduction</a></li><li class="tocline"><a href="#rtcstatscallback" class="tocxref"><span class="secno">6.2 </span>RTCStatsCallback</a><ul class="toc"><li class="tocline"><a href="#callback-rtcstatscallback-parameters" class="tocxref"><span class="secno">6.2.1 </span>Callback <span class="formerLink"><code>RTCStatsCallback</code></span> Parameters</a></li></ul></li><li class="tocline"><a href="#rtcstatselement-dictionary" class="tocxref"><span class="secno">6.3 </span>RTCStatsElement dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-rtcstatselement-members" class="tocxref"><span class="secno">6.3.1 </span>Dictionary <span class="formerLink"><code>RTCStatsElement</code></span> Members</a></li></ul></li><li class="tocline"><a href="#rtcstatsreport-type" class="tocxref"><span class="secno">6.4 </span>RTCStatsReport Type</a><ul class="toc"><li class="tocline"><a href="#attributes-8" class="tocxref"><span class="secno">6.4.1 </span>Attributes</a></li><li class="tocline"><a href="#methods-2" class="tocxref"><span class="secno">6.4.2 </span>Methods</a></li></ul></li><li class="tocline"><a href="#example" class="tocxref"><span class="secno">6.5 </span>Example</a></li></ul></li><li class="tocline"><a href="#identity" class="tocxref"><span class="secno">7. </span>Identity</a><ul class="toc"><li class="tocline"><a href="#identity-provider-interaction" class="tocxref"><span class="secno">7.1 </span>Identity Provider Interaction</a><ul class="toc"><li class="tocline"><a href="#peer-connection-idp-communications" class="tocxref"><span class="secno">7.1.1 </span>Peer-Connection/IdP
        Communications</a></li><li class="tocline"><a href="#requesting-assertions" class="tocxref"><span class="secno">7.1.2 </span>Requesting
        Assertions</a></li><li class="tocline"><a href="#verifying-assertions" class="tocxref"><span class="secno">7.1.3 </span>Verifying Assertions</a></li></ul></li><li class="tocline"><a href="#rtcidentityassertion-type" class="tocxref"><span class="secno">7.2 </span>RTCIdentityAssertion Type</a><ul class="toc"><li class="tocline"><a href="#dictionary-rtcidentityassertion-members" class="tocxref"><span class="secno">7.2.1 </span>Dictionary <span class="formerLink"><code>RTCIdentityAssertion</code></span> Members</a></li></ul></li><li class="tocline"><a href="#examples" class="tocxref"><span class="secno">7.3 </span>Examples</a></li></ul></li><li class="tocline"><a href="#media-stream-api-extensions-for-network-use" class="tocxref"><span class="secno">8. </span>Media Stream API Extensions for Network Use</a><ul class="toc"><li class="tocline"><a href="#introduction-2" class="tocxref"><span class="secno">8.1 </span>Introduction</a></li><li class="tocline"><a href="#mediastream" class="tocxref"><span class="secno">8.2 </span>MediaStream</a><ul class="toc"><li class="tocline"><a href="#id" class="tocxref"><span class="secno">8.2.1 </span>id</a></li><li class="tocline"><a href="#events-on-mediastream" class="tocxref"><span class="secno">8.2.2 </span>Events on MediaStream</a></li></ul></li><li class="tocline"><a href="#mediastreamtrack" class="tocxref"><span class="secno">8.3 </span>MediaStreamTrack</a></li><li class="tocline"><a href="#audiomediastreamtrack" class="tocxref"><span class="secno">8.4 </span>AudioMediaStreamTrack</a><ul class="toc"><li class="tocline"><a href="#attributes-9" class="tocxref"><span class="secno">8.4.1 </span>Attributes</a></li><li class="tocline"><a href="#methods-3" class="tocxref"><span class="secno">8.4.2 </span>Methods</a></li></ul></li><li class="tocline"><a href="#mediastreamevent" class="tocxref"><span class="secno">8.5 </span>MediaStreamEvent</a><ul class="toc"><li class="tocline"><a href="#attributes-10" class="tocxref"><span class="secno">8.5.1 </span>Attributes</a></li><li class="tocline"><a href="#dictionary-mediastreameventinit-members" class="tocxref"><span class="secno">8.5.2 </span>Dictionary <span class="formerLink"><code>MediaStreamEventInit</code></span> Members</a></li></ul></li></ul></li><li class="tocline"><a href="#examples-and-call-flows" class="tocxref"><span class="secno">9. </span>Examples and Call Flows</a><ul class="toc"><li class="tocline"><a href="#simple-peer-to-peer-example" class="tocxref"><span class="secno">9.1 </span>Simple Peer-to-peer Example</a></li><li class="tocline"><a href="#advanced-peer-to-peer-example" class="tocxref"><span class="secno">9.2 </span>Advanced Peer-to-peer Example</a></li><li class="tocline"><a href="#peer-to-peer-data-example" class="tocxref"><span class="secno">9.3 </span>Peer-to-peer Data Example</a></li><li class="tocline"><a href="#call-flow-browser-to-browser" class="tocxref"><span class="secno">9.4 </span>Call Flow Browser to Browser</a></li></ul></li><li class="tocline"><a href="#event-summary" class="tocxref"><span class="secno">10. </span>Event summary</a></li><li class="tocline"><a href="#security-considerations" class="tocxref"><span class="secno">11. </span>Security Considerations</a></li><li class="tocline"><a href="#iana-registrations" class="tocxref"><span class="secno">12. </span>IANA Registrations</a><ul class="toc"><li class="tocline"><a href="#constraints" class="tocxref"><span class="secno">12.1 </span>Constraints</a></li></ul></li><li class="tocline"><a href="#change-log" class="tocxref"><span class="secno">13. </span>Change Log</a></li><li class="tocline"><a href="#acknowledgements" class="tocxref"><span class="secno">A. </span>Acknowledgements</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">B. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">B.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">B.2 </span>Informative references</a></li></ul></li></ul></section>

  

  <section id="intro" class="informative">
    
<!--OddPage-->
<h2><span class="secno">1. </span>Introduction</h2><p><em>This section is non-normative.</em></p>

    <p>There are a number of facets to video-conferencing in HTML covered by
    this specification:</p>

    <ul>
      <li>Connecting to remote peers using NAT-traversal technologies such as
      ICE, STUN, and TURN.</li>

      <li>Sending the locally-produced streams to remote peers and receiving
      streams from remote peers.</li>

      <li>Sending arbitrary data directly to remote peers.</li>
    </ul>

    <p>This document defines the APIs used for these features. This
    specification is being developed in conjunction with a protocol
    specification developed by the <a href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and an API
    specification to get access to local media devices developed by the
    <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task
    Force</a>.</p>
  </section>

  <section id="conformance">
<!--OddPage-->
<h2><span class="secno">2. </span>Conformance</h2>
<p>
  As well as sections marked as non-normative, all authoring guidelines, diagrams, examples,
  and notes in this specification are non-normative. Everything else in this specification is
  normative.
</p>
<p>
  The key words <em class="rfc2119" title="must">must</em>, <em class="rfc2119" title="must not">must not</em>, <em class="rfc2119" title="required">required</em>, <em class="rfc2119" title="should">should</em>, <em class="rfc2119" title="should not">should not</em>, <em class="rfc2119" title="recommended">recommended</em>, <em class="rfc2119" title="may">may</em>,
  and <em class="rfc2119" title="optional">optional</em> in this specification are to be interpreted as described in [<cite><a class="bibref" href="#bib-RFC2119">RFC2119</a></cite>].
</p>

    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn id="dfn-user-agent">user agent</dfn> that implements the interfaces that it
    contains.</p>

    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification must implement them in a manner consistent with the
    ECMAScript Bindings defined in the Web IDL specification [<cite><a class="bibref" href="#bib-WEBIDL">WEBIDL</a></cite>], as
    this specification uses that specification and terminology.</p>
  </section>

  <section id="terminology">
    
<!--OddPage-->
<h2><span class="secno">3. </span>Terminology</h2>

    <p>The <code><a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
    interface represents a callback used for event handlers as defined in
    [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>].</p>

    <p>The concepts <dfn id="dfn-queue-a-task"><a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a
    task</a></dfn> and <dfn id="dfn-fires-a-simple-event"><a href="http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a
    simple event</a></dfn> are defined in [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>].</p>

    <p>The terms <dfn id="dfn-event-handlers"><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
    handlers</a></dfn> and <dfn id="dfn-event-handler-event-types"><a href="http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
    handler event types</a></dfn> are defined in [<cite><a class="bibref" href="#bib-HTML5">HTML5</a></cite>].</p>
  </section>

  <section id="peer-to-peer-connections">
    
<!--OddPage-->
<h2><span class="secno">4. </span>Peer-to-peer connections</h2>

    <section id="introduction">
      <h3><span class="secno">4.1 </span>Introduction</h3>

      <p>An <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> allows two users to
      communicate directly, browser to browser. Communications are coordinated
      via a signaling channel which is provided by unspecified means, but
      generally by a script in the page via the server, e.g. using
      <code>XMLHttpRequest</code>.</p>
    </section>

    <section id="configuration">
      <h3><span class="secno">4.2 </span>Configuration</h3>

      <section id="rtcconfiguration-type">
        <h4><span class="secno">4.2.1 </span>RTCConfiguration Type</h4>

        <pre class="idl"><span id="idl-def-RTCConfiguration" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCConfiguration</span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCIceServer" class="idlType"><code>RTCIceServer</code></a>[]</span> <span class="idlMemberName"><a href="#widl-RTCConfiguration-iceServers">iceServers</a></span>;</span>
};</span></pre><section id="dictionary-rtcconfiguration-members"><h5><span class="secno">4.2.1.1 </span>Dictionary <a class="idlType" href="#idl-def-RTCConfiguration"><code>RTCConfiguration</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RTCConfiguration-iceServers"><code>iceServers</code> of type array of <span class="idlMemberType"><a href="#idl-def-RTCIceServer" class="idlType"><code>RTCIceServer</code></a></span></dt><dd>
            <p>An array containing STUN and TURN servers available to be used
            by ICE.</p>
          </dd></dl></section>
      </section>

      <section id="rtciceserver-type">
        <h4><span class="secno">4.2.2 </span>RTCIceServer Type</h4>

        <pre class="idl"><span id="idl-def-RTCIceServer" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCIceServer</span> {
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span>  <span class="idlMemberName"><a href="#widl-RTCIceServer-url">url</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a>?</span> <span class="idlMemberName"><a href="#widl-RTCIceServer-credential">credential</a></span>;</span>
};</span></pre><section id="dictionary-rtciceserver-members"><h5><span class="secno">4.2.2.1 </span>Dictionary <a class="idlType" href="#idl-def-RTCIceServer"><code>RTCIceServer</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RTCIceServer-credential"><code>credential</code> of type <span class="idlMemberType"><a>DOMString</a></span>, nullable</dt><dd>
            <p>If the url element of the internal array is a TURN URI, then
            this is the credential to use with that TURN server.</p>
          </dd><dt id="widl-RTCIceServer-url"><code>url</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd>
            <p>A STUN or TURN URI as defined in [<cite><a class="bibref" href="#bib-STUN-URI">STUN-URI</a></cite>] and
            [<cite><a class="bibref" href="#bib-TURN-URI">TURN-URI</a></cite>].</p>
          </dd></dl></section>

        <p>In network topologies with multiple layers of NATs, it is desirable
        to have a STUN server between every layer of NATs in addition to the
        TURN servers to minimize the peer to peer network latency.</p>

        <p>An example array of RTCIceServer objects is:</p>

        <p><code>[ { url:&quot;stun:stun.example.net&quot;] } , {
        url:&quot;turn:user@turn.example.org&quot;, credential:&quot;myPassword&quot;} ]</code></p>
      </section>
    </section>

    <section id="rtcpeerconnection-interface">
      <h3><span class="secno">4.3 </span>RTCPeerConnection Interface</h3>

      <p>The general operation of the RTCPeerConnection is described in
      [<cite><a class="bibref" href="#bib-RTCWEB-JSEP">RTCWEB-JSEP</a></cite>].</p>

      <section id="operation">
        <h4><span class="secno">4.3.1 </span>Operation</h4>

        <p>Calling <code>new <a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a>(<var>configuration</var>
        )</code> creates an <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object.</p>

        <p>The <var>configuration</var> has the information to find and access
        the [<cite><a class="bibref" href="#bib-STUN">STUN</a></cite>] and [<cite><a class="bibref" href="#bib-TURN">TURN</a></cite>] servers. There may be multiple servers of
        each type and any TURN server also acts as a STUN server.</p>

        <p>An <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object has an associated
        <dfn id="rtcpeerconnection-ice-agent">ICE agent</dfn>, [<cite><a class="bibref" href="#bib-ICE">ICE</a></cite>]
        <dfn id="rtcpeerconnection-readiness-state">RTCPeerConnection readiness
        state</dfn>, and ICE state. These are initialized when the object is
        created.</p>

        <p>When the <dfn id="dom-peerconnection"><code>RTCPeerConnection()</code></dfn> constructor
        is invoked, the user agent <em class="rfc2119" title="must">must</em> run the following steps. This algorithm
        has a synchronous section (which is triggered as part of the event loop
        algorithm).</p>

        <ol>
          <li>
            <p>Create an ICE Agent and let <var>connection</var>'s <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code> ICE
            Agent</a> be that ICE Agent and provide it the STUN and TURN
            servers from the configuration array. The ICE Agent will proceed
            with gathering as soon as the IceTransports constraint is not set
            to &quot;none&quot;. At this point the ICE Agent does not know how many ICE
            components it needs (and hence the number of candidates to gather),
            but it can make a reasonable assumption. As the
            <code>RTCPeerConnection</code> object gets more information, the
            ICE Agent can adjust the number of components.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
            readiness state</a> to <code>new</code>.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
            ice state</a> to <code>new</code>.</p>
          </li>

          <li>
            <p>Initialize an internal variable to represent a queue of
            <code>operations</code> with an empty set.</p>
          </li>

          <li>
            <p>Let <var>connection</var>'s <code title="dom-RTCPeerConnection-localStreams"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></code>
            attribute be an empty read-only <code><a>MediaStream</a></code>
            array.</p>
          </li>

          <li>
            <p>Let <var>connection</var>'s <code title="dom-RTCPeerConnection-remoteStreams"><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></code>
            attribute be an empty read-only <code><a>MediaStream</a></code>
            array.</p>
          </li>

          <li>
            <p>Return <var>connection</var>, but continue these steps
            asynchronously.</p>
          </li>

          <li>
            <p>Await a stable state. The synchronous section consists of the
            remaining steps of this algorithm.</p>
          </li>
        </ol>

        <p>Once the RTCPeerConnection object has been initialized, for every
        call to <code>createOffer</code>, <code>setLocalDescription</code>,
        <code>createAnswer</code> and <code>setRemoteDescription</code>;
        execute the following steps:</p>

        <ol>
          <li>
            <p>Append an object representing the current call being handled
            (i.e. function name and corresponding arguments) to the
            <code>operations</code> array.</p>
          </li>

          <li>
            <p>If the length of the <code>operations</code> array is exactly 1,
            execute the function from the front of the queue asynchronously.</p>
          </li>

          <li>
            <p>When the ascynchronous operation completes (either successfully
            or with an error), remove the corresponding object from the
            <code>operations</code> array. After removal, if the array is
            non-empty, execute the first object queued asynchronously and
            repeat this step on completion.</p>
          </li>
        </ol>

        <p>The general idea is to have only one among <code>createOffer</code>,
        <code>setLocalDescription</code>, <code>createAnswer</code> and
        <code>setRemoteDescription</code> executing at any given time. If
        subsequent calls are made while one of them is still executing, they
        are added to a queue and processed when the previous operation is fully
        completed. It is valid, and expected, for normal error handling
        procedures to be applied.</p>

        <p>Additionally, during the lifetime of the RTCPeerConnection object,
        the following procedures are followed when an ICE event occurs:</p>

        <ol>
          <li>
            <p>If <var>iceState</var> is &quot;new&quot; and the IceTransports constraint
            is not set to &quot;none&quot;, it <em class="rfc2119" title="must">must</em> queue a task to start gathering ICE
            addresses and set the <var>iceState</var> to &quot;gathering&quot;.</p>
          </li>

          <li>
            <p>If the ICE Agent has found one or more candidate pairs for each
            MediaStreamTrack that forms a valid connection, the ICE state is
            changed to &quot;connected&quot;.</p>
          </li>

          <li>
            <p>When the ICE Agent finishes checking all candidate pairs, if at
            least one connection has been found for each MediaStreamTrack, the
            <var>iceState</var> is changed to &quot;completed&quot;; else the iceState is
            changed to &quot;failed&quot;.</p>
          </li>

          <li>
            <p>If the <var>iceState</var> is &quot;connected&quot; or &quot;completed&quot; and
            both the local and remote session descriptions are set, the
            RTCPeerConnection state is set to &quot;active&quot;.</p>
          </li>

          <li>
            <p>If the <var>iceState</var> is &quot;failed&quot;, a task is queued to call
            the close method.</p>

            <div class="issue"><div class="issue-title"><span>Issue 1</span></div><p class="">ISSUE:: CJ - this seems wrong to me.</p></div>
          </li>
        </ol>

        <p>User agents negotiate the codec resolution, bitrate, and other media
        parameters. It is <em class="rfc2119" title="recommended">recommended</em> that user agents initially negotiate for
        the maximum resolution of a video stream. For streams that are then
        rendered (using a <code>video</code> element), it is <em class="rfc2119" title="recommended">recommended</em> that
        user agents renegotiate for a resolution that matches the rendered
        display size.</p>

        
<!--
          <p>All SDP media descriptions for RTP flows represented by <code>
              <a>MediaStreamTrack</a>
            </code> objects MUST include a label attribute ("<code
          title="">a=label:</code>") whose value is the value of the <code>
              <a>MediaStream</a>
            </code> object's <code title="dom-MediaStream-label">
              <a href="#dom-mediastream-label">label</a>
            </code> attribute. [[!SDP]] [[!SDPLABEL]]</p>

          <p><a href="#rtcpeerconnection"><code>RTCPeerConnection</code>s</a> MUST not
          generate any candidates for media streams whose media descriptions do
          not have a label attribute ("<code>a=label:</code>"). [[!ICE]] [[!SDP]]
          [[!SDPLABEL]]  (Note: CJ - I have no idea why this is here) </p>
        -->


        <p>The word &quot;components&quot; in this context refers to an RTP media flow
        and does not have anything to do with how [<cite><a class="bibref" href="#bib-ICE">ICE</a></cite>] uses the term
        &quot;component&quot;.</p>

        <p>When a user agent has reached the point where a
        <code><a>MediaStream</a></code> can be created to represent incoming
        components, the user agent <em class="rfc2119" title="must">must</em> run the following steps:</p>

        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> expecting this media.</p>
          </li>

          <li>
            <p>Create a <code><a>MediaStream</a></code> object
            <var>stream</var>, to represent the incoming media stream.
            
<!-- Set its <code> <a href="#dom-mediastream-label">label</a>
                </code> attribute to the value of the SDP Label attribute for that
              component's media stream. -->
</p>
          </li>

          <li>
            <p>Run the <a href="#represent-component-with-track">algorithm</a>
            to represent an incoming component with a track for each incoming
            component.</p>

            <div class="note"><div class="note-title"><span>Note</span></div><p class="">The creation of new incoming
            <code>MediaStream</code>s may be triggered either by SDP
            negotiation or by the receipt of media on a given flow. 
            
<!--  [[OPEN ISSUE: How many <code>MediaStream</code>s are created
                when you receive multiple conflicting pranswers?]] -->
</p></div>
          </li>

          <li>
            <p>Queue a task to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>connection</var>'s <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, abort these
                steps.</p>
              </li>
<!-- close() was probably called just before this
         task ran -->


              <li>
                <p>Add <var>stream</var> to the end of <var>connection</var>'s
                <code title="dom-RTCPeerConnection-remoteStreams"><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></code>
                array.</p>
              </li>

              <li>
                <p><a href="#fire-a-stream-event">Fire a stream event</a> named
                <code title="event-MediaStream-addstream"><a href="#event-mediastream-addstream">addstream</a></code> with
                <var>stream</var> at the <var title="">connection</var> object.
                </p>
              </li>
            </ol>
          </li>
        </ol>

        <p>When a user agent has negotiated media for a component that belongs
        to a media stream that is already represented by an existing
        <code><a>MediaStream</a></code> object, the user agent <em class="rfc2119" title="must">must</em> associate
        the component with that <code><a>MediaStream</a></code> object.</p>

        <p>When an <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> finds that a stream
        from the remote peer has been removed 
<!-- (its
          port has been set to zero in a media description sent on the signaling
          channel), -->
, the user agent <em class="rfc2119" title="must">must</em> follow these steps:</p>

        <ol>
          <li>
            <p>Let <var>connection</var> be the
            <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> associated with the stream
            being removed.</p>
          </li>

          <li>
            <p>Let <var>stream</var> be the <code><a>MediaStream</a></code>
            object that represents the media stream being removed, if any. If
            there isn't one, then abort these steps.</p>
          </li>

          <li>
            <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

            <div class="note"><div class="note-title"><span>Note</span></div><p class="">A <span title="concept-task">task</span> is thus
            <span title="queue a task">queued</span> to update
            <var>stream</var> and fire an event.</p></div>
          </li>

          <li>
            <p>Queue a task to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>connection</var>'s <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, abort these
                steps.</p>
              </li>
<!-- close() was probably called just before this
         task ran -->


              <li>
                <p>Remove <var>stream</var> from <var>connection</var>'s
                <code><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></code>
                array.</p>
              </li>

              <li>
                <p><a href="#fire-a-stream-event">Fire a stream event</a> named
                <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> with
                <var title="">stream</var> at the <var>connection</var>
                object.</p>
              </li>
            </ol>
          </li>
        </ol>

        <p>The task source for the <span title="concept-task">tasks</span>
        listed in this section is the networking task source.</p>

        <p>If something in the browser changes that causes the
        <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object to need to initiate a new
        session description negotiation, a <code><a href="#event-negotiation">negotiationneeded</a></code> event is fired at the
        <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object.</p>

        <p>In particular, if an <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object is
        <a title="consumer">consuming</a> a <code><a>MediaStream</a></code> on
        which a track is added, by, e.g., the <code><a href="getusermedia.html#dom-mediastream-addtrack">addTrack()</a></code>
        method being invoked, the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object
        <em class="rfc2119" title="must">must</em> fire the &quot;negotiationneeded&quot; event. Removal of media components
        must also trigger &quot;negotiationneeded&quot;.</p>

        <p class="warning">To prevent network sniffing from allowing a fourth
        party to establish a connection to a peer using the information sent
        out-of-band to the other peer and thus spoofing the client, the
        configuration information <em class="rfc2119" title="should">should</em> always be transmitted using an
        encrypted connection.</p>
      </section>

      <section id="interface-definition">
        <h4><span class="secno">4.3.2 </span>Interface Definition</h4>

        <pre class="idl"><span id="idl-def-MediaStreamArray" class="idlTypedef">typedef <span class="idlTypedefType"><a>MediaStream</a></span>[] <span class="idlTypedefID">MediaStreamArray</span>;</span></pre><div class="idlTypedefDesc">Throughout this specification, the identifier <span class="idlTypedefID">MediaStreamArray</span> is used to refer to the array of <span class="idlTypedefType"><a>MediaStream</a></span> type.</div>

        <pre class="idl"><span id="idl-def-RTCPeerConnection" class="idlInterface">[<span class="extAttr">Constructor (RTCConfiguration configuration, optional MediaConstraints constraints)</span>]
interface <span class="idlInterfaceID">RTCPeerConnection</span> : <span class="idlSuperclass"><a>EventTarget </a></span> {
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-createOffer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-MediaConstraints-constraints">createOffer</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCSessionDescriptionCallback" class="idlType"><code>RTCSessionDescriptionCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>MediaConstraints</a></span> <span class="idlParamName">constraints</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-createAnswer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-MediaConstraints-constraints">createAnswer</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCSessionDescriptionCallback" class="idlType"><code>RTCSessionDescriptionCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>MediaConstraints</a>?</span> <span class="idlParamName">constraints</span> = <span class="idlDefaultValue">null</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-setLocalDescription-void-RTCSessionDescription-description-RTCVoidCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback">setLocalDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCVoidCallback" class="idlType"><code>RTCVoidCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-localDescription">localDescription</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-setRemoteDescription-void-RTCSessionDescription-description-RTCVoidCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback">setRemoteDescription</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">description</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCVoidCallback" class="idlType"><code>RTCVoidCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-remoteDescription">remoteDescription</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCPeerState" class="idlType"><code>RTCPeerState</code></a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-readyState">readyState</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-updateIce-void-RTCConfiguration-configuration-MediaConstraints-constraints">updateIce</a></span> (<span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-RTCConfiguration" class="idlType"><code>RTCConfiguration</code></a>?</span> <span class="idlParamName">configuration</span> = <span class="idlDefaultValue">null</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>MediaConstraints</a>?</span> <span class="idlParamName">constraints</span> = <span class="idlDefaultValue">null</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-addIceCandidate-void-RTCIceCandidate-candidate">addIceCandidate</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></span> <span class="idlParamName">candidate</span></span>);</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCGatheringState" class="idlType"><code>RTCGatheringState</code></a></span>     <span class="idlAttrName"><a href="#widl-RTCPeerConnection-iceGatheringState">iceGatheringState</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCIceState" class="idlType"><code>RTCIceState</code></a></span>           <span class="idlAttrName"><a href="#widl-RTCPeerConnection-iceState">iceState</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-MediaStreamArray" class="idlType"><code>MediaStreamArray</code></a></span>      <span class="idlAttrName"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-MediaStreamArray" class="idlType"><code>MediaStreamArray</code></a></span>      <span class="idlAttrName"><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></span> <span class="idlMethName"><a href="#widl-RTCPeerConnection-createDataChannel-RTCDataChannel-DOMString-label-RTCDataChannelInit-dataChannelDict">createDataChannel</a></span> (<span class="idlParam">[<span class="extAttr">TreatNullAs=EmptyString</span>] <span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">label</span></span>, <span class="idlParam">optional <span class="idlParamType"><a href="#idl-def-RTCDataChannelInit" class="idlType"><code>RTCDataChannelInit</code></a></span> <span class="idlParamName">dataChannelDict</span></span>);</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-ondatachannel">ondatachannel</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-addStream-void-MediaStream-stream-MediaConstraints-constraints">addStream</a></span> (<span class="idlParam"><span class="idlParamType"><a>MediaStream</a></span> <span class="idlParamName">stream</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>MediaConstraints</a></span> <span class="idlParamName">constraints</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-removeStream-void-MediaStream-stream">removeStream</a></span> (<span class="idlParam"><span class="idlParamType"><a>MediaStream</a></span> <span class="idlParamName">stream</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-setIdentityProvider-void-DOMString-provider-DOMString-protocol-DOMString-username">setIdentityProvider</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">provider</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">protocol</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">username</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-getIdentityAssertion-void">getIdentityAssertion</a></span> ();</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCIdentityAssertion" class="idlType"><code>RTCIdentityAssertion</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCPeerConnection-peerIdentity">peerIdentity</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-getStats-void-MediaStreamTrack-selector-RTCStatsCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback">getStats</a></span> (<span class="idlParam"><span class="idlParamType"><a>MediaStreamTrack</a>?</span> <span class="idlParamName">selector</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCStatsCallback" class="idlType"><code>RTCStatsCallback</code></a></span> <span class="idlParamName">successCallback</span></span>, <span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></span> <span class="idlParamName">failureCallback</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span>           <span class="idlMethName"><a href="#widl-RTCPeerConnection-close-void">close</a></span> ();</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onnegotiationneeded">onnegotiationneeded</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onicecandidate">onicecandidate</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onopen">onopen</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onstatechange">onstatechange</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onaddstream">onaddstream</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onremovestream">onremovestream</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-ongatheringchange">ongatheringchange</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onicechange">onicechange</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>          <span class="idlAttrName"><a href="#widl-RTCPeerConnection-onidentityresult">onidentityresult</a></span>;</span>
};</span></pre><section id="attributes"><h5><span class="secno">4.3.2.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCPeerConnection-iceGatheringState"><code>iceGatheringState</code> of type <span class="idlAttrType"><a href="#idl-def-RTCGatheringState" class="idlType"><code>RTCGatheringState</code></a></span>, readonly</dt><dd>
            <p>The <dfn id="dom-peerconnection-icegatherstate"><code>iceGatheringState</code></dfn>
            attribute <em class="rfc2119" title="must">must</em> return the gathering state of the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code> ICE
            Agent</a> connection state.</p>
          </dd><dt id="widl-RTCPeerConnection-iceState"><code>iceState</code> of type <span class="idlAttrType"><a href="#idl-def-RTCIceState" class="idlType"><code>RTCIceState</code></a></span>, readonly</dt><dd>
            <p>The <dfn id="dom-peerconnection-icestate"><code>iceState</code></dfn> attribute
            <em class="rfc2119" title="must">must</em> return the state of the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code> ICE
            Agent</a> ICE state.</p>
          </dd><dt id="widl-RTCPeerConnection-localDescription"><code>localDescription</code> of type <span class="idlAttrType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span>, readonly</dt><dd>
            <p>The <dfn id="dom-peerconnection-localdescription"><code>localDescription</code></dfn>
            attribute <em class="rfc2119" title="must">must</em> return the <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code>
            that was most recently passed to <code><a href="#dom-peerconnection-setlocaldescription">setLocalDescription()</a></code>,
            plus any local candidates that have been generated by the ICE Agent
            since then.</p>

            <p>A null object will be returned if the local description has not
            yet been set.</p>
          </dd><dt id="widl-RTCPeerConnection-localStreams"><code>localStreams</code> of type <span class="idlAttrType"><a href="#idl-def-MediaStreamArray" class="idlType"><code>MediaStreamArray</code></a></span>, readonly</dt><dd>
            <p>Returns a live array containing the local streams (those that
            were added with <code title="dom-RTCPeerConnection-addStream"><a href="#dom-peerconnection-addstream">addStream()</a></code> ).</p>
          </dd><dt id="widl-RTCPeerConnection-onaddstream"><code>onaddstream</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-mediastream-addstream">addstream</a></code>, <em class="rfc2119" title="must">must</em> be fired by
          all objects implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
          interface. It is called any time a <code>MediaStream</code> is added
          by the remote peer. This will be fired only as a result of
          <code>setRemoteDescription</code>. Onnaddstream happens as early as
          possible after the <code>setRemoteDescription</code>. This callback
          does not wait for a given media stream to be accepted or rejected via
          SDP negotiation.</dd><dt id="widl-RTCPeerConnection-ondatachannel"><code>ondatachannel</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of type <code><a href="#event-peerconnection-datachannel">datachannel</a></code> , <em class="rfc2119" title="must">must</em> be
          supported by all objects implementing the
          <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> interface.</dd><dt id="widl-RTCPeerConnection-ongatheringchange"><code>ongatheringchange</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-icechange">icechange</a></code>, <em class="rfc2119" title="must">must</em> be fired by all objects
          implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> interface. It
          is called any time the <var>iceGatheringState</var> changes. NOTE: Is
          this really of type icechange??</dd><dt id="widl-RTCPeerConnection-onicecandidate"><code>onicecandidate</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-icecandidate">icecandidate</a></code>, <em class="rfc2119" title="must">must</em> be supported by
          all objects implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
          interface. It is called any time there is a new ICE candidate added
          to a previous offer or answer.</dd><dt id="widl-RTCPeerConnection-onicechange"><code>onicechange</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-icechange">icechange</a></code>, <em class="rfc2119" title="must">must</em> be fired by all objects
          implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> interface. It
          is called any time the <var>iceState</var> changes.</dd><dt id="widl-RTCPeerConnection-onidentityresult"><code>onidentityresult</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-identityresult">identityresult</a></code>, <em class="rfc2119" title="must">must</em> be fired by
          all objects implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
          interface. It is called any time an identity verification succeeds or
          fails.</dd><dt id="widl-RTCPeerConnection-onnegotiationneeded"><code>onnegotiationneeded</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-negotiation-needed">negotiationneeded</a></code> , <em class="rfc2119" title="must">must</em> be
          supported by all objects implementing the
          <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> interface.</dd><dt id="widl-RTCPeerConnection-onopen"><code>onopen</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>
            This event handler, of event handler event type <code><a href="#event-mediastream-open">open</a></code>, <em class="rfc2119" title="must">must</em> be supported by all
            objects implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
            interface.

            <div class="note"><div class="note-title"><span>Note</span></div><p class="">Open issue if the &quot;onopen&quot; is needed or not.</p></div>
          </dd><dt id="widl-RTCPeerConnection-onremovestream"><code>onremovestream</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-mediastream-removestream">removestream</a></code>, <em class="rfc2119" title="must">must</em> be
          fired by all objects implementing the
          <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> interface. It is called any
          time a <code>MediaStream</code> is removed by the remote peer. This
          will be fired only as a result of
          <code>setRemoteDescription</code>.</dd><dt id="widl-RTCPeerConnection-onstatechange"><code>onstatechange</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of event handler event type <code><a href="#event-mediastream-open">statechange</a></code>, <em class="rfc2119" title="must">must</em> be supported
          by all objects implementing the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
          interface. It is called any time the <code>readyState</code> changes,
          i.e., from a call to <code>setLocalDescription</code>, a call to
          <code>setRemoteDescription</code>, or code. It does not fire for the
          initial state change into <code>new</code>.</dd><dt id="widl-RTCPeerConnection-peerIdentity"><code>peerIdentity</code> of type <span class="idlAttrType"><a href="#idl-def-RTCIdentityAssertion" class="idlType"><code>RTCIdentityAssertion</code></a></span>, readonly, nullable</dt><dd>
            <p>Contains the peer identity assertion information if an identity
            assertion was provided and verified.</p>
          </dd><dt id="widl-RTCPeerConnection-readyState"><code>readyState</code> of type <span class="idlAttrType"><a href="#idl-def-RTCPeerState" class="idlType"><code>RTCPeerState</code></a></span>, readonly</dt><dd>
            <p>The <dfn id="dom-peerconnection-readystate"><code title="">readyState</code></dfn> attribute <em class="rfc2119" title="must">must</em> return the
            <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
            readiness state</a>.</p>
          </dd><dt id="widl-RTCPeerConnection-remoteDescription"><code>remoteDescription</code> of type <span class="idlAttrType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span>, readonly</dt><dd>
            <p>The <dfn id="dom-peerconnection-remotedescription"><code>remoteDescription</code></dfn>
            attribute <em class="rfc2119" title="must">must</em> return the <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code>
            that was most recently passed to <code><a href="#dom-peerconnection-setremotedescription">setRemoteDescription()</a></code>,
            plus any remote candidates that have been supplied via
            <code><a href="#dom-peerconnection-addicecandidate">addIceCandidate()</a></code>
            since then.</p>

            <p>A null object will be returned if the remote description has not
            yet been set.</p>
          </dd><dt id="widl-RTCPeerConnection-remoteStreams"><code>remoteStreams</code> of type <span class="idlAttrType"><a href="#idl-def-MediaStreamArray" class="idlType"><code>MediaStreamArray</code></a></span>, readonly</dt><dd>
            <p>Returns a live array containing the remote streams (those that
            were added by the remote side).</p>

            <p>This array is updated when <code><a href="#event-mediastream-addstream">addstream</a></code> and
            <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> events
            are fired.</p>
          </dd></dl></section><section id="methods"><h5><span class="secno">4.3.2.2 </span>Methods</h5><dl class="methods"><dt id="widl-RTCPeerConnection-addIceCandidate-void-RTCIceCandidate-candidate"><code>addIceCandidate</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-addicecandidate"><code>addIceCandidate()</code></dfn>
            method provides a remote candidate to the ICE Agent. In addition to
            being added to the remote description, connectivity checks will be
            sent to the new candidates as long as the &quot;IceTransports&quot;
            constraint is not set to &quot;none&quot;. This call will result in a change
            to the state of the ICE Agent, and may result in a change to media
            state if it results in different connectivity being
            established.</p>

            <p>An exception with an <code>RTCError</code> object of type
            <code>INVALID_CANDIDATE_TYPE</code> is thrown if candidate
            parameter is malformed.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">candidate</td><td class="prmType"><code><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-addStream-void-MediaStream-stream-MediaConstraints-constraints"><code>addStream</code></dt><dd>
            <p>Adds a new stream to the RTCPeerConnection.</p>

            <p>When the <dfn id="dom-peerconnection-addstream"><code title="">addStream()</code></dfn> method is invoked, the user agent <em class="rfc2119" title="must">must</em>
            run the following steps:</p>

            <ol>
              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
                <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, abort these steps,
                and throw an exception with an <code>RTCError</code> object of
                type <code>INVALID_STATE</code>.</p>
              </li>

              <li>
                <p>If <var>stream</var> is already in the
                <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's <code title="dom-RTCPeerConnection-localStreams"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></code>
                object, then abort these steps.</p>
              </li>

              <li>
                <p>Add <var>stream</var> to the end of the
                <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's <code title="dom-RTCPeerConnection-localStreams"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></code>
                object.</p>
              </li>

              <li>
                <p>Parse the <var>constraints</var> provided by the application
                and apply them to the MediaStream, if possible. If the
                constraints could not be successfully applied, provide an
                <code>RTCError</code> object of type
                <code>INCOMPATIBLE_CONSTRAINTS</code> to the failure
                callback.</p>
              </li>

              <li>
                <p>Fire a negotiationneeded event.</p>

                <div class="issue"><div class="issue-title"><span>Issue 3</span></div><p class="">ISSUE: Should this fire if the
                RTCPeerConnection is in &quot;new&quot;?</p></div>
              </li>
            </ol>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">stream</td><td class="prmType"><code><a>MediaStream</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a>MediaConstraints</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-close-void"><code>close</code></dt><dd>
            <p>When the <dfn id="dom-peerconnection-close"><code title="">close()</code></dfn> method is invoked, the user agent <em class="rfc2119" title="must">must</em> run
            the following steps:</p>

            <ol>
              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
                <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, throw an
                <code>INVALID_STATE</code> exception.</p>
              </li>

              <li>
                <p>Destroy the <a href="#rtcpeerconnection-ice-agent"><code>RTCPeerConnection</code>
                ICE Agent</a>, abruptly ending any active ICE processing and
                any active streaming, and releasing any relevant resources
                (e.g. TURN permissions).</p>
              </li>

              <li>
                <p>Set the object's <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> to <code>closed</code>.</p>
              </li>
            </ol>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-createAnswer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-MediaConstraints-constraints"><code>createAnswer</code></dt><dd>
            <p>The createAnswer method generates an [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>] answer with the
            supported configuration for the session that is compatible with the
            parameters in the remote configuration. Like createOffer, the
            returned blob contains descriptions of the local MediaStreams
            attached to this RTCPeerConnection, the codec/RTP/RTCP options
            negotiated for this session, and any candidates that have been
            gathered by the ICE Agent. The constraints parameter may be
            supplied to provide additional control over the generated
            answer.</p>

            <p>As an answer, the generated SDP will contain a specific
            configuration that, along with the corresponding offer, specifies
            how the media plane should be established. The generation of the
            SDP must follow the appropriate process for generating an
            answer.</p>

            <p>Session descriptions generated by createAnswer must be
            immediately usable by setLocalDescription without generating an
            error if setLocalDescription is called from the successCallback
            function. Like createOffer, the returned description should reflect
            the current state of the system. The session descriptions <em class="rfc2119" title="must">must</em>
            remain usable by setLocalDescription without causing an error until
            at least the end of the successCallback function. Calling this
            method is needed to get the ICE user name fragment and
            password.</p>

            <p>An answer can be marked as provisional, as described in
            [<cite><a class="bibref" href="#bib-RTCWEB-JSEP">RTCWEB-JSEP</a></cite>], by setting the <code><a href="#widl-RTCSessionDescription-type">type</a></code> to
            <code>&quot;pranswer&quot;</code>.</p>

            <p>If the <code>RTCPeerConnection</code> is configured to generate
            Identity assertions, then the session description <em class="rfc2119" title="shall">shall</em> contain an
            appropriate assertion.</p>

            <p>If this <code>RTCPeerConnection</code> object is closed before
            the SDP generation process completes, the USER agent <em class="rfc2119" title="must">must</em> suppress
            the result and not call any of the result callbacks.</p>

            <p>If the SDP generation process completed successfully, the user
            agent <em class="rfc2119" title="must">must</em> queue a task to invoke <var>successCallback</var> with a
            newly created <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> object,
            representing the generated answer, as its argument.</p>

            <p>If the SDP generation process failed for any reason, the user
            agent <em class="rfc2119" title="must">must</em> queue a task to invoke <var>errorCallback</var> with an
            <code>RTCError</code> object of type TBD as its argument.</p>

            <p>An exception with an <code>RTCError</code> object of type
            <code>INVALID_CONSTRAINTS_TYPE</code> is thrown if the constraints
            parameter is malformed, and an <code>RTCError</code> object of type
            <code>INCOMPATIBLE_CONSTRAINTS</code> is provided to the failure
            callback if the constraints could not be successfully applied.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a href="#idl-def-RTCSessionDescriptionCallback" class="idlType"><code>RTCSessionDescriptionCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a>MediaConstraints</a> = null</code></td><td class="prmNullTrue">✔</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-createDataChannel-RTCDataChannel-DOMString-label-RTCDataChannelInit-dataChannelDict"><code>createDataChannel</code></dt><dd>
            <p>Creates a new <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object with the
            given label. The <code><a href="#idl-def-RTCDataChannelInit" class="idlType"><code>RTCDataChannelInit</code></a></code> dictionary
            can be used to configure properties of the underlying channel such
            as 
<!--priority and-->
 data reliability. A corresponding
            <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object is dispatched at the
            other peer if the channel setup was successful.</p>

            <p>When the <dfn id="dom-peerconnection-createdatachannel"><code>createDataChannel()</code></dfn>
            method is invoked, the user agent <em class="rfc2119" title="must">must</em> run the following steps.</p>

            <ol>
              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object’s
                <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, throw an
                <code>INVALID_STATE</code> exception.</p>
              </li>

              <li>
                <p>Let <var>channel</var> be a newly created
                <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object.</p>
              </li>

              <li>
                <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-label">label</a></code> attribute to the
                value of the first argument.</p>
              </li>

              <li>
                <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-reliable">reliable</a></code> attribute to
                true.</p>
              </li>

              <li>
                <p>If the second argument is present and it contains a
                <code><a href="#widl-RTCDataChannelInit-reliable">reliable</a></code>
                dictionary member, then set <var>channel</var>'s <code><a href="#dom-rtcdatachannel-reliable">reliable</a></code> attribute to
                the dictionary member value.</p>
              </li>

              <li>
                <p>Return <var>channel</var> and continue these steps in the
                background.</p>
              </li>

              <li>
                <p>Create <var>channel</var>'s associated <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
                transport</a>.</p>
              </li>
            </ol>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">label</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">dataChannelDict</td><td class="prmType"><code><a href="#idl-def-RTCDataChannelInit" class="idlType"><code>RTCDataChannelInit</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code></div></dd><dt id="widl-RTCPeerConnection-createOffer-void-RTCSessionDescriptionCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback-MediaConstraints-constraints"><code>createOffer</code></dt><dd>
            <p>The createOffer method generates a blob of SDP that contains an
            RFC 3264 offer with the supported configurations for the session,
            including descriptions of the local <code>MediaStream</code>s
            attached to this <code>RTCPeerConnection</code>, the codec/RTP/RTCP
            options supported by this implementation, and any candidates that
            have been gathered by the ICE Agent. The constraints parameter may
            be supplied to provide additional control over the offer generated.
            More information about constraints can be found in
            [<cite><a class="bibref" href="#bib-RTCWEB-CONSTRAINTS">RTCWEB-CONSTRAINTS</a></cite>].</p>

            <p>As an offer, the generated SDP will contain the full set of
            capabilities supported by the session (as opposed to an answer,
            which will include only a specific negotiated subset to use); for
            each SDP line, the generation of the SDP must follow the
            appropriate process for generating an offer. In the event
            createOffer is called after the session is established, createOffer
            will generate an offer that is compatible with the current session,
            incorporating any changes that have been made to the session since
            the last complete offer-answer exchange, such as addition or
            removal of streams. If no changes have been made, the offer will
            include the capabilities of the current local description as well
            as any additional capabilities that could be negotiated in an
            updated offer.</p>

            <p>Session descriptions generated by createOffer <em class="rfc2119" title="must">must</em> be
            immediately usable by setLocalDescription without causing an error
            as long as setLocalDiscription is called within the successCallback
            function. If a system has limited resources (e.g. a finite number
            of decoders), createOffer needs to return an offer that reflects
            the current state of the system, so that setLocalDescription will
            succeed when it attempts to acquire those resources. The session
            descriptions <em class="rfc2119" title="must">must</em> remain usable by setLocalDescription without
            causing an error until at least end of the successCallback
            function. Calling this method is needed to get the ICE user name
            fragment and password.</p>

            <p>If the <code>RTCPeerConnection</code> is configured to generate
            Identity assertions, then the session description <em class="rfc2119" title="shall">shall</em> contain an
            appropriate assertion.</p>

            <p>If this <code>RTCPeerConnection</code> object is closed before
            the SDP generation process completes, the USER agent <em class="rfc2119" title="must">must</em> suppress
            the result and not call any of the result callbacks.</p>

            <p>If the SDP generation process completed successfully, the user
            agent <em class="rfc2119" title="must">must</em> queue a task to invoke <var>successCallback</var> with a
            newly created <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> object,
            representing the generated offer, as its argument.</p>

            <p>If the SDP generation process failed for any reason, the user
            agent <em class="rfc2119" title="must">must</em> queue a task to invoke <var>errorCallback</var> with an
            <code>RTCError</code> object of type TBD as its argument.</p>

            <p>An exception with an <code>RTCError</code> object of type
            <code>INVALID_CONSTRAINTS_TYPE</code> is thrown if the constraints
            parameter is malformed, and an <code>RTCError</code> object of type
            <code>INCOMPATIBLE_CONSTRAINTS</code> is provided to the failure
            callback if the constraints could not be successfully applied.</p>

            <p>To Do: Discuss privacy aspects of this from a fingerprinting
            point of view - it's probably around as bad as access to a canvas
            :-)</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a href="#idl-def-RTCSessionDescriptionCallback" class="idlType"><code>RTCSessionDescriptionCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a>MediaConstraints</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-getIdentityAssertion-void"><code>getIdentityAssertion</code></dt><dd>
            <p>Initiates the process of obtaining an identity assertion.
            Applications need not make this call. It is merely intended to
            allow them to start the process of obtaining identity assertions
            before a call is initiated. If an identity is needed, either
            because the browser has been configured with a default identity
            provider or because the <code>setIdentityProvider()</code> method
            was called, then an identity will be automatically requested when
            an offer or answer is created.</p>

            <p>Queue a task to run the following substeps.</p>

            <ol>
              <li>
                <p>If the <var>connection</var>'s <a href="#peerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, abort these
                steps.</p>
              </li>
<!-- close() was probably called just before this
                        task ran -->


              <li>
                <p>Instantiate a new IdP proxy and request an identity
                assertion.</p>
              </li>
            </ol>
          <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-getStats-void-MediaStreamTrack-selector-RTCStatsCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>getStats</code></dt><dd>
            <p>When the <dfn id="dom-peerconnection-getStats"><code title="">getStats()</code></dfn> method is invoked, the user agent <em class="rfc2119" title="must">must</em>
            queue a task to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
                <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, throw an
                <code>INVALID_STATE</code> exception.</p>
              </li>

              <li>
                <p>Gather the stats indicated by the selector. If the selector
                is invalid, call the failureCallback.</p>
              </li>

              <li>
                <p>Call the successCallback, supplying the relevant statistics
                object.</p>
              </li>
            </ol>

            <p>The &quot;selector&quot; may be a <code>MediaStreamTrack</code> that is a
            member of a <code>MediaStream</code> on the incoming or outgoing
            streams. The callback reports on all relevant statistics for that
            selector. If the selector is blank or missing, stats for the whole
            <code>RTCPeerConnection</code> are reported. TODO: Evaluate the
            need for other selectors than MediaStreamTrack.</p>

            <p>The returned structure contains a list of
            <code>RTCStatsElement</code>s, each reporting stats for one object
            that the implementation thinks is relevant for the selector. One
            achieves the total for the selector by summing over all the
            elements; for instance, if a <code>MediaStreamTrack</code> is
            carried by multiple SSRCs over the network, the
            <code>getStats()</code> function may return one
            <code>RTCStatsElement</code> per SSRC (which can be distinguished
            by the value of the “ssrc” stats attribute).</p>

            <p>An <code>RTCPeerConnection</code> <em class="rfc2119" title="must">must</em> return consistent stats
            for each element in the array, adding new elements to the end as
            needed; this is needed so that an application can simply correlate
            a value read at one moment to a value read at a later moment.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">selector</td><td class="prmType"><code><a>MediaStreamTrack</a></code></td><td class="prmNullTrue">✔</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a href="#idl-def-RTCStatsCallback" class="idlType"><code>RTCStatsCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-removeStream-void-MediaStream-stream"><code>removeStream</code></dt><dd>
            <p>Removes the given stream from the localStream array in the
            RTCPeerConnection and fires the <a href="#event-negotiation">negotiationneeded</a> event.</p>

            <p>When the other peer stops sending a stream in this manner, a
            <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> event is
            fired at the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object.</p>

            <p>When the <dfn id="dom-peerconnection-removestream"><code title="">removeStream()</code></dfn> method is invoked, the user agent
            <em class="rfc2119" title="must">must</em> run the following steps:</p>

            <ol>
              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
                <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code>closed</code>, throw an
                <code>INVALID_STATE</code> exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is not in the
                <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's <code title="dom-RTCPeerConnection-localStreams"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></code>
                object, then abort these steps.</p>
              </li>

              <li>
                <p>Remove <var>stream</var> from the
                <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's <code title="dom-RTCPeerConnection-localStreams"><a href="#widl-RTCPeerConnection-localStreams">localStreams</a></code>
                object.</p>
              </li>

              <li>
                <p>Fire a <a href="#event-negotiation">negotiationneeded</a>
                event.</p>
              </li>
            </ol>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">stream</td><td class="prmType"><code><a>MediaStream</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-setIdentityProvider-void-DOMString-provider-DOMString-protocol-DOMString-username"><code>setIdentityProvider</code></dt><dd>
            <p>Sets the identity provider to be used for a given
            <code>PeerConnection</code> object. Applications need not make this
            call; if the browser is already configured for an IdP, then that
            configured IdP will be used to get an assertion.</p>

            <p>When the <dfn id="dom-peerconnection-setidentityprovider"><code title="">setIdentityProvider()</code></dfn> method is invoked, the user
            agent <em class="rfc2119" title="must">must</em> run the following steps:</p>

            <ol>
              <li>
                <p>Set the current identity values to the triplet
                (<code>provider</code>, <code>protocol</code>,
                <code>username</code>).</p>
              </li>

              <li>
                <p>If the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
                <a href="#peerconnection-readiness-state"><code>RTCPeerConnection</code>
                readiness state</a> is <code><a href="#widl-RTCPeerConnection-ACTIVE">active</a></code>, and any of
                the identity settings have changed, queue a task to run the
                following substeps:</p>

                <ol>
                  <li>
                    <p>If the <var>connection</var>'s <a href="#peerconnection-readiness-state"><code>RTCPeerConnection</code>
                    readiness state</a> is <code>closed</code>, abort these
                    steps, and throw an exception with an <code>RTCError</code>
                    object of type <code>INVALID_STATE</code>.</p>
                  </li>

                  <li>
                    <p>Instantiate a new IdP proxy and request an identity
                    assertion.</p>
                  </li>

                  <li>
                    <p>If/when the assertion is obtained, fire a <a href="#event-negotiation">negotiationneeded</a> event.</p>
                  </li>
                </ol>
              </li>
            </ol>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">provider</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">protocol</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr><tr><td class="prmName">username</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-setLocalDescription-void-RTCSessionDescription-description-RTCVoidCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>setLocalDescription</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-setlocaldescription"><code>setLocalDescription()</code></dfn>
            method instructs the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> to apply
            the supplied <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> as the local
            description.</p>

            <p>This API changes the local media state. In order to successfully
            handle scenarios where the application wants to offer to change
            from one media format to a different, incompatible format, the
            <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> must be able to
            simultaneously support use of both the old and new local
            descriptions (e.g. support codecs that exist in both descriptions)
            until a final answer is received, at which point the
            <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> can fully adopt the new local
            description, or roll back to the old description if the remote side
            denied the change.</p>

            <div class="issue"><div class="issue-title"><span>Issue 2</span></div><p class="">ISSUE: how to indicate to roll back?</p></div>

            <p>To Do: specify what parts of the SDP can be changed between the
            createOffer and setLocalDescription</p>

            <p>Changes to the state of media transmission will occur when a
            final answer is successfully applied.
            <code><a href="#dom-peerconnection-localdescription" class="internalDFN">localDescription</a></code> <em class="rfc2119" title="must">must</em> return the previous
            description until the new description is successfully applied.</p>

            <p>The <code>failureCallback</code> will be called if the
            <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> is a valid description
            but cannot be applied at the media layer, e.g., if there are
            insufficient resources to apply the SDP. The user agent <em class="rfc2119" title="must">must</em> roll
            back as necessary if the new description was partially applied when
            the failure occurred.</p>

            <p>An <code>RTCError</code> object of type
            <code>INVALID_SESSION_DESCRIPTION</code> is provided to the failure
            callback if the SDP content is invalid.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a href="#idl-def-RTCVoidCallback" class="idlType"><code>RTCVoidCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-setRemoteDescription-void-RTCSessionDescription-description-RTCVoidCallback-successCallback-RTCPeerConnectionErrorCallback-failureCallback"><code>setRemoteDescription</code></dt><dd>
            <p>The <dfn id="dom-peerconnection-setremotedescription"><code>setRemoteDescription()</code></dfn>
            method instructs the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> to apply
            the supplied <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> as the
            remote offer or answer. This API changes the local media state.</p>

            <p>If <code>a=identity</code> attributes are present, the browser
            verifies the identity following the procedures in [XREF
            sec.identity-proxy-assertion-request].</p>

            <p>Changes to the state of media transmission will occur when a
            final answer is successfully applied.
            <code><a href="#dom-peerconnection-remotedescription" class="internalDFN">remoteDescription</a></code> <em class="rfc2119" title="must">must</em> return the previous
            description until the new description is successfully applied.</p>

            <p>The <code>failureCallback</code> will be called if the
            <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> is a valid description
            but cannot be applied at the media layer, e.g., if there are
            insufficient resources to apply the SDP. The user agent <em class="rfc2119" title="must">must</em> roll
            back as necessary if the new description was partially applied when
            the failure occurred.</p>

            <p>An <code>RTCError</code> object of type
            <code>INVALID_SESSION_DESCRIPTION</code> is provided to the failure
            callback if the SDP content is invalid.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">description</td><td class="prmType"><code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">successCallback</td><td class="prmType"><code><a href="#idl-def-RTCVoidCallback" class="idlType"><code>RTCVoidCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">failureCallback</td><td class="prmType"><code><a href="#idl-def-RTCPeerConnectionErrorCallback" class="idlType"><code>RTCPeerConnectionErrorCallback</code></a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCPeerConnection-updateIce-void-RTCConfiguration-configuration-MediaConstraints-constraints"><code>updateIce</code></dt><dd>
            <p>The updateIce method updates the ICE Agent process of gathering
            local candidates and pinging remote candidates. If there is a
            mandatory constraint called &quot;IceTransports&quot; it will control how the
            ICE engine can act. This can be used to limit the use to TURN
            candidates by a callee to avoid leaking location information prior
            to the call being accepted.</p>

            <p>This call may result in a change to the state of the ICE Agent,
            and may result in a change to media state if it results in
            connectivity being established.</p>

            <div class="note"><div class="note-title"><span>Note</span></div><div class="">
              This method was previously used to restart ICE. We should
              document the new procedure in the correct place.
            </div></div>

            <p>An exception with an <code>RTCError</code> object of type
            <code>INVALID_CONSTRAINTS_TYPE</code> is thrown if the constraints
            parameter is malformed, and an <code>RTCError</code> object of type
            <code>INCOMPATIBLE_CONSTRAINTS</code> is provided to the failure
            callback if the constraints could not be successfully applied.</p>
          <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">configuration</td><td class="prmType"><code><a href="#idl-def-RTCConfiguration" class="idlType"><code>RTCConfiguration</code></a> = null</code></td><td class="prmNullTrue">✔</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr><tr><td class="prmName">constraints</td><td class="prmType"><code><a>MediaConstraints</a> = null</code></td><td class="prmNullTrue">✔</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></section>
      </section>

      <section id="garbage-collection">
        <h4><span class="secno">4.3.3 </span>Garbage collection</h4>

        <p>A <code>Window</code> object <dfn id="concept-peerconnection-owner">has a strong reference</dfn> to any
        <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> objects created from the
        constructor whose global object is that <code>Window</code> object.</p>
        
<!-- we could be less strict here, e.g. dropping the reference when
        there’s no way for an event to be fired because there’s no event
        handlers registered and there’s no way for the remote peer to notice
        anything because no media is streaming; or e.g. dropping the reference
        when the object reaches the CLOSED state. But as dropping the reference
        in those cases is black-box indistinguishable from keeping the
        reference, I haven't bothered to work out the exact rules. If you do
        change this, see the /unloading document cleanup steps/. -->

      </section>
    </section>

    <section id="state-definitions">
      <h3><span class="secno">4.4 </span>State Definitions</h3>

      <section id="rtcpeerstate-enum">
        <h4><span class="secno">4.4.1 </span>RTCPeerState Enum</h4>

        <pre class="idl"><span id="idl-def-RTCPeerState" class="idlEnum">enum <span class="idlEnumID">RTCPeerState</span> {
    &quot;<span class="idlEnumItem">new</span>&quot;,
    &quot;<span class="idlEnumItem">have-local-offer</span>&quot;,
    &quot;<span class="idlEnumItem">have-local-pranswer</span>&quot;,
    &quot;<span class="idlEnumItem">have-remote-pranswer</span>&quot;,
    &quot;<span class="idlEnumItem">active (also could be called &quot;open&quot;, &quot;stable&quot;)</span>&quot;,
    &quot;<span class="idlEnumItem">closed</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>new</code></td><td>The object was just created, and no networking has yet
          occurred.</td></tr><tr><td><code>have-local-offer</code></td><td>A local description, of type &quot;offer&quot;, has been supplied.</td></tr><tr><td><code>have-local-pranswer</code></td><td>A remote description of type &quot;offer&quot; has been supplied and a
          local description of type &quot;pranswer&quot; has been supplied.</td></tr><tr><td><code>have-remote-pranswer</code></td><td>A local description of type &quot;offer&quot; has been supplied and a
          remote description of type &quot;pranswer&quot; has been supplied.</td></tr><tr><td><code>active (also could be called &quot;open&quot;, &quot;stable&quot;)</code></td><td>Both local and remote descriptions have been supplied, and the
          offer-answer exchange is complete.</td></tr><tr><td><code>closed</code></td><td>The connection is closed.</td></tr></table>

        <p>The non-normative peer state transitions are: <img style="width:100%" src="images/peerstates.svg" alt="The non-normative peer state transition diagram" /></p>

        <p>An example set of transitions might be:</p>

        <p>Caller transition:</p>

        <ul>
          <li>new PeerConnection(): new</li>

          <li>setLocal(offer): have-local-offer</li>

          <li>setRemote(pranswer): have-remote-pranswer</li>

          <li>setRemote(answer): active</li>

          <li>close(): closed</li>
        </ul>

        <p>Callee transition:</p>

        <ul>
          <li>new PeerConnection(): new</li>

          <li>setRemote(offer): received-offer</li>

          <li>setLocal(pranswer): have-local-pranswer</li>

          <li>setLocal(answer): active</li>

          <li>close(): closed</li>
        </ul>
      </section>

      <section id="rtcgatheringstate-enum">
        <h4><span class="secno">4.4.2 </span>RTCGatheringState Enum</h4>

        <pre class="idl"><span id="idl-def-RTCGatheringState" class="idlEnum">enum <span class="idlEnumID">RTCGatheringState</span> {
    &quot;<span class="idlEnumItem">new</span>&quot;,
    &quot;<span class="idlEnumItem">gathering</span>&quot;,
    &quot;<span class="idlEnumItem">complete</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>new</code></td><td>The object was just created, and no networking has occurred
          yet.</td></tr><tr><td><code>gathering</code></td><td>The ICE engine is in the process of gathering candidates for this
          RTCPeerConnection.</td></tr><tr><td><code>complete</code></td><td>The ICE engine has completed gathering. Events such as adding a
          new interface or new TURN server could cause the state to go back to
          gathering.</td></tr></table>
      </section>

      <section id="rtcicestate-enum">
        <h4><span class="secno">4.4.3 </span>RTCIceState Enum</h4>

        <div class="note"><div class="note-title"><span>Note</span></div><p class="">There is active discussion around changing these
        states.</p></div>

        <pre class="idl"><span id="idl-def-RTCIceState" class="idlEnum">enum <span class="idlEnumID">RTCIceState</span> {
    &quot;<span class="idlEnumItem">starting</span>&quot;,
    &quot;<span class="idlEnumItem">checking</span>&quot;,
    &quot;<span class="idlEnumItem">connected</span>&quot;,
    &quot;<span class="idlEnumItem">completed</span>&quot;,
    &quot;<span class="idlEnumItem">failed</span>&quot;,
    &quot;<span class="idlEnumItem">disconnected</span>&quot;,
    &quot;<span class="idlEnumItem">closed</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>starting</code></td><td>The ICE Agent is gathering addresses and/or waiting for remote
          candidates to be supplied.</td></tr><tr><td><code>checking</code></td><td>The ICE Agent has received remote candidates on at least one
          component, and is checking candidate pairs but has not yet found a
          connection. In addition to checking, it may also still be
          gathering.</td></tr><tr><td><code>connected</code></td><td>The ICE Agent has found a usable connection for all components
          but is still checking other candidate pairs to see if there is a
          better connection. It may also still be gathering.</td></tr><tr><td><code>completed</code></td><td>The ICE Agent has finished gathering and checking and found a
          connection for all components.</td></tr><tr><td><code>failed</code></td><td>The ICE Agent is finished checking all candidate pairs and failed
          to find a connection for at least one component.</td></tr><tr><td><code>disconnected</code></td><td>Liveness checks have failed for one or more components. This is
          more aggressive than <code>failed</code>, and may trigger
          intermittently (and resolve itself without action) on a flaky
          network.</td></tr><tr><td><code>closed</code></td><td>The ICE Agent has shut down and is no longer responding to STUN
          requests.</td></tr></table>

        <p>States take either the value of any component or all components, as
        outlined below:</p>

        <ul>
          <li><code>checking</code> occurs if ANY component has received a
          candidate and can start checking</li>

          <li><code>connected</code> occurs if ALL components have established
          a working connection</li>

          <li><code>completed</code> occurs if ALL components have finalized
          the running of their ICE processes</li>

          <li><code>failed</code> occurs if ANY component has given up trying
          to connect</li>

          <li><code>disconnected</code> occurs if ANY component has failed
          liveness checks</li>

          <li><code>closed</code> occurs only if
          <code>PeerConnection.close()</code> has been called.</li>
        </ul>

        <div class="note"><div class="note-title"><span>Note</span></div><div class="">
          The WG is discussing if starting/checking should be one state or two.
        </div></div>

        <p>If a component is discarded as a result of signaling (e.g. RTCP mux
        or BUNDLE), the state may advance directly from <code>checking</code>
        to <code>completed</code>.</p>

        <p>An example transition might look like:</p>

        <ul>
          <li>new PeerConnection(): Starting</li>

          <li>(Starting, remote candidates received): Checking</li>

          <li>(Checking, found usable connection): Connected</li>

          <li>(Checking, gave up): Failed</li>

          <li>(Connected, finished all checks): Completed</li>

          <li>(Completed, lost connectivity): Disconnected</li>

          <li>(any state, ICE restart occurs): Starting</li>

          <li>close(): Closed</li>
        </ul>

        <p>The non-normative ICE state transitions are: <img style="width:80%" src="images/icestates.svg" alt="The non-normative ICE state transition diagram" /></p>
      </section>
    </section>

    <section id="callback-definitions">
      <h3><span class="secno">4.5 </span>Callback Definitions</h3>

      <section id="rtcvoidcallback">
        <h4><span class="secno">4.5.1 </span>RTCVoidCallback</h4>

        <pre class="idl"><span id="idl-def-RTCVoidCallback" class="idlCallback">callback <span class="idlCallbackID">RTCVoidCallback</span> = <span class="idlCallbackType"><a>void</a></span> ();</span></pre>
      </section>

      <section id="rtcpeerconnectionerrorcallback">
        <h4><span class="secno">4.5.2 </span>RTCPeerConnectionErrorCallback</h4>

        <pre class="idl"><span id="idl-def-RTCPeerConnectionErrorCallback" class="idlCallback">callback <span class="idlCallbackID">RTCPeerConnectionErrorCallback</span> = <span class="idlCallbackType"><a>void</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCError" class="idlType"><code>RTCError</code></a></span> <span class="idlParamName">error</span></span>);</span></pre><section id="callback-rtcpeerconnectionerrorcallback-parameters"><h5><span class="secno">4.5.2.1 </span>Callback <a class="idlType" href="#idl-def-RTCPeerConnectionErrorCallback"><code>RTCPeerConnectionErrorCallback</code></a> Parameters</h5><dl class="callback-members"><dt id="widl-RTCPeerConnectionErrorCallback-error"><code>error</code> of type <span class="idlMemberType"><a href="#idl-def-RTCError" class="idlType"><code>RTCError</code></a></span></dt><dd>An error object encapsulating information about what went
          wrong.</dd></dl></section>
      </section>
    </section>

    <section id="error-handling">
      <h3><span class="secno">4.6 </span>Error Handling</h3>

      <section id="general-principles">
        <h4><span class="secno">4.6.1 </span>General Principles</h4>

        <p>Errors are indicated in two ways: exceptions and objects passed to
        error callbacks. Both forms of error reporting <em class="rfc2119" title="must">must</em> provide an object
        of type <code>RTCError</code>. An exception <em class="rfc2119" title="must">must</em> be thrown in the
        following cases:</p>

        <ul>
          <li>The type of any argument passed to a function did not match what
          was expected. An appropriate string from the
          <code>RTCExceptionName</code> enum <em class="rfc2119" title="must">must</em> be used as the error
          name.</li>

          <li>A function call was made when the RTCPeerConnection is in an
          invalid state, or a state in which that particular function is not
          allowed to be executed. In this case, the string
          <code>INVALID_STATE</code> <em class="rfc2119" title="must">must</em> be used as the error name.</li>
        </ul>

        <p>In all other cases, an error object <em class="rfc2119" title="must">must</em> be provided to the failure
        callback. The error name in the object provided <em class="rfc2119" title="must">must</em> be picked from
        either the <code>RTCExceptionName</code> or <code>RTCErrorName</code>
        enums.</p>
      </section>

      <section id="rtcerror">
        <h4><span class="secno">4.6.2 </span>RTCError</h4>

        <pre class="idl"><span id="idl-def-RTCError" class="idlInterface">interface <span class="idlInterfaceID">RTCError</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a></span>  <span class="idlAttrName"><a href="#widl-RTCError-name">name</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a>?</span> <span class="idlAttrName"><a href="#widl-RTCError-message">message</a></span>;</span>
};</span></pre><section id="attributes-1"><h5><span class="secno">4.6.2.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCError-message"><code>message</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly, nullable</dt><dd>A human readable description of the error. This string may vary
          between different user agents.</dd><dt id="widl-RTCError-name"><code>name</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly</dt><dd>A string representing the type of error. This string must be one
          of those defined by the <code>RTCExceptionName</code> or
          <code>RTCErrorName</code> enums for the error object to be
          valid.</dd></dl></section>
      </section>

      <section id="rtcsdperror">
        <h4><span class="secno">4.6.3 </span>RTCSdpError</h4>

        <pre class="idl"><span id="idl-def-RTCSdpError" class="idlInterface">interface <span class="idlInterfaceID">RTCSdpError</span> : <span class="idlSuperclass"><a href="#idl-def-RTCError" class="idlType"><code>RTCError</code></a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>long</a></span> <span class="idlAttrName"><a href="#widl-RTCSdpError-sdpLineNumber">sdpLineNumber</a></span>;</span>
};</span></pre><section id="attributes-2"><h5><span class="secno">4.6.3.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCSdpError-sdpLineNumber"><code>sdpLineNumber</code> of type <span class="idlAttrType"><a>long</a></span>, readonly</dt><dd>
            The line number of an <a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a> at which the
            error was encountered.
          </dd></dl></section>
      </section>

      <section id="rtcexceptionname">
        <h4><span class="secno">4.6.4 </span>RTCExceptionName</h4>

        <pre class="idl"><span id="idl-def-RTCExceptionName" class="idlEnum">enum <span class="idlEnumID">RTCExceptionName</span> {
    &quot;<span class="idlEnumItem">INVALID_SUCCESS_CALLBACK</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_FAILURE_CALLBACK</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_CONSTRAINTS_TYPE</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_SESSION_DESCRIPTION_TYPE</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_CONFIGURATION_TYPE</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_CANDIDATE_TYPE</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_MEDIASTREAM</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_MEDIASTREAM_TRACK</span>&quot;,
    &quot;<span class="idlEnumItem">INVALID_STATE</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>INVALID_SUCCESS_CALLBACK</code></td><td>The provided successCallback is not a function.</td></tr><tr><td><code>INVALID_FAILURE_CALLBACK</code></td><td>The provided failureCallback is not a function.</td></tr><tr><td><code>INVALID_CONSTRAINTS_TYPE</code></td><td>The provided constraints object is not a dictionary with either
          the <code>mandatory</code> or <code>optional</code> keys.</td></tr><tr><td><code>INVALID_SESSION_DESCRIPTION_TYPE</code></td><td>The provided session description is not an object of type
          <code>RTCSessionDescription</code>.</td></tr><tr><td><code>INVALID_CONFIGURATION_TYPE</code></td><td>The provided configuration is not an object of type
          <code>RTCConfiguration</code>.</td></tr><tr><td><code>INVALID_CANDIDATE_TYPE</code></td><td>The provided candidate is not an object of type
          <code>RTCIceCandidate</code>.</td></tr><tr><td><code>INVALID_MEDIASTREAM</code></td><td>The provided media stream is not an object of type
          <code>MediaStream</code>.</td></tr><tr><td><code>INVALID_MEDIASTREAM_TRACK</code></td><td>The provided track is not an object of type
          <code>MediaStreamTrack</code>.</td></tr><tr><td><code>INVALID_STATE</code></td><td>The function was called on a <code>RTCPeerConnection</code> that
          is an invalid state, or a state in which the function is not allowed
          to be executed.</td></tr></table>
      </section>

      <section id="rtcerrorname">
        <h4><span class="secno">4.6.5 </span>RTCErrorName</h4>

        <pre class="idl"><span id="idl-def-RTCErrorName" class="idlEnum">enum <span class="idlEnumID">RTCErrorName</span> {
    &quot;<span class="idlEnumItem">INVALID_SESSION_DESCRIPTION</span>&quot;,
    &quot;<span class="idlEnumItem">INCOMPATIBLE_CONSTRAINTS</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>INVALID_SESSION_DESCRIPTION</code></td><td>The provided <code>RTCSessionDescription</code> either contained
          invalid SDP, or SDP that could not be correctly applied to the
          <code>RTCPeerConnection</code> due to its current state. User agents
          <em class="rfc2119" title="should">should</em> provide as much additional information in the error message as
          possible, including the <code>sdpLineNumber</code>, if
          appropriate.</td></tr><tr><td><code>INCOMPATIBLE_CONSTRAINTS</code></td><td>The provided <code>MediaConstraints</code> could not be correctly
          applied to the <code>RTCPeerConnection</code> due to its current
          state. User agents <em class="rfc2119" title="should">should</em> provide as much additional information in
          the error message as possible.</td></tr></table>
      </section>
    </section>

    <section id="session-description-model">
      <h3><span class="secno">4.7 </span>Session Description Model</h3>

      <section id="rtcsdptype">
        <h4><span class="secno">4.7.1 </span>RTCSdpType</h4>

        <p>The RTCSdpType enum describes the type of an
        <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> instance.</p>

        <pre class="idl"><span id="idl-def-RTCSdpType" class="idlEnum">enum <span class="idlEnumID">RTCSdpType</span> {
    &quot;<span class="idlEnumItem">offer</span>&quot;,
    &quot;<span class="idlEnumItem">pranswer</span>&quot;,
    &quot;<span class="idlEnumItem">answer</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>offer</code></td><td>
            <p>An RTCSdpType of &quot;offer&quot; indicates that a description should be
            treated as an [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>] offer.</p>
          </td></tr><tr><td><code>pranswer</code></td><td>
            <p>An RTCSdpType of &quot;pranswer&quot; indicates that a description should
            be treated as an [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>] answer, but not a final answer. A
            description used as an SDP &quot;pranswer&quot; may be applied as a response
            to a SDP offer, or an update to a previously sent SDP
            &quot;pranswer&quot;.</p>
          </td></tr><tr><td><code>answer</code></td><td>
            <p>An RTCSdpType of &quot;answer&quot; indicates that a description should be
            treated as an [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>] final answer, and the offer-answer exchange
            should be considered complete. A description used as an SDP answer
            may be applied as a response to an SDP offer or as an update to a
            previously sent SDP &quot;pranswer&quot;.</p>
          </td></tr></table>
      </section>

      <section id="rtcsessiondescription-class">
        <h4><span class="secno">4.7.2 </span>RTCSessionDescription Class</h4>

        <p>The <dfn id="dom-sessiondescription"><code>RTCSessionDescription()</code></dfn>
        constructor takes an optional dictionary argument,
        <var>descriptionInitDict</var>, whose content is used to initialize the
        new <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code> object. If a dictionary
        key is not present in <var>descriptionInitDict</var>, the corresponding
        attribute will be initialized to null. If the constructor is run
        without the dictionary argument, all attributes will be initialized to
        null. This class is a future extensible carrier for the data contained
        in it and does not perform any substantive processing.</p>

        <p>Objects implementing the <code><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></code>
        interface <em class="rfc2119" title="must">must</em> serialize with the serialization pattern &quot;<code>{
        attribute }</code>&quot;.</p>

        <pre class="idl"><span id="idl-def-RTCSessionDescription" class="idlInterface">[<span class="extAttr">Constructor (optional RTCSessionDescriptionInit descriptionInitDict)</span>]
interface <span class="idlInterfaceID">RTCSessionDescription</span> {
<span class="idlAttribute">             attribute <span class="idlAttrType"><a href="#idl-def-RTCSdpType" class="idlType"><code>RTCSdpType</code></a>?</span> <span class="idlAttrName"><a href="#widl-RTCSessionDescription-type">type</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>DOMString</a>?</span>  <span class="idlAttrName"><a href="#widl-RTCSessionDescription-sdp">sdp</a></span>;</span>
};<br /><span id="idl-def-RTCSessionDescriptionInit" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCSessionDescriptionInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCSdpType" class="idlType"><code>RTCSdpType</code></a></span> <span class="idlMemberName"><a href="#widl-RTCSessionDescriptionInit-type">type</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span>  <span class="idlMemberName"><a href="#widl-RTCSessionDescriptionInit-sdp">sdp</a></span>;</span>
};</span></span></pre><section id="attributes-3"><h5><span class="secno">4.7.2.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCSessionDescription-sdp"><code>sdp</code> of type <span class="idlAttrType"><a>DOMString</a></span>, nullable</dt><dd>The string representation of the SDP [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>]</dd><dt id="widl-RTCSessionDescription-type"><code>type</code> of type <span class="idlAttrType"><a href="#idl-def-RTCSdpType" class="idlType"><code>RTCSdpType</code></a></span>, nullable</dt><dd>The type of SDP this RTCSessionDescription represents.</dd></dl></section>

        <section id="dictionary-rtcsessiondescriptioninit-members"><h5><span class="secno">4.7.2.2 </span>Dictionary <a class="idlType" href="#idl-def-RTCSessionDescriptionInit"><code>RTCSessionDescriptionInit</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RTCSessionDescriptionInit-sdp"><code>sdp</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd></dd><dt id="widl-RTCSessionDescriptionInit-type"><code>type</code> of type <span class="idlMemberType"><a href="#idl-def-RTCSdpType" class="idlType"><code>RTCSdpType</code></a></span></dt><dd>DOMString sdp</dd></dl></section>
      </section>

      <section id="rtcsessiondescriptioncallback">
        <h4><span class="secno">4.7.3 </span>RTCSessionDescriptionCallback</h4>

        <pre class="idl"><span id="idl-def-RTCSessionDescriptionCallback" class="idlCallback">callback <span class="idlCallbackID">RTCSessionDescriptionCallback</span> = <span class="idlCallbackType"><a>void</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span> <span class="idlParamName">sdp</span></span>);</span></pre><section id="callback-rtcsessiondescriptioncallback-parameters"><h5><span class="secno">4.7.3.1 </span>Callback <a class="idlType" href="#idl-def-RTCSessionDescriptionCallback"><code>RTCSessionDescriptionCallback</code></a> Parameters</h5><dl class="callback-members"><dt id="widl-RTCSessionDescriptionCallback-sdp"><code>sdp</code> of type <span class="idlMemberType"><a href="#idl-def-RTCSessionDescription" class="idlType"><code>RTCSessionDescription</code></a></span></dt><dd>The object containing the SDP [<cite><a class="bibref" href="#bib-SDP">SDP</a></cite>].</dd></dl></section>
      </section>
    </section>

    <section id="interfaces-for-connectivity-establishment">
      <h3><span class="secno">4.8 </span>Interfaces for Connectivity Establishment</h3>

      <section id="rtcicecandidate-type">
        <h4><span class="secno">4.8.1 </span>RTCIceCandidate Type</h4>

        <p>The <dfn id="dom-icecandidate"><code>RTCIceCandidate()</code></dfn>
        constructor takes an optional dictionary argument,
        <var>candidateInitDict</var>, whose content is used to initialize the
        new <code><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></code> object. If a dictionary key is
        not present in <var>candidateInitDict</var>, the corresponding
        attribute will be initialized to null. If the constructor is run
        without the dictionary argument, all attributes will be initialized to
        null. This class is a future extensible carrier for the data contained
        in it and does not perform any substantive processing.</p>

        <p>Objects implementing the <code><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></code>
        interface <em class="rfc2119" title="must">must</em> serialize with the serialization pattern &quot;<code>{
        attribute }</code>&quot;.</p>

        <pre class="idl"><span id="idl-def-RTCIceCandidate" class="idlInterface">[<span class="extAttr">Constructor (optional RTCIceCandidateInit candidateInitDict)</span>]
interface <span class="idlInterfaceID">RTCIceCandidate</span> {
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>DOMString</a>?</span>      <span class="idlAttrName"><a href="#widl-RTCIceCandidate-candidate">candidate</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>DOMString</a>?</span>      <span class="idlAttrName"><a href="#widl-RTCIceCandidate-sdpMid">sdpMid</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>unsigned short</a>?</span> <span class="idlAttrName"><a href="#widl-RTCIceCandidate-sdpMLineIndex">sdpMLineIndex</a></span>;</span>
};<br /><span id="idl-def-RTCIceCandidateInit" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCIceCandidateInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span>      <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-candidate">candidate</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span>      <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-sdpMid">sdpMid</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>unsigned short</a></span> <span class="idlMemberName"><a href="#widl-RTCIceCandidateInit-sdpMLineIndex">sdpMLineIndex</a></span>;</span>
};</span></span></pre><section id="attributes-4"><h5><span class="secno">4.8.1.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCIceCandidate-candidate"><code>candidate</code> of type <span class="idlAttrType"><a>DOMString</a></span>, nullable</dt><dd>This carries the candidate-attribute as defined in section 15.1
          of [<cite><a class="bibref" href="#bib-ICE">ICE</a></cite>].</dd><dt id="widl-RTCIceCandidate-sdpMLineIndex"><code>sdpMLineIndex</code> of type <span class="idlAttrType"><a>unsigned short</a></span>, nullable</dt><dd>This indicates the index (starting at zero) of the m-line in the
          SDP this candidate is associated with.</dd><dt id="widl-RTCIceCandidate-sdpMid"><code>sdpMid</code> of type <span class="idlAttrType"><a>DOMString</a></span>, nullable</dt><dd>If present, this contains the identifier of the &quot;media stream
          identification&quot; as defined in [RFC 3388] for the m-line this
          candidate is associated with.</dd></dl></section>

        <section id="dictionary-rtcicecandidateinit-members"><h5><span class="secno">4.8.1.2 </span>Dictionary <a class="idlType" href="#idl-def-RTCIceCandidateInit"><code>RTCIceCandidateInit</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RTCIceCandidateInit-candidate"><code>candidate</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd>DOMString sdpMid</dd><dt id="widl-RTCIceCandidateInit-sdpMLineIndex"><code>sdpMLineIndex</code> of type <span class="idlMemberType"><a>unsigned short</a></span></dt><dd></dd><dt id="widl-RTCIceCandidateInit-sdpMid"><code>sdpMid</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd>unsigned short sdpMLineIndex</dd></dl></section>
      </section>

      <section id="rtcpeerconnectioniceevent">
        <h4><span class="secno">4.8.2 </span>RTCPeerConnectionIceEvent</h4>

        <p>The <code>icecandidate</code> event of the RTCPeerConnection uses
        the <code><a href="#idl-def-RTCPeerConnectionIceEvent" class="idlType"><code>RTCPeerConnectionIceEvent</code></a></code> interface.</p>

        <p><dfn title="Fire an ice candidate event" id="dfn-fire-an-ice-candidate-event">Firing an
        <code><a href="#idl-def-RTCPeerConnectionIceEvent" class="idlType"><code>RTCPeerConnectionIceEvent</code></a></code> event named
        <var>e</var></dfn> with an <code><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></code>
        <var>candidate</var> means that an event with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>RTCPeerConnectionIceEvent</code> interface with the
        <code>candidate</code> attribute set to the new ICE candidate, <em class="rfc2119" title="must">must</em> be
        created and dispatched at the given target.</p>

        <pre class="idl"><span id="idl-def-RTCPeerConnectionIceEvent" class="idlInterface">[<span class="extAttr">Constructor(DOMString type, RTCPeerConnectionIceEventInit eventInitDict)</span>]
interface <span class="idlInterfaceID">RTCPeerConnectionIceEvent</span> : <span class="idlSuperclass"><a>Event</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></span> <span class="idlAttrName"><a href="#widl-RTCPeerConnectionIceEvent-candidate">candidate</a></span>;</span>
};<br /><span id="idl-def-RTCPeerConnectionIceEventInit" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCPeerConnectionIceEventInit</span> : <span class="idlSuperclass"><a>EventInit</a></span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></span> <span class="idlMemberName"><a href="#widl-RTCPeerConnectionIceEventInit-candidate">candidate</a></span>;</span>
};</span></span></pre><section id="attributes-5"><h5><span class="secno">4.8.2.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-RTCPeerConnectionIceEvent-candidate"><code>candidate</code> of type <span class="idlAttrType"><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></span>, readonly</dt><dd>
            <p>The <code>candidate</code> attribute is the
            <code><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></code> object with the new ICE
            candidate that caused the event.</p>
          </dd></dl></section>

        <section id="dictionary-rtcpeerconnectioniceeventinit-members"><h5><span class="secno">4.8.2.2 </span>Dictionary <a class="idlType" href="#idl-def-RTCPeerConnectionIceEventInit"><code>RTCPeerConnectionIceEventInit</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RTCPeerConnectionIceEventInit-candidate"><code>candidate</code> of type <span class="idlMemberType"><a href="#idl-def-RTCIceCandidate" class="idlType"><code>RTCIceCandidate</code></a></span></dt><dd>
            <p> </p>
          </dd></dl></section>
      </section>
    </section>
  </section>

  <section id="peer-to-peer-data-api">
    
<!--OddPage-->
<h2><span class="secno">5. </span>Peer-to-peer Data API</h2>

    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer.</p>

    <div class="issue"><div class="issue-title"><span>Issue 4</span>: More Open Issues</div><div class="">
      <ul>
        <li>Data channel setup signaling (signaling via SDP and application
        specific signaling channel or first channel via SDP and consecutive
        channels via internal signaling).</li>

        <li>What can be shared with the WebSocket API specification regarding
        actual interfaces.</li>
      </ul>
    </div></div>

    <section id="rtcdatachannel">
      <h3><span class="secno">5.1 </span>RTCDataChannel</h3>

      <p>The <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> is created via a factory method on an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object. The corresponding
      <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object is then dispatched at the other
      peer if the channel setup was successful.</p>

      <p>Each <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> has an associated
      <dfn id="dfn-underlying-data-transport">underlying data transport</dfn> that is used to transport actual
      data to the other peer. The transport properties of the <a href="#dfn-underlying-data-transport" class="internalDFN">underlying
      data transport</a>, such as reliability mode, are configured by the peer
      taking the initiative to create the channel. The other peer cannot change
      any transport properties of an offered data channel. The actual wire
      protocol between the peers is out of the scope for this
      specification.</p>

      <p>A <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> created with <code><a href="#dom-peerconnection-createdatachannel">createDataChannel()</a></code>
      <em class="rfc2119" title="must">must</em> initially be in the <code>connecting</code> state. If the
      <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object’s <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
      transport</a> is successfully set up, the user agent <em class="rfc2119" title="must">must</em> <a href="#announce-datachannel-open">announce the <code>RTCDataChannel</code> as
      open</a>.</p>

      <p>When the user agent is to <dfn id="announce-datachannel-open">announce
      a <code>RTCDataChannel</code> as open</dfn>, the user agent <em class="rfc2119" title="must">must</em> queue a
      task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
          <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
          readiness state</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
          object to be announced.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>open</code>.</p>
        </li>

        <li>
          <p><a>Fire a simple event</a> named <code><a href="#event-datachannel-open">open</a></code> at <var>channel</var>.</p>
        </li>
      </ol>

      <p>When an <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a> has been established, the
      user agent of the peer that did not initiate the creation process <em class="rfc2119" title="must">must</em>
      queue a task to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
          <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
          readiness state</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>configuration</var> be an information bundle with
          key-value pairs, received from the other peer as a part of the
          process to establish the <a>underlying data channel</a>.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object.</p>
        </li>

        <li>
          <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-label">label</a></code> attribute to value that
          corresponds to the &quot;<code>label</code>&quot; key in
          <var>configuration</var>.</p>
        </li>

        <li>
          <p>Initialize <var>channel</var>'s <code><a href="#dom-datachannel-reliable">reliable</a></code> attribute to
          true.</p>
        </li>

        <li>
          <p>If <var>configuration</var> contains a key named
          &quot;<code>reliable</code>&quot;, set <var>channel</var>'s <code><a href="#dom-datachannel-reliable">reliable</a></code> attribute to the
          corresponding value.</p>
        </li>
<!--
          <li>
          <p>Have the user agent <a href="#announce-datachannel-open">announce
          <var>connection</var> as open</a>.</p>
          </li>
          -->


        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>open</code>.</p>
        </li>

        <li>
          <p><a>Fire a datachannel event</a> named <code><a href="#event-peerconnection-datachannel">datachannel</a></code> with
          <var>channel</var> at the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
          object.</p>
        </li>
      </ol>

      <p>When the <dfn id="tear-down-data-transport">process of tearing down a
      <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object's <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
      transport</a></dfn> is initiated, the user agent <em class="rfc2119" title="must">must</em> run the following
      steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object's
          <a href="#rtcpeerconnection-readiness-state"><code>RTCPeerConnection</code>
          readiness state</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
          object which is about to be closed.</p>
        </li>

        <li>
          <p>If <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> is
          <code>closing</code> or <code>closed</code>, then abort these
          steps.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
          <code>closing</code>.</p>
        </li>

        <li>
          <p>Queue a task to run the following steps:</p>
        </li>

        <li>
          <ol>
            <li>
              <p>Close <var>channel</var>'s <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
              transport</a>.</p>

              <div class="note"><div class="note-title"><span>Note</span></div><div class="">
                The data transport protocol will specify what happens to, e.g.
                buffered data, when the data transport is closed.
              </div></div>
            </li>

            <li>
              <p>Set <var>channel</var>'s <code><a href="#dom-datachannel-readystate">readyState</a></code> attribute to
              <code>closed</code>.</p>
            </li>

            <li>
              <p>Fire a simple event named <code title="event-RTCDataChannel-close"><a href="#event-datachannel-close">close</a></code> at
              <var>channel</var>.</p>
            </li>
          </ol>
        </li>
      </ol>

      <pre class="idl"><span id="idl-def-RTCDataChannel" class="idlInterface">interface <span class="idlInterfaceID">RTCDataChannel</span> : <span class="idlSuperclass"><a>EventTarget</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>DOMString</a></span>           <span class="idlAttrName"><a href="#widl-RTCDataChannel-label">label</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>boolean</a></span>             <span class="idlAttrName"><a href="#widl-RTCDataChannel-reliable">reliable</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCDataChannelState" class="idlType"><code>RTCDataChannelState</code></a></span> <span class="idlAttrName"><a href="#widl-RTCDataChannel-readyState">readyState</a></span>;</span>
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>unsigned long</a></span>       <span class="idlAttrName"><a href="#widl-RTCDataChannel-bufferedAmount">bufferedAmount</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onopen">onopen</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onerror">onerror</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onclose">onclose</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-RTCDataChannel-close-void">close</a></span> ();</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>EventHandler</a></span>        <span class="idlAttrName"><a href="#widl-RTCDataChannel-onmessage">onmessage</a></span>;</span>
<span class="idlAttribute">             attribute <span class="idlAttrType"><a>DOMString</a></span>           <span class="idlAttrName"><a href="#widl-RTCDataChannel-binaryType">binaryType</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-DOMString-data">send</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-ArrayBuffer-data">send</a></span> (<span class="idlParam"><span class="idlParamType"><a>ArrayBuffer</a></span> <span class="idlParamName">data</span></span>);</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-RTCDataChannel-send-void-Blob-data">send</a></span> (<span class="idlParam"><span class="idlParamType"><a>Blob</a></span> <span class="idlParamName">data</span></span>);</span>
};</span></pre><section id="attributes-6"><h4><span class="secno">5.1.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-RTCDataChannel-binaryType"><code>binaryType</code> of type <span class="idlAttrType"><a>DOMString</a></span></dt><dd>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">FIXME: align behavior with WebSocket API</p></div>
        </dd><dt id="widl-RTCDataChannel-bufferedAmount"><code>bufferedAmount</code> of type <span class="idlAttrType"><a>unsigned long</a></span>, readonly</dt><dd>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">FIXME: align behavior with WebSocket API</p></div>
        </dd><dt id="widl-RTCDataChannel-label"><code>label</code> of type <span class="idlAttrType"><a>DOMString</a></span>, readonly</dt><dd>
          <p>The <dfn id="dom-datachannel-label"><code>RTCDataChannel.label</code></dfn>
          attribute represents a label that can be used to distinguish this
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object from other
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> objects. The attribute <em class="rfc2119" title="must">must</em> return
          the value to which it was set when the
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object was created.</p>
        </dd><dt id="widl-RTCDataChannel-onclose"><code>onclose</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of type <code><a href="#event-datachannel-close">close</a></code>, <em class="rfc2119" title="must">must</em> be supported by all
        objects implementing the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onerror"><code>onerror</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of type <code><a href="#event-datachannel-error">error</a></code>, <em class="rfc2119" title="must">must</em> be supported by all
        objects implementing the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onmessage"><code>onmessage</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of type <code><a href="#event-datachannel-message">message</a></code> ,<em class="rfc2119" title="must">must</em> be supported by
        all objects implementing the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-onopen"><code>onopen</code> of type <span class="idlAttrType"><a>EventHandler</a></span></dt><dd>This event handler, of type <code><a href="#event-datachannel-open">open</a></code>, <em class="rfc2119" title="must">must</em> be supported by all
        objects implementing the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
        interface.</dd><dt id="widl-RTCDataChannel-readyState"><code>readyState</code> of type <span class="idlAttrType"><a href="#idl-def-RTCDataChannelState" class="idlType"><code>RTCDataChannelState</code></a></span>, readonly</dt><dd>
          <p>The <dfn id="dom-datachannel-readystate"><code>RTCDataChannel.readyState</code></dfn>
          attribute represents the state of the <code>RTCDataChannel</code>
          object. It <em class="rfc2119" title="must">must</em> return the value to which the user agent last set it
          (as defined by the processing model algorithms).</p>
        </dd><dt id="widl-RTCDataChannel-reliable"><code>reliable</code> of type <span class="idlAttrType"><a>boolean</a></span>, readonly</dt><dd>
          <p>The <dfn id="dom-datachannel-reliable"><code>RTCDataChannel.reliable</code></dfn>
          attribute returns true if the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> is
          reliable, and false otherwise. The attribute <em class="rfc2119" title="must">must</em> return the value to
          which it was set when the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> was
          created.</p>
        </dd></dl></section><section id="methods-1"><h4><span class="secno">5.1.2 </span>Methods</h4><dl class="methods"><dt id="widl-RTCDataChannel-close-void"><code>close</code></dt><dd>
          <p>Closes the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>. It may be called
          regardless of whether the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object
          was created by this peer or the remote peer.</p>

          <p>When the <dfn id="dfn-close"><code>close()</code></dfn> method is called, the
          user agent <em class="rfc2119" title="must">must</em> initiate <a href="#tear-down-data-transport">the
          process of tearing down</a> the <code>RTCDataChannel</code> object’s
          <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a>.</p>
        <div><em>No parameters.</em></div><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCDataChannel-send-void-DOMString-data"><code>send</code></dt><dd>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">FIXME: align behavior with WebSocket API</p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCDataChannel-send-void-ArrayBuffer-data"><code>send</code></dt><dd>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">FIXME: align behavior with WebSocket API</p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code><a>ArrayBuffer</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd><dt id="widl-RTCDataChannel-send-void-Blob-data"><code>send</code></dt><dd>
          <div class="note"><div class="note-title"><span>Note</span></div><p class="">FIXME: align behavior with WebSocket API</p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">data</td><td class="prmType"><code><a>Blob</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></section>

      <pre class="idl"><span id="idl-def-RTCDataChannelInit" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCDataChannelInit</span> {
<span class="idlMember">    <span class="idlMemberType"><a>boolean</a></span> <span class="idlMemberName"><a href="#widl-RTCDataChannelInit-reliable">reliable</a></span>;</span>
};</span></pre><section id="dictionary-rtcdatachannelinit-members"><h4><span class="secno">5.1.3 </span>Dictionary <a class="idlType" href="#idl-def-RTCDataChannelInit"><code>RTCDataChannelInit</code></a> Members</h4><dl class="dictionary-members"><dt id="widl-RTCDataChannelInit-reliable"><code>reliable</code> of type <span class="idlMemberType"><a>boolean</a></span></dt><dd>FIXME: write description</dd></dl></section>

      <pre class="idl"><span id="idl-def-RTCDataChannelState" class="idlEnum">enum <span class="idlEnumID">RTCDataChannelState</span> {
    &quot;<span class="idlEnumItem">connecting</span>&quot;,
    &quot;<span class="idlEnumItem">open</span>&quot;,
    &quot;<span class="idlEnumItem">closing</span>&quot;,
    &quot;<span class="idlEnumItem">closed</span>&quot;
};</span></pre><table class="simple"><tr><th colspan="2">Enumeration description</th></tr><tr><td><code>connecting</code></td><td>
          <p>The user agent is attempting to establish the <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
          transport</a>. This is the initial state of a
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object created with <code><a href="#dom-peerconnection-createdatachannel">createDataChannel()</a></code>
          .</p>
        </td></tr><tr><td><code>open</code></td><td>
          <p>The <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a> is established and
          communication is possible. This is the initial state of a
          <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object dispatched as a part of a
          <code><a href="#idl-def-RTCDataChannelEvent" class="idlType"><code>RTCDataChannelEvent</code></a></code> .</p>
        </td></tr><tr><td><code>closing</code></td><td>
          <p>The process of closing down the <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a>
          has started.</p>
        </td></tr><tr><td><code>closed</code></td><td>
          <p>The <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a> has been closed or could not
          be established.</p>
        </td></tr></table>
    </section>

    <section id="rtcdatachannelevent">
      <h3><span class="secno">5.2 </span>RTCDataChannelEvent</h3>

      <p>The <code><a href="#event-peerconnection-datachannel">datachannel</a></code> event uses the
      <code><a href="#idl-def-RTCDataChannelEvent" class="idlType"><code>RTCDataChannelEvent</code></a></code> interface.</p>

      <p><dfn title="fire a datachannel event" id="fire-a-datachannel-event">Firing a datachannel event named
      <var>e</var></dfn> with a <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
      <var>channel</var> means that an event with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a href="#idl-def-RTCDataChannelEvent" class="idlType"><code>RTCDataChannelEvent</code></a></code> interface with the <code><a href="#dom-datachannelevent-channel">channel</a></code> attribute set to
      <var>channel</var>, <em class="rfc2119" title="must">must</em> be created and dispatched at the given
      target.</p>

      <pre class="idl"><span id="idl-def-RTCDataChannelEvent" class="idlInterface">[<span class="extAttr">Constructor(DOMString type, RTCDataChannelEventInit eventInitDict)</span>]
interface <span class="idlInterfaceID">RTCDataChannelEvent</span> : <span class="idlSuperclass"><a>Event</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></span> <span class="idlAttrName"><a href="#widl-RTCDataChannelEvent-channel">channel</a></span>;</span>
};<br /><span id="idl-def-RTCDataChannelEventInit" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCDataChannelEventInit</span> : <span class="idlSuperclass"><a>EventInit</a></span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></span> <span class="idlMemberName"><a href="#widl-RTCDataChannelEventInit-channel">channel</a></span>;</span>
};</span></span></pre><section id="attributes-7"><h4><span class="secno">5.2.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-RTCDataChannelEvent-channel"><code>channel</code> of type <span class="idlAttrType"><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></span>, readonly</dt><dd>
          <p>The <dfn id="dom-datachannelevent-channel"><code>channel</code></dfn> attribute
          represents the <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object associated
          with the event.</p>
        </dd></dl></section>

      <section id="dictionary-rtcdatachanneleventinit-members"><h4><span class="secno">5.2.2 </span>Dictionary <a class="idlType" href="#idl-def-RTCDataChannelEventInit"><code>RTCDataChannelEventInit</code></a> Members</h4><dl class="dictionary-members"><dt id="widl-RTCDataChannelEventInit-channel"><code>channel</code> of type <span class="idlMemberType"><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></span></dt><dd>
          <p> </p>
        </dd></dl></section>
    </section>

    <section id="garbage-collection-1">
      <h3><span class="secno">5.3 </span>Garbage Collection</h3>

      <p>A <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object <em class="rfc2119" title="must">must</em> not be garbage
      collected if its</p>

      <ul>
        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>connecting</code> and at least one event listener is
          registered for <code>open</code> events, <code>message</code> events,
          <code>error</code> events, or <code>close</code> events.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>open</code> and at least one event listener is registered
          for <code>message</code> events, <code>error</code> events, or
          <code>close</code> events.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">readyState</a></code>
          is <code>closing</code> and at least one event listener is registered
          for <code>error</code> events, or <code>close</code> events.</p>
        </li>

        <li>
          <p><a href="#dfn-underlying-data-transport" class="internalDFN">underlying data transport</a> is established and data is queued
          to be transmitted.</p>
        </li>
      </ul>
    </section>
  </section>

  <section id="statistics-model">
    
<!--OddPage-->
<h2 id="sec.stats-model"><span class="secno">6. </span>Statistics Model</h2>

    <section id="introduction-1">
      <h3><span class="secno">6.1 </span>Introduction</h3>

      <p>The basic statistics model is that the browser maintains a set of
      statistics indexed by <code>selector</code>. The &quot;selector&quot; may be a
      <code>MediaStreamTrack</code> that is a member of a
      <code>MediaStream</code> on the incoming or outgoing streams. The calling
      Web application provides the selector to the <code>getStats()</code>
      method and the browser returns (in the JavaScript) a set of statistics
      that it believes is relevant to the selector.</p>

      <p>The statistics returned are designed in such a way that repeated
      queries yield the same statistics in the same place in the structure.
      Thus, a Web application can make measurements over a given time period by
      requesting measurements at the beginning and end of that period.</p>
    </section>

    <section id="rtcstatscallback">
      <h3><span class="secno">6.2 </span>RTCStatsCallback</h3>

      <pre class="idl"><span id="idl-def-RTCStatsCallback" class="idlCallback">callback <span class="idlCallbackID">RTCStatsCallback</span> = <span class="idlCallbackType"><a>void</a></span> (<span class="idlParam"><span class="idlParamType"><a href="#idl-def-RTCStatsElement" class="idlType"><code>RTCStatsElement</code></a>[]</span> <span class="idlParamName">statsElements</span></span>, <span class="idlParam"><span class="idlParamType"><a>MediaStreamTrack</a>?</span> <span class="idlParamName">selector</span></span>);</span></pre><section id="callback-rtcstatscallback-parameters"><h4><span class="secno">6.2.1 </span>Callback <a class="idlType" href="#idl-def-RTCStatsCallback"><code>RTCStatsCallback</code></a> Parameters</h4><dl class="callback-members"><dt id="widl-RTCStatsCallback-statsElements"><code>statsElements</code> of type array of <span class="idlMemberType"><a href="#idl-def-RTCStatsElement" class="idlType"><code>RTCStatsElement</code></a></span></dt><dd>
          <p>The objects containing the stats result.</p>
        </dd><dt id="widl-RTCStatsCallback-selector"><code>selector</code> of type <span class="idlMemberType"><a>MediaStreamTrack</a></span>, nullable</dt><dd>
          <p>The selector object that the statistics were gathered for.
          Currently only <code><a>MediaStreamTrack</a></code> is supported as a
          selector object.</p>
        </dd></dl></section>
    </section>

    <section id="rtcstatselement-dictionary">
      <h3><span class="secno">6.3 </span>RTCStatsElement dictionary</h3>

      <p>Each <code>RTCStatsElement</code> object consists of two
      <code>RTCStatsReport</code> objects, one corresponding to local
      statistics and one to remote statistics.</p>

      <pre class="idl"><span id="idl-def-RTCStatsElement" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCStatsElement</span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCStatsReport" class="idlType"><code>RTCStatsReport</code></a></span> <span class="idlMemberName"><a href="#widl-RTCStatsElement-local">local</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-RTCStatsReport" class="idlType"><code>RTCStatsReport</code></a></span> <span class="idlMemberName"><a href="#widl-RTCStatsElement-remote">remote</a></span>;</span>
};</span></pre><section id="dictionary-rtcstatselement-members"><h4><span class="secno">6.3.1 </span>Dictionary <a class="idlType" href="#idl-def-RTCStatsElement"><code>RTCStatsElement</code></a> Members</h4><dl class="dictionary-members"><dt id="widl-RTCStatsElement-local"><code>local</code> of type <span class="idlMemberType"><a href="#idl-def-RTCStatsReport" class="idlType"><code>RTCStatsReport</code></a></span></dt><dd>
          <p>The statistics corresponding to local properties.</p>
        </dd><dt id="widl-RTCStatsElement-remote"><code>remote</code> of type <span class="idlMemberType"><a href="#idl-def-RTCStatsReport" class="idlType"><code>RTCStatsReport</code></a></span></dt><dd>
          <p>The statistics corresponding to remote properties.</p>
        </dd></dl></section>
    </section>

    <section id="rtcstatsreport-type">
      <h3><span class="secno">6.4 </span>RTCStatsReport Type</h3>

      <p>Each <code>RTCStatsReport</code> has a timestamp. Individual
      statistics are accessed by passing string names to the <code><a href="#dom-rtcstatsreport-getvalue">getValue()</a></code> method. Note that
      while stats names are standardized [[OPEN ISSUE: Need to define an IANA
      registry for this and populate with pointers to existing things such as
      the RTCP statistics. ]], any given implementation may be using
      experimental values or values not yet known to the Web application. Thus,
      applications <em class="rfc2119" title="must">must</em> be prepared to deal with unknown stats.</p>

      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if &quot;bytesSent&quot; and
      &quot;packetsSent&quot; are both reported, they both need to be reported over the
      same interval, so that &quot;average packet size&quot; can be computed as &quot;bytes /
      packets&quot; - if the intervals are different, this will yield errors. Thus
      implementations <em class="rfc2119" title="must">must</em> return synchronized values for all stats in a
      <code>RTCStatsReport</code>.</p>

      <pre class="idl"><span id="idl-def-RTCStatsReport" class="idlInterface">interface <span class="idlInterfaceID">RTCStatsReport</span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>long</a></span> <span class="idlAttrName"><a href="#widl-RTCStatsReport-timestamp">timestamp</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>any</a></span> <span class="idlMethName"><a href="#widl-RTCStatsReport-getValue-any-DOMString-statName">getValue</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">statName</span></span>);</span>
};</span></pre><section id="attributes-8"><h4><span class="secno">6.4.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-RTCStatsReport-timestamp"><code>timestamp</code> of type <span class="idlAttrType"><a>long</a></span>, readonly</dt><dd>
          <p>The timestamp in milliseconds since the UNIX epoch (Jan 1, 1970,
          UTC).</p>
        </dd></dl></section><section id="methods-2"><h4><span class="secno">6.4.2 </span>Methods</h4><dl class="methods"><dt id="widl-RTCStatsReport-getValue-any-DOMString-statName"><code>getValue</code></dt><dd>
          <p>The <dfn id="dom-rtcstatsreport-getvalue"><code>getValue()</code></dfn> method
          returns the value for the statistic that corresponds to
          <var>statName</var>.</p>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">statName</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>any</a></code></div></dd></dl></section>
    </section>

    <section id="example">
      <h3><span class="secno">6.5 </span>Example</h3>

      <p>Consider the case where the user is experiencing bad sound and the
      application wants to determine if the cause of it is packet loss. The
      sound track is audio track 0 of remote stream 0 of pc1. The following
      example code might be used:</p>
      <div class="example"><div class="example-title"><span>Example 1</span></div><pre class="example highlight prettyprint"><span class="kwd">var</span><span class="pln"> baseline</span><span class="pun">,</span><span class="pln"> now</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> selector </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">remoteStreams</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">audioTracks</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">

pc</span><span class="pun">.</span><span class="pln">getStats</span><span class="pun">(</span><span class="pln">selector</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">stats</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    baseline </span><span class="pun">=</span><span class="pln"> stats</span><span class="pun">;</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

</span><span class="com">// ... wait a bit</span><span class="pln">
setTimeout</span><span class="pun">(</span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">getStats</span><span class="pun">(</span><span class="pln">selector</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">stats</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        now </span><span class="pun">=</span><span class="pln"> stats</span><span class="pun">;</span><span class="pln">
        processStats</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> aBit</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> processStats</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// Real code would:</span><span class="pln">
    </span><span class="com">// - Check that timestamp of “local stats” and “remote stats”</span><span class="pln">
    </span><span class="com">//   are reasonably consistent.</span><span class="pln">
    </span><span class="com">// - Sum up over all the elements rather than just accessing</span><span class="pln">
    </span><span class="com">//   element zero.</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> packetsSent </span><span class="pun">=</span><span class="pln"> now</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">remote</span><span class="pun">.</span><span class="pln">getValue</span><span class="pun">(</span><span class="str">&quot;packetsSent&quot;</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln">
            baseline</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">remote</span><span class="pun">.</span><span class="pln">getValue</span><span class="pun">(</span><span class="str">&quot;packetsSent&quot;</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> packetsReceived </span><span class="pun">=</span><span class="pln"> now</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">local</span><span class="pun">.</span><span class="pln">getValue</span><span class="pun">(</span><span class="str">&quot;packetsReceived&quot;</span><span class="pun">)</span><span class="pln"> </span><span class="pun">-</span><span class="pln">
            baseline</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="kwd">local</span><span class="pun">.</span><span class="pln">getValue</span><span class="pun">(</span><span class="str">&quot;packetsReceived&quot;</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// if fractionLost is &gt; 0.3, we have probably found the culprit</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> fractionLost </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">packetsSent </span><span class="pun">-</span><span class="pln"> packetsReceived</span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> packetsSent</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></pre></div>
    </section>
  </section>

  <section id="identity">
    
<!--OddPage-->
<h2 id="sec.identity-proxy"><span class="secno">7. </span>Identity</h2>

    <section id="identity-provider-interaction">
      <h3><span class="secno">7.1 </span>Identity Provider Interaction</h3>

      <p>WebRTC offers and answers (and hence the channels established by
      <code>RTCPeerConnection</code> objects) can be authenticated by using
      web-based Identity Providers. The idea is that the entity sending the
      offer/answer acts as the Authenticating Party (AP) and obtains an
      identity assertion from the IdP which it attaches to the offer/answer.
      The consumer of the offer/answer (i.e., the
      <code>RTCPeerConnection</code> on which
      <code>setRemoteDescription()</code> is called acts as the Relying Party
      (RP) and verifies the assertion.</p>

      <p>The interaction with the IdP is designed to decouple the browser from
      any particular identity provider; the browser need only know how to load
      the IdP's JavaScript -- which is deterministic from the IdP's identity --
      and the generic protocol for requesting and verifying assertions. The IdP
      provides whatever logic is necessary to bridge the generic protocol to
      the IdP's specific requirements. Thus, a single browser can support any
      number of identity protocols, including being forward compatible with
      IdPs which did not exist at the time the browser was written. The generic
      protocol details are described in [RTCWEB-SECURITY-ARCH]. This document
      specifies the procedures required to instantiate the IdP proxy, request
      identity assertions, and consume the results.</p>

      <section id="peer-connection-idp-communications">
        <h4 id="sec.identity-proxy-communications"><span class="secno">7.1.1 </span>Peer-Connection/IdP
        Communications</h4>

        <p>In order to communicate with the IdP, the browser must instantiate
        an isolated interpreted context [TODO: What's the technical term?],
        such as an invisible IFRAME. The initial contents of the context are
        loaded from a URI derived from the IdP's domain name.
        [RTCWEB-SECURITY-ARCH; Section XXX].</p>

        <p>For purposes of generating assertions, the IdP shall be chosen as
        follows:</p>

        <ol>
          <li>If the <code>setIdentityProvider()</code> method has been called,
          the IdP provided shall be used.</li>

          <li>If the <code>setIdentityProvider()</code> method has not been
          called, then the browser shall use an IdP configured into the
          browser. If more than one such IdP is configured, the browser should
          provide the user with a chooser interface.</li>
        </ol>

        <p>In order to verify assertions, the IdP domain name and protocol
        shall be equal to the &quot;domain&quot; and &quot;protocol&quot; fields of the identity
        assertion.</p>

        <p>The context <em class="rfc2119" title="must">must</em> have a <code>MessageChannel</code> named
        <code>window.TBD</code> which is &quot;entangled&quot; to the
        <code>RTCPeerConnection</code> and is unique to that subcontext. This
        channel is used for messaging between the
        <code>RTCPeerConnection</code> and the IdP. All messages sent via this
        channel are strings, specifically the JSONified versions of JavaScript
        structs.</p>

        <p>All messages sent from the <code>RTCPeerConnection</code> to the IdP
        context <em class="rfc2119" title="must">must</em> have an <code>origin</code> of
        <code>rtcweb://peerconnection/</code>. The fact that ordinary Web pages
        cannot set their origin values arbitrarily is an essential security
        feature, as it stops attackers from requesting WebRTC-compatible
        identity assertions from IdPs. For this reason, the origin must be
        included in the identity assertion and verified by the consuming
        <code>RTCPeerConnection</code>.</p>
      </section>

      <section id="requesting-assertions">
        <h4 id="sec.identity-proxy-assertion-request"><span class="secno">7.1.2 </span>Requesting
        Assertions</h4>

        <p>The identity assertion request process involves the following
        steps.</p>

        <ol>
          <li>The <code>RTCPeerConnection</code> instantiates an IdP context as
          described in the previous section.</li>

          <li>The IdP serves up the IdP JavaScript code to the IdP
          context.</li>

          <li>Once the IdP is loaded and ready to receive messages it sends a
          &quot;READY&quot; message [RTCWEB-SECURITY-ARCH; Section 5.6.5.2]. Note that
          this does not imply that the user is logged in, merely that enough
          IdP state is booted up to be ready to handle PostMessage calls.</li>

          <li>The IdP sends a &quot;SIGN&quot; message (Section 5.6.5.2.2) to the IdP
          proxy context. This message includes the material the
          <code>RTCPeerConnection</code> desires to be bound to the user's
          identity.</li>

          <li>If the user is not logged in, at this point the IdP will initiate
          the login process. For instance, it might pop up a dialog box
          inviting the user to enter their (IdP) username and password.</li>

          <li>Once the user is logged in (potentially after the previous step),
          the IdP proxy generates an identity assertion (depending on the
          authentication protocol this may involve interacting with the IDP
          server).</li>

          <li>Once the assertion is generated, the IdP proxy sends a response
          (Section 5.6.5.2.2) containing the assertion to the
          <code>RTCPeerConnection</code> over the message channel.</li>

          <li>The <code>RTCPeerConnection</code> stores the assertion for use
          with future offers or answers. If the identity request was triggered
          by a <code>createOffer()</code> or <code>createAnswer()</code>, then
          the assertion is inserted in the offer/answer.</li>
        </ol>
      </section>

      <section id="verifying-assertions">
        <h4 id="sec.identity-verify-assertion"><span class="secno">7.1.3 </span>Verifying Assertions</h4>

        <p>The identity assertion request process involves the following
        steps.</p>

        <ol>
          <li>The <code>RTCPeerConnection</code> instantiates an IdP context as
          described in the previous section.</li>

          <li>The IdP serves up the IdP JavaScript code to the IdP
          context.</li>

          <li>Once the IdP is loaded and ready to receive messages it sends a
          &quot;READY&quot; message [RTCWEB-SECURITY-ARCH; Section 5.6.5.2]. Note that
          this does not imply that the user is logged in, merely that enough
          IdP state is booted up to be ready to handle <code>PostMessage</code>
          calls.</li>

          <li>The IdP sends a &quot;VERIFY&quot; message (Section 5.6.5.2.2) to the IdP
          proxy context. This message includes assertion from the offer/answer
          which is to be verified.</li>

          <li>The IdP proxy verifies the identity assertion (depending on the
          authentication protocol this may involve interacting with the IDP
          server).</li>

          <li>Once the assertion is verified the IdP proxy sends a response
          containing the verified assertion results (Section 5.6.5.2.3) to the
          <code>RTCPeerConnection</code> over the message channel.</li>

          <li>The <code>RTCPeerConnection</code> displays the assertion
          information in the browser UI and stores the assertion in the
          <code><a href="#widl-RTCPeerConnection-peerIdentity">peerIdentity</a></code>
          attribute for availability to the JavaScript application. The
          assertion information to be displayed shall contain the domain name
          of the IdP and the identity returned by the IdP and must be displayed
          via some mechanism which cannot be spoofed by content. [[OPEN ISSUE:
          The identity information should also be available in the inspector
          interface defined in [RTCWEB-SECURITY-ARCH; Section 5.5].</li>
        </ol>
      </section>
    </section>

    <section id="rtcidentityassertion-type">
      <h3><span class="secno">7.2 </span>RTCIdentityAssertion Type</h3>

      <pre class="idl"><span id="idl-def-RTCIdentityAssertion" class="idlDictionary">dictionary <span class="idlDictionaryID">RTCIdentityAssertion</span> {
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span> <span class="idlMemberName"><a href="#widl-RTCIdentityAssertion-idp">idp</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a>DOMString</a></span> <span class="idlMemberName"><a href="#widl-RTCIdentityAssertion-name">name</a></span>;</span>
};</span></pre><section id="dictionary-rtcidentityassertion-members"><h4><span class="secno">7.2.1 </span>Dictionary <a class="idlType" href="#idl-def-RTCIdentityAssertion"><code>RTCIdentityAssertion</code></a> Members</h4><dl class="dictionary-members"><dt id="widl-RTCIdentityAssertion-idp"><code>idp</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd>
          <p>A domain name representing the identity provider.</p>
        </dd><dt id="widl-RTCIdentityAssertion-name"><code>name</code> of type <span class="idlMemberType"><a>DOMString</a></span></dt><dd>
          <p>An RFC822-conformant [TODO: REF] representation of the verified
          peer identity. This identity will have been verified via the
          procedures described in [RTCWEB-SECURITY-ARCH].</p>
        </dd></dl></section>
    </section>

    <section id="examples">
      <h3><span class="secno">7.3 </span>Examples</h3>

      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an IdP into their browser, then the
      browser will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>

      <div>
        <p>This example shows how to configure the identity provider and
        protocol.</p>
        <div class="example"><div class="example-title"><span>Example 2</span></div><pre class="example highlight prettyprint"><span class="pln">pc</span><span class="pun">.</span><span class="pln">setIdentityProvider</span><span class="pun">(</span><span class="str">&quot;example.com&quot;</span><span class="pun">,</span><span class="pln"> </span><span class="str">&quot;default&quot;</span><span class="pun">,</span><span class="pln"> </span><span class="str">&quot;alice@example.com&quot;</span><span class="pun">);</span></pre></div>
      </div>

      <div>
        <p>This example shows how to consume identity assertions inside a Web
        application.</p>
        <div class="example"><div class="example-title"><span>Example 3</span></div><pre class="example highlight prettyprint"><span class="pln">pc</span><span class="pun">.</span><span class="pln">onidentityresult </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">&quot;IdP= &quot;</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">peerIdentity</span><span class="pun">.</span><span class="pln">idp </span><span class="pun">+</span><span class="pln">
              </span><span class="str">&quot; identity=&quot;</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">peerIdentity</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span></pre></div>
      </div>
    </section>
  </section>

  <section id="media-stream-api-extensions-for-network-use">
    
<!--OddPage-->
<h2><span class="secno">8. </span>Media Stream API Extensions for Network Use</h2>

    <section id="introduction-2">
      <h3><span class="secno">8.1 </span>Introduction</h3>

      <p>The <code>MediaStream</code> interface, as defined in the
      [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>] specification, typically represents a stream of data of
      audio and/or video. A <code>MediaStream</code> may be extended to
      represent a stream that either comes from or is sent to a remote node
      (and not just the local camera, for instance). The extensions required to
      enable this capability on the <code>MediaStream</code> object will be
      described in this document.</p>

      <p>A <code>MediaStream</code> as defined in [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>] may contain
      zero or more <code>MediaStreamTrack</code> objects. A
      <code>MediaStreamTrack</code> sent to another peer will appear as one and
      only one <code>MediaStreamTrack</code> to the recipient. A peer is
      defined as a user agent that supports this specification.</p>

      <p>Channels are the smallest unit considered in the
      <code>MediaStream</code> specification. Channels are intended to be
      encoded together for transmission as, for instance, an RTP payload type.
      All of the channels that a codec needs to encode jointly <em class="rfc2119" title="must">must</em> be in the
      same <code>MediaStreamTrack</code> and the codecs <em class="rfc2119" title="should">should</em> be able to
      encode, or discard, all the channels in the track.</p>

      <p>The concepts of an input and output to a given
      <code>MediaStream</code> apply in the case of <code>MediaStream</code>
      objects transmitted over the network as well. A
      <code><a>MediaStream</a></code> created by an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object (described later in this
      document) will take as input the data received from a remote peer.
      Similarly, a <code>MediaStream</code> from a local source, for instance a
      camera via [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>], will have an output that represents what is
      transmitted to a remote peer if the object is used with an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object.</p>

      <p>The concept of duplicating <code>MediaStream</code> objects as
      described in [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>] is also applicable here. This feature can
      be used, for instance, in a video-conferencing scenario to display the
      local video from the user’s camera and microphone in a local monitor,
      while only transmitting the audio to the remote peer (e.g. in response to
      the user using a &quot;video mute&quot; feature). Combining tracks from different
      <code><a>MediaStream</a></code> objects into a new
      <code><a>MediaStream</a></code> is useful in certain situations.</p>

      <div class="note"><div class="note-title"><span>Note</span></div><p class="">In this document, we only specify aspects of the
      following objects that are relevant when used along with an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>. Please refer to the original
      definitions of the objects in the [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>] document for general
      information on using <code>MediaStream</code> and
      <code>MediaStreamTrack</code>.</p></div>
    </section>

    <section id="mediastream">
      <h3><span class="secno">8.2 </span>MediaStream</h3>

      <section id="id">
        <h4><span class="secno">8.2.1 </span>id</h4>

        <p>The <code><a href="getusermedia.html#dom-mediastream-id">id</a></code> attribute specified
        in <code>MediaStream</code> returns an id that is unique to this stream,
        so that streams can be recognized after they are sent through the
        <code><a href="#rtcpeerconnection">RTCPeerConnection</a></code>
        API.</p>

        <p>When a <code><a href="#mediastream">MediaStream</a></code> is
        created to represent a stream obtained from a remote peer, the
        <code><a href="getusermedia.html#dom-mediastream-id">id</a></code>
        attribute is initialized from information provided by the remote
        source.</p>

        <div class="note"><div class="note-title"><span>Note</span></div><p class="">The id of a <code><a>MediaStream</a></code> object
        is unique to the source of the stream, but that does not mean it is not
        possible to end up with duplicates. For example, a locally generated
        stream could be sent from one user agent to a remote peer using
        <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> and then sent back to the
        original user agent in the same manner, in which case the original user
        agent will have multiple streams with the same id (the
        locally-generated one and the one received from the remote peer).</p></div>
      </section>

      <section id="events-on-mediastream">
        <h4><span class="secno">8.2.2 </span>Events on MediaStream</h4>

        <p>A new media track may be associated with an existing
        <code><a>MediaStream</a></code>. For example, if a remote peer adds a
        new <code><a>MediaStreamTrack</a></code> object to a
        <code><a>MediaStream</a></code> that is being sent over an
        <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>, this is observed on the local
        user agent. If this happens for the reason exemplified, or for any
        other reason than the <code><a href="getusermedia.html#dom-mediastream-addtrack">addTrack()</a></code>
        method being invoked locally on a <code><a>MediaStream</a></code> or
        tracks being added as the stream is created (i.e. the stream is
        initialized with tracks), the user agent <em class="rfc2119" title="must">must</em> run the following steps:
        </p>

        <ol>
          <li>
            <p>Let <var>stream</var> be the target
            <code><a>MediaStream</a></code> object.</p>
          </li>

          <li>
            <p><dfn id="represent-component-with-track">Represent component with
            track</dfn>: Run the following steps to create a track representing
            the incoming component:
            </p>

            <ol>
              <li>
                <p>Create a <code><a>MediaStreamTrack</a></code> object
                <var>track</var> to represent the component.</p>
              </li>

              <li>
                <p>Initialize <var>track’s</var> <code><a href="getusermedia.html#dom-mediastreamtrack-kind">kind</a></code>
                attribute to &quot;<code>audio</code>&quot; or &quot;<code>video</code>&quot;
                depending on the media type of the incoming component.</p>
              </li>

              <li>
                <p>Initialize <var>track’s</var> <code><a href="getusermedia.html#dom-mediastreamtrack-id">id</a></code>
                attribute to the component track id.</p>
              </li>

              <li>
                <p>Initialize <var>track’s</var> <code><a href="getusermedia.html#dom-mediastreamtrack-label">label</a></code>
                attribute to &quot;<code>remote audio</code>&quot; or &quot;<code>remote
                video</code>&quot; depending on the media type of the incoming
                component.</p>
              </li>

              <li>
                <p>Initialize <var>track’s</var> <code><a href="getusermedia.html#dom-mediastreamtrack-readystate">readyState</a>
                </code> attribute to <code>muted</code>.</p>
              </li>

              <li>
                <p>Add <var>track</var> to <var>stream’s</var>
                <a href="getusermedia.html#track-set">track set</a>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Fire a track event named <code><a href="getusermedia.html#event-mediastream-addtrack">
            addtrack</a></code> with the newly created
            <code><a>MediaStreamTrack</a></code> object at <var>stream</var>.
            </p>
          </li>
        </ol>

        <p>An existing media track may also be disassociated from a
        <code><a>MediaStream</a></code>. If this happens for any other reason
        than the <code><a href="getusermedia.html#dom-mediastream-removetrack">removeTrack()</a></code>
        method being invoked locally on a <code><a>MediaStream</a></code> or the
        stream being destroyed, the user agent <em class="rfc2119" title="must">must</em> run the following steps:</p>

        <ol>
          <li>
            <p>Let <var>stream</var> be the target
            <code><a>MediaStream</a></code> object.</p>
          </li>

          <li>
            <p>Let <var>track</var> be the <code><a>MediaStreamTrack</a></code>
            object representing the media component about to be removed.</p>
          </li>

          <li>
            <p>Remove <var>track</var> from <var>stream’s</var>
            <a href="getusermedia.html#track-set">track set</a>.</p>
          </li>

          <li>
            <p>Fire a track event named <code><a href="getusermedia.html#event-mediastream-removetrack">
            removetrack</a></code> with <var>track</var> at <var>stream</var>.
            </p>
          </li>
        </ol>

        <p>The event source for the <code>onended</code> event in the networked
        case is the <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code> object.</p>
      </section>
    </section>

    <section id="mediastreamtrack">
      <h3><span class="secno">8.3 </span>MediaStreamTrack</h3>

      <p>A <code>MediaStreamTrack</code> object’s reference to its
      <code>MediaStream</code> in the non-local media source case (an RTP
      source, as is the case for a <code>MediaStream</code> received over an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>) is always strong.</p>

      <p>When a track belongs to a <code><a>MediaStream</a></code> that comes
      from a remote peer and the remote peer has permanently stopped sending
      data the <code>ended</code> event <em class="rfc2119" title="must">must</em> be fired on the track, as
      specified in [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>].</p>

      <div class="issue"><div class="issue-title"><span>Issue 5</span></div><p class="">ISSUE: How do you know when it has stopped? This seems
      like an SDP question, not a media-level question.</p></div>

      <p>A track in a <code><a>MediaStream</a></code>, received with an
      <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>, <em class="rfc2119" title="must">must</em> have its
      <code>readyState</code> attribute [<cite><a class="bibref" href="#bib-GETUSERMEDIA">GETUSERMEDIA</a></cite>] set to
      <code>muted</code> until media data arrives.</p>

      <p>In addition, a <code>MediaStreamTrack</code> has its
      <code>readyState</code> set to <code>muted</code> on the remote peer if
      the local user agent disables the corresponding
      <code><a>MediaStreamTrack</a></code> in the
      <code><a>MediaStream</a></code> that is being sent. When the addstream
      event triggers on an <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>, all
      <code><a>MediaStreamTrack</a></code> objects in the resulting
      <code><a>MediaStream</a></code> are muted until media data can be read
      from the RTP source.</p>

      <div class="issue"><div class="issue-title"><span>Issue 6</span></div><p class="">ISSUE: How do you know when it has been disabled? This
      seems like an SDP question, not a media-level question.</p></div>
    </section>

    <section id="audiomediastreamtrack">
      <h3><span class="secno">8.4 </span>AudioMediaStreamTrack</h3>

      <div class="note"><div class="note-title"><span>Note</span></div><p class="">The DTMF API is undergoing significant list discussion
      and will probably change.</p></div>

      <p>The <code><a href="#idl-def-AudioMediaStreamTrack" class="idlType"><code>AudioMediaStreamTrack</code></a></code> is a specialization of a
      normal <code><a>MediaStreamTrack</a></code> that only carries audio and
      is extended to have the capability to send and/or receive DTMF codes.</p>

      <pre class="idl"><span id="idl-def-AudioMediaStreamTrack" class="idlInterface">interface <span class="idlInterfaceID">AudioMediaStreamTrack</span> : <span class="idlSuperclass"><a>MediaStreamTrack</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>boolean</a></span> <span class="idlAttrName"><a href="#widl-AudioMediaStreamTrack-canInsertDTMF">canInsertDTMF</a></span>;</span>
<span class="idlMethod">    <span class="idlMethType"><a>void</a></span> <span class="idlMethName"><a href="#widl-AudioMediaStreamTrack-insertDTMF-void-DOMString-tones-long-duration">insertDTMF</a></span> (<span class="idlParam"><span class="idlParamType"><a>DOMString</a></span> <span class="idlParamName">tones</span></span>, <span class="idlParam">optional <span class="idlParamType"><a>long</a></span> <span class="idlParamName">duration</span></span>);</span>
};</span></pre><section id="attributes-9"><h4><span class="secno">8.4.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-AudioMediaStreamTrack-canInsertDTMF"><code>canInsertDTMF</code> of type <span class="idlAttrType"><a>boolean</a></span>, readonly</dt><dd>
          <p>The <dfn id="dom-audiomediastreamtrack-caninsertdtmf"><code>canInsertDTMF</code></dfn>
          attribute <em class="rfc2119" title="must">must</em> indicate if the
          <code><a href="#idl-def-AudioMediaStreamTrack" class="idlType"><code>AudioMediaStreamTrack</code></a></code> is capable of sending
          DTMF.</p>
        </dd></dl></section><section id="methods-3"><h4><span class="secno">8.4.2 </span>Methods</h4><dl class="methods"><dt id="widl-AudioMediaStreamTrack-insertDTMF-void-DOMString-tones-long-duration"><code>insertDTMF</code></dt><dd>
          <p>When an <code><a href="#idl-def-AudioMediaStreamTrack" class="idlType"><code>AudioMediaStreamTrack</code></a></code> object’s
          <dfn id="dom-AudioMediaStreamTrack-insertDTMF"><code>insertDTMF()</code></dfn>
          method is invoked, the user agent <em class="rfc2119" title="must">must</em> queue a task that sends the
          DTMF tones.</p>

          <p>The tone parameters is treated as a series of characters. The
          characters 0 through 9, A through D, #, and * generate the associated
          DTMF tones. The characters a to d are equivalent to A to D. The
          character',' indicates a delay of 2 seconds before processing the
          next character in the tones parameter. Unrecognized characters are
          ignored.</p>

          <p>The duration parameter indicates the duration in ms to use for
          each character passed in the tones parameters. The duration cannot be
          more than 6000 or less than 70. The default duration is 100 ms for
          each tone. The gap between tones <em class="rfc2119" title="must">must</em> be at least 50 ms but should be
          as short as possible.</p>

          <div class="issue"><div class="issue-title"><span>Issue 7</span></div><p class="">ISSUE: How are invalid values handled?</p></div>

          <p>If insertDTMF is called on the same object while an existing task
          for this object to generate DTMF is still running, the previous task
          is canceled. Calling insertDTMF with an empty tones parameter can be
          used to cancel any tones currently being sent.</p>

          <div class="note"><div class="note-title"><span>Note</span></div><p class="">Editor Note: We need to add a callback to insertDTMF
          that is called after the tones are sent. This is needed to allow the
          application to know when it can send new tones without canceling the
          tones that are currently being sent.</p></div>

          <div class="note"><div class="note-title"><span>Note</span></div><p class="">Editor Note: It seems we would want a callback or
          event for incoming tones. The proposal sent to the list had them
          played as audio to the speaker but I don’t see how that is
          useful.</p></div>
        <table class="parameters"><tr><th>Parameter</th><th>Type</th><th>Nullable</th><th>Optional</th><th>Description</th></tr><tr><td class="prmName">tones</td><td class="prmType"><code><a>DOMString</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptFalse">✘</td><td class="prmDesc"></td></tr><tr><td class="prmName">duration</td><td class="prmType"><code><a>long</a></code></td><td class="prmNullFalse">✘</td><td class="prmOptTrue">✔</td><td class="prmDesc"></td></tr></table><div><em>Return type: </em><code><a>void</a></code></div></dd></dl></section>
    </section>

    <section id="mediastreamevent">
      <h3><span class="secno">8.5 </span>MediaStreamEvent</h3>

      <p>The <code><a href="#event-mediastream-addstream">addstream</a></code>
      and <code title="event-MediaStream-removestream"><a href="#event-mediastream-removestream">removestream</a></code> events use the
      <code><a href="#idl-def-MediaStreamEvent" class="idlType"><code>MediaStreamEvent</code></a></code> interface.</p>

      <p><dfn title="fire a stream event" id="fire-a-stream-event">Firing a
      stream event named <var>e</var></dfn> with a
      <code><a>MediaStream</a></code> <var>stream</var> means that an event
      with the name <var>e</var>, which does not bubble (except where otherwise
      stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a href="#idl-def-MediaStreamEvent" class="idlType"><code>MediaStreamEvent</code></a></code> interface with the
      <code><a href="#dom-mediastreamevent-stream">stream</a></code> attribute
      set to <var title="">stream</var>, <em class="rfc2119" title="must">must</em> be created and dispatched at the
      given target.</p>

      <pre class="idl"><span id="idl-def-MediaStreamEvent" class="idlInterface">[<span class="extAttr">Constructor(DOMString type, MediaStreamEventInit eventInitDict)</span>]
interface <span class="idlInterfaceID">MediaStreamEvent</span> : <span class="idlSuperclass"><a>Event</a></span> {
<span class="idlAttribute">    readonly attribute <span class="idlAttrType"><a>MediaStream</a>?</span> <span class="idlAttrName"><a href="#widl-MediaStreamEvent-stream">stream</a></span>;</span>
};<br /><span id="idl-def-MediaStreamEventInit" class="idlDictionary">dictionary <span class="idlDictionaryID">MediaStreamEventInit</span> : <span class="idlSuperclass"><a>EventInit</a></span> {
<span class="idlMember">    <span class="idlMemberType"><a>MediaStream</a></span> <span class="idlMemberName"><a href="#widl-MediaStreamEventInit-stream">stream</a></span>;</span>
};</span></span></pre><section id="attributes-10"><h4><span class="secno">8.5.1 </span>Attributes</h4><dl class="attributes"><dt id="widl-MediaStreamEvent-stream"><code>stream</code> of type <span class="idlAttrType"><a>MediaStream</a></span>, readonly, nullable</dt><dd>
          <p>The <dfn id="dom-mediastreamevent-stream"><code>stream</code></dfn> attribute
          represents the <code><a>MediaStream</a></code> object associated with
          the event.</p>
        </dd></dl></section>

      <section id="dictionary-mediastreameventinit-members"><h4><span class="secno">8.5.2 </span>Dictionary <a class="idlType" href="#idl-def-MediaStreamEventInit"><code>MediaStreamEventInit</code></a> Members</h4><dl class="dictionary-members"><dt id="widl-MediaStreamEventInit-stream"><code>stream</code> of type <span class="idlMemberType"><a>MediaStream</a></span></dt><dd>
          <p> </p>
        </dd></dl></section>
    </section>
  </section>

  <section class="informative" id="examples-and-call-flows">
    
<!--OddPage-->
<h2><span class="secno">9. </span>Examples and Call Flows</h2><p><em>This section is non-normative.</em></p>

    <section id="simple-peer-to-peer-example">
      <h3><span class="secno">9.1 </span>Simple Peer-to-peer Example</h3><p><em>This section is non-normative.</em></p>

      <div>
        <p>When two peers decide they are going to set up a connection to each
        other, they both go through these steps. The STUN/TURN server
        configuration describes a server they can use to get things like their
        public IP address or to set up NAT traversal. They also have to send
        data for the signaling channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <div class="example"><div class="example-title"><span>Example 4</span></div><pre class="example highlight prettyprint"><span class="kwd">var</span><span class="pln"> signalingChannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SignalingChannel</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> configuration </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">&quot;iceServers&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln"> </span><span class="str">&quot;url&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="str">&quot;stun:stun.example.org&quot;</span><span class="pln"> </span><span class="pun">}]</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> pc</span><span class="pun">;</span><span class="pln">

</span><span class="com">// call start() to initiate</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> start</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCPeerConnection</span><span class="pun">(</span><span class="pln">configuration</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// send any ice candidates to the other peer</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onicecandidate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">&quot;candidate&quot;</span><span class="pun">:</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">candidate </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// let the &quot;negotiationneeded&quot; event trigger offer generation</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onnegotiationneeded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">createOffer</span><span class="pun">(</span><span class="pln">localDescCreated</span><span class="pun">,</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="com">// once remote stream arrives, show it in the remote video element</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onaddstream </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        remoteView</span><span class="pun">.</span><span class="pln">src </span><span class="pun">=</span><span class="pln"> URL</span><span class="pun">.</span><span class="pln">createObjectURL</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// get a local stream, show it in a self-view and add it to be sent</span><span class="pln">
    navigator</span><span class="pun">.</span><span class="pln">getUserMedia</span><span class="pun">({</span><span class="pln"> </span><span class="str">&quot;audio&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln"> </span><span class="str">&quot;video&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">},</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">stream</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        selfView</span><span class="pun">.</span><span class="pln">src </span><span class="pun">=</span><span class="pln"> URL</span><span class="pun">.</span><span class="pln">createObjectURL</span><span class="pun">(</span><span class="pln">stream</span><span class="pun">);</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addStream</span><span class="pun">(</span><span class="pln">stream</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> localDescCreated</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">&quot;sdp&quot;</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

signalingChannel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">pc</span><span class="pun">)</span><span class="pln">
        start</span><span class="pun">();</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> message </span><span class="pun">=</span><span class="pln"> JSON</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">)</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCSessionDescription</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="com">// if we received an offer, we need to answer</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pc</span><span class="pun">.</span><span class="pln">remoteDescription</span><span class="pun">.</span><span class="pln">type </span><span class="pun">==</span><span class="pln"> </span><span class="str">&quot;offer&quot;</span><span class="pun">)</span><span class="pln">
                pc</span><span class="pun">.</span><span class="pln">createAnswer</span><span class="pun">(</span><span class="pln">localDescCreated</span><span class="pun">,</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addIceCandidate</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCIceCandidate</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">));</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> logError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">&quot;: &quot;</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> error</span><span class="pun">.</span><span class="pln">message</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </div>
    </section>

    <section id="advanced-peer-to-peer-example">
      <h3><span class="secno">9.2 </span>Advanced Peer-to-peer Example</h3>

      <div>
        <p>This example shows the more complete functionality.</p>
        <div class="example"><div class="example-title"><span>Example 5</span></div><pre class="example highlight prettyprint"><span class="pln">TODO</span></pre></div>
      </div>
    </section>

    <section id="peer-to-peer-data-example">
      <h3><span class="secno">9.3 </span>Peer-to-peer Data Example</h3>

      <div>
        <p>This example shows how to create a
        <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object and perform the offer/answer
        exchange required to connect the channel to the other peer. The
        <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> is used in the context of a simple
        chat application and listeners are attached to monitor when the channel
        is ready, messages are received and when the channel is closed.</p>

        <div class="note"><div class="note-title"><span>Note</span></div><p class="">This example uses the <code>negotiationneeded</code>
        event to initiate the offer/answer dialog. The exact behavior
        surrounding the <code>negotiationneeded</code> event is not specified
        in detail at the moment. This example can hopefully help to drive that
        discussion. An assumption made in this example is that the event only
        triggeres when a new negotiation should be started. This means that an
        action (such as addStream()) that normally would have fired the
        <code>negotiationneeded</code> event will not do so during an ongoing
        offer/answer dialog.</p></div>
        <div class="example"><div class="example-title"><span>Example 6</span></div><pre class="example highlight prettyprint"><span class="kwd">var</span><span class="pln"> signalingChannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SignalingChannel</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> configuration </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="str">&quot;iceServers&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln"> </span><span class="str">&quot;url&quot;</span><span class="pun">:</span><span class="pln"> </span><span class="str">&quot;stun:stun.example.org&quot;</span><span class="pln"> </span><span class="pun">}]</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> pc</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> channel</span><span class="pun">;</span><span class="pln">

</span><span class="com">// call start(true) to initiate</span><span class="pln">
</span><span class="kwd">function</span><span class="pln"> start</span><span class="pun">(</span><span class="pln">isInitiator</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCPeerConnection</span><span class="pun">(</span><span class="pln">configuration</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// send any ice candidates to the other peer</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onicecandidate </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">)</span><span class="pln">
            signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">&quot;candidate&quot;</span><span class="pun">:</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">candidate </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    </span><span class="com">// let the &quot;negotiationneeded&quot; event trigger offer generation</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">onnegotiationneeded </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">createOffer</span><span class="pun">(</span><span class="pln">localDescCreated</span><span class="pun">,</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isInitiator</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// create data channel and setup chat</span><span class="pln">
        channel </span><span class="pun">=</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">createDataChannel</span><span class="pun">(</span><span class="str">&quot;chat&quot;</span><span class="pun">);</span><span class="pln">
        setupChat</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// setup chat on incoming data channel</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">ondatachannel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            channel </span><span class="pun">=</span><span class="pln"> evt</span><span class="pun">.</span><span class="pln">channel</span><span class="pun">;</span><span class="pln">
            setupChat</span><span class="pun">();</span><span class="pln">
        </span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> localDescCreated</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    pc</span><span class="pun">.</span><span class="pln">setLocalDescription</span><span class="pun">(</span><span class="pln">desc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        signalingChannel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">({</span><span class="pln"> </span><span class="str">&quot;sdp&quot;</span><span class="pun">:</span><span class="pln"> pc</span><span class="pun">.</span><span class="pln">localDescription </span><span class="pun">}));</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

signalingChannel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">pc</span><span class="pun">)</span><span class="pln">
        start</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">var</span><span class="pln"> message </span><span class="pun">=</span><span class="pln"> JSON</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">)</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">setRemoteDescription</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCSessionDescription</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">sdp</span><span class="pun">),</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="com">// if we received an offer, we need to answer</span><span class="pln">
            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pc</span><span class="pun">.</span><span class="pln">remoteDescription</span><span class="pun">.</span><span class="pln">type </span><span class="pun">==</span><span class="pln"> </span><span class="str">&quot;offer&quot;</span><span class="pun">)</span><span class="pln">
                pc</span><span class="pun">.</span><span class="pln">createAnswer</span><span class="pun">(</span><span class="pln">localDescCreated</span><span class="pun">,</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
        </span><span class="pun">},</span><span class="pln"> logError</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln">
        pc</span><span class="pun">.</span><span class="pln">addIceCandidate</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RTCIceCandidate</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">candidate</span><span class="pun">));</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> setupChat</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    channel</span><span class="pun">.</span><span class="pln">onopen </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// e.g. enable send button</span><span class="pln">
        enableChat</span><span class="pun">(</span><span class="pln">channel</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">

    channel</span><span class="pun">.</span><span class="pln">onmessage </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">(</span><span class="pln">evt</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        showChatMessage</span><span class="pun">(</span><span class="pln">evt</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> sendChatMessage</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    channel</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">msg</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> logError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">.</span><span class="pln">name </span><span class="pun">+</span><span class="pln"> </span><span class="str">&quot;: &quot;</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> error</span><span class="pun">.</span><span class="pln">message</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></pre></div>
      </div>
<!--div>
    <p>This simple example shows how configure two RTCDataChannel objects for different purposes.</p>
<pre  class='example sh_javascript'>
// the chat channel is reliable and not as prioritized as game data
var chatChan = peerConn.createDataChannel("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low latency channel for high performance
var gameDataChan = peerConn.createDataChannel("data", { "reliable": false, "priority": 10 });
    </pre>
  </div-->

    </section>

    <section id="call-flow-browser-to-browser">
      <h3><span class="secno">9.4 </span>Call Flow Browser to Browser</h3>

      <div class="note"><div class="note-title"><span>Note</span></div><p class="">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p></div>

      <p>This shows an example of one possible call flow between two browsers.
      This does not show every callback that gets fired but instead tries to
      reduce it down to only show the key events and messages.</p>

      <p><img style="width:100%" src="images/ladder-2party-simple.svg" alt="A message sequence chart detailing a call flow between two browsers" /></p>
<!--
      <p>The following flow shows a more complete set of the callbacks and
      events that happen.</p>

      <p><img alt=
      "A more complete message sequence chart detailing a call flow between two browsers"
      src="images/ladder-2party-full.svg" style="width:100%"></p>
      -->

    </section>
<!--
    <section>
      <h3>Call Flow Browser to MCU</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between a centralized
      conferencing server and a browser. This does not show every callback that
      gets fired but instead tries to reduce it down to only show the key
      events and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between a browser and a centralized conferencing server"
      src="images/ladder-mcu-simple.svg" style="width:100%"></p>
    </section>
-->

  </section>

  <section class="informative" id="event-summary">
    
<!--OddPage-->
<h2><span class="secno">10. </span>Event summary</h2><p><em>This section is non-normative.</em></p>

    <p>The following events fire on <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>
            The <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object's <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-message"><code>MessageEvent</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>A message was successfully received. TODO: Ref where MessageEvent
          is defined?</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-error"><code>error</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>TODO.</td>
        </tr>

        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>
            The <code><a href="#idl-def-RTCDataChannel" class="idlType"><code>RTCDataChannel</code></a></code> object's <a href="#dfn-underlying-data-transport" class="internalDFN">underlying data
            transport</a> has bee closed.
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following events fire on <code><a href="#idl-def-RTCPeerConnection" class="idlType"><code>RTCPeerConnection</code></a></code>
    objects:</p>

    <table border="1" style="border-width:0; width:60%">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-mediastream-connecting"><code>connecting</code></dfn></td>

          <td><code>Event</code></td>

          <td>TODO</td>
        </tr>

        <tr>
          <td><dfn id="event-mediastream-open"><code>open</code></dfn></td>

          <td><code>Event</code></td>

          <td>TODO</td>
        </tr>
<!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-RTCPeerConnection-close">close()</code> method was
            called. </td>
        </tr>
        <tr>
          <td>
            <dfn id="event-mediastream-message">
              <code>message</code>
            </dfn>
          </td>

          <td>
            <code>MessageEvent</code>
          </td>

          <td>A <a href="#data-udp-media-stream">data UDP media
          stream</a> message was received.</td>
        </tr>
        -->


        <tr>
          <td><dfn id="event-mediastream-addstream"><code>addstream</code></dfn></td>

          <td><code><a href="#idl-def-MediaStreamEvent" class="idlType"><code>MediaStreamEvent</code></a></code></td>

          <td>A new stream has been added to the <code title="dom-RTCPeerConnection-remoteStreams"><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></code>
          array.</td>
        </tr>

        <tr>
          <td><dfn id="event-mediastream-removestream"><code>removestream</code></dfn></td>

          <td><code><a href="#idl-def-MediaStreamEvent" class="idlType"><code>MediaStreamEvent</code></a></code></td>

          <td>A stream has been removed from the <code title="dom-RTCPeerConnection-remoteStreams"><a href="#widl-RTCPeerConnection-remoteStreams">remoteStreams</a></code>
          array.</td>
        </tr>

        <tr>
          <td><dfn id="event-negotiation"><code>negotiationneeded</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>The browser wishes to inform the application that session
          negotiation needs to be done at some point in the near future.</td>
        </tr>

        <tr>
          <td><dfn id="event-statechange"><code>statechange</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>TODO</td>
        </tr>

        <tr>
          <td><dfn id="event-icechange"><code>icechange</code></dfn></td>

          <td><code><a>Event</a></code></td>

          <td>TODO</td>
        </tr>

        <tr>
          <td><dfn id="event-icecandidate"><code>icecandidate</code></dfn></td>

          <td><code><a href="#idl-def-RTCPeerConnectionIceEvent" class="idlType"><code>RTCPeerConnectionIceEvent</code></a></code></td>

          <td>TODO</td>
        </tr>

        <tr>
          <td><dfn id="event-identityresult"><code>identityresult</code></dfn></td>

          <td><code><a>RTCIdentityEvent</a></code></td>

          <td>TODO</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section id="security-considerations">
    
<!--OddPage-->
<h2><span class="secno">11. </span>Security Considerations</h2>

    <p>TBD.</p>
  </section>

  <section id="iana-registrations">
    
<!--OddPage-->
<h2 id="sec-iana"><span class="secno">12. </span>IANA Registrations</h2>

    <p>IANA is requested to register the constraints defined in <a href="#sec-constraints">Constraints Section</a> as specified in
    [<cite><a class="bibref" href="#bib-RTCWEB-CONSTRAINTS">RTCWEB-CONSTRAINTS</a></cite>].</p>

    <section id="constraints">
      <h3 id="sec-constraints"><span class="secno">12.1 </span>Constraints</h3>

      <p>TOOD: Need to change the naming and declaration of these constraints
      to match the constraints draft once that is a bit further along. The
      names here now are likely not quite right but they serve as a place
      holder.</p>

      <div class="issue"><div class="issue-title"><span>Issue 8</span></div><p class="">ISSUE: there are multiple ways to add constraints. How
      are multiple values reconciled?</p></div>

      <p>The following new constraints are defined that can be used with an
      <code>RTCPeerConnection</code> object:</p>

      <dl>
        <dt>OfferToReceiveVideo</dt>

        <dd>
          <p>This is an enum type constraint that can take the values &quot;true&quot;
          and &quot;false&quot;. The default is a non mandatory &quot;true&quot; for an
          <code>RTCPeerConnection</code> object that has a video stream at the
          point in time when the constraints are being evaluated and is non
          mandatory &quot;false&quot; otherwise.</p>

          <p>In some cases, an <code>RTCPeerConnection</code> may wish to
          receive video but not send any video. The
          <code>RTCPeerConnection</code> needs to know if it should signal to
          the remote side whether it wishes to receive video or not. This
          constraint allows an application to indicate its preferences for
          receiving video when creating an offer.</p>
        </dd>

        <dt>OfferToReceiveAudio</dt>

        <dd>
          <p>This is an enum type constraint that can take the values &quot;true&quot;
          and &quot;false&quot;. The default is a non mandatory &quot;true&quot;.</p>

          <p>In some cases, an <code>RTCPeerConnection</code> may wish to
          receive audio but not send any audio. The
          <code>RTCPeerConnection</code> needs to know if it should signal to
          the remote side whether it wishes to receive audio. This constraints
          allows an application to indicate its preferences for receiving audio
          when creating an offer.</p>
        </dd>

        <dt>VoiceActivityDetection</dt>

        <dd>
          <p>This is an enum type constraint that can take the values &quot;true&quot;
          and &quot;false&quot;. The default is a non mandatory &quot;true&quot;.</p>

          <p>Many codecs and system are capable of detecting &quot;silence&quot; and
          changing their behavior in this case by doing things such as not
          transmitting any media. In many cases, such as when dealing with
          sounds other than spoken voice or emergency calling, it is desirable
          to be able to turn off this behavior. This constraint allows the
          application to provide information about whether it wishes this type
          of processing enabled or disabled.</p>
        </dd>

        <dt>IceTransports</dt>

        <dd>
          <p>This is an enum type constraint that can take the values &quot;none&quot;,
          &quot;relay&quot;, and &quot;all&quot;. The default is a non mandatory &quot;all&quot;.</p>

          <p>This constraint indicates which candidates the ICE engine is
          allowed to use. The value &quot;none&quot; means the ICE engine <em class="rfc2119" title="must">must</em> not send
          or receive any packets at this point. The value &quot;relay&quot; indicates the
          ICE engine <em class="rfc2119" title="must">must</em> only use media relay candidates such as candidates
          passing through a TURN server. This can be used to reduce leakage of
          IP addresses in certain use cases. The value of &quot;all&quot; indicates all
          values can be used.</p>
        </dd>

        <dt>RequestIdentity</dt>

        <dd>
          <p>This is an enum type constraint that can take the values &quot;yes&quot;,
          &quot;no&quot;, and &quot;ifconfigured&quot;. The default is a non mandatory
          &quot;ifconfigured&quot;.</p>

          <p>This constraint indicates whether an identity should be requested.
          The constraint may be used with either of the
          <code>createOffer()</code> or <code>createAnswer()</code> calls or
          with the constructor. The value &quot;yes&quot; means that an identity must be
          requested. The value &quot;no&quot; means that no identity is to be requested.
          The value &quot;ifconfigured&quot; means that an identity will be requested if
          either the user has configured an identity in the browser or if the
          <code>setIdentityProvider()</code> call has been made in JavaScript.
          As this is the default value, an identity will be requested if and
          only if the user has configured an IdP in some way. Note that as long
          as DTLS-SRTP is in used, fingerprints will be sent regardless of the
          value of this constraint.</p>
        </dd>
      </dl>

      <p>TODO items - need to register with IANA.</p>
    </section>
  </section>

  <section id="change-log">
    
<!--OddPage-->
<h2><span class="secno">13. </span>Change Log</h2>

    <p>This section will be removed before publication.</p>
    
<!-- Why do the first two headings automatically convert to <h2>? -->


    <h2 id="changes-since-nov-13-2012">Changes since Nov 13, 2012</h2>

    <ol>
      <li>Made some clarifications as to how operation queuing works, and fixed
      a few errors with the error handling description.</li>

      <li>Introduced new representation of tracks in a stream
      (removed MediaStreamTrackList). Added algorithm for creating a track
      to represent an incoming network media component.</li>

      <li>Renamed MediaStream.label to MediaStream.id (the definition needs
      some more work).</li>
    </ol>

    <h2 id="changes-since-nov-03-2012">Changes since Nov 03, 2012</h2>

    <ol>
      <li>Added text describing the queuing mechanism for
      RTCPeerConnection.</li>

      <li>Updated simple P2P example to include all mandatory (error)
      callbacks.</li>

      <li>Updated P2P data example to include all mandatory (error) callbacks.
      Also added some missing RTC prefixes.</li>
    </ol>

    <h3 id="changes-since-oct-19-2012">Changes since Oct 19, 2012</h3>

    <ol>
      <li>Clarified how createOffer() and createAnswer() use their
      callbacks.</li>

      <li>Made all failure callbacks mandatory.</li>

      <li>Added error object types, general error handling principles, and
      rules for when errors should be thrown.</li>
    </ol>

    <h3 id="changes-since-sept-23-2012">Changes since Sept 23, 2012</h3>

    <ol>
      <li>Restructured the document layout and created separate sections for
      features like Peer-to-peer Data API, Statistics and Identity.</li>
    </ol>

    <h3 id="changes-since-aug-16-2012">Changes since Aug 16, 2012</h3>

    <ol>
      <li>Replaced stringifier with serializer on RTCSessionDescription and
      RTCIceCandidate (used when JSON.stringify() is called).</li>

      <li>Removed offer and createProvisionalAnswer arguments from the
      createAnswer() method.</li>

      <li>Removed restart argument from the updateIce() method.</li>

      <li>Made RTCDataChannel an EventTarget</li>

      <li>Updated simple PeerConnection example to match spec changes.</li>

      <li>Added section about RTCDataChannel garbage collection.</li>

      <li>Added stuff for identity proxy.</li>

      <li>Added stuff for stats.</li>

      <li>Added stuff peer and ice state reporting.</li>

      <li>Minor changes to sequence diagrams.</li>

      <li>Added a more complete RTCDataChannel example</li>

      <li>Various fixes from Dan's Idp API review.</li>

      <li>Patched the Stats API.</li>
    </ol>

    <h3 id="changes-since-aug-13-2012">Changes since Aug 13, 2012</h3>

    <ol>
      <li>Made the RTCSessionDescription and RTCIceCandidate constructors take
      dictionaries instead of a strings. Also added detailed stringifier
      algorithm.</li>

      <li>Went through the list of issues (issue numbers are only valid with
      HEAD at fcda53c460). Closed (fixed/wontfix): 1, 8, 10, 13, 14, 16, 18,
      19, 22, 23, 24. Converted to notes: 4, 12. Updated: 9.</li>

      <li>Incorporate <a href="http://lists.w3.org/Archives/Public/www-archive/2012Aug/0015.html">changes
      proposed</a> by Li Li.
      </li>

      <li>Use an enum for DataChannelState and fix IDLs where using an optional
      argument also requires all previous optional arguments to have a default
      value.</li>
    </ol>

    <h3 id="changes-since-jul-20-2012">Changes since Jul 20, 2012</h3>

    <ol>
      <li>Added RTC Prefix to names (including the notes below).</li>

      <li>Moved to new definition of configuration and ice servers object.</li>

      <li>Added correlating lines to candidate structure.</li>

      <li>Converted setLocalDescription and setRemoteDescription to be
      asynchronous.</li>

      <li>Added call flows.</li>
    </ol>

    <h3 id="changes-since-jul-13-2012">Changes since Jul 13, 2012</h3>

    <ol>
      <li>Removed peer attribute from RTCPeerConnectionIceEvent (duplicates
      functionality of Event.target attribute).</li>

      <li>Removed RTCIceCandidateCallback (no longer used).</li>

      <li>Removed RTCPeerConnectionEvent (we use a simple event instead).</li>

      <li>Removed RTCSdpType argument from setLocalDescription() and
      setRemoteDescription(). Updated simple example to match.</li>
    </ol>

    <h3 id="changes-since-may-28-2012">Changes since May 28, 2012</h3>

    <ol>
      <li>Changed names to use RTC Prefix.</li>

      <li>Changed the data structure used to pass in STUN and TURN servers in
      configuration.</li>

      <li>Updated simple RTCPeerConnection example (RTCPeerConnection
      constructor arguments; use icecandidate event).</li>

      <li>Initial import of new Data API.</li>

      <li>Removed some left-overs from the old Data Stream API.</li>

      <li>Renamed &quot;underlying data channel&quot; to &quot;underlying data transport&quot;.
      Fixed closing procedures. Fixed some typos.</li>
    </ol>

    <h3 id="changes-since-april-27-2012">Changes since April 27, 2012</h3>

    <ol>
      <li>Major rewrite of RTCPeerConnection section to line up with IETF JSEP
      draft.</li>

      <li>Added simple RTCPeerConnection example. Initial update of
      RTCSessionDescription and RTCIceCandidate to support serialization and
      construction.</li>
    </ol>

    <h3 id="changes-since-21-april-2012">Changes since 21 April 2012</h3>

    <ol>
      <li>Moved MediaStream and related definitions to getUserMedia.</li>

      <li>Removed section &quot;Obtaining local multimedia content&quot;.</li>

      <li>Updated getUserMedia() calls in examples (changes in Media Capture TF
      spec).</li>

      <li>Introduced MediaStreamTrackList interface with support for adding and
      removing tracks.</li>

      <li>Updated the algorithm that is run when RTCPeerConnection receives a
      stream (create new stream when negotiated instead of when data
      arrives).</li>
    </ol>

    <h3 id="changes-since-12-january-2012">Changes since 12 January 2012</h3>

    <ol>
      <li>Clarified the relation of Stream, Track, and Channel.</li>
    </ol>

    <h3 id="changes-since-17-october-2011">Changes since 17 October 2011</h3>

    <ol>
      <li>Tweak the introduction text and add a reference to the IETF RTCWEB
      group.</li>

      <li>Changed the first argument to getUserMedia to be an object.</li>

      <li>Added a MediaStreamHints object as a second argument to
      RTCPeerConnection.addStream.</li>

      <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
    </ol>

    <h3 id="changes-since-23-august-2011">Changes since 23 August 2011</h3>

    <ol>
      <li>Separated the SDP and ICE Agent into separate agents and added
      explicit state attributes for each.</li>

      <li>Removed the send method from PeerConenction and associated callback
      function.</li>

      <li>Modified MediaStream() constructor to take a list of MediaStreamTrack
      objects instead of a MediaStream. Removed text about MediaStream parent
      and child relationship.</li>

      <li>Added abstract.</li>

      <li>Moved a few paragraphs from the MediaStreamTrack.label section to the
      MediaStream.label section (where they belong).</li>

      <li>Split MediaStream.tracks into MediaStream.audioTracks and
      MediaStream.videoTracks.</li>

      <li>Removed a sentence that implied that track access is limited to
      LocalMediaStream.</li>

      <li>Updated a few getUserMedia()-examples to use MediaStreamOptions.</li>

      <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
      example code.</li>

      <li>Fixed some broken getUserMedia() links.</li>

      <li>Introduced state handling on MediaStreamTrack (removed state handling
      from MediaStream).</li>

      <li>Reintroduced onended on MediaStream to simplify checking if all
      tracks are ended.</li>

      <li>Aligned the MediaStreamTrack ended event dispatching behavior with
      that of MediaStream.</li>

      <li>Updated the LocalMediaStream.stop() algorithm to implicitly use the
      end track algorithm.</li>

      <li>Replaced an occurrence the term finished track with ended track (to
      align with rest of spec).</li>

      <li>Moved (and extended) the explanation about track references and media
      sources from LocalMediaStream to MediaStreamTrack.</li>
    </ol>
  </section>

  <section class="appendix" id="acknowledgements">
    
<!--OddPage-->
<h2><span class="secno">A. </span>Acknowledgements</h2>

    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan Håkansson and Dominique Hazaël-Massieux, for
    their support. Substantial text in this specification was provided by many
    people including Harald Alvestrand, Justin Uberti, and Eric Rescorla.</p>
  </section>


<section id="references" class="appendix">
<!--OddPage-->
<h2><span class="secno">B. </span>References</h2><section id="normative-references"><h3><span class="secno">B.1 </span>Normative references</h3><dl class="bibliography"><dt id="bib-GETUSERMEDIA">[GETUSERMEDIA]</dt><dd>D. Burnett, A. Narayanan. <a href="http://dev.w3.org/TR/2012/WD-mediacapture-streams-20120628/"><cite>Media Capture and Streams</cite></a> 28 June 2012. W3C Working Draft (Work in progress.) URL: <a href="http://dev.w3.org/TR/2012/WD-mediacapture-streams-20120628/">http://dev.w3.org/TR/2012/WD-mediacapture-streams-20120628/</a> 
</dd><dt id="bib-HTML5">[HTML5]</dt><dd>Ian Hickson; David Hyatt. <a href="http://www.w3.org/TR/html5"><cite>HTML5.</cite></a> 29 March 2012. W3C Working Draft. (Work in progress.) URL: <a href="http://www.w3.org/TR/html5">http://www.w3.org/TR/html5</a> 
</dd><dt id="bib-ICE">[ICE]</dt><dd>J. Rosenberg. <a href="http://tools.ietf.org/html/rfc5245"><cite>Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols.</cite></a> April 2010. Internet RFC 5245. URL: <a href="http://tools.ietf.org/html/rfc5245">http://tools.ietf.org/html/rfc5245</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd>S. Bradner. <a href="http://www.ietf.org/rfc/rfc2119.txt"><cite>Key words for use in RFCs to Indicate Requirement Levels.</cite></a> March 1997. Internet RFC 2119.  URL: <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a> 
</dd><dt id="bib-RTCWEB-CONSTRAINTS">[RTCWEB-CONSTRAINTS]</dt><dd>D. Burnett. <a href="http://datatracker.ietf.org/doc/draft-burnett-rtcweb-constraints-registry/"><cite>IANA Registry for RTCWeb Media Constraints.</cite></a> URL: <a href="http://datatracker.ietf.org/doc/draft-burnett-rtcweb-constraints-registry/">http://datatracker.ietf.org/doc/draft-burnett-rtcweb-constraints-registry/</a> 
</dd><dt id="bib-SDP">[SDP]</dt><dd>J. Rosenberg, H. Schulzrinne. <a href="http://tools.ietf.org/html/rfc3264"><cite>An Offer/Answer Model with the Session Description Protocol (SDP).</cite></a> June 2002. Internet RFC 3264. URL: <a href="http://tools.ietf.org/html/rfc3264">http://tools.ietf.org/html/rfc3264</a>
</dd><dt id="bib-STUN">[STUN]</dt><dd>J. Rosenberg, R. Mahy, P. Matthews, D. Wing. <a href="http://tools.ietf.org/html/rfc5389"><cite>Session Traversal Utilities for NAT (STUN).</cite></a> October 2008. Internet RFC 5389. URL: <a href="http://tools.ietf.org/html/rfc5389">http://tools.ietf.org/html/rfc5389</a>
</dd><dt id="bib-STUN-URI">[STUN-URI]</dt><dd>S. Nandakumar,  G. Salgueiro, P. Jones, and M. Petit-Huguenin. <a href="http://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri"><cite>URI Scheme for Session Traversal Utilities for NAT (STUN) Protocol.</cite></a> 12 March 2012. Internet Draft (work in progress). URL: <a href="http://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri">http://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri</a> 
</dd><dt id="bib-TURN">[TURN]</dt><dd>P. Mahy, P. Matthews, J. Rosenberg. <a href="http://tools.ietf.org/html/rfc5766"><cite>Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN).</cite></a> April 2010. Internet RFC 5766. URL: <a href="http://tools.ietf.org/html/rfc5766">http://tools.ietf.org/html/rfc5766</a>
</dd><dt id="bib-TURN-URI">[TURN-URI]</dt><dd>M. Petit-Huguenin, S. Nandakumar,  G. Salgueiro, and  P. Jones. <a href="http://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris"><cite>Traversal Using Relays around NAT (TURN) Uniform Resource Identifiers.</cite></a> 12 March 2012. Internet Draft (work in progress). URL: <a href="http://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris">http://tools.ietf.org/html/draft-petithuguenin-behave-turn-uris</a> 
</dd><dt id="bib-WEBIDL">[WEBIDL]</dt><dd>Cameron McCormack. <a href="http://www.w3.org/TR/2011/WD-WebIDL-20110927/"><cite>Web IDL.</cite></a> 27 September 2011. W3C Working Draft. (Work in progress.) URL: <a href="http://www.w3.org/TR/2011/WD-WebIDL-20110927/">http://www.w3.org/TR/2011/WD-WebIDL-20110927/</a> 
</dd></dl></section><section id="informative-references"><h3><span class="secno">B.2 </span>Informative references</h3><dl class="bibliography"><dt id="bib-RTCWEB-JSEP">[RTCWEB-JSEP]</dt><dd>J. Uberti, C. Jennings. <a href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/"><cite>Javascript Session Establishment Protocol.</cite></a> URL: <a href="http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/">http://datatracker.ietf.org/doc/draft-ietf-rtcweb-jsep/</a> 
</dd></dl></section></section></body></html>
