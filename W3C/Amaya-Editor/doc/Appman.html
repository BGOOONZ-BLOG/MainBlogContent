<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">
  <!-- Document generated by Thot -->
  <title>Appman-E</title>
  <link href="Appman.toc.html" rel="ToC">
</head>

<body>
<pre><em>ThotLib V4</em></pre>
<pre>Date: June, 2002</pre>

<h1>The Thot Application Generation Language</h1>
<address>
  Vincent QUINT, Irène VATTON - INRIA 
</address>
<hr>

<div class="Section">
<h2><a name="secta1">1</a> Principles</h2>

<p>The Thot application generation language enables applications based on the
<em>active document</em> concept. An active document is an electronic
document which transforms itself or acts on its computing environment when
certain editing commands are issued by the user. This concept is used to
build different types of applications including access to databases, user
interface construction and technical document processing.</p>

<p>The Thot application generation language is used to define a graphic
interface (a set of menus) to which the application designer can associate
functions. These functions are either Thot standard functions or new specific
functions.</p>

<p>The language and its associated mechanisms also allow application
designers to modify or extend standard Thot editing functions. The
application can receive control during the execution of a standard function,
by asking for an <em>event</em>. These events are also specified in the
application generation language.</p>

<p>Consequently, an application is constituted by two different sets of
functions:</p>
<ul>
  <li><em>Commands</em> are run when the user selects a menu item. These
    commands can be standard commands provided by the Thot toolkit or new,
    specific commands written by the application developer.</li>
  <li><em>Actions</em> are run when certain events occur during standard
    editing commands.</li>
</ul>

<p>Commands and actions can use the Thot API  in order to modify the
documents being handled (refer to <em>The Thot Tool Kit API)</em></p>

<p>Application generation is based on <em>application schema</em>s written in
a specific language, the <em>A language</em>. Menus and associated specific
commands are declared in the main application schema, called
<code>EDITOR.A</code>. This application schema can refer to other application
schemas that define shared components reusable in different applications.
These application schemas are based on a generic logical structure and are
related to a structure schema. These application schemas have the same name
as the corresponding structure schema and the <code>.A</code> suffix.</p>

<div class="Section">
<h3><a name="sectb11">1.1</a> Menus and specific commands</h3>

<p>The <code>EDITOR.A</code> application schema defines the menus of the main
window (if this main window exists) and those attached to the menu bar of
each document window. The app application allows one to define different
menus for different document types (identified by their structure names). For
a specific document type, menus can differ form one view to another (the
range in presentation schema identified the view when the menu is specific to
one view).</p>

<p>The application schema associates a command with each item in these menus.
Each item is located within a menu or a cascade submenu of a menu. The
cascade is limited to one level.</p>

<p>When the user selects a menu item, the corresponding command is called,
with the current document and view as parameters.</p>

<p>There are different menu sections in the <code>EDITOR.A</code> application
schema:</p>
<ul>
  <li>The Main Window section is optional. It defines the menus attached to
    the main window.</li>
  <li>The Document Windows section is mandatory. It defines the menu bar of
    all document windows.</li>
  <li>The Structure_name Windows sections are optional. They specify the menu
    bar for specific document types.</li>
</ul>
</div>

<div class="Section">
<h3><a name="sectb12">1.2</a> Events and actions</h3>

<p>An event is raised by the editor whenever a Thot <em>standard</em> editing
command perform some treatment that the application needs to complement or
replace. For example, an event can be raised when the user selects an
element, modifies a character string, creates or deletes a logical element,
associates an attribute with an element, opens or closes a document view,
saves a document, etc.</p>

<p>Only standard editing commands raise events. <em>Specific</em> commands
associated with menu items in an application schema <em>do not</em> raise any
event.</p>

<p>Each event raised by Thot is associated with the object concerned by the
Thot editing command that triggers the event: element, attribute, view,
document, etc.</p>

<p>Whenever an event is raised, Thot calls the corresponding actions that is
associated with the event and the corresponding object in the application
schemas in use.</p>

<p>The user and the programs (commands and actions) can access the same
functions, but through different interfaces: standard Thot commands for the
user, API for programs. The operations performed on documents by an
application programs using the Thot API do not create events. However, there
are some exceptions to this rule; they are mentioned below.</p>

<p>The Thot standard editing commands generally produce two events with the
same name but with different suffixes:</p>
<ul>
  <li><em>.Pre</em>: this event is raised (and the action is executed) when
    the standard command is called by the user, before being processed by the
    editor. It allows the application to perform some processing,
    <em>before</em> the editor executes the standard command <em>or instead
    of</em> the normal processing of the editor. The action called in the
    application by the event returns a boolean value to indicate whether or
    not the performed action replaces the standard processing of the editor.
    If it is a replacement (<code>True</code> is returned by the action), the
    editor does not perform the normal processing.</li>
  <li><em>.Post</em>: this event is raised (and the action is executed)
    <em>after</em> the editor has performed the standadrd command
  normally.</li>
</ul>

<p>When an action performed on a <em>.Pre</em> event has replaced the normal
processing of the standard command, there is no corresponding <em>.Pos</em>t
event since the editor has not processed the command.</p>

<p>Each time an action of the application is called by an event, it receives
a context as a parameter, which allows the application to identify the
conditions in which the event has been raised. This context varies from an
event to the other because it only provides information significant for the
event in question.</p>

<p>Here is a list of all items that can be found in the context (for each
event, only a subset of this list is present):</p>
<ul>
  <li>the standard editing command which triggered the event (this
    information is always present because it permits the identification of
    the event and it determines the other items present in the context);</li>
  <li>the document in question;</li>
  <li>the element in question;</li>
  <li>the element type in question;</li>
  <li>the target element of the editing operation. It may be different from
    the element in question, for instance in the case of a reference;</li>
  <li>the type of the presentation rule in question;</li>
  <li>the attribute in question;</li>
  <li>the attribute type in question.</li>
</ul>

<p>Section <a href="#secta5">5</a> lists all the events that can be raised,
with the name of the event, the parameters received by the action which
handles this event and the conditions in which it is raised.</p>
</div>
</div>

<div class="Section">
<h2><a name="secta2">2</a> The A language</h2>

<p>Application generation is based <em>application schema</em>s written in a
specific language, the <em>A language</em>. Menus and associated specific
commands are declared in the main application schema, <code>EDITOR.A</code>.
This application schema can refer to other application schemas related to
different structure schemas.</p>

<p>Any application schema starts with the <em>APPLICATION</em> keyword
followed by the <em>EDITOR</em> word or the structure schema name.</p>

<p>The main application schema of the application contains two sections that
do not appear in other application schemas.</p>
<ul>
  <li>The <em>USES</em> section appears just after the <em>APPLICATION</em>
    statement. This section is optional and when it is present, it declares
    the other structure schemas used by the application as well as the
    modules needed. A module is a set of standard editing functions that each
    application may decide to use or not.</li>
  <li>The <em>MENUS</em> section is a mandatory section in the
    <code>EDITOR.A</code> schema and appears at the end of the schema.</li>
</ul>

<p>Three other sections can appear in any application schema:
<em>DEFAULT</em>, <em>ELEMENTS</em> and <em>ATTRIBUTES</em>. These sections
are optional but at least one of them must be present in an application
schema associated with a structure schema.</p>

<p>The schema must end with the <em>END</em> keyword.</p>
<pre>ASchema =         'APPLICATION' ElemIdent ';'
                  [ 'USES' SchemaAndModules ]
                  [ 'DEFAULT' EvtActionList ]
                  [ 'ELEMENTS' &lt; ElemActionList &gt; ]
                  [ 'ATTRIBUTES' &lt; AttrActionList &gt; ] 
                  [ 'MENUS' Menus ]
                  'END' .</pre>

<div class="Section">
<h3><a name="sectb21">2.1</a> Application integration</h3>

<p>A single application can use several application schemas: one per
structure schema for which specific commands or actions must be performed
(for instance, Report and Paragraph) and one general application schema (the
EDITOR schema). When an event is raised for a given element, the editor
consults first the application schema of the structure defining this element
in order to check whether an action has been attached to this event. If it is
not the case, the editor consults sequentially the application schemas of the
parent elements and finally the <code>EDITOR</code> application schema.</p>

<p>The <code>EDITOR.A</code> schema lists the names of other application
schemas involved in the application, in its USES section. The A compiler uses
this list to load the corresponding commands and actions.</p>

<p>The USES section lists also all the modules needed by the application.</p>
<pre>SchemasAndModules = SchemaOrModule &lt; ',' SchemaOrModule &gt; ';' .
SchemaOrModule    = DocumentType | Module .</pre>

<p>The Thot library provides optional modules which can be used or not by an
application. As an example, a document reader application does not need
editing functions. The USES section allows application developer to
explicitly load the needed Thot modules. The available modules are:</p>
<ul>
  <li>Editing: This module provides basic editing functions. It is
    automatically loaded when at least one standard editing command is used
    in the MENUS section (TtcCutSelection, etc.)</li>
  <li>StructEditing: This module has to be loaded explicitly. It provides
    restructuring functions and handles the Thot standard insertion menu.</li>
  <li>StructSelect: This module has to be loaded explicitly. It provides a
    structural selection instead of the standard one (no automatic
    replacement, ability to select directly structured elements, etc.)</li>
  <li>Search: This module provides search and replace functions. It is
    automatically loaded when a Thot search command is used.</li>
  <li>StructSearch: This module has to be loaded explicitly. It allows a
    combination of structural search with textual search and replace.</li>
  <li>Index: This module has to be loaded explicitly. It provides the Thot
    index capability.</li>
  <li>DisplayEmptyBox: This module has to be loaded explicitly. It displays
    empty elements as grey rectangles.</li>
  <li>Lookup: This module has to be loaded explicitly. It provides an
    <code>XLookupString</code> function that allows users to insert composed
    characters into Motif widget.</li>
  <li>Keyboards: This module has to be loaded explicitly. It allows Thot to
    display the Symbols and Greek keyboards when needed.</li>
  <li>Graphics:  This module has to be loaded explicitly. It allows Thot to
    display the Graphics keyboard when needed.</li>
</ul>
</div>

<div class="Section">
<h3><a name="sectb22">2.2</a> Menus declaration</h3>

<p>The MENUS section defines the menus contituting a menu bar (see example in
<a href="#secta7">7</a>):</p>
<ul>
  <li>The <code>Main Window</code> section is optional. It defines the menu
    bar of the main window.</li>
  <li>The <code>Document Windows</code> section is mandatory. It defines the
    menu bar of all document windows.</li>
  <li>The <code><em>Structure_name</em></code><code> Windows</code> sections
    are optional. They specify the menu bar for specific document types.</li>
</ul>
<pre>Menus =         [ 'Main' 'Window' ':' MenuList ]
                [ 'Document' 'Windows' ':' MenuList ]
                &lt; DocumentType 'Windows' ':' MenuList &gt; .
 
MenuList =      'BEGIN' NewMenu &lt; NewMenu &gt; 'END' ';' /
                NewMenu .
 
NewMenu =       [ 'view' ':' ViewNum ] MenuIdent
                [ '.' SubmenuIdent] [ ItemCascade ] ';' .
ItemCascade =   'Separator' / 'Button' ':' ItemAction /
                'Toggle' ':' ItemAction /
                'Dynamic' ':' ItemIdent .
ItemAction =    ItemIdent '-&gt;' ActionIdent .
 
DocumentType =  NAME .
MenuIdent =     NAME .
SubmenuIdent =  NAME .
ItemIdent =     NAME .
IdentAction =   NAME .</pre>

<p>For each menu item, the application schema associates a specific command,
except for the standard menus, composed by the Thot editor. For these menus
neither items nor actions have to be specified. There are two such menus:
"Attributes_" and  "Selection_".</p>

<p>The Thot toolkit allows application designers to declare one-level cascade
menus (menu and submenu).</p>

<p>A menu item can be:</p>
<ul>
  <li>a simple push button: "Button",</li>
  <li>a toggle button: "Toggle",</li>
  <li>a separator: "Separator" (there is no action in this case),</li>
  <li>or a dynamic entry: "Dynamic" (allows dynamic extension of the
    dialogue).</li>
</ul>

<p>The Thot toolkit is designed to support multilingual dialogue. Names of
menus, submenus and menu items declared in the application schema are
considered as generic names. When the application starts, the editor looks
for a dialogue table:<br>
config/$LANG-'name'dialogue  ('name' represents the application name)<br>
to substitute generic names by localized name adapted to the current language
$LANG.</p>

<p>The A compiler automatically generates a <code>EDITORdialogue</code> file
that can be used as a model to construct dialogue tables for each supported
language.</p>
</div>

<div class="Section">
<h3><a name="sectb23">2.3</a> <a name="L221">Associating actions with
events</a></h3>

<p>Actions that must be executed when certain events are raised, are
specified in sections <em>DEFAULT</em>, <em>ELEMENTS</em> and
<em>ATTRIBUTES</em>. Association of actions with events is simply expressed
by the name of the event (see the list of events in section <a
href="#secta5">5</a>) followed by an arrow (the two characters '-' and
'&gt;') and the name of the action.</p>

<p>The name of the event contains the suffix <em>.Pre</em> or <em>.Post</em>
depending on whether the action must be performed before or after normal
processing by the editor. If no suffix is present the event is assumed to
have the <em>.Pre</em> suffix.</p>

<p>The name of the action is the name of the procedure written by the
programmer and called by the event.</p>
<pre>EvtAction =    EvtIdent [ '.' PostPre ] '-&gt;' ActionIdent ';' .
PostPre =      'Post' / 'Pre' .
EvtIdent =     NAME .
ActionIdent =  NAME .</pre>
</div>

<div class="Section">
<h3><a name="sectb24">2.4</a> Default actions</h3>

<p>The <em>DEFAULT</em> section includes the event/action associations which,
by default, apply to all element types and all the attributes defined in the
structure schema corresponding to the application schema.</p>

<p>For a given element type and for a given event, when the <em>ELEMENTS</em>
section does not contain an event/action association, the association of the
<em>DEFAULT</em> section is taken into account if it exits. The
<em>DEFAULT</em> section can be absent. It can also contain only a subset of
the events listed in section <a href="#secta5">5</a>. When the
<em>ELEMENTS</em> section for a given element type and the <em>DEFAULT</em>
section do not define any action for a given event, this event has no effect
for the elements of that type.</p>

<p>The same principle applies to attributes: the <em>DEFAULT</em> section
specifies the event/action associations which apply to all attributes for
which the <em>ATTRIBUTE</em> section does not include these events.</p>

<p>The <em>DEFAULT</em> section is composed of the <em>DEFAULT</em> keyword
followed by an event/action association, if there is a single default
association, or by a sequence of associations between the keywords
<strong>BEGIN</strong> and <strong>END</strong>, if there are several. The
<strong>END</strong> keyword must be followed by a semicolon. The
event/action associations can be either for element types (see section <a
href="#sectb25">2.5</a>) or for attributes (see section <a
href="#sectb26">2.6</a>).</p>
<pre>                 'DEFAULT' EvtActionList
EvtActionList =  EvtAction /
                 'BEGIN' EvtAction &lt; EvtAction &gt; 'END' ';' .</pre>
</div>

<div class="Section">
<h3><a name="sectb25">2.5</a> <a name="L317">Actions associated with
elements</a></h3>

<p>The actions to be called for elements of a given type are defined in the
<em>ELEMENTS</em> section. In this section, the name of each element type
requiring actions is followed by a colon and by the event/action association
to be applied (if there is only one) or the list of associations (if there
are several) between the keywords <strong>BEGIN</strong> and
<strong>END</strong>. The <strong>END</strong> keyword is followed by a
semicolon.</p>

<p>In the case where the element type is a mark pair, but only in this case,
the type name can be preceded by the keywords <em>First</em> or
<em>Second</em>. These keywords indicate whether the associations that follow
apply to the first or second mark of the pair.</p>

<p>Each event/action association for an element type is composed in the same
way as described in section <a href="#sectb23">2.3</a>.</p>
<pre>                 'ELEMENTS' &lt; ElemActionList &gt;
ElemActionList = ElemActions &lt; ElemActions &gt; .
ElemActions =    [ FirstSec ] ElemIdent ':' EvtActionList .
FirstSec =       'First' / 'Second' .
ElemIdent =       NAME .
EvtActionList =   EvtAction /
                 'BEGIN' EvtAction &lt; EvtAction &gt; 'END' ';' .</pre>
</div>

<div class="Section">
<h3><a name="sectb26">2.6</a> <a name="L350">Actions associated with
attributes</a></h3>

<p>The actions to be called for given attributes are defined in the
<em>ATTRIBUTES</em> section. In this section, the name of each attribute
requiring actions is followed by a colon and by the event/action association
to be applied (if there is only one) or the list of associations (if there
are several) between the keywords <strong>BEGIN</strong> and
<strong>END</strong>; the <strong>END</strong> keyword is followed by a
semicolon.</p>

<p>Each event/action association for an attribute is composed in the same way
as indicated in section <a href="#sectb23">2.3</a>, but only certain events
are allowed for attributes, those beginning with <em>Attr</em> (see section
<a href="#sectb51">5.1</a> for the definition of these events).</p>
<pre>                 'ATTRIBUTES' &lt; AttrActionList &gt;
AttrActionList = AttrActions &lt; AttrActions &gt; .
AttrActions =    AttrIdent ':' EvtActionList .
AttrIdent =      NAME .</pre>
</div>
</div>

<div class="Section">
<h2><a name="secta3">3</a> Thot standard commands</h2>

<p>The Thot toolkit provides a set of standard commands. The commands
parameters are always the document identification and the view number.</p>
<dl>
  <dt>TtcChangeCharacters  (Document, View):</dt>
    <dd>Display the form that allows user to change font family, character
      style and character size.</dd>
</dl>
<dl>
  <dt>TtcChangeColors  (Document, View):</dt>
    <dd>Display the form that allows user to change background and foreground
      colors.</dd>
</dl>
<dl>
  <dt>TtcChangeFormat  (Document, View):</dt>
    <dd>Display the form that allows user to change indentation, alignment,
      justification and line spacing.</dd>
</dl>
<dl>
  <dt>TtcChangeGraphics  (Document, View):</dt>
    <dd>Display the form that allows user to change line weight,</dd>
</dl>
<dl>
  <dt>TtcChangePresentation  (Document, View):</dt>
    <dd>Display the menu that allows user to change presentation schema of
      document and its natures.</dd>
</dl>
<dl>
  <dt>TtcChildElement  (Document, View):</dt>
    <dd>Move the selection to the first enclosed element.</dd>
</dl>
<dl>
  <dt>TtcCloseDocument  (Document, View):</dt>
    <dd>Close the current document after acknowledgement if the document was
      previously modified.</dd>
</dl>
<dl>
  <dt>TtcCloseView  (Document, View):</dt>
    <dd>Close the current view of the document and the document if it is the
      last opened view. Close the document if that view is the last opened
      view.</dd>
</dl>
<dl>
  <dt>TtcCopySelection  (Document, View):</dt>
    <dd>Copy the current selection into the Thot clipboard.</dd>
</dl>
<dl>
  <dt>TtcCopyToClipboard  (Document, View):</dt>
    <dd>Copy the current selection into the X clipboard.</dd>
</dl>
<dl>
  <dt>TtcCreateDocument  (Document, View):</dt>
    <dd>Display the form that allows user to create a new document.</dd>
</dl>
<dl>
  <dt>TtcCutSelection  (Document, View):</dt>
    <dd>Delete the current selection and save it in the Thot clipboard.</dd>
</dl>
<dl>
  <dt>TtcDeletePreviousChar  (Document, View):</dt>
    <dd>Delete the previous character.</dd>
</dl>
<dl>
  <dt>TtcDeleteSelection  (Document, View):</dt>
    <dd>Delete the current selection.</dd>
</dl>
<dl>
  <dt>TtcDisplayGraphicsKeyboard  (Document, View):</dt>
    <dd>Display the graphic keyboard.</dd>
</dl>
<dl>
  <dt>TtcDisplayGreekKeyboard  (Document, View):</dt>
    <dd>Display the greek keyboard.</dd>
</dl>
<dl>
  <dt>TtcDisplayLatinKeyboard  (Document, View):</dt>
    <dd>Display the ISO Latin-1 keyboard.</dd>
</dl>
<dl>
  <dt>TtcDisplayMathKeyboard  (Document, View):</dt>
    <dd>Display the math-symbol keyboard.</dd>
</dl>
<dl>
  <dt>TtcEndOfLine(Document, View):</dt>
    <dd>Move the cursor to the end of the line.</dd>
</dl>
<dl>
  <dt>TtcGotoPage  (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcHolophrast  (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcInclude (Document, View):</dt>
    <dd>Obtain a  live  copy, i.e. a copy which is automatically updated each
      time you modify the copied element. The <code>TtcInclude</code> command
      presents the same menu as that offered by the <code>TtcInsert</code>
      command, i.e. the list of elements that can be created before or after
      the selected part. Once you have selected the type and the position of
      the copy, click with the left mouse button on the element to be copied.
      You can click in any Thot window of a document provided that you click
      on an element of the required type. You can move throughout the
      document by using the scroll bars in order to display the desired
      element before clicking on it.</dd>
</dl>
<dl>
  <dt>TtcIndex (Document, View):</dt>
    <dd>Activate the Thot index application. If the document does not already
      include index marks, that function initializes the Thot index
      application and allows insertion of index marks in the insert menu.
      After that, the function computes index marks to provide index
    table.</dd>
</dl>
<dl>
  <dt>TtcInsert (Document, View):</dt>
    <dd>Display the insert menu. This menu is built according to the current
      selection and the document structure schema. Thus, it may vary. It
      displays all element types that can be created before or after the
      current selection. By selecting an item from this menu, you choose the
      element to be created and its structural position.</dd>
</dl>
<dl>
  <dt>TtcInsertPageBreak (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcLineDown (Document, View):</dt>
    <dd>Scroll one line down.</dd>
</dl>
<dl>
  <dt>TtcLineUp (Document, View):</dt>
    <dd>Scroll one line up.</dd>
</dl>
<dl>
  <dt>TtcNextChar (Document, View):</dt>
    <dd>Move the cursor to the next character.</dd>
</dl>
<dl>
  <dt>TtcNextElement (Document, View):</dt>
    <dd>Move the selection to the next element.</dd>
</dl>
<dl>
  <dt>TtcNextLine (Document, View):</dt>
    <dd>Move the cursor one line down.</dd>
  <dt>TtcNextSelChar (Document, View):</dt>
    <dd>Extend the selection to the next character.</dd>
  <dt>TtcNextSelLine (Document, View):</dt>
    <dd>Extend the selection to the next line.</dd>
  <dt>TtcNextSelWord  (Document, View):</dt>
    <dd>Extend the selection to the next word.</dd>
  <dt>TtcNextWord (Document, View):</dt>
    <dd>Move the cursor to the beginning of the next word.</dd>
</dl>
<dl>
  <dt>TtcOpenDocument (Document, View):</dt>
    <dd>Display the form that allows user to open a new document.</dd>
</dl>
<dl>
  <dt>TtcOpenView (Document, View):</dt>
    <dd>Allow to open one of the available views of the document.</dd>
</dl>
<dl>
  <dt>TtcPageDown (Document, View):</dt>
    <dd>Move the current view one page down.</dd>
</dl>
<dl>
  <dt>TtcPageEnd (Document, View):</dt>
    <dd>Move the current view to the bottom of the document.</dd>
</dl>
<dl>
  <dt>TtcPageTop (Document, View):</dt>
    <dd>Move the current view to the top of the document.</dd>
</dl>
<dl>
  <dt>TtcPageUp (Document, View):</dt>
    <dd>Move the current view one page up.</dd>
</dl>
<dl>
  <dt>TtcPaginateDocument (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcPaginateView (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcParentElement (Document, View):</dt>
    <dd>Move the selection to the enclosing element.</dd>
</dl>
<dl>
  <dt>TtcPaste (Document, View):</dt>
    <dd>Insert the content of the Thot clipboard.</dd>
</dl>
<dl>
  <dt>TtcPasteFromClipboard (Document, View):</dt>
    <dd>Insert the content of the X clipboard.</dd>
</dl>
<dl>
  <dt>TtcPreviousChar (Document, View):</dt>
    <dd>Move the cursor to the previous</dd>
</dl>
<dl>
  <dt>TtcPreviousElement (Document, View):</dt>
    <dd>Move the selection to the previous element.</dd>
</dl>
<dl>
  <dt>TtcPreviousLine (Document, View):</dt>
    <dd>Move the cursor one line up.</dd>
  <dt>TtcPreviousSelChar (Document, View):</dt>
    <dd>Extend the selection to the previous character.</dd>
  <dt>TtcPreviousSelLine (Document, View):</dt>
    <dd>Extend the selection to the previous line.</dd>
  <dt>TtcPreviousSelWord  (Document, View):</dt>
    <dd>Extend the selection to the previous word.</dd>
  <dt>TtcPreviousWord (Document, View):</dt>
    <dd>Move the cursor to the beginning of the previous word.</dd>
</dl>
<dl>
  <dt>TtcPrint (Document, View):</dt>
    <dd>Start the printing process using options defined by the
      <code>TtcPrintSetup</code> command.</dd>
</dl>
<dl>
  <dt>TtcPrintSetup (Document, View):</dt>
    <dd>Display the form that allows user to change printing options.</dd>
</dl>
<dl>
  <dt>TtcSetupAndPrint (Document, View):</dt>
    <dd>Display the form that allows user to change printing options. With
      option to print.</dd>
</dl>
<dl>
  <dt>TtcQuit (Document, View):</dt>
    <dd>Close  all documents and quit the application.</dd>
</dl>
<dl>
  <dt>TtcSaveDocument (Document, View):</dt>
    <dd>Save the document at the same place.</dd>
</dl>
<dl>
  <dt>TtcSaveDocumentAs (Document, View):</dt>
    <dd>Display the save or export dialogue.</dd>
</dl>
<dl>
  <dt>TtcScrollLeft (Document, View):</dt>
    <dd>Scroll one position left.</dd>
</dl>
<dl>
  <dt>TtcScrollRight (Document, View):</dt>
    <dd>Scroll one position right</dd>
</dl>
<dl>
  <dt>TtcSearchEmptyElement (Document, View):</dt>
    <dd>Display the form that allows user to search empty elements in the
      current document.</dd>
</dl>
<dl>
  <dt>TtcSearchEmptyReference (Document, View):</dt>
    <dd>Display the form that allows user to search empty references in the
      current document.</dd>
</dl>
<dl>
  <dt>TtcSearchReference (Document, View):</dt>
    <dd>Display the form that allows user to search internal and external
      (located in other documents) references to the current selected part of
      the document.</dd>
</dl>
<dl>
  <dt>TtcSearchText (Document, View):</dt>
    <dd>Display the form that allows user to search and replace text in the
      current document.</dd>
</dl>
<dl>
  <dt>TtcSetBackupInterval (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcSetDocumentPath (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcSetSchemaPath (Document, View):</dt>
    <dd>Not implemented yet....</dd>
</dl>
<dl>
  <dt>TtcSetVisibilityView (Document, View):</dt>
    <dd>Allow user to filter what elements are displayed in the document
    view.</dd>
</dl>
<dl>
  <dt>TtcSetZoomView (Document, View):</dt>
    <dd>Allow user to grow or shrink character sizes in the document
    view.</dd>
</dl>
<dl>
  <dt>TtcSpellCheck (Document, View):</dt>
    <dd>Allow the user to check the spelling of a document being processed.
      Checking is based on dictionaries. The checker compares the words of
      the text with those in the available dictionaries. It suggests several
      replacements for each word which has not been found in the
      dictionaries. The user can then choose the correct word from the list
      of suggested words (or can type another word). The replacement
      operation is performed by the checker.</dd>
</dl>
<dl>
  <dt>TtcStandardGeometry (Document,View):</dt>
    <dd>Allow user to restore the standard geometry of selected elements.</dd>
</dl>
<dl>
  <dt>TtcStartOfLine (Document, View):</dt>
    <dd>Move the cursor to the beginning of the line.</dd>
</dl>
<dl>
  <dt>TtcSwitchButtonBar (Document, View):</dt>
    <dd>Alternatively, map an unmap the button bar in the document view.</dd>
  <dt>TtcUndo (Document, View):</dt>
    <dd>Undo the previous editing.</dd>
  <dt>TtcRedo (Document, View):</dt>
    <dd>Redo the previous undo.</dd>
</dl>
<dl>
  <dt>TtcSwitchCommands (Document, View):</dt>
    <dd>Alternatively, map and unmap the command zone (logo and textual
      commands) in the document view.</dd>
</dl>

<p>The Thot standard commands <strong>TtcInsertChar</strong> and
<strong>TtcInsertGraph</strong> need an extra parameter: the character to be
inserted. These commands can be called by application specific commands, but
cannot appear in the menus defined by the application schema EDITOR.A.</p>
<dl>
  <dt>TtcInsertChar (Document, View, char):</dt>
    <dd>This command inserts the character 'c' at the current insertion
    point.</dd>
</dl>
<dl>
  <dt>TtcInsertGraph (Document, View, char):</dt>
    <dd>This command inserts the graphics 'c' at the current insertion
    point.</dd>
</dl>
</div>

<div class="Section">
<h2><a name="secta4">4</a> Keyboard shortcuts</h2>

<p>It is convenient to be able to invoke menu commands from the keyboard. The
Thot toolkit provides a facility that let user accomplish this. When the
application starts, the Thot toolkit looks for the keyboard shortcuts file
for the application. This file defines a list of associations between a
keyboard sequence an the corresponding command.</p>

<p>The syntax used to define association is:</p>
<pre>Directive = KeySeq ':' IdentCommand ;
KeysSeq = KeySet [ ',' KeySet ] ;
KeySet = [ Modifier ] [ 'Shift' ] Key ;
Key = '&lt;Key&gt;' KeyValue / '&lt;Key&gt;' SpecialKey ;
Modifier = 'Ctrl' / 'Alt' / 'Meta' ;
KeyValue = 'a' / 'b' / ... ;
SpecialKey = 'Escape' / 'Delete' / 'Space' / 'BackSpace' / 'Return' / 'Up' /
'Down' / 'Left' / 'Right' / 'Home' / 'End' / 'F1' / ... / 'L1' / ... / 'R1' /
... ;
IdentCommand = 'TtcInsertChar(' Char ')' / NAME '()' ;
Char = KeyValue / OctalValue ; 
OctalValue = '\' NUMBER ; </pre>

<p>An <code>IdentCommand</code> can be either a standard Thot command or an
application specific command. We give below the example of the
<code>amaya.keyboard</code> file.</p>
<pre>#Amaya example
Ctrl &lt;Key&gt;1: CreateHeading1()
Ctrl &lt;Key&gt;2: CreateHeading2()
Ctrl &lt;Key&gt;3: CreateHeading3()
Ctrl &lt;Key&gt;Space: TtcInsertChar("\240")
Ctrl &lt;Key&gt;Return: TtcInsertChar("\212")
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;s: SaveDocument()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;p: TtcPrint()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;c: TtcCloseDocument()
Ctrl &lt;Key&gt;x , Ctrl &lt;Key&gt;f: TtcSearchText()
Ctrl &lt;Key&gt;c: TtcCopySelection()
Ctrl &lt;Key&gt;y: TtcPaste()
Ctrl &lt;Key&gt;w: TtcCutSelection()
Ctrl &lt;Key&gt;d: TtcDeleteSelection()
&lt;Key&gt;Delete: TtcDeleteSelection()
&lt;Key&gt;Escape: TtcParentElement()
Ctrl &lt;Key&gt;-: TtcChildElement()
Ctrl &lt;Key&gt;a: TtcStartOfLine()
Ctrl &lt;Key&gt;e: TtcEndOfLine()
&lt;Key&gt;Return: TtcCreateElement()
&lt;Key&gt;Home: TtcStartOfLine()
&lt;Key&gt;End: TtcEndOfLine()
Ctrl &lt;Key&gt;b: TtcPreviousElement()
Ctrl &lt;Key&gt;f: TtcNextElement()
&lt;Key&gt;L6: TtcCopyToClipboard()
&lt;Key&gt;L8: TtcPasteFromClipboard()</pre>

<p>The keyboard shortcuts file can be located either in the user's
<code>HOME</code> directory or in the <code>bin</code> directory within the
Thot hierarchy.</p>

<p>File paths are:</p>
<ul>
  <li>$HOME/'name'.keyboard</li>
  <li>$THOTDIR/bin/'name'.keyboard</li>
</ul>

<p>where 'name' represents the application name.</p>
</div>

<div class="Section">
<h2><a name="secta5">5</a> <a name="L500">Events</a></h2>

<p>Events can take two different forms: <em>.Pre</em> or <em>.Post</em>. The
actions called by the <em>.Pre</em> events must return a boolean value which
is <em>True</em> if the action replaces the standard processing of the
editor. The actions called by the <em>.Post</em> events have no return value.
The <em>.Pre</em> and <em>.Post</em> forms of the same event generally call
the corresponding actions with different parameters.</p>

<p>Events are grouped in several categories depending on the objects to which
they are transmitted: attributes, elements, specific presentation rules,
documents, views, application.</p>

<div class="Section">
<h3><a name="sectb51">5.1</a> <a name="L525">Events for attributes</a></h3>

<p>The following events only appear in the <code>DEFAULT</code> section or in
the <code>ATTRIBUTES</code> section of an application schema.</p>

<p>If they appear in the <code>DEFAULT</code> section, they are raised each
time an attribute of any type is created, modified, deleted, saved or read
(according to the event), whatever the element in question.</p>

<p>In the <code>ATTRIBUTES</code> section, these events are associated with
an attribute type and raised by the editor when attributes of this type are
created, deleted, modified, saved or read (according to the event), whatever
the element in question.</p>

<p>Each attribute's event is accompanied with a pointer to the subsequent
structure (this structure is defined in the <em>appaction.h</em> file):</p>
<pre>typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Attribute attribute;
  AttributeType attributeType;
} NotifyAttribute;
 </pre>
<dl>
  <dt>AttrCreate.Pre (NotifyAttribute):</dt>
    <dd>The editor is going to create for the element <code>element</code>
      indicated an attribute of type <code>attributeType</code>. The
      <em>attribute</em> field is not filled since the attribute has not yet
      been created.<br>
      If it deals with a mandatory attribute (preceded by an exclamation mark
      in the structure schema), the attribute is always created by the
      editor, whether the action returns <em>True</em> or <em>False</em> and
      the editor raises the events <code>AttrCreate.Pre</code> (before
      creating the attribute) and <code>AttrModify.Pre</code> (before
      requiring the user to assign a value to the attribute).<br>
      Attributes with an imposed value (entered with the <code>WITH</code>
      keyword in the structure schema), do not raise
      <code>AttrCreate.Pre</code> event when created.</dd>
</dl>
<dl>
  <dt>AttrCreate.Post (NotifyAttribute):</dt>
    <dd>The editor has created the attribute of type
      <code>attributeType</code> for the element <code>element</code>.<br>
      Attributes with imposed value (entered with the <code>WITH</code>
      keyword in the structure schema) do not raise a
      <code>AttrCreate.Post</code> event.</dd>
</dl>
<dl>
  <dt>AttrDelete.Pre (NotifyAttribute):</dt>
    <dd>The editor is going to delete the attribute <code>attribute</code>
      for the element in question. The attribute is still attached to the
      element and its value is still accessible.</dd>
</dl>
<dl>
  <dt>AttrDelete.Post (NotifyAttribute):</dt>
    <dd>The editor has removed an attribute of type
      <code>attributeType</code> for the indicated element. The attribute
      field is not filled since the attribute no longer exists.</dd>
</dl>
<dl>
  <dt>AttrExport.Pre (NotifyAttribute):</dt>
    <dd>This event occurs when a document is exported in a format that is not
      the standard Thot format (pivot format), and even if export is required
      by an application through the API (exception to the rule). The editor
      is going to generate the translation of the attribute<code>
      attribute</code> of the element <code>element</code>. If the action
      returns <em>True</em>, the attribute is not exported in the output
    file.</dd>
</dl>
<dl>
  <dt>AttrExport.Post (NotifyAttribute):</dt>
    <dd>The editor has exported in the output file the attribute
      <code>attribute</code> of the element <code>element</code>.</dd>
</dl>
<dl>
  <dt>AttrMenu.Pre (NotifyElement):</dt>
    <dd>The editor is composing the ``Attributes'' menu and will add to this
      menu an item which allows the user to create an attribute of type
      <code>attributeType</code> for element <code>element</code>. The
      <em>attribute</em> field is not filled since the attribute has not yet
      been created.
      <p>If the action called by the event returns <em>True</em>, the
      corresponding item is not included in the menu; if it returns
      <em>False</em>, the item is normally included in the menu.<br>
      There is no <code>AttrMenu.Post</code> event.</p>
    </dd>
</dl>
<dl>
  <dt>AttrModify.Pre (NotifyAttribute):</dt>
    <dd>The editor is going to change the value of the indicated attribute
      <code>attribute</code> for the element <code>element</code>.<br>
      If this is a mandatory attribute (i.e. an attribute preceded by an
      exclamation mark in the structure schema) and if the action gives a
      value to the attribute and returns <em>True</em>, the editor will not
      require the user to give a value.</dd>
</dl>
<dl>
  <dt>AttrModify.Post (NotifyAttribute):</dt>
    <dd>The editor has changed the value of the attribute
      <code>attribute</code> for the element <code>element</code>. The
      attribute then has the new value.</dd>
</dl>
<dl>
  <dt>AttrRead.Pre (NotifyAttribute):</dt>
    <dd>This event occurs when a document file is read and even if this is
      required by the API (exception to the rule). The editor starts reading
      an attribute of type <code>attributeType</code>. The attribute field is
      not significant. If the action returns <em>True</em>, the attribute is
      not included in the abstract tree.</dd>
</dl>
<dl>
  <dt>AttrRead.Post (NotifyAttribute):</dt>
    <dd>The editor has read the attribute attribute of the element element
      and has inserted it into the abstract tree.</dd>
</dl>
<dl>
  <dt>AttrSave.Pre (NotifyAttribute):</dt>
    <dd>This event occurs when a document is saved to a file and even if the
      backup is required by the API (exception to the rule). The editor
      writes the attribute<code> attribute</code> of the element
      <code>element</code>. If the action returns <em>True</em>, the
      attribute is not written in the file.</dd>
</dl>
<dl>
  <dt>AttrSave.Post (NotifyAttribute):</dt>
    <dd>The editor has written in the file the attribute
      <code>attribute</code> of the element <code>element</code>.</dd>
</dl>
</div>

<div class="Section">
<h3><a name="sectb52">5.2</a> Events for elements</h3>

<p>The following events only appear in the DEFAULT or ELEMENTS section of an
application schema.</p>

<p>In the DEFAULT section, they are raised as soon as any element is affected
by the relevant event.</p>

<p>In the <code>ELEMENTS</code> section, they are associated with an element
type and raised as soon as an element of this type is affected by the
relevant event.</p>

<p>Three different structures can accompany the events on elements (see the
structure specified for each event. These structures are defined in the
<code>appaction.h</code> file):</p>
<pre>typedef struct {
  TTEevent event;
  Document document;
  Element element;
  ElementType elementType;
  int position;
} NotifyElement;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  ElementType elementType;
  ElementType targetElementType;
} NotifyOnElementType;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Element target;
  Document targetdocument;
} NotifyOnTarget;
 
typedef struct {
  TTEevent event;
  Document document;
  Element element;
  Element target;
  int value;
} NotifyOnValue;
 </pre>
<dl>
  <dt>ElemActivate.Pre (NotifyElement):</dt>
    <dd>The user has just double-clicked on the element <code>element</code>.
      The selection has not already changed. This event is accepted for all
      elements (references or not). The <code>position</code> field has no
      meaning.</dd>
</dl>
<dl>
  <dt>ElemActivate.Post (NotifyElement):</dt>
    <dd>The selection has been moved once the user has double-clicked on the
      element <code>element</code>. You can ask the API where the new
      selection is if is the <code>ElemSelect</code> event has not been
      retrieved. The <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemChange.Pre (NotifyElement):</dt>
    <dd>The user is going to change the type of element <code>element</code>.
      The element has still its old type. The <code>elementType</code> field
      indicates the new type that will be given to the element.  The
      <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemChange.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just changed type. The
      <code>elementType</code> field indicates the previous type of the
      element. The <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemLClick.Pre (NotifyElement):</dt>
    <dd>The user has just clicked (Left button down) on the element
      <code>element</code>. The selection was not changed. This event is
      accepted for all elements (references or not). The
      <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemMClick.Pre (NotifyElement):</dt>
    <dd>The user has just clicked (Middle button down) on the element
      <code>element</code>. The selection was not changed. This event is
      accepted for all elements (references or not). The
      <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemRClick.Pre (NotifyElement):</dt>
    <dd>The user has just clicked (Middle button down) on the element
      <code>element</code>. The selection was not changed. This event is
      accepted for all elements (references or not). The
      <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemClick.Pre (NotifyElement):</dt>
    <dd>The user has just clicked (button up) on the element
      <code>element</code>. The selection was changed. This event is accepted
      for all elements (references or not). The <code>position</code> field
      has no meaning.</dd>
</dl>
<dl>
  <dt>ElemClick.Post (NotifyElement):</dt>
    <dd>The selection has just clicked on the element <code>element</code>.
      It's similar to the Pre event because Thot doesn't do anything for this
      event.</dd>
</dl>
<dl>
  <dt>ElemCopy.Pre (NotifyElement):</dt>
    <dd>The user is going to copy the element <code>element </code>contained
      in the abstract tree. The <code>position</code> field has no
      meaning.<br>
      When the event must copy a whole subtree, this event can only be raised
      for the root of the subtree to be copied or to each element of the
      subtree, depending on the notification mode in which the document is
      placed (see the <code>TtaSetNotificationMode</code> function of the
      API). However, even when the document is in the full notification mode,
      the event is only raised for the elements which require it.</dd>
</dl>
<dl>
  <dt>ElemCopy.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been copied. It is placed
      in the abstract tree. The <code>position</code> field has no
      meaning.<br>
      When the event has copied a subtree, this event can only be raised for
      the root of the copied subtree or on the contrary to each element of
      the subtree, depending on the notification mode of the document (see
      the <code>TtaSetNotificationMode</code> function of the API). However,
      even when the document is in the full notification mode, the event is
      only raised for the elements which have required it.</dd>
</dl>
<dl>
  <dt>ElemDelete.Pre (NotifyElement):</dt>
    <dd>The element <code>element</code> will be removed from its abstract
      tree if a  « Delete » or « Cut » command is issued by the user, or if
      the Thot kernel has detected two Text elements that may be merged. This
      element is still included in the abstract tree when the event is
      raised. 
      <p>The <code>position</code> field may take different values depending
      on the three following cases:</p>
      <dl>
        <dt>Case 1: « Delete » or « Cut »</dt>
          <dd>This event signals the deletion of an item of a delete sequence
            that depends on the selection. This functionnality allows the
            application, if such treatment is requested, to postpone its
            treatment until the full delete sequence is obtained.
            <p>Values of the position field maty be the following:</p>
            <p>TTE_STANDARD_DELETE_FIRST_ITEMS: the element is among the
            first items of the delete sequence: the event delete sequence is
            not complete, and next event(s) will follow this one.</p>
            <p>TTE_STANDARD_DELETE_LAST_ITEM: this is the last item of the
            delete sequence.</p>
          </dd>
      </dl>
      <dl>
        <dt>Case 2: Two Text units may be merged</dt>
          <dd>Two Text elements own the same caracteristics, and may be
            merged. The content of the second element will be merged into the
            first one, and this element will be deleted from the abstract
            tree if the application authorizes this deletion. Otherwise,
            these two elements will come apart.
            <p>The position field value is: TTE_MERGE_DELETE_ITEM</p>
          </dd>
      </dl>
      <dl>
        <dt>Case 3: Requested deleting (must be suppressed)</dt>
          <dd>The element will be necessarily deleted independent of the
            value returned by the event treatment. This event goal is simply
            indicative.
            <p>Value of the position field is: TTE_TOOLKIT_DELETE</p>
          </dd>
      </dl>
      <p>When the event must remove a whole subtree, this event can only be
      raised for the root of the subtree to be removed or on the contrary, to
      each element of this subtree, depending on which notification mode the
      document is in (see the <code>TtaSetNotificationMode</code> function of
      the API). However, even when the document is in the full notification
      mode, the event is only raised for the elements which require it.</p>
    </dd>
</dl>
<dl>
  <dt>ElemDelete.Post (NotifyElement):</dt>
    <dd>An element of type <code>elementType</code>, child of element, has
      been removed from the abstract tree. The <code>position</code> field
      gives the position of the removed element in the list of the children
      of <code>element</code> (0 for the first child, 1 for the second,
      etc.). If a subtree has been deleted, the event is only raised for the
      root of this subtree and not to each element of the subtree, even if
      the document is included in the full notification mode.</dd>
</dl>
<dl>
  <dt>ElemExport.Pre (NotifyElement):</dt>
    <dd>This event occurs when a document is exported, and even if export is
      required by the API (exception to the rule). The editor is going to
      generate the translation of the element <code>element</code>. The
      <code>position</code> field has no meaning. If the action returns
      <em>True</em>, the subtree is not exported in the output file.</dd>
</dl>
<dl>
  <dt>ElemExport.Post (NotifyElement):</dt>
    <dd>The editor has exported the element <code>element</code>. The
      <code>position</code> field has no meaning.</dd>
</dl>
<dl>
  <dt>ElemExtendSelect.Pre (NotifyElement):</dt>
    <dd>The user wants to extend the selection to the element
      <code>element</code>. This event is only raised when the selection
      implies at least two elements. The <code>position</code> field has no
      meaning.</dd>
</dl>
<dl>
  <dt>ElemExtendSelect.Post (NotifyElement):</dt>
    <dd>The selection has just been extended to the element
      <code>element</code>. The <code>position</code> field has no
    meaning.</dd>
</dl>
<dl>
  <dt>ElemInclude.Pre (NotifyElement):</dt>
    <dd>The user is going to include a new element of type
      <code>elementType</code> as the child of the element
      <code>element</code>. The <code>position</code> field gives the
      position of the element which will be included in the list of the
      children of <code>element</code> (0 before the first child, 1 after the
      first child, 2 after the second one, etc.).<br>
      If a whole subtree is to be included, the event is only raised for the
      root of the subtree.</dd>
</dl>
<dl>
  <dt>ElemFetchInclude.Pre (NotifyOnTarget)</dt>
    <dd>The user requires that the copy element <code>element </code>be up to
      date with the value of its source element.
      <p>In any case the source element are not accessible (for example when
      this is placed in a non loaded document), so the <code>element
      target</code> and <code>targetdocument</code> components are equal to
      NULL. Otherwise, the element<code> target</code> and
      <code>targetdocument</code> point to the source element and document
      where this is placed, respectively. <code></code></p>
    </dd>
</dl>
<dl>
  <dt>ElemFetchInclude.Post (NotifyOnTarget)</dt>
    <dd>If the document where the source element is placed is accessible, the
      copy element <code>element</code> was up to dated with the value of
      element <code>target</code>.</dd>
</dl>
<dl>
  <dt>ElemInclude.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been included. The
      <code>position</code> field has no meaning.<br>
      If a whole subtree has been included, the event is only raised for the
      root of this subtree.<br>
    </dd>
</dl>
<dl>
  <dt>ElemMenu.Pre (NotifyElement):</dt>
    <dd>The editor is composing the ``Insert'' or the ``Paste'' menu and will
      add to this menu an item which allows the user to create or paste an
      element of type <code>elementType</code> (with its descent) as the
      child of the element <code>element</code>. The <code>position</code>
      field gives the position of the element that will be created or pasted
      (when the user chooses the item of the menu) in the list of the
      children of <code>element</code> (0 before the first child or as the
      first child if element has no child, 1 after the first child, 2 after
      the second one, etc.).<br>
      If the event is in the <code>ELEMENTS</code> section, it is only raised
      when the editor includes in the menu the item regarding an element of
      the corresponding type.<br>
      If the event is in the <code>DEFAULT</code> section, it is raised as
      soon as the editor includes an item in the ``Insert'' menu, whatever
      the element type in question.<br>
      If the action called by the event returns <em>True</em>, the
      corresponding item is not included in the menu; if it returns
      <em>False</em>, the item is normally included in the menu.<br>
      There is no <code>ElemMenu.Post event</code>.</dd>
</dl>
<dl>
  <dt>ElemMove.Pre (NotifyElement):</dt>
    <dd>The user is going to create a surrounding element for element
      <code>element</code>. The <code>position</code> field has no
    meaning.</dd>
</dl>
<dl>
  <dt>ElemMove.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been surrounded by a new
      element. The <code>position</code> field has no meaning.</dd>
  <dt>ElemMouseOut.Pre (NotifyElement):</dt>
    <dd>Not supported yet.</dd>
  <dt>ElemMouseOut.Post (NotifyElement):</dt>
    <dd>Not supported yet.</dd>
  <dt>ElemMouseOver.Pre (NotifyElement):</dt>
    <dd>Not supported yet.</dd>
  <dt>ElemMouseOver.Post (NotifyElement):</dt>
    <dd>Not supported yet.</dd>
</dl>
<dl>
  <dt>ElemNew.Pre (NotifyElement):</dt>
    <dd>The user is going to create a new element of type
      <code>elementType</code> (with its descent) as the child of the element
      <code>element</code>. The <code>position</code> field gives the
      position of the element which will be created in the list of the
      children of <code>element</code> (0 before the first child or as the
      first child if the element has no child, 1 after the first child, 2
      after the second one, etc.).<br>
      If the event is in the <code>ELEMENTS</code> section, it is raised only
      when the user wants to create an element of the corresponding type.<br>
      If the event is in the <code>DEFAULT</code> section, it is raised as
      soon as the user creates a new element, whatever its type.<br>
      In all cases, this event is only raised for the root of a subtree that
      will be created and not for each element of this subtree.</dd>
</dl>
<dl>
  <dt>ElemNew.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been created and placed
      into the abstract tree of its document. The <code>position</code> field
      has no meaning.<br>
      If the event is in the <code>ELEMENTS</code> section, it is only raised
      when the user has created an element of the corresponding type.<br>
      If the event is in the <code>DEFAULT</code> section, it is raised each
      time the user creates a new element, whatever its type.<br>
      When the event has created a subtree, this event can only be raised for
      the root of the subtree newly created or on the contrary to each
      element of this subtree, depending on the notification mode in which
      the document can be found (see the <code>TtaSetNotificationMode</code>
      of the API). However, even when the document is included in the full
      notification mode, the event is only raised for the elements which
      require it.</dd>
</dl>
<dl>
  <dt>ElemPaste.Pre (NotifyOnValue):</dt>
    <dd>The user is going to paste the element <code>target</code> as the
      descendant of the element <code>element</code>. The element
      <code>target</code> is not already pasted at the position required by
      the user. The <code>value</code> field gives the position of the
      element to be pasted in the list of the children of
      <code>element</code> (0 before the first child, 1 after the first
      child, 2 after the second child, etc.).<br>
      In all cases, this event is only raised for the root of a subtree which
      will be pasted and not to each element of the subtree.</dd>
</dl>
<dl>
  <dt>ElemPaste.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been pasted. It is placed
      into the abstract tree. The <code>position</code> field contains the
      document from which the element has been copied or cut.<br>
      When the event has pasted a subtree, this event can only be raised for
      the root of the pasted subtree or on the contrary to each element of
      the subtree, depending on the notification mode of the document (see
      the <code>TtaSetNotificationMode</code> function of the API). However,
      even when the document is in the full notification mode, the event is
      only raised for the elements which have required it.</dd>
</dl>
<dl>
  <dt>ElemGraphModify.Pre (NotifyOnValue):</dt>
    <dd>The user wants to replace by <code>value</code> the contents of the
      graphic or symbol leaf <code>target</code> which has an ascendant
      <code>element</code>. <code>Element</code> is the element of the type
      with which the event is associated. If the event is defined in the
      <code>DEFAULT</code> section then <code>element</code> is equal to
      <code>target</code>.</dd>
</dl>
<dl>
  <dt>ElemGraphModify.Post (NotifyOnValue):</dt>
    <dd>The user has just replaced the contents of the graphic or symbol leaf
      <code>target</code> which has an ascendant <code>element</code>.</dd>
  <dt>ElemRead.Pre (NotifyElement):</dt>
    <dd>This event occurs when a document file is read and even if this is
      required by the API (exception to the rule). The editor starts reading
      an element of type <code>elementType</code> which must be the last
      child of <code>element</code>. The <code>position</code> field has no
      meaning. If the action returns <em>True</em>, the element (and the
      whole subtree) is not included in the abstract tree.</dd>
  <dt>ElemRead.Post (NotifyElement):</dt>
    <dd>The editor has read the element <code>element</code> and the whole
      subtree and has inserted it into the abstract tree. The
      <code>position</code> field has no meaning.</dd>
  <dt>ElemReturn.Pre (NotifyElement):</dt>
    <dd>The user hits the key Enter (or Return) when the target element was
      selected. <code>Element</code> is the element of the type with which
      the event is associated.</dd>
  <dt>ElemReturn.Post (NotifyElement):</dt>
    <dd>The thotlib has finished to handle the key Enter (or Return) on the
      target element. <code>Element</code> is the element of the type with
      which the event is associated.</dd>
  <dt>ElemSave.Pre (NotifyElement):</dt>
    <dd>This event occurs when a document is saved to a file and even if the
      backup is required by the API (exception to the rule). The editor is
      going to write the element <code>element</code>. The
      <code>position</code> field has no meaning. If the action returns
      <em>True</em>, the subtree is not written in the file.</dd>
  <dt>ElemSave.Post (NotifyElement):</dt>
    <dd>The editor has written the element <code>element</code>. The
      <code>position</code> field has no meaning.</dd>
  <dt>ElemSelect.Pre (NotifyElement):</dt>
    <dd>The user wants to select the element <code>element</code>. The
      selection has not been already made. This event is also raised before a
      double-click and when the editor follows a hypertext link. The
      <code>position</code> field has no meaning.</dd>
  <dt>ElemSelect.Post (NotifyElement):</dt>
    <dd>The element <code>element</code> has just been selected by the user.
      The <code>position</code> field has no meaning.</dd>
  <dt>ElemSetReference.Pre (NotifyOnTarget):</dt>
    <dd>The user requires that the reference element <code>element</code>
      points to the element <code>target</code> belonging to the
      <code>targetdocument</code> document. The link is not already
      established and the reference element still points its old target (or
      nothing at all). In the <code>ELEMENTS</code> section, this event is
      only valid for the elements of type reference (this is checked by the
      compiler). If this event is included in the <code>DEFAULT</code>
      section, it will only apply to the reference elements. This event is
      not accepted in the <code>ATTRIBUTES</code> section even for reference
      attributes (see the <code>AttrModify</code> event).</dd>
  <dt>ElemSetReference.Post (NotifyOnTarget):</dt>
    <dd>The reference element <code>element</code> has just changed its
      target upon the user's request. It now points to the element
      <code>target</code> belonging to the <code>targetdocument</code>
      document.</dd>
  <dt>ElemTab.Pre (NotifyElement):</dt>
    <dd>The user hits the key Tab when the target element was selected.
      <code>Element</code> is the element of the type with which the event is
      associated.</dd>
  <dt>ElemTab.Post (NotifyElement):</dt>
    <dd>The thotlib has finished to handle the key Tab on the target element.
      <code>Element</code> is the element of the type with which the event is
      associated.</dd>
  <dt>ElemTextModify.Pre (NotifyOnTarget):</dt>
    <dd>The user starts modifying the contents of the text or image leaf
      (modification of the name of the image file) <code>target</code> in the
      element <code>element</code>. The <code>element</code> parameter is the
      element of the type which has requested the event and which is an
      ascendant of the <code>target</code> leaf. The text leaf still has its
      previous contents.<br>
      If this event is in the <code>ELEMENTS</code> section, it is only
      raised if one of the ascendants (at any level) of the text leaf in
      question has the type with which the event is associated. If several
      ascendants require the event, it is raised for each one and first to
      the ones at the lowest level.<br>
      If this event is in the <code>DEFAULT</code> section, it is raised as
      soon as any text leaf is affected. In this case, both parameters
      <code>element </code>and <code>target</code> have the same value: the
      affected text leaf.<br>
      The return of the function called in the application is indifferent:
      whether it returns True or False, the behaviour of the editor is not
      modified.</dd>
  <dt>ElemTextModify.Post (NotifyOnTarget):</dt>
    <dd>The user has finished modifying the contents of the text or image
      leaf (modification of the name of the image file) <code>target</code>
      within element <code>element</code>. Several changes can have been made
      since the corresponding <code>ElemTextModify.Pre</code> event has been
      raised: inserted, pasted, deleted characters, etc. When the event is
      raised, the text leaf has its new contents. This event is raised in the
      same way as the <code>ElemTextModify.Pre</code> event.</dd>
  <dt>ElemTransform.Pre (NotifyOnElementType):</dt>
    <dd>The editor is changing the type of selected elements. The event is
      raised if the editor could not transform the whole selection into
      <code>targetElementType</code>, and before it tries to change
      individually each selected element.
      <p>If the event is in the <code>ELEMENTS</code> section, it is raised
      only if all the selected elements belong to the corresponding type.</p>
      <p>If the event is in the section <code>DEFAULT</code>, it is sent
      whatever the type of selected elements is.</p>
      <p>If the action called by the event returns <em>True</em>, the editor
      will not try to change individually the type of selected elements, if
      it returns <em>False</em>, the editor will try.</p>
      <p>There is no ElemTransorm.Post event.</p>
    </dd>
</dl>
</div>

<div class="Section">
<h3><a name="sectb53">5.3</a> Events for the specific presentation</h3>

<p>The following events can only appear in the <code>DEFAULT</code> or
<code>ELEMENTS</code> section of an application schema.</p>

<p>In the <code>DEFAULT</code> section, they are raised each time a specific
presentation rule is created, modified or deleted (depending on the event),
whatever the element in question.</p>

<p>In the <code>ELEMENTS</code> section, they are associated with an element
type and raised by the editor when the specific rule concerns an element of
the type in question.</p>

<p>A single type of context is associated with the events for the specific
presentation (this structure is defined in the <code>appaction.h</code>
file):</p>
<pre>typedef struct {
  TTEevent event;
  Document document;
  Element element;
  PRule pRule;
  int pRuleType;
} NotifyPresentation;
 </pre>
<dl>
  <dt>PRuleCreate.Pre (NotifyPresentation):</dt>
    <dd>The user requires a specific presentation rule of type
      <code>typePRule</code> to be added for the element
      <code>element</code>. The rule is not already added. The
      <code>pRule</code> field has no significant value.</dd>
</dl>
<dl>
  <dt>PRuleCreate.Post (NotifyPresentation):</dt>
    <dd>The <code>pRule</code> rule has just been added to the element
      <code>element</code>.</dd>
</dl>
<dl>
  <dt>PRuleModify.Pre (NotifyPresentation):</dt>
    <dd>The user wants to change the value of the <code>pRule</code> specific
      presentation rule associated with the element <code>element</code>.</dd>
</dl>
<dl>
  <dt>PRuleModify.Post (NotifyPresentation):</dt>
    <dd>The user has just changed the value of the <code>pRule</code>
      specific presentation rule associated with the element
      <code>element</code>.</dd>
</dl>
<dl>
  <dt>PRuleDelete.Pre (NotifyPresentation):</dt>
    <dd>The user wants to remove a <code>pRule</code> specific presentation
      rule associated with the element <code>element</code>.</dd>
</dl>
<dl>
  <dt>PRuleDelete.Post (NotifyPresentation):</dt>
    <dd>The user has removed a specific presentation rule of type
      <code>pRuleType</code> associated with the element
      <code>element</code>. The <code>pRule</code> field has no significant
      value.</dd>
</dl>
</div>

<div class="Section">
<h3><a name="sectb54">5.4</a> Events for documents</h3>

<p>The following events are intended for documents. They can only appear in
the <code>DEFAULT</code> section of an application schema. If it is an
application schema associated with a type of document, they are raised each
time a document of this type is (respectively) opened, created, closed or
saved. If they are included in the <code>DEFAULT</code> section of the
<code>EDITOR.A</code> schema, these events are raised whatever the type of
document.</p>

<p>Only one type of context accompanies the events for documents. The
<code>view</code> field is not significant for any event on documents (this
structure is defined in the <code>appaction.h</code> file):</p>
<pre>typedef struct {
  TTEevent event;
  Document document;
  View view;
} NotifyDialog;</pre>
<dl>
  <dt>DocOpen.Pre (NotifyDialog):</dt>
    <dd>The user requires a document to be opened. The document is not
      already opened but the <code>document</code> field already contains the
      identifier to be associated with the document if the application
      accepts to open it.</dd>
</dl>
<dl>
  <dt>DocOpen.Post (NotifyDialog):</dt>
    <dd>The user has opened the document designated by the
      <code>document</code> field.</dd>
</dl>
<dl>
  <dt>DocCreate.Pre (NotifyDialog):</dt>
    <dd>The user requires a new document to be created. The document is not
      already created but the <code>document</code> field already contains
      the identifier to be associated with the document if the application
      accepts its creation.</dd>
</dl>
<dl>
  <dt>DocCreate.Post (NotifyDialog):</dt>
    <dd>The user has created the document designated by the
      <code>document</code> field.</dd>
</dl>
<dl>
  <dt>DocClose.Pre (NotifyDialog):</dt>
    <dd>The user requires the document designated by the
      <code>document</code> field to be closed. The document is still
    open.</dd>
</dl>
<dl>
  <dt>DocClose.Post (NotifyDialog):</dt>
    <dd>The user has closed the document designated by the
      <code>document</code> field. This document identifier is no longer
    used.</dd>
</dl>
<dl>
  <dt>DocSave.Pre (NotifyDialog):</dt>
    <dd>The user requires the document designated by the
      <code>document</code> field to be saved. The document is not saved
    yet.</dd>
</dl>
<dl>
  <dt>DocSave.Post (NotifyDialog):</dt>
    <dd>The user has saved the document designated by the
      <code>document</code> field.</dd>
</dl>
<dl>
  <dt>DocExport.Pre (NotifyDialog):</dt>
    <dd>The user requires the document designated by the
      <code>document</code> field to be exported. The document is not
      exported yet.</dd>
</dl>
<dl>
  <dt>DocExport.Post (NotifyDialog):</dt>
    <dd>The user has exported the document designated by the
      <code>document</code> field.</dd>
</dl>
</div>

<div class="Section">
<h3><a name="sectb55">5.5</a> Events for views</h3>

<p>The following events are intended for views. They can only appear in the
<code>DEFAULT</code> section of an application schema and concern all views
of a given document (if they are in an application schema associated with
this type of document) or all views of all types of documents (if they are in
the <code>EDITOR.A</code> schema).</p>

<p>Two types of context can accompany the events for views (these structures
are defined in the <code>appaction.h</code> file):</p>
<pre>typedef struct {
  TTEevent event;
  Document document;
  View view;
} NotifyDialog;
 
typedef struct {
  TTEevent event;
  Document document;
  int verticalValue;
  int horizontalValue;
} NotifyWindow;</pre>
<dl>
  <dt>ViewOpen.Pre (NotifyDialog):</dt>
    <dd>The editor is going to open a view for the document designated by the
      <code>document</code> field. The <code>view</code> field is the view
      which will open.</dd>
</dl>
<dl>
  <dt>ViewOpen.Post (NotifyDialog):</dt>
    <dd>The editor has just opened the view for the document
      <code>document</code>. The  view  field is the view which is
    opened.</dd>
</dl>
<dl>
  <dt>ViewClose.Pre (NotifyDialog):</dt>
    <dd>The editor is going to close the view <code>view</code> for the
      document <code>document</code>.</dd>
</dl>
<dl>
  <dt>ViewClose.Post (NotifyDialog):</dt>
    <dd>The editor has just closed the view <code>view</code> for the
      document <code>document</code>.</dd>
</dl>
<dl>
  <dt>ViewResize.Pre (NotifyWindow):</dt>
    <dd>The editor is going to resize the view <code>view</code> for the
      document <code>document</code>. The parameters
      <code>verticalValue</code> and <code>horizontalValue</code> give the
      vertical and horizontal variations of the window. These values are
      expressed in pixels and can be positive or negative numbers. A negative
      value expresses a shrinking of the window.</dd>
</dl>
<dl>
  <dt>ViewResize.Post (NotifyWindow):</dt>
    <dd>The editor has just resized the view <code>view</code> for the
      document <code>document</code>.. The parameters
      <code>verticalValue</code> and <code>horizontalValue</code> give the
      vertical and horizontal variations of the window. These values are
      expressed in pixels and can be positive or negative numbers. A negative
      value expresses a shrinking of the window.</dd>
</dl>
<dl>
  <dt>ViewScroll.Pre (NotifyWindow):</dt>
    <dd>The editor is going to scroll the view <code>view</code> for the
      document <code>document</code>. The parameters
      <code>verticalValue</code> and <code>horizontalValue</code> give the
      vertical or horizontal scrolling value (one of them is nul). The
      scrolling value is expressed in pixels and can be a positive or
      negative number. When the scroll is done by a jump to a specific point
      within the document, the editor cannot compute the scrolling value; the
      value 65535 is returned in that case.</dd>
</dl>
<dl>
  <dt>ViewScroll.Post (NotifyWindow):</dt>
    <dd>The editor has just scrolled the view <code>view</code> for the
      document <code>document</code>. The parameters
      <code>verticalValue</code> and <code>horizontalValue</code> give the
      vertical or horizontal scrolling value (one of them is nul). The
      scrolling value is expressed in pixels and can be a positive or
      negative number. When the scroll is done by a jump to a specific point
      within the document, the editor cannot compute the scrolling value; the
      value 65535 is returned in that case.</dd>
</dl>
</div>

<div class="Section">
<h3><a name="sectb56">5.6</a> Events for the application</h3>

<p>The events described in this section do not concern a particular object
but the whole application. They appear when the editor is launched and
closed.</p>

<p>As they are not intended for a particular type of document, these events
can only appear in the <code>EDITOR.A</code> schema. They are independent of
any element or attribute. As a result, they can only appear in the
<code>DEFAULT</code> section of this schema.</p>

<p>Each event for the application is accompanied with a pointer to the
subsequent structure (this structure is defined in the
<code>appaction.h</code> file):</p>
<pre>typedef struct {
  TTEevent event;
} NotifyEvent;</pre>
<dl>
  <dt>Init.Pre (NotifyEvent):</dt>
    <dd>The editor is going to start. This event (and the next one) allows
      the application to carry out initializations. If the action triggered
      off by the event returns <code>True</code>, the editor does not start
      and the application immediately ends.</dd>
</dl>
<dl>
  <dt>Init.Post (NotifyEvent):</dt>
    <dd>The editor has just started. It can now receive the events issued by
      the user and the calls made by the application through the API.</dd>
</dl>
<dl>
  <dt>Exit.Pre (NotifyEvent):</dt>
    <dd>The editor is going to stop once the ``Quit'' command has been issued
      by the user. No operation has been already performed. In particular,
      all opened documents and views are still opened. If the action
      triggered off by this event returns <code>True</code>, the editor does
      not do anything and the editing session carries on.</dd>
</dl>
<dl>
  <dt>Exit.Post (NotifyEvent):</dt>
    <dd>The editor stops. The application can still use the API but all the
      documents which were opened at the end of the session are already
      closed.</dd>
</dl>
</div>
</div>

<div class="Section">
<h2><a name="secta6">6</a> Defining actions</h2>

<p>The actions of the application always receive a parameter which is a
pointer to a context whose structure depends on the processed event. If the
action knows the processed event, it can directly handle the parameter with
the correct structure (NotifyEvent, NotifyDialog, etc.). Conversely, if the
action is able to process several events, it can use the subsequent
declaration in order to sign the parameter and test the value of the event
field in order to analyze the rest of the context (these definitions can be
found in the <code>appaction.h</code> file):</p>
<pre>typedef union {
  NotifyEvent notifyevent;
  NotifyDialog notifydialog;
  NotifyWindow notifywindow;
  NotifyAttribute notifyattribute;
  NotifyElement notifyelement;
  NotifyOnElementType notifyonelementtype;
  NotifyOnTarget notifyontarget;
  NotifyOnValue notifyonvalue;
  NotifyPresentation notifypresentation;
} Notify;
 </pre>

<p>The list of events is defined as follows (only internal events are
listed):</p>
<pre>typedef enum {
  TteAttrMenu,
  TteAttrCreate,
  TteAttrModify,
  TteAttrRead,
  TteAttrSave,
  TteAttrExport,
  TteAttrDelete,
 
  TteElemMenu,
  TteElemTransform,
  TteElemNew,
  TteElemRead,
  TteElemSave,
  TteElemExport,
  TteElemDelete,
  TteElemSelect,
  TteElemExtendSelect,
  TteElemClick,
  TteElemLClick,
  TteElemMClick,
  TteElemRClick,
  TteElemActivate,
  TteElemSetReference,
  TteElemInclude,
  TteElemFetchInclude,
  TteElemPaste,
  TteElemChange,
  TteElemMove,
  TteElemTextModify,
  TteElemGraphModify,
  TteElemMouseOver,
  TteElemMouseOut,
 
  TtePRuleCreate,
  TtePRuleModify,
  TtePRuleDelete,
 
  TteDocOpen,
  TteDocTmpOpen,
  TteDocCreate,
  TteDocClose,
  TteDocSave,
  TteDocExport,
 
  TteViewOpen,
  TteViewClose,
  TteViewResize,
  TteViewScroll,
 
  TteInit,
  TteExit
} TteEvent;
 </pre>

<p>The type signature of a <code>.Pre</code> action of the application is:</p>
<pre>boolean Action(notify)
   Notify *notify;</pre>

<p>The type signature of a <code>.Post</code> action of the application
is:</p>
<pre>void Action(notify)
   Notify *notify;</pre>
</div>

<div class="Section">
<h2><a name="secta7">7</a> <a name="L1741">Example</a></h2>

<p>Amaya is an example of appplication built on Thot library. We just explain
here how this application declares a subset of its user interface and a
subset of Thot events using <code>EDITOR.A</code> and <code>HTML.A</code>
files. These complete files can be found in the  amaya  directory.</p>
<pre>APPLICATION EDITOR;
USES
 HTML, Lookup, NoStructSelect;
DEFAULT
   Init.Post -&gt; InitAmaya;

MENUS
   HTML Windows:
 BEGIN
.......
 view:1 Style button:BCreateClass -&gt; ChangeClass;
 view:1 Style button:BApplyClass -&gt; ApplyClass;
 view:1 Style Separator;
 view:1 Style button:BCSS -&gt; InitCSSDialog;
        view:1 Style Separator;
        view:1 Style.Phrase toggle:TEmphasis -&gt; CreateElemEmphasis;
....... 
        view:1 Style.Font toggle:TItalic -&gt; CreateElemItalic;
        view:1 Style.Font toggle:TBold -&gt; CreateElemBold;
        view:1 Style.Font toggle:TTeletype -&gt; CreateElemTeletype;
        view:1 Style.Font toggle:TStrikeOut -&gt; CreateElemStrikeOut;
        view:1 Style.Font toggle:TBig -&gt; CreateElemBig;
        view:1 Style.Font toggle:TSmall -&gt; CreateElemSmall;
        view:1 Style.Font button:BSub -&gt; CreateSub;
        view:1 Style.Font button:BSup -&gt; CreateSup;
 view:1 Style.Font button:BFont -&gt; CreateElemFont;

 Attributes_;

 view:1 Help_ button:BInformation -&gt; HelpAmaya;

 END;
END
 </pre>

<p>This <code>EDITOR.A</code> file declares in <code>USES</code> section that
Amaya loads the other application schema <code>HTML.A</code> and the Thot
modules:  Lookup, NoStructSelect.</p>

<p>The <code>DEFAULT</code> section allows Amaya to execute the
<code>InitAmaya</code> function as initial function.</p>

<p>The <code>MENUS</code> section declares only menus specific to HTML
documents. The Style menu is only defined for the view 1 of the HTML
presentation schema.</p>

<p>It  contains:</p>
<ul>
  <li>simple buttons like <code>BCreateClass</code> and
    <code>BApplyClass</code>, etc.,</li>
  <li>separators,</li>
  <li>cascade submenus like <code>Font</code> submenu which contains simple
    buttons and toggle buttons.</li>
</ul>

<p></p>

<table border="0">
  <tbody>
    <tr>
      <td width="50%"><p><img src="button.gif" alt="Image button.gif"></p>
      </td>
      <td width="50%"><p>&lt;- Menu Style in View 1</p>

        <p>&lt;- Simple buttons</p>

        <p></p>

        <p>&lt;- Separator</p>

        <p></p>

        <p></p>

        <p>&lt;- Cascade submenu Font</p>

        <p>&lt;- Toggles</p>
      </td>
    </tr>
  </tbody>
</table>

<p></p>
<pre>APPLICATION HTML;

DEFAULT
   BEGIN
   ElemActivate.Pre -&gt; DoubleClick;
.....
   END;

ELEMENTS

   PICTURE_UNIT:
   BEGIN
   ElemNew.Post -&gt; UpdateSRCattribute;
   ElemTextModify.Post -&gt; UpdateSRCattribute;
   END;

.....
ATTRIBUTES

   SRC:
   BEGIN
   AttrModify.Post -&gt; SRCattrModified;
   END;
.....
 END;
END</pre>

<p>The <code>HTML.A</code> file declares in <code>DEFAULT</code> section that
the Amaya action <code>DoubleClick</code> have to be called when user double
click any element in HTML documents. This action is called before Thot do
anything.</p>

<p>In section <code>ELEMENTS</code>, the <code>UpdateSRCattribute</code>
function will be called after the user creates a new picture element or
changes the contents of an existing one.</p>

<p>In section <code>ATTRIBUTES</code>, the <code>SRCattrModified</code>
function will be called after the attribute SRC is modified.</p>
</div>

<div class="Section">
<h2><a name="secta8">8</a> Compiling application schemas to generate
application</h2>

<p>Once application schemas have been written (see example in section <a
href="#secta7">7</a>), they must be compiled. To do this, corresponding
structure schemas have to be previously compiled and accessible (application
schema and structure schema have to be located in the same directory).</p>

<p>To compile the <code>EDITOR.A</code> schema the developer has to
invoke:</p>
<pre>app EDITOR</pre>

<p>The compiler creates four files:</p>
<ul>
  <li><code>EDITOR.h</code>: a file of definitions intended to be included in
    modules containing actions. This file defines all menus, submenus and
    menu items used in EDITOR.A file.</li>
  <li>EDITORdialogue: an example file of dialogue table which can be
    connected to substitute generic names by localized name adapted to the
    current language.</li>
  <li><code>EDITORAPP.c</code>: a file of C code which initializes the
    application. This file should not be modified.</li>
  <li><code>EDITORactions.proto</code>: a file containing the prototype of
    all application functions that have to be implemented. The first time,
    this file must then be renamed in <code>EDITORactions.c</code> and the
    body of actions must be written. Other time, the developer will take in
    this file only new functions to add them to its EDITORactions.c file.</li>
</ul>

<p>To compile the <code>HTML.A</code> schema the developer has to invoke:</p>
<pre>app HTML</pre>

<p>The compiler creates three files:</p>
<ul>
  <li><code>HTML.h</code>: a file of definitions intended to be included in
    modules containing actions. This file defines all the element types and
    the attributes contained in the (<code>HTML.S</code>) structure
  schema.</li>
  <li><code>HTMLAPP.c</code>: a file of C code which initializes the
    application. This file should not be modified.</li>
  <li><code>HTMLactions.proto</code>: a file containing the prototype of all
    application functions that have to be implemented. The first time, this
    file must then be renamed in <code>EDITORactions.c</code> and the body of
    actions must be written. Other time, the developer will take in this file
    only new functions to add them to its HTMLactions.c file.</li>
</ul>
</div>

<div class="Section">
<h2><a name="secta9">9</a> Makefile</h2>

<p>Once the code of actions has been written, it can be compiled and linked.
For compiling and  linking, modules generate by the app compiler have to be
included.</p>

<p>We provide a Imakefile for Thot applications which can be extended or used
as example (see makes/Imakefile).</p>

<p>Thot uses a set of libraries which are necessary to successfully compile
and link the application. Some of them are given with the Thot
environment:</p>
<ul>
  <li>libjpeg.a</li>
  <li>libz.a</li>
  <li>libpng.a</li>
  <li>libwww.a (only for Amaya)</li>
</ul>

<p>Other libraries have to be found in your specific environment:</p>
<ul>
  <li>libX11.a or libX11.so</li>
  <li>libXt.a or libXt.so</li>
  <li>libXm.a or libXm.so</li>
</ul>
</div>
</body>
</html>
