\documentstyle[titreRV,11pt,times]{book}

\marginparwidth 0pt
\oddsidemargin  1 cm
\evensidemargin  1 cm
\marginparsep 0pt
\topmargin   0pt
\textwidth   14 cm
\textheight  22.5 cm

\newenvironment{example}{\begin{quotation}\noindent{\bf Exemple~:}}{\end{quotation}}

\begin{document}
\sloppy

\title{\Huge Les langages de Thot}
\author{Vincent Quint}
\date{Version du 14 de'cembre 1996}
\maketitle

\chapter{Mode`le de document de Thot}

Tous les traitements offerts par Thot a` l'utilisateur se fondent sur la
repre'sentation des documents a` l'inte'rieur du syste`me. Cette repre'sentation
est elle-me^me de'rive'e du mode`le de document qui est a` la base de Thot.
C'est ce mode`le qui est pre'sente' ici, avant l'expose' des langages qui
permettent de de'crire les documents de fac,on ge'ne'rique.

\section{Structure logique des documents}

Le mode`le de document de Thot est principalement conc,u pour permettre a`
l'utilisateur d'agir sur les entite's qu'il a a` l'esprit lorsqu'il travaille
sur un document. Le mode`le prend donc en compte ces entite's en tant que
telles. Ce sont essentiellement des entite's logiques, comme des paragraphes,
des sections, des chapitres, des notes, des titres, des renvois et toutes les
entite's qui permettent de structurer logiquement un document.

Gra^ce a` ce mode`le, l'auteur peut de'couper son document en chapitres et
donner un titre a` chacun. Le contenu des chapitres peut aussi e^tre de'coupe'
en sections, sur plusieurs niveaux. Le texte est organise' en paragraphes
successifs, en fonction du contenu. Dans la phase d'e'criture, les
lignes, les pages, les marges, les espaces, les polices, les corps des
caracte`res n'ont pas grande importance. Au contraire, si le syste`me impose
de de'crire les documents en ces termes, cela constitue pluto^t une ge^ne.
Aussi le mode`le de Thot est-il d'abord fonde' sur l'aspect logique des
documents. La conception d'un mode`le de ce genre ne'cessite essentiellement
la de'finition~:

\begin{itemize}
\item
des entite's mises en jeu dans les documents,
\item
des relations entre ces entite's.
\end{itemize}

Le choix des entite's a` inte'grer dans le mode`le est de'licat. Pour tel
document on a besoin de chapitres, pour tel autre on utilise seulement des
sections de diffe'rents niveaux. Certains documents contiennent des annexes,
d'autres pas. Selon les documents, la me^me entite' peut porter des noms
diffe'rents comme ``Introduction'' ou ``Pre'sentation''. Certaines entite's,
indispensables pour quelques documents, comme les clauses dans un contrat
ou l'adresse du destinataire dans une lettre, sont sans utilite' dans
la plupart des autres cas.

Les diffe'rences entre documents ne re'sident pas seulement dans les entite's
mises en jeu, mais aussi dans leurs relations, dans la fac,on dont elles
s'articulent. Dans certains documents, les notes se trouvent disperse'es au
fil du document, par exemple au bas de la page ou` se trouve leur renvoi,
alors que dans d'autres documents elles sont regroupe'es a` la fin de
chaque chapitre, ou encore en fin d'ouvrage. Pour certains documents,
l'introduction peut e^tre compose'e de plusieurs sections, pour d'autres,
elle est limite'e a` une courte suite de paragraphes.

Tout cela rend improbable la de'finition d'un mode`le unique pouvant de'crire
n'importe quel document a` un niveau d'abstraction relativement e'leve'.
On pourrait e'videmment tenter de dresser une liste d'entite's d'usage
ge'ne'ral, comme les chapitres, sections, paragraphes, titres, etc.
et ramener les entite's exclues de cette liste a` celles qui y figurent.
Ainsi une introduction pourrait e^tre assimile'e a` un chapitre, une clause de
contrat a` un paragraphe ou une section. Mais en voulant e'largir le domaine
d'utilisation de certaines entite's privile'gie'es, on risque de les vider de
leur sens et donc de re'duire la puissance du mode`le. Et puis,
cela re'soudrait partiellement
le proble`me du choix des entite's, mais pas celui de leur organisation~: si
un chapitre doit clairement comporter des sections, comment indiquer qu'une
introduction n'en comporte pas, si on l'assimile a` un
chapitre~? Une solution consisterait a` compter l'introduction dans la liste
des entite's de base. Mais alors comment distinguer, selon les documents,
les introductions qui comportent des sections de celles qui n'en comportent
pas~? Peut-e^tre en de'finissant deux types d'introduction...
Dans ce cas, la liste des entite's d'usage ge'ne'ral risque de s'e'tendre
inde'finiment.

\section{Structures ge'ne'riques et spe'cifiques}

Ainsi, il parai^t impossible de dresser un inventaire exhaustif de toutes les
entite's ne'cessaires et suffisantes pour de'crire n'importe quel document.
Il semble tout aussi impossible de de'crire une fois pour toutes l'organisation
de ces entite's dans un document. C'est pourquoi Thot utilise pluto^t un
{\em me'ta-mode`le} qui permet de de'crire de nombreux {\em mode`les}, chaque
mode`le servant a` de'crire une {\em classe} de documents.

On appelle {\em classe} un ensemble de documents ayant des structures tre`s
proches. Ainsi, l'ensemble des rapports de recherche publie's par un
laboratoire constitue une classe~; l'ensemble des propositions commerciales
e'tablies par le service des ventes d'une socie'te' constitue une autre classe~;
l'ensemble des articles publie's par une revue donne'e constitue
une troisie`me classe. Il est clair qu'on ne peut pas dresser un inventaire
de toutes les classes de documents possibles et qu'on peut e^tre amene' a` en
cre'er de nouvelles selon les besoins et les applications.

Pour donner une de'finition plus rigoureuse des classes, il faut introduire
les notions de {\em structure ge'ne'rique} et de {\em structure spe'cifique}.
Chaque document a une {\em structure spe'cifique} qui organise
les diffe'rentes parties dont il est constitue'. Illustrons cela a` l'aide
d'un exemple simplifie' (voir figure~\ref{structspec}).
Dans cet exemple, on conside`re deux rapports, A et B.
Le rapport A comprend une introduction suivie de trois chapitres et d'une
conclusion. Le premier chapitre comprend deux sections, le deuxie`me trois
sections. Cela constitue la structure {\em spe'cifique} du document A.
On peut pre'senter de me^me la structure spe'cifique du document B~:
une introduction, deux chapitres, une conclusion~; le chapitre 1 est compose'
de trois sections et le chapitre 2 de quatre. Les structures spe'cifiques de
ces deux documents sont donc diffe'rentes.

\begin{figure}
\begin{verbatim}
        Rapport A                 Rapport B
             Introduction              Introduction
             Chapitre 1                Chapitre 1
                  Section 1.1               Section 1.1
                  Section 1.2               Section 1.2
             Chapitre 2                     Section 1.3
                  Section 2.1          Chapitre 2
                  Section 2.2               Section 2.1
                  Section 2.3               Section 2.2
             Chapitre 3                     Section 2.3
             Conclusion                     Section 2.4
                                       Conclusion
\end{verbatim}
\caption{Deux structures spe'cifiques}
\label{structspec}
\end{figure}

La {\em structure ge'ne'rique} de'finit le mode de construction des structures
spe'cifiques. Elle indique comment engendrer des structures spe'cifiques.
Les rapports A et B, bien que diffe'rents, sont construits
selon la me^me structure ge'ne'rique, qui spe'cifie qu'un rapport comporte
une introduction suivie d'un nombre variable de chapitres et d'une
conclusion, chaque chapitre comportant un nombre variable de sections.

Il y a une correspondance biunivoque entre une classe et une structure
ge'ne'rique~: tous les documents d'une classe sont construits d'apre`s la
me^me structure ge'ne'rique. D'ou` la de'finition de la classe~:
{\it une classe est un ensemble de documents dont la structure spe'cifique
est construite d'apre`s la me^me structure ge'ne'rique.}
Une classe est caracte'rise'e par sa structure ge'ne'rique.

Ainsi, une structure ge'ne'rique peut e^tre conside're'e comme un mode`le
du niveau qui nous inte'resse, mais seulement pour une classe
de documents. Si on se limite a` une classe, il est alors possible de
de'finir un mode`le (disons maintenant une structure ge'ne'rique) qui
repre'sente bien les documents de la classe, avec les entite's ne'cessaires,
et sans s'encombrer d'entite's inutiles. La description de l'organisation
des documents de la classe peut alors e^tre suffisamment pre'cise.

\section{Structure logique et structure physique}

Avec les structures ge'ne'riques, on ne conside`re que l'organisation {\em logique}
des documents, pas leur pre'sentation {\em physique} sur un e'cran ou des feuilles
de papier. Cependant, il faut bien prendre en compte la pre'sentation
graphique des documents de`s qu'il s'agit de les afficher ou de les imprimer.

Si on conside`re les documents imprime's courants, on constate que les de'tails
de pre'sentation servent essentiellement a` faire ressortir leur structure
logique. En dehors de quelques domaines particuliers, comme la publicite'
notamment, la pre'sentation est rarement inde'pendante de l'organisation
logique du texte. Tout l'art du typographe consiste d'ailleurs a` mettre
en relief l'organisation du texte qu'il compose, sans pour autant accrocher
l'oeil du lecteur avec des effets trop marque's. Ainsi on utilise l'italique
ou le gras pour mettre en valeur certains mots ou expressions qui ont une
signification plus forte que le reste du texte~: mots cle's, nouvelles
notions, citations, titres d'ouvrages, etc. D'autres effets
concernent l'organisation du texte~: espacement vertical, changement de marge,
saut de page, centrage, e'ventuellement combine's a` des changements de corps
ou de graisse des caracte`res. Ces effets servent a` indiquer les
changements de paragraphe, de section ou de chapitre~: le niveau dans la
structure logique du document est d'autant plus e'leve' que l'effet est plus
marque'.

Puisque le mode`le permet de de'crire toute la structure logique du document, la
pre'sentation peut se faire a` partir du mode`le, sans e^tre immerge'e dans
le document lui-me^me. Il suffit d'utiliser la structure logique du document
pour effectuer les changements voulus dans sa pre'sentation~: changement
de corps, de graisse, espacements, marges, centrages, etc.

De me^me qu'on ne peut pas de'finir une structure logique ge'ne'rique unique
pour toutes les classes de documents, de me^me on ne peut pas de'finir des
re`gles de pre'sentation universelles qui s'appliqueraient a` toutes les classes
de documents~: pour tel type de document les titres de chapitres seront
centre's dans la page et imprime's en gras dans un corps important, pour tel
autre document ces me^mes titres de chapitres seront imprime's en italique
dans un corps plus faible, et aligne's sur la marge gauche.

Il faut donc spe'cifier la pre'sentation des documents selon leur classe,
ce qui peut e^tre fait de fac,on fine, puisque la pre'sentation peut
s'exprimer en fonction des entite's de'finies dans la structure logique
ge'ne'rique de la classe. Ainsi il est possible de pre'ciser une pre'sentation
diffe'rente pour les titres de chapitre et les titres de section, et me^me
pour les diffe'rents titres de section selon leur niveau hie'rarchique.
L'ensemble des re`gles qui spe'cifient la pre'sentation de tous les types
d'e'le'ments de'finis dans une structure logique ge'ne'rique est appele' une
{\em pre'sentation ge'ne'rique}.

Les be'ne'fices tire's d'une pre'sentation lie'e a` la structure ge'ne'rique
et de'crite par une pre'sentation ge'ne'rique sont multiples. Il y a d'abord
l'homoge'ne'ite'. Puisque tous les documents d'une classe re'pondent a` la
me^me structure logique ge'ne'rique, une pre'sentation homoge`ne des
diffe'rents documents de la me^me classe peut e^tre assure'e en appliquant la
me^me pre'sentation ge'ne'rique a` tous les documents de la classe.
L'homoge'ne'ite' de pre'sentation s'applique e'galement a` l'inte'rieur d'un
document~: tous les titres de section du document seront pre'sente's de
la me^me fac,on, la premie`re ligne de tous les paragraphes de me^me type
aura le me^me renfoncement, etc.

Un autre avantage de cette approche de la pre'sentation est qu'elle
facilite les changements de l'aspect graphique des documents. Il suffit de
modifier, dans la pre'sentation ge'ne'rique, les re`gles attache'es a` chaque
type d'entite' pour transformer la pre'sentation de tout un document,
et de fac,on homoge`ne pour ce document. Dans ce cas, e'videmment,
l'homoge'ne'ite' a` l'inte'rieur de la classe n'est plus assure'e, mais le
moyen de la contro^ler est simple, il suffit d'adopter une seule pre'sentation
ge'ne'rique pour toute la classe.

Si l'homoge'ne'ite' de pre'sentation de la classe n'est pas requise de
fac,on stricte, on peut ainsi adapter l'aspect du document selon
l'utilisation qui en est faite ou selon l'appareil utilise' pour le
traiter. Il suffit pour cela de disposer de plusieurs pre'sentations
ge'ne'riques diffe'rentes pour une me^me classe de documents.
\label{presmul}
En appliquant l'une ou l'autre de ces pre'sentations au document, on peut le
voir sous diffe'rents aspects graphiques. Il faut souligner que ce type de
modification de la pre'sentation n'est pas un changement dans le document
lui-me^me (dans sa structure logique spe'cifique ou son contenu), mais
seulement dans son apparence au moment de l'e'dition ou de l'impression.

\section{Structures de documents et structures d'objets}

Nous n'avons jusqu'ici aborde' que la structure globale des documents,
sans envisager le contenu de cette structure. On pourrait se limiter a`
un contenu purement textuel en conside'rant qu'un titre ou un paragraphe
contient un simple texte line'aire. Mais ce mode`le serait trop restrictif.
En effet, certains documents ne contiennent pas uniquement du texte,
mais e'galement des tableaux, des sche'mas, des photographies, des
formules mathe'matiques, des fragments de programme. Le mode`le doit donc
permettre la repre'sentation de tels {\em objets}.

De la me^me fac,on que pour l'ensemble d'un document, le mode`le prend en
compte la structure logique des objets de ce genre. Certains sont clairement
structure's, d'autres le sont moins. On peut reconnai^tre une structure
logique dans les formules mathe'matiques, dans les tableaux,
ou dans certains types de sche'mas. En revanche, il est plus difficile de
de'finir la structure logique d'une photographie ou de certains dessins.
Mais dans tous les cas, il ne semble pas possible de de'finir une structure
unique qui puisse repre'senter l'ensemble de ces types d'objets. L'approche
qui a mene' a` la de'finition d'une me'ta-structure et de classes pour les
documents s'applique e'galement aux objets. On de'finit des classes d'objets
qui regroupent les objets de me^me nature, construits a` partir de la me^me
structure logique ge'ne'rique.

Ainsi, on peut de'finir une classe mathe'matique (classe d'objets formules)
et lui associer une structure logique ge'ne'rique. Mais si, avec une structure
ge'ne'rique unique, on peut repre'senter des formules mathe'matiques suffisamment
varie'es, pour d'autres objets, structure's de fac,on moins rigoureuse, il
est ne'cessaire de de'finir plusieurs classes. Cela assure, comme pour les
documents, que le mode`le de'crit bien les objets que l'on veut repre'senter.
Cela permet aussi de prendre en compte des objets qui n'auraient pas e'te'
pre'vus initialement. Cette remarque peut d'ailleurs s'appliquer e'galement
aux mathe'matiques~: on peut de'finir plusieurs classes de formules, selon la
partie des mathe'matiques a` laquelle on s'inte'resse.

Puisqu'on retient pour les objets le me^me niveau de repre'sentation logique
que pour les documents, on peut en tirer les me^mes avantages. En particulier,
il est possible de de'finir la pre'sentation de fac,on externe aux objets
eux-me^mes et de la relier a` la classe. Ainsi, comme pour les documents, on
obtient une pre'sentation uniforme des objets de me^me nature et on peut
changer globalement la pre'sentation de tous les objets d'une classe donne'e,
simplement en changeant la pre'sentation ge'ne'rique de la classe. Autre
avantage, en utilisant ce mode`le de document, le syste`me ne perturbe pas
l'utilisateur avec des ta^ches de pre'sentation, mais au contraire, il le
laisse se concentrer sur l'aspect logique du document et des objets.

Il est clair que tous les documents d'une classe n'utilisent pas
ne'cessairement les me^mes classes d'objets~:
dans un rapport technique on utilisera des
tableaux, dans un autre on utilisera des formules mathe'matiques, mais pas
de tableaux. Les classes d'objets utilisables ne sont pas mentionne'es
de manie`re limitative dans la structure logique ge'ne'rique des documents~;
au contraire, il est possible de les choisir librement, inde'pendamment
de la classe du document, parmi un large ensemble.

Les classes d'objets e'tant ainsi banalise'es et utilisables dans tout
document, on peut e'largir la notion d'objet et accepter sous ce vocable non
seulement des e'le'ments non textuels, mais aussi certaines varie'te's d'e'le'ments
textuels qui peuvent apparai^tre dans pratiquement tous les documents, quelle
que soit leur classe. Parmi ces e'le'ments textuels, on peut mentionner un
certain nombre d'e'le'ments de'finis dans les formateurs Scribe et \LaTeX\
comme des {\em environnements}~: e'nume'ration, description, exemple, citation,
etc., voire me^me les paragraphes.

On de'finit donc le mode`le de document non pas comme un mode`le unique et
ge'ne'ral de'crivant d'un coup toutes les varie'te's de documents, mais
pluto^t comme un me'ta-mode`le qui permet de de'crire de la me^me fac,on
plusieurs mode`les repre'sentant chacun, soit une classe de documents
semblables, soit une classe d'objets similaires que tout document peut
inte'grer.


\chapter{Langage S}

\section{Me'ta-structure des documents}

S'il apparai^t que le concept de me'ta-structure convient bien a` la
description des documents a` un niveau d'abstraction e'leve', il faut encore
de'finir pre'cise'ment cette me'ta-structure. Pour cela, on pre'sente d'abord
les e'le'ments de base a` partir desquels les documents et les objets
structure's sont compose's, et on pre'cise ensuite les moyens d'assembler
ces e'le'ments de base dans des structures repre'sentant des documents ou
des objets complets.

\subsection{Types de base}

Au niveau le plus bas de la structure d'un document, le premier atome
conside're' est le caracte`re. Comme les caracte`res sont rarement
isole's mais font pluto^t partie d'une suite line'aire, et pour alle'ger
les structures, on retient comme atome la {\em chai^ne de caracte`res}
et on regroupe dans une me^me chai^ne les caracte`res conse'cutifs appartenant
au me^me e'le'ment structural.

Si on ne raffine pas la structure d'un document jusqu'a` descendre au
niveau des mots ou des phrases, on peut conside'rer que le contenu
d'un simple paragraphe est une unique chai^ne de caracte`res. En revanche,
le titre d'un chapitre, le titre de la premie`re section de ce chapitre
et le texte du premier paragraphe de cette section constituent trois
chai^nes de caracte`res diffe'rentes, puisqu'appartenant a` des e'le'ments
structuraux distincts.

Si au contraire on cherche une repre'sentation tre`s
fine de la structure d'un document, on peut de'finir des chai^nes ne
contenant qu'un mot, voire me^me un seul caracte`re. C'est le cas par exemple
des programmes, pour lesquels on voudrait retenir une structure tre`s
proche de la syntaxe du langage de programmation. Dans ce cas, une instruction
Pascal d'affectation initialisant une variable simple a` ze'ro comportera
deux e'le'ments structuraux, l'identificateur de la variable
(une courte chai^ne de caracte`res) et la valeur affecte'e (une chai^ne d'un
seul caracte`re, ``0'').

La chai^ne de caracte`res n'est pas le seul atome ne'cessaire pour
repre'senter les documents qui nous inte'ressent. Elle suffirait pour les
documents purement textuels, mais de`s que les objets que nous avons
conside're's interviennent, il faut d'autres atomes~; et selon les classes
d'objets que l'on veut repre'senter, une varie'te' plus ou moins grande
d'atomes est ne'cessaire.

Des {\em e'le'ments graphiques} de base sont utiles pour les tableaux et les
sche'mas de diffe'rents types. Ces e'le'ments sont des formes ge'ome'triques
simples comme des traits horizontaux ou verticaux, suffisants pour les
tableaux, ou encore des lignes obliques, des fle`ches, des rectangles,
des cercles, pour les sche'mas. \`{A} partir de ces e'le'ments et des chai^nes
de caracte`res, on peut construire les objets graphiques et les tables.

Les photographies et les images en ge'ne'ral, bien que peu structure'es,
doivent pouvoir e^tre repre'sente'es dans les documents. Pour cela on
dispose d'e'le'ments {\em images}.

Enfin les notations mathe'matiques font appel a` des e'le'ments qui tiennent
a` la fois du caracte`re et de l'e'le'ment graphique, qui sont les
{\em symboles}. \`{A} titre d'exemple on peut citer les radicaux, ou les
signes d'inte'gration, ou encore les grandes parenthe`ses, qui tous prennent
des dimensions lie'es a` leur environnement, c'est-a`-dire a` l'expression sur
laquelle ils portent.

Pour re'sumer, les e'le'ments de base qui servent a` la construction de
documents et d'objets structure's sont~:

\begin{itemize}
\item
les chai^nes de caracte`res,
\item
les e'le'ments graphiques,
\item
les images,
\item
les symboles mathe'matiques.
\end{itemize}

\subsection{E'le'ments construits}

Un document est e'videmment forme' d'e'le'ments de base. Mais le mode`le de
Thot comprend aussi des e'le'ments de plus haut niveau. Ainsi dans un document
forme' de plusieurs chapitres, chaque chapitre est un e'le'ment, et dans les
chapitres chaque section est e'galement un e'le'ment, et ainsi de suite.
Un document est donc un ensemble organise' d'e'le'ments.

Il y a dans un document diffe'rentes sortes d'e'le'ments. Chaque e'le'ment
a un {\em type} qui indique le ro^le de l'e'le'ment dans l'ensemble du
document. Ainsi, nous aurons par exemple les types chapitre et section.
Le document est forme' d'e'le'ments type's~: des e'le'ments de type chapitre
et des e'le'ments de type section, entre autres, mais aussi des e'le'ments
de type chai^ne de caracte`res ou de type graphique~: les e'le'ments de base
sont e'galement des e'le'ments type's. A` l'oppose', le document lui-me^me
est aussi conside're' comme un e'le'ment type'.

La diffe'rence importante entre les e'le'ments de base et les autres
e'le'ments du document est que les e'le'ments de base sont des atomes
(ils ne sont pas de'compose's), alors que les autres, appele's
{\em e'le'ments construits}, sont compose's d'autres e'le'ments,
qui peuvent e^tre aussi bien des e'le'ments de base que des
e'le'ments construits. Un e'le'ment construit de type chapitre (on dit plus
simplement ``un chapitre'') est compose' de sections, qui sont e'galement des
e'le'ments construits. Un paragraphe, e'le'ment construit, peut e^tre compose'
de chai^nes de caracte`res, qui sont des e'le'ments de base, et de formules,
qui sont des e'le'ments construits.

On peut ici faire un paralle`le entre les types d'e'le'ments et les types de
donne'es des langages de programmation type's, comme Pascal. Les quatre types
de base de Thot peuvent se comparer aux types de base standard de Pascal~:
entier, caracte`re, boole'en, re'el. Les types d'e'le'ments construits
peuvent se comparer aux types structure's de Pascal, que chaque programmeur
de'finit a` partir des types de base.

Un document est e'galement un e'le'ment construit. Cette remarque a son
importance, elle permet notamment de conside'rer un document comme une
partie d'un autre document, et inversement, de traiter une partie
d'un document comme un document complet. Ainsi, un article propose' a`
une revue est traite' par son auteur comme un document en soi,
alors que l'e'diteur de la revue le conside`re comme une partie d'un
fascicule. Un tableau ou une figure appartenant a` un document peuvent
en e^tre extraits et traite's comme un document complet, par exemple
pour pre'parer un transparent pour une confe'rence.

Ces conside'rations sur les types et les e'le'ments construits s'appliquent
aussi bien aux objets qu'aux documents. Un tableau est un e'le'ment construit
forme' d'autres e'le'ments construits, des lignes et des colonnes. Une
ligne ou une colonne est forme'e de cellules, qui sont e'galement des
e'le'ments construits contenant des e'le'ments de base (des chai^nes de
caracte`res) et/ou des e'le'ments construits commes des formules.

\subsection{Constructeurs des structures logiques}

Apre`s les e'le'ments de base et les e'le'ments construits, on de'finit
les types d'orga\-ni\-sa\-tion qui permettent de construire des structures.
On s'appuie pour cela sur la notion de {\em constructeur}.
Un constructeur de'finit un mode d'assemblage de certains e'le'ments dans
une structure. Il se place bien au niveau de la me'ta-structure~:
il ne de'crit pas les relations existant dans une structure donne'e, mais
de'finit de quelle fac,on on peut assembler des e'le'ments pour construire
une structure conforme a` un mode`le.
Par comparaison avec Pascal, les constructeurs correspondent aux me'thodes
de structuration des types de donne'es~: tableaux, enregistrements, ensembles
et fichiers.

Pour l'organisation globale des documents, les deux premiers constructeurs
propose's sont l'agre'gat et la liste.

\subsubsection{Agre'gat et liste}

L'{\em agre'gat} permet de de'finir la structure d'un type d'e'le'ment
construit comme e'tant la collection, ordonne'e ou non, d'un nombre donne'
d'e'le'ments (construits ou de base), chacun de ces e'le'ments ayant un type
de'termine'.
Un rapport (un e'le'ment construit du type rapport) a une structure
d'agre'gat~: il est forme' d'un titre, d'un nom d'auteur, d'une introduction,
d'un corps et d'une conclusion, c'est-a`-dire de cinq e'le'ments type's.
Ce type de construction se retrouve dans pratiquement tous les documents,
et en ge'ne'ral a` plusieurs niveaux dans un document. 
Il correspond a` l'enregistrement ({\tt record}) de Pascal.

La {\em liste} permet de de'finir la structure d'un type d'e'le'ment construit
comme e'tant la suite ordonne'e d'e'le'ments (construits ou de base) ayant tous
le me^me type. Le nombre des e'le'ments d'une liste peut e^tre limite' aussi
bien infe'rieurement que supe'rieurement. Il peut aussi e^tre totalement
libre. Le corps d'un rapport est une liste de chapitres et on peut limiter
infe'rieurement a` 2 le nombre d'e'le'ments de cette liste (un chapitre est-il
vraiment utile s'il n'y en a qu'un dans le rapport~?) Le chapitre
lui-me^me peut contenir une liste de sections, chaque section contenant
une liste de paragraphes.
La liste correspond au tableau ({\tt array}) a` une dimension de Pascal.
Au me^me titre que l'agre'gat, la liste est un
constructeur tre`s fre'quemment utilise' dans toutes sortes de documents.
Mais ces deux constructeurs ne sont pas suffisants pour de'crire les
structures des documents~; d'autres viennent donc les comple'ter.

\subsubsection{Choix, nature et unite'}

Le constructeur {\em choix} permet de de'finir la structure d'un type
d'e'le'ment comme e'tant l'une parmi plusieurs possibles. Ainsi, un paragraphe
peut e^tre soit un simple paragraphe de texte, soit une e'nume'ration, soit
une citation. Le choix peut se comparer aux parties variantes des
enregistrements Pascal ({\tt case} dans un {\tt record}).

Le constructeur choix indique la liste comple`te des options offertes,
ce qui peut e^tre trop restrictif dans certains cas,
comme dans celui du paragraphe pris comme exemple. Deux constructeurs,
unite' et nature, pallient cet inconve'nient. Ils permettent de
choisir le type d'un e'le'ment plus librement. Si un paragraphe est de'fini
comme une nature, il est alors possible de mettre a` la place d'un paragraphe
un tableau, une formule, un dessin ou n'importe quel autre objet de'fini par
une autre structure logique ge'ne'rique. On peut aussi de'finir un paragraphe
comme une suite d'unite's, qui repre'sentent des chai^nes de caracte`res,
des symboles ou des images. En utilisant uniquement le constructeur choix,
on de'finit une structure logique ge'ne'rique relativement contraignante ;
au contraire, avec les unite's et les natures, on peut de'finir une structure
tre`s ouverte. L'unite' et la nature n'ont pas d'e'quivalent en Pascal.

La {\em nature} repre'sente un objet de'fini par une structure logique
ge'ne'rique choisie librement parmi celles qui sont disponibles.

L'{\em unite'} repre'sente un e'le'ment dont le type peut e^tre soit un type
de base, soit un e'le'ment de'fini comme tel dans la structure logique ge'ne'rique du
document\footnote{ou dans une autre structure logique ge'ne'rique utilise'e
dans le document} et utilisable dans les objets du document construits selon
d'autres structures ge'ne'riques.

Ainsi, par exemple, si le renvoi a` une note est de'fini dans la structure
logique ge'ne'rique Article comme une unite', un tableau (objet construit
selon une autre structure ge'ne'rique) peut comporter des renvois a`
des notes, lorsqu'il figure dans un article. Dans un autre type de
document, un tableau de'fini par la me^me structure ge'ne'rique peut comporter
d'autres types d'e'le'ments, spe'cifiques au type du document ou` il
s'inse`re. Il suffit pour cela de de'clarer, dans la structure ge'ne'rique
des tableaux, que le contenu des cellules est forme' d'unite's. De cette
fac,on, la structure ge'ne'rique des objets est rendue re'ellement
partageable entre diffe'rents types de documents, puisqu'elle s'adapte a`
l'environnement dans lequel elle s'inse`re.

\subsubsection{Re'fe'rence et inclusion}

La {\em re'fe'rence} est le dernier constructeur. Il permet de de'finir un
e'le'ment d'un document comme e'tant un renvoi a` un autre e'le'ment,
tel qu'une section, un chapitre, une citation bibliographique ou une figure.
La re'fe'rence peut e^tre compare'e au pointeur de Pascal, mais, a` la
diffe'rence du pointeur, la re'fe'rence est bidirectionnelle~: on peut,
depuis la re'fe'rence, acce'der a` l'e'le'ment qu'elle de'signe, mais on peut
aussi acce'der a` toutes les re'fe'rences qui de'signent un e'le'ment donne'.

Les re'fe'rences peuvent e^tre aussi bien {\em internes} que {\em externes},
c'est-a`-dire qu'elles peuvent de'signer des e'le'ments qui appartiennent
au me^me document ou a` un autre document.

\label{inclusion}
L'{\em inclusion} est une varie'te' de re'fe'rence particulie`re.
C'est aussi un lien bidirectionnel interne ou externe, mais ce
n'est pas un renvoi. Ce lien repre'sente l'inclusion ``vivante'' de
l'e'le'ment de'signe'~; il s'agit toujours de la dernie`re version
de cet e'le'ment et non pas d'une copie ``morte'', fige'e dans
l'e'tat ou` se trouvait l'e'le'ment au moment ou` la copie a e'te'
faite. De`s qu'un e'le'ment est modifie', toutes ses inclusions
sont automatiquement mises a` jour. Il faut noter, qu'en plus de
l'inclusion, l'e'diteur Thot permet d'effectuer des copies mortes.

On distingue trois sortes d'inclusions~: les inclusions avec
expansion comple`te, les inclusions avec expansion partielle
et les inclusions sans expansion. Lors de l'e'dition, les
inclusions sans expansion sont repre'sente'es a` l'e'cran par le nom
(en grise' ou dans une couleur particulie`re, selon le type d'e'cran)
du document inclus, alors que les inclusions avec
expansion (comple`te ou partielle) sont repre'sente'es par une copie
(comple`te ou partielle) de l'e'le'ment inclus (e'galement en grise'
ou en couleur). La partie qui apparai^t dans une expansion partielle
est la forme ``squelette'' du document inclus (voir
page~\pageref{squelette}).

L'inclusion avec expansion comple`te permet d'inclure dans un document
des parties de ce me^me document ou d'autres documents. C'est donc
un lien interne ou externe. On peut l'utiliser, par exemple, pour inclure
dans un article scientifique certaines entre'es de la bibliographie
d'un autre article, ou pour copier dans une formule mathe'matique une
partie d'une autre formule du me^me document avec une garantie de
cohe'rence entre les deux formules.

L'inclusion sans expansion ou avec expansion partielle sert a` inclure
des documents complets. C'est donc toujours un lien externe. Elle sert
principalement a` e'clater les tre`s gros documents en sous-documents
plus faciles a` manipuler, surtout lorsqu'il y a plusieurs auteurs.
Ainsi, un livre peut inclure des chapitres, chaque chapitre formant
un document diffe'rent, qui peut e^tre e'dite' se'pare'ment. Dans le
livre, on peut utiliser des inclusions avec expansion partielle,
de fac,on a` ne voir a` l'e'cran que les titres de section des chapitres
inclus, par exemple.

Lors de l'impression, les inclusions sans expansion ou avec expansion
partielle peuvent e^tre repre'sente'es soit de la me^me fac,on qu'a`
l'e'cran, soit par une copie comple`te (et a` jour) de l'e'le'ment
ou du document inclus.

L'inclusion, quel que soit son type, respecte la structure ge'ne'rique~:
on ne peut inclure a` une
position structurale donne'e d'un document que les e'le'ments autorise's par
la structure ge'ne'rique.

\subsubsection{Paires de marques}

Il est souvent utile de de'limiter certaines parties d'un document
inde'pendemment de la structure logique, par exemple un groupe de mots
ou quelques paragraphes conse'cutifs, auxquels on veut associer une
information (sous la forme d'un attribut, voir section \ref{attributs})
ou un traitement particulier. Les paires de marques servent a` cet usage.

Il s'agit d'e'le'ments qui vont toujours par deux et qui sont des
terminaux dans la structure logique d'un document. Leur position dans
la structure du document est de'finie dans la structure ge'ne'rique.
Il faut noter qu'on utilise en ge'ne'ral les extensions (voir section
suivante) de sorte qu'ils puissent e^tre utilise's relativement
librement.

\subsubsection{Restrictions et extensions}

Les types de base et les constructeurs pre'sente's jusqu'ici permettent de
de'finir les structures logiques des documents et des objets de fac,on
rigoureuse. Mais cette de'finition peut e^tre tre`s lourde dans certains cas,
notamment lorsqu'on veut, dans un contexte particulier, restreindre ou
au contraire e'tendre les types d'e'le'ments autorise's. Pour cela, on
dispose des {\em restrictions} et des {\em extensions}.

La restriction permet d'associer a` un type d'e'le'ment la liste des
types d'e'le'ments que cet e'le'ment ne doit pas contenir, me^me si
sa de'finition et celle de ses composants l'autorisent par ailleurs.
Cela simplifie l'e'criture des structures logiques ge'ne'riques
et permet, lorsque c'est ne'cessaire, de limiter les possibilite's offertes
par les natures et les unite's.

L'extension est l'inverse de la restriction. Elle permet d'associer a` un
type d'e'le'ment la liste des types d'e'le'ments que cet e'le'ment peut
contenir, me^me si sa de'finition et celle de ses composants ne l'autorisent
pas par ailleurs.

\subsubsection{Re'sume'}

Pour construire un document on utilise donc quatre constructeurs~:

\begin{itemize}
\item
l'agre'gat,
\item
la liste,
\item
le choix et ses extensions, l'unite' et la nature,
\item
la re'fe'rence et sa variante, l'inclusion.
\end{itemize}

Pour les objets e'galement ces quatre constructeurs sont suffisants.
Ainsi, on obtient avec ces constructeurs un me'ta-mode`le homoge`ne qui peut
de'crire a` la fois l'organisation globale d'un document et celle des objets
de diffe'rentes natures qu'il contient. On verra, apre`s la pre'sentation du
langage de description des structures logiques, quelques exemples qui
mettent en e'vidence cette proprie'te' du mode`le.

Les trois premiers constructeurs (agre'gat, liste et choix) conduisent a`
des structures arborescentes pour les documents et les objets, les
objets e'tant simplement des sous-arbres de l'arbre d'un document (ou
me^me d'autres sous-arbres d'objets). Le constructeur re'fe'rence, lui,
introduit d'autres relations, non-hie'rarchiques, qui viennent s'ajouter a`
celles de l'arbre~: quand un paragraphe fait re'fe'rence a` un chapitre ou a`
une section, cette relation sort de la structure purement arborescente.
De plus les re'fe'rences et les inclusions externes permettent d'e'tablir
des liens entre documents diffe'rents, cre'ant ainsi une structure
hypertexte.

\subsection{E'le'ments associe's}
\label{elemassoc}

Gra^ce aux constructeurs liste agre'gat et choix, on spe'cifie de fac,on stricte
l'organisation du document, avec des e'le'ments construits et des e'le'ments
de base. Mais un document ne comporte pas que des e'le'ments aussi clairement
relie's entre eux. Il existe des e'le'ments dont la position par rapport a`
la structure du document n'est pas de'termine'e. C'est notamment le cas des
figures ou des notes. Une figure peut e^tre de'signe'e en plusieurs points
du me^me document et sa place dans le document physique peut varier au
cours de la vie du document sans rien changer au sens ou me^me a` la
clarte' du document. Elle peut e^tre place'e une fois en fin de document,
avec toutes les autres figures, une autre fois en haut de la page qui
suit la premie`re de'signation. Les figures peuvent e^tre disperse'es a`
travers le document ou, au contraire, regroupe'es. Il en est de me^me pour les
notes, qui peuvent e^tre imprime'es en bas de la page ou` elles sont appele'es
ou regoupe'es en fin de chapitre ou encore en fin d'ouvrage. Bien su^r,
il s'agit la` de la position physique des e'le'ments dans les documents
mis en page, mais cela refle`te l'instabilite' structurale de ces e'le'ments.
On ne peut pas les traiter de la me^me fac,on que des e'le'ments comme les
paragraphes ou les sections, dont les positions dans la structure sont
directement lie'es a` la se'mantique du document.

Ces e'le'ments dont la position n'est pas fixe'e de fac,on unique dans la
structure du document, mais qui en font toutefois partie, sont appele's
les {\em e'le'ments associe's}. Cela n'empe^che pas qu'ils soient
e'galement structure's, c'est-a`-dire que leur contenu soit organise'
logiquement par des constructeurs, a` partir d'e'le'ments de base et
d'e'le'ments construits.

Il peut arriver que des e'le'ments associe's soient totalement de'connecte's
de la structure du document, comme peut l'e^tre un commentaire ou
une appre'ciation d'un lecteur sur l'ensemble du document.
Mais le plus souvent, les e'le'ments associe's sont relie's au contenu du
document par des re'fe'rences. C'est ge'ne'ralement le cas des notes ou
des figures, entre autres.

Les e'le'ments associe's introduisent donc une nouvelle utilisation pour le
constructeur re'fe'rence. Celui-ci ne sert pas seulement a` e'tablir des liens
entre e'le'ments de la structure principale du document, il sert aussi a`
relier a` la structure principale les e'le'ments associe's.

\subsection{Attributs logiques}
\label{attributs}

Tout l'aspect logique des documents n'est pas entie`rement de'crit par
la structure. Certaines informations d'ordre se'mantique, mais non
exprime'es explicitement dans le texte du document, me'ritent d'e^tre prises
en compte. Ce sont notamment celles qui sont habituellement refle'te'es
par des effets typographiques qui ne correspondent pas a` un changement
d'e'le'ment structural. En effet, certains titres peuvent e^tre mis en gras
ou en italique, ou e^tre imprime's avec un style de caracte`re diffe'rent
du reste du texte, pour marquer qu'il s'agit d'un e'le'ment de structure
distinct. Mais ces me^mes effets apparaissent parfois au milieu d'un texte
continu, a` l'inte'rieur d'un paragraphe, par exemple. Dans ce cas, il n'y a
pas de changement d'e'le'ment structural~; il s'agit de la mise en e'vidence
d'un mot, d'une expression ou d'une phrase. La notion d'{\em attribut} est
utilise'e pour exprimer ce type d'information.

Un attribut est une information attache'e a` un e'le'ment structural qui
s'ajoute au type de l'e'le'ment et en pre'cise la fonction dans le document.
Les mots cle's, les mots d'une langue e'trange`re, les titres d'oeuvre qui
apparaissent dans le fil du texte sont autant de chai^nes de caracte`res
portant un attribut. Mais les attributs ne s'attachent pas seulement
aux e'le'ments de base, il peuvent aussi porter sur des e'le'ments construits.
Ainsi un attribut indiquant la langue peut e^tre attache' a` un simple mot
aussi bien qu'a` toute une partie d'un document e'crit en plusieurs langues.

En fait, on traite comme un attribut une information qui est lie'e a`
une partie d'un document et qui peut e^tre utile a` toute application qui
travaille sur le document. Par exemple, la langue dans laquelle est e'crit le
document de'termine le choix du jeu de caracte`res pour un e'diteur ou un
formateur, elle de'termine aussi l'algorithme ou le dictionnaire de coupure
des mots a` utiliser. L'attribut ``mot cle''' facilite le travail d'un
syste`me documentaire. L'attribut ``mot d'index'' permet a` un formateur de
construire automatiquement un index a` la fin du document.

De me^me que les types d'e'le'ments construits sont de'finis dans chaque
structure logique ge'ne'rique, et non pas dans le me'ta-mode`le, de me^me les
attributs et les valeurs qu'ils peuvent prendre sont de'finis dans chaque
structure ge'ne'rique, selon les besoins de la classe de documents ou de la
nature d'objet.

Plusieurs types d'attributs sont propose's~: les attributs {\em nume'riques},
{\em textuels}, {\em re'fe'rence} et {\em e'nume're's}.
Les attributs nume'riques peuvent prendre des valeurs entie`res, ne'gatives,
positives ou nulles.
Les attributs textuels ont pour valeur une chai^ne de caracte`res.
Les attributs re'fe'rence de'signent un e'le'ment de la structure logique.
Les attributs e'nume're's peuvent prendre une valeur parmi une liste limite'e
de valeurs possibles, chaque valeur possible e'tant un nom.

Dans une structure ge'ne'rique, on distingue les {\em attributs globaux} et
les {\em attributs locaux}. Un attribut global peut s'appliquer a` tous les types
d'e'le'ments de'finis dans la structure ge'ne'rique ou` il est spe'cifie'. Un
attribut local, au contraire, ne peut s'appliquer qu'a` certains types
d'e'le'ments, ou me^me a` un seul type. L'attribut langue pre'sente' plus haut
est un exemple d'attribut global. Un exemple d'attribut local est la
qualite' d'un auteur (auteur principal du document ou auteur secondaire)~:
cet attribut n'a de sens qu'applique' a` un e'le'ment de type auteur.

Les attributs peuvent e^tre affecte's de plusieurs fac,ons diffe'rentes aux
e'le'ments qui constituent le document.
Ils peuvent e^tre mis dynamiquement et librement, par l'auteur du
document, sur n'importe quelle partie, pour y attacher un comple'ment
d'information de son choix. Toutefois, cela ne peut e^tre fait qu'en
respectant la structure ge'ne'rique~; en particulier, les attributs locaux ne
peuvent e^tre affecte's qu'aux types d'e'le'ments pour lesquels ils sont
de'finis. 

Dans la structure ge'ne'rique, certains attributs locaux peuvent e^tre rendus
{\em obligatoires} pour certains types d'e'le'ments. Dans ce cas,
l'e'diteur Thot associe automatiquement l'attribut aux e'le'ments de ce
type et il impose a` l'utilisateur de fournir une valeur a` cet attribut.

Les attributs peuvent e'galement e^tre affecte's, avec une valeur donne'e,
automatiquement par toute application traitant le document, y compris
l'e'diteur Thot, pour ajouter syste'matiquement une information a`
certains e'le'ments pre'de'finis du document. \`{A} titre d'exemple, dans
un rapport comportant un re'sume' en franc,ais et un re'sume' en
anglais, chacun des deux re'sume's est de'fini comme une suite de
paragraphes, avec, pour le premier re'sume', la valeur impose'e ``franc,ais''
pour l'attribut ``langue'', et, pour le deuxie`me, la valeur impose'e
``anglais'' pour ce me^me attribut.

Dans le cas des paires de marques, les attributs sont associe's logiquement
a` l'ensemble de la paire, mais ils sont en fait attache's a` la premie`re
marque.

\subsection{Discussion du mode`le}

Les notions d'attribut, de constructeur, d'e'le'ment structure', d'e'le'ment
associe', sont utilise'es dans la de'finition des structures logiques
ge'ne'riques des documents et des objets. Le proble`me est de les
regrouper pour constituer ces structures ge'ne'riques. En effet de
nombreux types d'e'le'ments et de nombreux attributs se retrouvent dans
plusieurs structures ge'ne'riques. Pluto^t que de les rede'finir pour
chaque structure ou` ils apparaissent, il convient de les partager entre ces
structures. Les classes d'objets remplissent de'ja` cette fonction de partage.
Si on de'finit une classe mathe'matique, on peut utiliser des formules
dans plusieurs classes de documents, sans en rede'finir la structure
pour chaque classe. Ce proble`me ne se pose pas seulement pour les
objets conside're's jusqu'ici, il se pose aussi pour des e'le'ments textuels
banalise's que l'on retrouve dans de nombreuses classes de documents.
C'est la raison pour laquelle la notion d'objet est e'largie, et que
des paragraphes ou des e'nume'rations sont e'galement conside're's comme des
objets. Ces classes d'objets permettent le partage non seulement des
structures d'e'le'ments, mais aussi des attributs de'finis dans les structures
ge'ne'riques.

La structure, telle qu'elle est pre'sente'e ici, peut parai^tre tre`s rigide,
et on peut imaginer qu'un syste`me de production de documents fonde' sur ce
mode`le se re've`le tre`s contraignant pour l'utilisateur. C'est en effet un
reproche qui est souvent adresse' aux e'diteurs dirige's par la syntaxe.
Pour trois raisons principalement, ce de'faut peut e^tre e'vite' avec Thot~:

\begin{itemize}
\item
les structures ge'ne'riques ne sont pas fige'es dans le mode`le lui-me^me,
\item
le mode`le prend en compte la dynamique des documents,
\item
les constructeurs offrent une grande souplesse.
\end{itemize}

Puisque la structure ge'ne'rique d'un document n'est pas pre'de'finie, mais
au contraire conc,ue spe'cifiquement pour chaque classe de documents,
elle peut e^tre tre`s pre'cise'ment adapte'e aux besoins. En cas
d'inade'quation de la structure ge'ne'rique a` un document particulier de
la classe, il est toujours possible, soit de cre'er une nouvelle classe
avec une structure ge'ne'rique bien adapte'e au nouveau cas, soit
d'e'tendre la structure ge'ne'rique de la classe existante pour prendre
en compte les spe'cificite's du document qui pose proble`me. Ces deux
solutions s'appliquent e'galement aux objets dont les structures
ge'ne'riques se re've'leraient mal adapte'es.

Le mode`le est suffisamment souple pour prendre en compte toutes
les e'tapes de la vie du document. Quand une structure ge'ne'rique spe'cifie
qu'un rapport doit contenir un titre, un re'sume', une introduction,
au moins deux chapitres et une conclusion, cela signifie seulement qu'un
rapport, {\em une fois termine'}, devrait contenir tous ces e'le'ments. Lorsque
l'auteur commence a` e'crire, aucun de ces e'le'ments n'est pre'sent. L'e'diteur
Thot utilise ce mode`le. Il tole`re donc des documents non strictement
conformes a` la structure ge'ne'rique de leur classe~; il conside`re pluto^t
la structure logique ge'ne'rique comme un moyen d'aider l'utilisateur dans
la construction d'un document complexe.

D'autres applications au contraire peuvent rejeter un document qui ne
serait pas strictement conforme a` sa structure ge'ne'rique. C'est par exemple
ce que font les compilateurs qui refusent d'engendrer le code pour un
programme qui n'est pas syntaxiquement correct. C'est ce que pourrait
faire une application documentaire pour un rapport qui n'aurait pas de
re'sume' ou de titre.

Les constructeurs du mode`le apportent une grande souplesse dans les
structures ge'ne'riques. Un choix, et plus encore une unite' ou une nature,
peuvent repre'senter des e'le'ments tre`s diffe'rents. Le constructeur liste
autorise la multiplication des e'le'ments de me^me type. Combine's, ces deux
constructeurs permettent n'importe quelle succession d'e'le'ments de types
diffe'rents. Bien su^r, cette souplesse peut e^tre re'duite la` ou` c'est
ne'cessaire puisqu'une structure ge'ne'rique peut limiter les choix et le
nombre d'e'le'ments des listes.

Une autre difficulte' lie'e a` l'utilisation de la structure dans le mode`le de
document re'side dans le choix du niveau de structure. On pourrait envisager
d'aborder le domaine linguistique pour extraire du texte me^me la structure
du discours. Certaines e'tudes vont dans ce sens, mais le mode`le de Thot
exclut ce type de structure. Il ne prend en compte que la structure
{\em logique} exprime'e explicitement par l'auteur.

Cependant le niveau de structure du mode`le n'est pas impose'. Chaque
structure ge'ne'rique de'finit son propre niveau de structuration, adapte' a`
la classe du document ou de l'objet, mais aussi aux traitements que le
document doit subir. S'il s'agit seulement d'e'diter et d'imprimer un
document, une structure relativement simple suffit. S'il faut effectuer
des traitements plus spe'cifiques, la structure doit repre'senter
les types d'e'le'ments sur lesquels les traitements devront agir. \`{A} titre
d'exemple, une structure simple est suffisante pour imprimer des
formules, mais une structure plus riche est ne'cessaire pour effectuer
des calculs formels ou nume'riques sur des expressions mathe'matiques.
Le mode`le de Thot autorise les deux types de structure.

\section{Langage de de'finition des structures ge'ne'riques}

Les structures ge'ne'riques, qui constituent le fondement du mode`le de
document de Thot, sont exprime'es dans un langage adapte'. C'est ce langage
de de'finition de structures ge'ne'riques, appele' le langage S, qui est
pre'sente' maintenant.

Chaque structure ge'ne'rique, qu'elle de'finisse une classe de documents ou
d'objets, est spe'cifie'e par une sorte de programme, e'crit dans le langage S,
qui est appele' un {\em sche'ma de structure}. Les sche'mas de structure sont
compile's et donnent lieu a` des tables, dites tables de structure, qui sont
utilise'es par l'e'diteur Thot et qui de'terminent son comportement.

\subsection{Conventions d'e'criture}
\label{metalang}

La grammaire du langage S, comme celle des langages P et T pre'sente's plus
loin, est de'crite a` l'aide du me'ta-langage M, de'rive' de la forme de
Backus-Naur (BNF).

Dans ce me'ta-langage chaque re`gle de la grammaire du langage de'fini est
constitue'e d'un symbole de la grammaire suivi du signe {\tt =} et de la
partie droite de la re`gle. Le signe {\tt =} joue le me^me ro^le que le
traditionnel {\tt ::=} de la BNF~: il indique que la partie droite de'finit
le symbole de la partie gauche. Dans la partie droite,

\begin{description}
\item
[la concate'nation] est simplement marque'e par la juxtaposition des symboles~;
\item
[les chai^nes de caracte`res] entre apostrophes {\tt '} repre'sentent des
symboles terminaux, c'est-a`-dire des mots cle's du langage de'fini. Les
mots cle's sont ici souvent e'crits en majuscules, mais ils peuvent e'galement
e^tre e'crits en minuscules ou dans un me'lange de majuscules et de minuscules.
Par exemple, le mot {\tt DEFPRES} du langage S peut e^tre e'crit e'galement
{\tt defpres} ou {\tt DefPres}.
\item
[les parties entre crochets] {\tt [} et {\tt ]} sont facultatives ;
\item
[les parties entre] {\tt <} et {\tt >} peuvent e^tre re'pe'te'es plusieurs
fois ou omises ;
\item
[la barre oblique] {\tt /} indique une alternative, un choix entre les
diffe'rentes options se'pare'es par le caracte`re {\tt /}~;
\item
[le point] {\tt .} marque la fin d'une re`gle ;
\item
[le texte entre accolades] {\tt \{} et {\tt \} }est un simple commentaire.
\end{description}

Le me'ta-langage M utilise e'galement les notions d'identificateurs, de chai^nes
et d'entiers~:

\begin{description}
\item
[ {\tt NAME} ] repre'sente un identificateur, c'est-a`-dire une suite de
lettres majuscules ou minuscules, de chiffres et de caracte`res de soulignement
{\tt \_}, commenc,ant par une lettre. On accepte comme une lettre la suite de
caracte`res {\tt $\backslash$nnn} ou` les {\tt n} repre'sentent le code de la
lettre en octal, dans le jeu de caracte`res ISO Latin 1. On peut ainsi utiliser
dans les identificateurs les lettres accentue'es du franc,ais. La longueur
maximum des identificateurs est fixe'e par le compilateur. Elle est
normalement de 19 caracte`res.

\`{A} la diffe'rence des mots cle's, les majuscules et les minuscules sont
distingue'es dans les identificateurs. Ainsi, {\tt Titre}, {\tt TITRE} et
{\tt titre} sont conside're's comme des identificateurs diffe'rents.

\item
[ {\tt STRING} ] repre'sente une chai^ne. C'est une suite de caracte`res
quelconques de'limite's par des apostrophes. Si une apostrophe doit figurer
dans la chai^ne de caracte`res, elle est double'e. Comme pour les
identificateurs, les chai^nes peuvent comprendre des caracte`res repre'sente's
par leur code octal (apre`s un $\backslash$). Si un caracte`re $\backslash$
doit figurer dans une chai^ne, il est double'.

\item
[ {\tt NUMBER} ] repre'sente un entier positif ou nul, sans signe,
c'est-a`-dire une suite de chiffres de'cimaux.
\end{description}

Le langage M peut se de'finir lui-me^me de la fac,on suivante~:

\begin{verbatim}
{Les textes entre accolades sont des commentaires}
Grammaire    = Regle < Regle > 'END' .
               {Les signes < et > indiquent une repetition
                (zero, une ou plusieurs fois)}
               {END marque la fin de la grammaire}
Regle        = Ident '=' PartieDroite '.' .
               {Le point indique la fin d'une regle}
PartieDroite = DrTerminal / DrIntermed .
               {La barre oblique indique une alternative}
DrTerminal   ='NAME' / 'STRING' / 'NUMBER' .
               {Partie droite d'une regle terminale}
DrIntermed   = Possibilite < '/' Possibilite > .
               {Partie droite d'une regle intermediaire}
Possibilite  = ElRepetOpt < ElRepetOpt > .
ElRepetOpt   = Element / '[' Element < Element > ']' /
              '<' Element < Element > '>'  .
               {Les crochets delimitent une partie
                facultative}
Element      = Ident / MotCle .
Ident        = NAME .
               {Identificateur, suite de caracteres}
MotCle       = STRING .
               {Chaine de caracteres delimitee par des
                 apostrophes}
END
\end{verbatim}

\subsection{Sche'mas d'extension}
\label{schext}

Un sche'ma de structure de'finit la structure logique ge'ne'rique d'une
classe de documents ou d'objets, inde'pendemment des traitements qui peuvent
e^tre applique's aux documents. Cependant, certaines applications peuvent
ne'cessiter des informations particulie`res dans la structure des
documents qu'elles traitent. Ainsi un gestionnaire
de versions de documents aura besoin d'indiquer dans le document les parties
qui appartiennent a` une version ou a` une autre~; un syste`me d'indexation
ajoutera des tables d'index fortement structure'es ainsi que des liens entre
ces tables et le reste du document.

Chaque application a ainsi besoin d'e'tendre la structure ge'ne'rique des
documents qu'elle traite pour introduire de nouveaux attributs, des
e'le'ments associe's ou de nouveaux types d'e'le'ments. Ces ajouts
sont propres a` chaque application et doivent pouvoir e^tre faits sur
n'importe quelle structure ge'ne'rique~: on peut vouloir ge'rer les versions
ou construire les index de divers types de documents. Les sche'mas d'extension
servent a` cette fin~: ils de'finissent des attributs, des e'le'ments, des
e'le'ments associe's, des unite's, etc., mais ils ne peuvent e^tre utilise's
que conjointement avec un sche'ma de structure qu'ils comple`tent.
Par ailleurs, les sche'mas de structure peuvent toujours e^tre utilise's
sans ces extensions, si les applications correspondantes ne sont pas
disponibles.

\subsection{Organisation ge'ne'rale d'un sche'ma de structure}

Tout sche'ma de structure commence par le mot cle' {\tt STRUCTURE} et se
termine par le mot cle' {\tt END}. Le mot cle' {\tt STRUCTURE} est suivi du
mot cle' {\tt EXTENSION} dans le cas ou` le sche'ma de'finit une extension,
puis du nom de la structure ge'ne'rique (ou de l'extension). Le nom de la
structure est suivi d'un point-virgule.

Dans le cas d'un sche'ma complet (c'est-a`-dire un sche'ma qui n'est pas une
extension), la de'finition du nom de la structure est suivie par les
de'clarations du sche'ma de pre'sentation par de'faut, des attributs globaux,
des parame`tres, des re`gles de structuration, des e'le'ments associe's, des
unite's, des e'le'ments de squelette et des exceptions. Les de'clarations des
attributs globaux et des parame`tres sont optionnelles, de me^me que les
de'finitions des e'le'ments associe's, des unite's, des e'le'ments de
squelette et des exceptions. Seule la de'finition des re`gles de structuration
est obligatoire. Chaque se'rie de de'clarations est introduite par un mot cle'~:
{\tt DEFPRES}, {\tt ATTR}, {\tt PARAM}, {\tt STRUCT}, {\tt ASSOC},
{\tt UNITS}, {\tt EXPORT} et {\tt EXCEPT}.

Dans le cas d'une extension de sche'ma, il n'y a pas de parame`tres ni
d'e'le'ments de squelette et la section {\tt STRUCT} est optionnelle, alors
que cette section est obligatoire dans un sche'ma qui n'est pas une extension.
En revanche, les extensions de sche'ma peuvent comporter une section
{\tt EXTENS}, qui ne doit pas apparai^tre dans une sche'ma qui n'est pas
une extension~; cette section de'finit des comple'ments a` apporter
a` des re`gles qui existent dans le sche'ma auquel sera ajoute' l'extension.
Les sections {\tt ATTR}, {\tt STRUCT}, {\tt ASSOC}, et {\tt UNITS}, elles,
de'finissent de nouveaux attributs, de nouveaux e'le'ments, de nouveaux
e'le'ments associe's et de nouvelles unite's qui s'ajoutent a` ceux
de'finis dans le sche'ma principal.

\begin{verbatim}
     SchemaStruct ='STRUCTURE' IdentElem ';'
                   'DEFPRES' IdentPres ';'
                 [ 'ATTR' SuiteAttr ]
                 [ 'PARAM' SuiteRegles ]
                   'STRUCT' SuiteRegles
                 [ 'ASSOC' SuiteRegles ]
                 [ 'UNITS' SuiteRegles ]
                 [ 'EXPORT' SuiteSquelette ]
                 [ 'EXCEPT' SuiteExcept ]
                   'END' .
     IdentElem    = NAME .
\end{verbatim}
ou
\begin{verbatim}
     SchemaExtens ='STRUCTURE' 'EXTENSION' IdentElem ';'
                   'DEFPRES' IdentPres ';'
                 [ 'ATTR' SuiteAttr ]
                 [ 'STRUCT' SuiteRegles ]
                 [ 'EXTENS' SuiteRegleExtens ]
                 [ 'ASSOC' SuiteRegles ]
                 [ 'UNITS' SuiteRegles ]
                 [ 'EXCEPT' SuiteExcept ]
                   'END' .
     IdentElem    = NAME .
\end{verbatim}

\subsection{Pre'sentation par de'faut}

On a vu page~\pageref{presmul} que plusieurs pre'sentations diffe'rentes sont
possibles pour les documents et les objets d'une me^me classe. Le sche'ma de
structure indique, pour la classe, une pre'sentation pre'fe'rentielle, dite
pre'sentation par de'faut. Comme les structures ge'ne'riques, les pre'sentations
sont de'crites par des programmes, appele's {\em sche'mas de pre'sentation},
e'crits dans un langage spe'cifique, le langage P, pre'sente' plus loin
(voir page~\pageref{langp}). C'est le nom du sche'ma de pre'sentation par
de'faut qui est indique' apre`s le mot cle' {\tt DEFPRES}. Lors de la cre'ation
d'un nouveau document, l'e'diteur Thot proposera d'utiliser ce sche'ma de
pre'sentation, mais l'utilisateur reste libre d'en choisir un autre s'il le
de'sire.

\begin{verbatim}
     IdentPres = NAME .
\end{verbatim}

\subsection{Attributs logiques globaux}
\label{attrglobaux}

Si la structure ge'ne'rique comprend des attributs globaux qui lui sont
propres, ceux-ci sont de'clare's apre`s le mot cle' {\tt ATTR}. Chaque
attribut global est de'fini par son nom, suivi du signe {\tt =} et de la
de'finition de son type. La de'claration d'un attribut global se termine par
un point-virgule.

Pour les attributs de type nume'rique, textuel ou re'fe'rence, le type est
indique' par un mot cle', {\tt INTEGER}, {\tt TEXT} ou {\tt REFERENCE}
respectivement.

Dans le cas d'un attribut re'fe'rence, le mot cle' {\tt REFERENCE} est
suivi, entre parenthe`ses, du type de l'e'le'ment que l'attribut doit
de'signer.
Il peut s'agir soit d'un type quelconque, repre'sente' par le mot cle'
{\tt ANY}, soit d'un type de'termine'. Dans ce dernier cas, le type
d'e'le'ment de'signe' par la re'fe'rence peut e^tre de'fini soit dans la section
{\tt STRUCT} du me^me sche'ma de structure (voir section~\ref{elemstruct})
soit dans la section {\tt STRUCT} d'un autre sche'ma de structure.
Dans ce dernier cas, le type d'e'le'ment est suivi, entre
parenthe`ses, du nom du sche'ma de structure externe ou` il est de'fini.
Le nom du type d'e'le'ment de'signe' peut e^tre pre'ce'de' du mot cle'
{\tt First} ou {\tt Second}, uniquement dans le cas ou` ce type est de'fini
comme une paire (voir section~\ref{paires}). Ces mots cle's indiquent
respectivement si l'attribut doit de'signer la premie`re marque de la paire
ou la seconde. S'il s'agit d'une paire et qu'aucun de ces deux mots cle's
n'est pre'sent, c'est la marque de de'but qui est prise en compte.

Dans le cas d'un attribut de type e'nume're', le signe {\tt '='} est suivi
de la liste des noms repre'sentant les valeurs possibles de l'attribut, les
noms e'tant se'pare's les uns des autres par des virgules. Un attribut
e'nume're' a au moins une valeur possible~; le nombre maximum de valeurs
possibles est de'fini par le compilateur du langage S.

\begin{verbatim}
     SuiteAttr    = Attribut < Attribut > .
     Attribut     = IdentAttr '=' TypeAttr ';' .
     TypeAttr     = 'INTEGER' / 'TEXT' /
                    'REFERENCE' '(' TypeRef ')' /
                    SuiteValeurs .
     TypeRef      = 'ANY' / [ FirstSec ] IdentElem
                    [ StructExt ] .
     FirstSec     = 'First' / 'Second' .
     StructExt    = '(' IdentElem ')' .
     SuiteValeurs = ValAttr < ',' ValAttr > .
     IdentAttr    = NAME .
     ValAttr      = NAME .
\end{verbatim}

Il existe un attribut global pre'de'fini de type texte, la langue, qui est
automatiquement ajoute' a` tous les sche'mas de structure Thot. Cela permet
a` l'e'diteur d'effectuer certains traitements, comme la coupure des mots
en fin de ligne ou la correction orthographique, qui ne peuvent e^tre faits
sans la connaissance de la langue dans laquelle est e'crit le fragment de
texte traite'. Cet attribut peut e^tre utilise' comme n'importe quel
attribut de'clare' explicitement~: tout se passe comme si tout sche'ma de
structure contenait
\begin{verbatim}
ATTR
   Langue = TEXT;
\end{verbatim}

\begin{example}
Si, pour une classe de document, on veut de'finir un attribut global de
type e'nume're's, qui est le type de mot, on e'crit~:

\begin{verbatim}
ATTR
   Type_de_mot = Definition, Mot_index, Titre_ouvrage;
\end{verbatim}
\end{example}

\subsection{Parame`tres}
\label{param}

Un parame`tre est un e'le'ment du document qui peut apparai^tre plusieurs fois
dans le document, mais toujours avec la me^me valeur. Cette valeur ne peut
e^tre modifie'e que de fac,on contro^le'e, par certaines applications.
Par exemple, pour une lettre circulaire, le nom du destinataire peut figurer
dans la partie adresse et dans la formule de politesse finale. Une valeur
ne peut lui e^tre affecte'e que par l'application de publipostage.

Toutes les classes de documents n'utilisent pas des parame`tres, mais
si le sche'ma comprend des parame`tres, ceux-ci sont de'clare's apre`s le
mot cle' {\tt PARAM}.
Chaque de'claration de parame`tre est constitue'e de la me^me fac,on qu'une
de'claration d'e'le'ment structure' (voir section~\ref{elemstruct}).

Lors de l'e'dition, Thot permet d'inse'rer des parame`tres partout ou` le sche'ma
de structure le pre'voit~; il permet aussi de supprimer les parame`tres
qui existent dans le document, mais il interdit d'en modifier le contenu
ou de lui affecter un contenu s'il n'en a pas. Le contenu est mis
automatiquement par l'e'diteur lors de la cre'ation du parame`tre, avec la
valeur qu'a ce parame`tre pour le document.

\subsection{E'le'ments structure's}
\label{elemstruct}

Les re`gles de de'finition des e'le'ments structure's sont
obligatoires{\footnote {sauf s'il s'agit d'une extension de sche'ma.}: elles
constituent l'essentiel d'un sche'ma de structure, puisqu'elles de'finissent
la structure des diffe'rents types d'e'le'ments qui interviennent dans un
document ou un objet de la classe de'finie par le sche'ma.

La premie`re re`gle de structuration apre`s le mot {\tt STRUCT} doit e^tre
celle qui de'finit la structure de la classe dont le nom apparai^t dans la
premie`re instruction ({\tt STRUCTURE}) d'un sche'ma de structure.
C'est la re`gle racine du sche'ma, celle qui de'finit la racine de l'arbre
d'un document ou d'un objet de la classe.

Les autres re`gles peuvent e^tre place'es dans un ordre quelconque, puisque
le langage permet de de'finir les types d'e'le'ments avant ou apre`s leur
utilisation, ou me^me dans l'instruction ou` ils sont utilise's. Dans ce
dernier cas les re`gles sont imbrique'es les unes dans les autres.

Chaque re`gle est constitue'e d'un nom (le nom du type d'e'le'ment dont
on de'finit la structure) suivi du signe {\tt =} et d'une de'finition de
structure.

Si des attributs locaux sont associe's au type d'e'le'ment de'fini par la re`gle,
ils apparaissent entre parenthe`ses apre`s le nom du type. Cette parenthe`se
contient d'abord le mot cle' {\tt ATTR} puis la liste des attributs locaux,
se'pare's par des points-virgules. Chaque attribut local est forme' du nom de
l'attribut, suivi e'ventuellement d'un signe {\tt =} et de la de'finition
du type de l'attribut, comme dans la de'finition des attributs globaux (voir
section~\ref{attrglobaux}).
Le nom de l'attribut peut e^tre pre'ce'de' d'un point d'exclamation pour
indiquer que l'attribut doit obligatoirement e^tre pre'sent pour ce type
d'e'le'ment.
Un me^me attribut, identifie' par son nom, peut e^tre de'fini comme attribut
local de plusieurs types d'e'le'ments. Dans ce cas, le signe {\tt =} et la
de'finition du type d'attribut ne doivent apparai^tre qu'a` la premie`re
occurence de l'attribut. Notons que les attributs globaux ne peuvent pas e^tre
de'finis comme attributs locaux.

Si des extensions sont de'finies pour ce type d'e'le'ment, un signe {\tt +}
suit la de'finition de structure et les noms des types des e'le'ments
d'extension apparaissent entre parenthe`ses apre`s ce signe {\tt +}. S'il
y a plusieurs extensions, chaque nom de type est se'pare' du suivant
par une virgule. Ces types peuvent e^tre soit des types de'finis dans le
sche'ma, soit des types de'finis dans d'autres sche'mas de structure (il
s'agit alors du nom du sche'ma), soit encore des types de base identifie's
par les mots cle's {\tt TEXT}, {\tt GRAPHICS}, {\tt SYMBOL} ou {\tt PICTURE}.

Les restrictions sont indique'es de la me^me fac,on que les extensions, mais
elles sont introduites par le signe {\tt -} et elles viennent apre`s les
extensions ou, s'il n'y a pas d'extension, apre`s la de'finition de structure.

Si des valeurs d'attributs doivent e^tre syste'matiquement attache'es
a` ce type d'e'le'ment, elles sont introduites par le mot cle' {\tt WITH}
et elles sont de'clare'es sous la forme d'une liste des attributs a` valeur
impose'e. Cette de'finiton des attributs a` valeur impose'e vient apre`s la
de'finition des restrictions, ou apre`s celle des extensions s'il n'y a pas de
restriction, ou apre`s la de'finition de structure s'il n'y a ni extension ni
restriction.

La re`gle se termine par un point-virgule.

\begin{verbatim}
     SuiteRegles    = Regle < Regle > .
     Regle          = IdentElem [ SuiteAttrLoc ] '='
                      DefAvecAttr ';'.
     SuiteAttrLoc   = '(' 'ATTR' AttrLocal
                      < ';' AttrLocal > ')' .
     AttrLocal      = [ '!' ] IdentAttr [ '=' TypeAttr ] .
     DefAvecAttr    = Definition
                      [ '+' '(' SuiteExtension ')' ]
                      [ '-' '(' SuiteRestrict ')' ]
                      [ 'WITH' SuiteAttrFixes ] .
     SuiteExtension = ElemExtension < ',' ElemExtension > .
     ElemExtension  = IdentElem / 'TEXT' / 'GRAPHICS' /
                      'SYMBOL' / 'PICTURE' .
     SuiteRestrict  = ElemRestrict < ',' ElemRestrict > .
     ElemRestrict   = IdentElem / 'TEXT' / 'GRAPHICS' /
                      'SYMBOL' / 'PICTURE' .
\end{verbatim}

La liste des attributs a` valeur impose'e est constitue'e d'une suite de
couples attribut-valeur, se'pare's par des virgules. Chaque couple
comprend le nom de l'attribut dont la valeur est impose'e pour ce type
d'e'le'ment et sa valeur impose'e, les deux e'tant se'pare's par un signe {\tt =}.
Si ce signe est pre'ce'de' d'un point d'interrogation {\tt ?}
la valeur est conside're'e comme e'tant une valeur initiale
modifiable ulte'rieurement et non comme une valeur impose'e de'finitivement.
Seuls les attributs de type re'fe'rence sont repre'sente's par leur seul nom
et n'ont donc pas de valeur impose'e~; c'est leur pre'sence qui est impose'e.
Pour les autres types d'attributs, la valeur impose'e est indique'e par un
entier e'ventuellement signe' (attributs nume'riques), une chai^ne de caracte`res
entre apostrophes (attributs textuels) ou le nom d'une des valeurs possibles
(attributs e'nume're's).

Les attributs a` valeur impose'e peuvent e^tre soit des attributs globaux
(voir section~\ref{attrglobaux}) soit des attributs locaux au type de
l'e'le'ment pour lequel ils sont impose's, mais ils doivent toujours e^tre
de'clare's avant d'e^tre utilise's comme attributs impose's.


\begin{verbatim}
     SuiteAttrFixes = AttrFixe < ',' AttrFixe > .
     AttrFixe       = IdentAttr [ ValFixeOuModif ] .
     ValFixeOuModif = [ '?' ] '=' ValeurFixe .
     ValeurFixe     = [ '-' ] ValeurNum / ValeurTexte /
                      ValAttr .
     ValeurNum      = NUMBER .
     ValeurTexte    = STRING .
\end{verbatim}

\subsection{De'finitions de structure}
\label{defstruct}

La structure d'un type d'e'le'ment peut e^tre un simple type de base ou
un type construit.

Pour les types construits, il est fre'quent de trouver des structures
semblables en plusieurs endroits d'un document. Par exemple, les contenus du
re'sume', de l'introduction et d'une section peuvent avoir la me^me structure,
celle d'une suite de paragraphes. Dans ce cas, on de'finit une seule fois la
structure commune, avec un nom commun ({\tt Suite\_de\_paragraphes} dans cet
exemple), et on indique que chacun des types d'e'le'ment particuliers
posse`de cette structure, de la fac,on suivante~:

\begin{verbatim}
     Resume             = Suite_de_paragraphes;
     Introduction       = Suite_de_paragraphes;
     Contenu_de_section = Suite_de_paragraphes;
\end{verbatim}
Le signe {\tt =} signifie ``a la me^me structure que''.

Si le type d'e'le'ment de'fini est un simple type de base, il est indique'
par l'un des mots cle's {\tt TEXT}, {\tt GRAPHICS}, {\tt SYMBOL} ou
{\tt PICTURE}. Si des attributs locaux doivent e^tre associe's a` un type
de base, le mot cle' du type de base est suivi de la de'claration de ces
attributs locaux, sous la forme pre'sente'e section~\ref{elemstruct}.

Dans le cas d'un choix e'tendu, le type est indique' par le mot cle'
{\tt UNIT} pour les unite's ou le mot cle' {\tt NATURE}, pour les objets
d'une nature quelconque.

Une unite' repre'sente l'une des deux cate'gories d'e'le'ments suivantes~:
\begin{itemize}
\item
un des types de base~: texte, e'le'ment graphique, symbole, image,
\item
un e'le'ment dont le type est choisi parmi les types de'finis comme unite's
dans la section {\tt UNITS} du sche'ma de structure du document
ou de l'un des e'le'ments qui englobent l'e'le'ment auquel s'applique la
re`gle (voir page~\pageref{uniteslog}).
\end{itemize}

Lors de la cre'ation d'un e'le'ment de'fini comme unite',
l'e'diteur Thot propose a` l'utilisateur le choix entre ces cate'gories
d'e'le'ments.

Ainsi, on peut spe'cifier le contenu d'un paragraphe comme une suite
d'{\tt UNIT}s, ce qui permettra d'inclure dans les paragraphes des chai^nes
de caracte`res, des symboles, et des e'le'ments divers, comme des renvois
par exemple, si ceux-ci sont de'finis comme unite's.

Une nature (mot cle' {\tt NATURE}) repre'sente un objet de'fini par un
sche'ma de structure choisi librement parmi les sche'mas disponibles~;
dans ce cas l'e'le'ment a le type de'fini par la premie`re re`gle
(la re`gle racine) du sche'ma choisi.

Si le type d'e'le'ment de'fini est un type construit, on utilise l'un des
constructeurs liste, agre'gat, choix, ou re'fe'rence. Dans ce cas,
la de'finition commence par un mot cle' identifiant le constructeur.
Ce mot cle' est suivi d'une partie spe'cifique a` chaque constructeur.

Apre`s le nom du type d'e'le'ment de'fini apparaissent ses attributs locaux,
si ce type d'e'le'ment comprend des attributs locaux. La syntaxe de
de'finition des attributs locaux est pre'sente'e section~\ref{elemstruct}.

\begin{verbatim}
     Definition = TypeDeBase [ SuiteAttrLoc ] / Constr /
                  Element .
     TypeDeBase ='TEXT' / 'GRAPHICS' / 'SYMBOL' /
                 'PICTURE' / 'UNIT' / 'NATURE' .
     Element    = IdentElem [ ExtOuDef ] .
     ExtOuDef   ='EXTERN' / 'INCLUDED' / 
                 [ SuiteAttrLoc ] '=' Definition .
     Constr     ='LIST' [ '[' min '..' max ']' ] 'OF'
                          '(' DefAvecAttr ')' /
                 'BEGIN' SuiteDefOpt 'END' /
                 'AGGREGATE' SuiteDefOpt 'END' /
                 'CASE' 'OF' SuiteDef 'END' /
                 'REFERENCE' '(' TypeRef ')' /
                 'PAIR' .
\end{verbatim}

\subsubsection{Liste}

Le constructeur liste permet de de'finir un type d'e'le'ment constitue'
d'une liste d'e'le'ments, tous du me^me type. La de'finition de la liste
est forme'e du mot cle' {\tt LIST} suivi, entre crochets et de manie`re
facultative, des nombres minimum et maximum d'e'le'ments de la liste
se'pare's par deux points, et, apre`s le mot cle'
{\tt OF}, de la de'finition, entre parenthe`ses, du type des e'le'ments qui
doivent constituer la liste. Si les nombres minimum et maximum d'e'le'ments
sont absents, cela signifie qu'il n'y a pas de contrainte sur le nombre
d'e'le'ments de la liste~; mais si l'un des deux nombres est spe'cifie',
l'autre doit l'e^tre e'galement. Dans le cas ou` l'un des deux nombres est
inde'termine', il est repre'sente' par une e'toile.\footnote{S'il n'y a
aucune limite au nombre d'e'le'ments de la liste, on peut e'crire
{\tt LIST [\verb|*|..\verb|*|] OF}, mais le plus simple est de ne pas
spe'cifier les limites~: {\tt LIST OF}.}

\begin{verbatim}
             'LIST' [ '[' min '..' max ']' ] 'OF' '(' DefAvecAttr ')'
     min    = Entier / '*' .
     max    = Entier / '*' .
     Entier = NUMBER .
\end{verbatim}

Lors de l'e'dition d'un document, l'e'diteur Thot cre'e le nombre minimum
d'e'le'ments de la liste. S'il n'y a pas de minimum indique', il cre'e un seul
e'le'ment. Si le nombre maximum d'e'le'ments est indique' et si ce nombre est
atteint, l'e'diteur refuse de cre'e' de nouveaux e'le'ments dans la liste.

\begin{example}
Les deux instructions suivantes de'finissent le corps d'un document comme
une suite d'au moins deux chapitres et le contenu d'une section comme une
suite de paragraphes. Une section peut e^tre constitue'e d'un unique
paragraphe.

\begin{verbatim}
Corps           = LIST [2..*] OF (Chapitre);
Contenu_section = LIST OF (Paragraphe);
\end{verbatim}
\end{example}

\subsubsection{Agre'gat}

Le constructeur agre'gat permet de de'finir un type d'e'le'ment comme un
ensemble, ordonne' ou non, d'e'le'ments appele's composants de l'agre'gat,
chacun ayant un type fixe'.
Dans la de'finition d'un agre'gat, un mot cle' indique si l'agre'gat est
ordonne' ou non~: {\tt BEGIN} pour un agre'gat ordonne', {\tt AGGREGATE}
pour un agre'gat sans ordre.
Ce mot cle' est suivi de la liste des de'finitions de types des composants.
Cette liste se termine avec le mot cle' {\tt END}. Les de'finitions
de type des composants sont se'pare'es les unes des autres par des
points-virgules.

Lors de la cre'ation d'un agre'gat, l'e'diteur Thot cre'e, dans l'ordre
indique', me^me pour les agre'gats sans ordre, tous les composants, a`
l'exception de ceux dont le nom est pre'ce'de' du caracte`re {\tt ?}.
Ces composants, conside're's comme facultatifs, peuvent e^tre cre'e's
sur demande explicite, une fois que l'agre'gat a e'te' cre'e', mais
ils ne sont pas cre'e's automatiquement lors de la cre'ation de l'agre'gat.
Ce n'est que dans les agre'gats sans ordre qu'il est ensuite possible de
changer l'ordre des composants.

\begin{verbatim}
                  'BEGIN' SuiteDefOpt 'END'
     SuiteDefOpt = DefOpt ';' < DefOpt ';' > .
     DefOpt      = [ '?' ] DefAvecAttr .
\end{verbatim}

\begin{example}
Dans un document bilingue, chaque paragraphe est forme' de sa version en
anglais et de sa version en franc,ais. Dans certains cas, le traducteur
veut ajouter une note marginale, mais cette note est pre'sente dans tre`s peu
de paragraphes. Elle ne doit donc pas e^tre cre'e'e syste'matiquement pour chaque
paragraphe. Un paragraphe bilingue de ce type est donc de'clare'~:

\begin{verbatim}
Paragraphe_bilingue = BEGIN
                      Paragraphe_francais = TEXT;
                      Paragraphe_anglais  = TEXT;
                      ? Note              = TEXT;
                      END;
\end{verbatim}
\end{example}

\subsubsection{Choix}

Le constructeur choix permet de de'finir le type d'un e'le'ment comme l'un
des types parmi un ensemble de types possibles. Les mots cle's {\tt CASE} et
{\tt OF} sont suivis de la liste des de'finitions des types possibles,
se'pare's les unes des autres par des points-virgules.
Cette liste se termine par le mot cle' {\tt END}.

\begin{verbatim}
               'CASE' 'OF' SuiteDef 'END'
     SuiteDef = DefAvecAttr ';' < DefAvecAttr ';' > .
\end{verbatim}

Lors de la cre'ation d'un e'le'ment de'fini comme choix, l'e'diteur Thot propose
a` l'utilisateur la liste des types possibles, tels qu'ils sont de'finis dans
la re`gle {\tt CASE}. L'utilisateur n'a qu'a` se'lectionner dans cette liste
le type de l'e'le'ment qu'il veut cre'er.

L'ordre des de'clarations des types possibles a une importance. Il de'termine
l'ordre de la liste propose'e lors de la cre'ation d'un e'le'ment. Il favorise
e'galement les premiers types lors de la cre'ation automatique d'un contenu
par l'e'diteur. En effet, l'e'diteur Thot permet, lorsqu'un e'le'ment Choix
n'a pas de type de'termine', de se'lectionner cet e'le'ment et de frapper un texte
au clavier. Dans ce cas, l'e'diteur de'termine le type de l'e'le'ment comme
celui du premier type possible qui puisse contenir un atome de type chai^ne
de caracte`res.

Les deux cas particuliers du constructeur choix, la nature et l'unite', sont
pre'sente's dans les sections~\ref{defstruct} et \ref{uniteslog}.

\begin{example}
On veut offrir la possibilite' de mettre comme paragraphe, soit un simple texte
(paragraphe ordinaire), soit une formule mathe'matique, dont la structure est
de'finie par un autre sche'ma de structure de nom Math, soit un tableau,
e'galement de'fini par un autre sche'ma de structure, de nom Table. Le paragraphe
est alors de'fini~:

\begin{verbatim}
Paragraphe = CASE OF
               Simple_texte = TEXT;
               Formule      = Math;
               Tableau      = Table;
               END;
\end{verbatim}
\end{example}

\subsubsection{Re'fe'rence}
\label{references}

Comme tous les e'le'ments dans Thot, les re'fe'rences sont type'es.
Un type d'e'le'ment de'fini comme re'fe'rence est un renvoi a` un
e'le'ment d'un type donne'. Le mot cle' {\tt REFERENCE} est suivi,
entre parenthe`ses, du nom de ce type. Dans le cas ou` le type
auquel on renvoie est de'fini dans un autre sche'ma de structure, le nom du
type est lui-me^me suivi entre parenthe`ses du nom de la structure externe
ou` il est de'fini.

Le nom du type d'e'le'ment de'signe' peut e^tre pre'ce'de' du mot cle'
{\tt First} ou {\tt Second}, uniquement dans le cas ou` ce type est de'fini
comme une paire (voir section~\ref{paires}). Ces mots cle's indiquent
respectivement si la re'fe'rence doit de'signer la premie`re marque de la paire
ou la seconde. S'il s'agit d'une paire et qu'aucun de ces deux mots cle's
n'est pre'sent, c'est la premie`re marque qui est prise en compte.

Il y a une exception au principe de typage des re'fe'rences~: il est possible
de de'finir une re'fe'rence qui de'signe un e'le'ment d'un type quelconque,
qui peut e^tre aussi bien dans le me^me document que dans un autre document.
Pour cela, il suffit de mettre le mot cle' {\tt ANY} dans la parenthe`se
qui indique le type d'e'le'ment re'fe'rence'.

\begin{verbatim}
             'REFERENCE' '(' TypeRef ')'
   TypeRef = 'ANY' / [ FirstSec ] IdentElem [ StructExt ] .
\end{verbatim}

S'il s'agit d'une inclusion, on n'utilise pas le mot cle' {\tt REFERENCE}.
Les inclusions avec expansion comple`te ne sont pas de'clare'es en tant que telles
dans les sche'mas de structure, puisque n'importe quel e'le'ment de'fini
dans un sche'ma de structure peut e^tre remplace' par l'inclusion d'un
e'le'ment de me^me type. Au contraire, on doit de'clarer explicitement
les inclusions sans expansion ou avec expansion partielle lorsqu'il s'agit
d'inclure un objet complet
(et non pas une partie d'un objet). Dans ce cas, le type d'objet a` inclure
(le nom de son sche'ma de structure) est simplement suivi d'un mot cle'~:
{\tt EXTERN} quand on ne veut pas d'expansion et {\tt INCLUDED} quand on veut
une expansion partielle.

Lors de la cre'ation d'un renvoi ou d'une inclusion, l'e'diteur Thot
demande a` l'utilisateur de choisir, sur les images des documents affiche's,
l'e'le'ment que cette re'fe'rence doit de'signer.

\begin{example}
Si les types Note et Section sont de'finis dans le sche'ma de
structure d'un article, on de'finit, dans ce sche'ma de structure
Article, une re'fe'rence a` une note et une re'fe'rence a` une
section de la fac,on suivante~:

\begin{verbatim}
Ref_note    = REFERENCE (Note);
Ref_section = REFERENCE (Section);
\end{verbatim}

On de'finit maintenant la structure ge'ne'rique d'un recueil d'articles,
qui inclut (avec expansion partielle) des objets de la classe Article
et qui posse`de une
introduction ou` on veut autoriser des renvois a` des sections des
diffe'rents articles inclus. Dans le sche'ma de structure Recueil,
on e'crit~:

\begin{verbatim}
Recueil = BEGIN
          Titre_recueil = TEXT;
          Introduction = LIST OF (Elem = CASE OF
                                           TEXT;
                                           Ref_sect;
                                           END);
          Corps = LIST OF (Article INCLUDED);
          END;
Ref_sect = REFERENCE (Section (Article));
\end{verbatim}

On de'finit une classe de documents Dossier qui posse`de un titre et
inclut des documents de differents types, et notamment des dossiers~:
\begin{verbatim}
Dossier = BEGIN
          Titre_dossier = TEXT;
          Contenu_dossier = LIST OF (Document);
          END;

Document = CASE OF
              Article EXTERN;
              Recueil EXTERN;
              Dossier EXTERN;
              END;
\end{verbatim}
Avec cette de'finition, Dossier repre'sente soit l'agre'gat qui
contient le titre du dossier et la liste des documents inclus, soit
un dossier inclus. Pour lever cette ambigui"te', dans le langage P,
on met un caracte`re {\tt *} devant le nom de type (Dossier ici)
lorsqu'il s'agit du document inclus.
\end{example}

\subsubsection{Paire de marques}
\label{paires}

Comme les autres e'le'ments, les paires de marques sont type'es. Les
deux marques de la paire ont le me^me type, mais il existe deux
sous-types pre'de'finis qui s'appliquent a` toutes les paires de marques~:
la premie`re marque de la paire (note'e {\tt First} dans les langages
P et T) et la deuxie`me marque (note'e {\tt Second}).

Dans le langages S, une paire de marques est simplement note'e par le
mot cle' {\tt PAIR}.

Dans l'e'diteur Thot, les marques sont toujours cre'e'es, de'place'es ou
de'truites par deux. Les deux marques d'une paire portent un me^me
identificateur, unique dans le document, ce qui permet d'entrelacer
les paires de marques sans risque d'ambigui"te'.

\subsection{Importations}

Gra^ce aux natures, il est possible, lors de l'e'dition d'un
document, d'utiliser des classes de'finies par d'autres sche'mas de structure,
qui sont alors indique's dynamiquement par l'utilisateur, au fur et a` mesure
de ses besoins. On peut aussi, dans le sche'ma de structure, imposer une nature
(une classe) particulie`re a` certains types d'e'le'ments. Dans ce cas, ces
classes sont simplement de'signe'es par leur nom, lorsqu'elles sont utilise'es
dans les de'finitions de type d'e'le'ments structure's~: si un nom de type
n'est pas de'fini dans le sche'ma de structure, c'est qu'il s'agit du nom
d'une structure de'finie par un autre sche'ma de structure.

\begin{example}
Si les types Math et Table n'apparaissent pas, dans le sche'ma,
en partie gauche d'une re`gle de structure, les deux re`gles suivantes
indiquent qu'une formule a la structure d'un objet de'fini par le sche'ma
de structure Math et qu'un tableau a la structure d'un objet de'fini
par le sche'ma Table.

\begin{verbatim}
Formule = Math;
Tableau = Table;
\end{verbatim}
\end{example}

\subsection{Re`gles d'extension}

La section {\tt EXTENS}, qui ne peut apparai^tre que dans un sche'ma
d'extension, de'finit des comple'ments a` apporter a` des re`gles qui
sont sense'es exister dans le sche'ma principal, c'est-a`-dire le
sche'ma de structure auquel s'appliquera le
sche'ma d'extension. Plus pre'cise'ment, cette section permet d'ajouter
a` un type de'ja` de'fini des attributs locaux, des extensions, des
restrictions et des attributs a` valeur impose'e.

Ces ajouts peuvent s'appliquer a` la re`gle racine du sche'ma principal,
de'signe'e par le mot cle' {\tt Root}, ou a` toute autre re`gle dont le nom
est indique' explicitement.

Les re`gles d'extension sont se'pare'es les unes des autres par un point-virgule
et chaque re`gle d'extension est forme'e de la me^me fac,on qu'une re`gle de
structuration (voir section~\ref{elemstruct}), mais la partie qui de'finit
le constructeur est e'videmment absente.

\begin{verbatim}
     SuiteRegleExtens = RegleExtens ';' < RegleExtens ';' > .
     RegleExtens =      RootOuElem [ SuiteAttrLoc ]
                        [ '+' '(' SuiteExtension ')' ]
                        [ '-' '(' SuiteRestrict ')' ]
                        [ 'WITH' SuiteAttrFixes ] .
     RootOuElem =       'Root' / IdentElem .
\end{verbatim}

\subsection{E'le'ments associe's}

Si des e'le'ments associe's sont ne'cessaires, ils doivent e^tre de'clare's
dans la section spe'cifique du sche'ma de structure, introduite par le mot cle' 
{\tt ASSOC}. Chaque type d'e'le'ment associe' est spe'cifie' comme n'importe
quel autre e'le'ment structure'. Cependant, ces types ne doivent apparai^tre
dans aucune autre re`gle du sche'ma, sauf dans des re`gles {\tt REFERENCE}.

\subsection{Unite's}
\label{uniteslog}

La section {\tt UNITS} du sche'ma de structure contient les de'clarations des
types d'e'le'ments qui pourront e^tre utilise's dans les objets faisant partie
des documents ou les objets de la classe de'finie par le sche'ma. Tout comme
les e'le'ments associe's, ces types d'e'le'ments sont de'finis comme n'importe
quel autre type d'e'le'ment structure'. Ils peuvent e^tre utilise's dans les
autres types d'e'le'ments du sche'ma, mais ils peuvent aussi n'e^tre utilise's
par aucune re`gle du sche'ma.

\begin{example}
Si on de'clare comme unite' les re'fe'rences aux notes~:
\begin{verbatim}
UNITS
   Ref_note = REFERENCE (Note);
\end{verbatim}
il est alors possible d'introduire des re'fe'rences a` des notes dans une cellule
d'un tableau, lui-me^me construit avec un sche'ma de structure externe. Il
suffit que dans le tableau le contenu de la cellule soit de'clare' comme
une suite d'unite's, qui pourront alors e^tre des e'le'ments de base (par
exemple du texte) ou des re'fe'rences a` des notes du document.
\begin{verbatim}
Cellule = LIST OF (UNITS);
\end{verbatim}
\end{example}

\subsection{E'le'ments de squelette}
\label{squelette}

Lorsqu'on e'dite un document qui comporte ou doit comporter des re'fe'rences externes a`
de nombreux autres documents, on peut e^tre amene' a` charger dans l'e'diteur
un nombre important de documents, simplement pour voir les parties
de'signe'es par les re'fe'rences externes du document en cours d'e'dition,
ou pour acce'der a` l'original des e'le'ments inclus.
Dans ce cas, on ne modifie pas les documents externes et on n'a besoin de
voir que leurs e'le'ments susceptibles d'e^tre re'fe'rence's. C'est pour cette
raison que l'e'diteur propose de charger les documents sous la forme de
leur ``squelette''. Cette forme ne comporte que les e'le'ments explicitement
mentionne's dans la section {\tt EXPORT} de leur sche'ma de structure
et, pour ces e'le'ments, elle comporte seulement la partie de contenu
spe'cifie'e dans cette me^me section. Cette forme a l'avantage d'e^tre
tre`s compacte et donc de mobiliser peu de ressources de l'e'diteur.
C'est aussi la forme squelette qui constitue l'expansion des inclusions avec
expansion partielle (voir page~\pageref{inclusion}).

Les e'le'ments de squelette doivent e^tre explicitement de'clare' comme tels,
dans la section {\tt EXPORT} du sche'ma de structure qui les de'finit.
Cette section est forme'e du mot cle' {\tt EXPORT} et de la liste des
types d'e'le'ments qui doivent figurer dans la forme squelette, se'pare's par
des virgules, le dernier e'tant suivi d'un point-virgule. Ces types doivent
tous e^tre de'clare's pre'alablement dans le sche'ma.

Pour chaque type d'e'le'ment de squelette, la partie du contenu qui est
charge'e, et donc affichable, par l'e'diteur peut e^tre spe'cifie'e en faisant
suivre le nom du type de l'e'le'ment par le mot cle' {\tt WITH}
et le nom du type de l'e'le'ment contenu que l'on veut charger. Dans ce cas
seul cet e'le'ment contenu sera effectivement charge' parmi tous les
e'le'ments contenus dans l'e'le'ment de squelette. Si l'e'le'ment de contenu
a` charger est de'fini dans un autre sche'ma de structure, le nom de ce
sche'ma doit e^tre mentionne' entre parenthe`ses.
Si la partie {\tt WITH} est absente, la totalite' du contenu de l'e'le'ment
de squelette sera charge'e charge'e par l'e'diteur.
Si au contraire, on veut charger, dans la forme squelette, un certain
type d'e'le'ment sans aucun contenu, il faut faire suivre le mot cle'
{\tt WITH} du mot {\tt Nothing}.

\begin{verbatim}
                [ 'EXPORT' SuiteSquelette ]

     SuiteSquelette = ElemSquelette
                      < ',' ElemSquelette > ';' .
     ElemSquelette  = IdentElem [ 'WITH' Contenu ] .
     Contenu        = 'Nothing' / IdentElem [ StructExt ] .
\end{verbatim}

\begin{example}
Dans les documents de la classe article, on veut mettre dans le squelette les 
e'le'ments de type Titre\_article, Figure, Section
et Biblio pour pouvoir y faire re'fe'rence plus facilement depuis
d'autres documents. Lorsqu'on charge un article sous la forme
de son squelette, on veut charger tous ces types d'e'le'ments, sauf les
paragraphes, avec, pour le titre de l'article, la totalite' de son
contenu, pour les figures, uniquement leur le'gende, pour les sections,
uniquement leur titre et pour les e'le'ments bibliographiques uniquement
le titre qu'ils contiennent (ces e'le'ments bibliographiques sont de'finis
dans un autre sche'ma de structure, RefBib). Pour obtenir ce re'sultat,
on e'crit les de'clarations suivantes dans le sche'ma de structure Article~:
\begin{verbatim}
EXPORT
   Titre_article,
   Figure With Legende,
   Section With Titre_section,
   Biblio With Titre_biblio(RefBib);
\end{verbatim}
\end{example}

\subsection{Exceptions}

Le comportement de l'e'diteur Thot et les traitements qu'il effectue sont
de'termine's par les sche'mas de structure. Ils s'appliquent a` tous les
types de documents et d'objets, en suivant leur structure ge'ne'rique.
Pour certains types d'objets, comme les tableaux ou les graphiques, ces
traitements ne sont pas suffisants ou sont mal adapte's et des traitements
particuliers doivent s'ajouter ou se substituer a` certains des traitements
standard. Ces traitements particuliers sont appele's des {\it exceptions}.

Les exceptions ne
permettent d'inhiber ou de modifier que certains traitements standard, mais
elles peuvent e^tre utilise'es librement dans tout sche'ma de structure.

Chaque sche'ma de structure peut comporter une section de'finissant des
exceptions.
Elle commence par le mot cle' {\tt EXCEPT} et comprend une suite de
de'clarations d'exceptions, se'pare'es par des point-virgules. Chaque
de'claration d'exceptions de'bute par le nom d'un type d'e'le'ment ou
d'un attribut, suivi de deux-points. Cela indique le type d'e'le'ment
ou l'attribut auquel se rapporte les exceptions qui suivent.
Lorsqu'il s'agit du nom d'un type d'e'le'ment et que ce type est de'fini
comme une paire (voir section~\ref{paires}), et uniquement dans ce cas,
le nom de type peut e^tre pre'ce'de' du mot cle' {\tt First} ou {\tt Second},
pour indiquer si les exceptions qui suivent sont associe'es a` la premie`re
marque de la paire ou a` la seconde. En l'absence de ce mot cle', il s'agit
des premie`res marques.

Lorsqu'il s'agit d'une extension de sche'ma (voir section~\ref{schext}),
le mot cle' {\tt EXTERN} indique que le nom de type qui suit appartient au
sche'ma principal, celui qui est e'tendu par l'extension de sche'ma.
Les exceptions sont indique'es par un nom. Elles sont
se'pare'es les unes des autres par des virgules.

\begin{verbatim}
                  [ 'EXCEPT' SuiteExcept ]

     SuiteExcept   = Except ';' < Except ';' > .
     Except        = [ 'EXTERN' ] [ FirstSec ]
                     TypeOuAttrExc ':' SuiteValExc .
     TypeOuAttrExc = IdentElem / IdentAttr .
     SuiteValExc   = ValeurExc < ',' ValeurExc > .
     ValeurExc     ='NoCut' / 'NoCreate' /
                    'NoHMove' / 'NoVMove' / 'NoMove' /
                    'NoHResize' / 'NoVResize' / 'NoResize' /
                    'NewWidth' / 'NewHeight' /
                    'NewHPos' / 'NewVPos' /
                    'Invisible' / 'NoSelect' /
                    'Hidden' / 'ActiveRef' /
                    'ImportLine' / 'ImportParagraph' /
                    'NoPaginate' / 'ParagraphBreak' /
                    'HighlightChildren' / 'ExtendedSelection' .
\end{verbatim}

Les exceptions utilisables sont les suivantes~:

\begin{description}
\item[{\tt NoCut}]~: 
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne sont pas
 de'truits par l'e'diteur.
\item[{\tt NoCreate}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne sont pas
 cre'e's par les commandes ordinaires de cre'ation de nouveaux e'le'ments.
 Ces e'le'ments sont ge'ne'ralement cre'e's par des traitements
 particuliers associe's a` d'autres exceptions.
\item[{\tt NoHMove}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent pas
 e^tre de'place's horizontalement a` l'aide de la souris.
\item[{\tt NoVMove}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent pas
 e^tre de'place's verticalement a` l'aide de la souris.
\item[{\tt NoMove}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent
 e^tre de'place's dans aucune direction a` l'aide de la souris.
\item[{\tt NoHResize}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent pas
 e^tre retaille's horizontalement a` l'aide de la souris.
\item[{\tt NoVResize}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent pas
 e^tre retaille's verticalement a` l'aide de la souris.
\item[{\tt NoResize}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent
 e^tre retaille's dans aucune direction a` l'aide de la souris.
\item[{\tt NoSelect}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Les e'le'ments du type auquel l'exception est associe'e ne peuvent
 pas e^tre se'lectionne's directement avec la souris, mais ils peuvent
 l'e^tre par les autres moyens fournis par l'e'diteur.
\item[{\tt NewWidth}]~:
 Cette exception ne peut s'appliquer qu'aux attributs nume'riques.
 Si la largeur d'un e'le'ment qui porte cet attribut est modifie'e a`
 l'aide de la souris, la valeur de la nouvelle largeur sera affecte'e a`
 l'attribut.
\item[{\tt NewHeight}]~:
 Cette exception ne peut s'appliquer qu'aux attributs nume'riques.
 Si la hauteur d'un e'le'ment qui porte cet attribut est modifie'e a`
 l'aide de la souris, la valeur de la nouvelle hauteur sera affecte'e a`
 l'attribut.
\item[{\tt NewHPos}]~:
 Cette exception ne peut s'appliquer qu'aux attributs nume'riques.
 Si la position horizontale d'un e'le'ment qui porte cet attribut est
 modifie'e a` l'aide de la souris, la valeur de la nouvelle position sera
 affecte'e a` l'attribut.
\item[{\tt NewVPos}]~:
 Cette exception ne peut s'appliquer qu'aux attributs nume'riques.
 Si la position verticale d'un e'le'ment qui porte cet attribut est
 modifie'e a` l'aide de la souris, la valeur de la nouvelle position sera
 affecte'e a` l'attribut.
\item[{\tt Invisible}]~:
 Cette exception ne peut s'appliquer qu'aux attributs, mais elle peut
 s'appliquer a` tous les types d'attributs. Elle indique que l'attribut
 ne doit pas e^tre vu par l'utilisateur, que sa valeur ne doit pas e^tre
 change'e directement. Cette exception est ge'ne'ralement utilise'e quand
 une autre exception manipule les valeurs de l'attribut.
\item[{\tt Hidden}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments. Elle indique
 que les e'le'ments de ce type, bien que pre'sents dans la structure du
 document, ne doivent pas e^tre montre's a` l'utilisateur de l'e'diteur.
 En particulier, les menus de cre'ation ne proposent pas ce type et le
 message de se'lection ne l'affiche pas.
\item[{\tt ActiveRef}]~:
 Cette exception ne peut s'appliquer qu'aux attributs de type re'fe'rence.
 Elle indique que lorsque l'utilisateur de l'e'diteur fera un double clic
 sur un e'le'ment qui posse`de un attribut re'fe'rence ayant cette exception,
 l'e'le'ment de'signe' par l'attribut re'fe'rence sera se'lectionne'.
\item[{\tt ImportLine}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments. Elle indique
 que les e'le'ments de ce type doivent recevoir le texte contenu dans les
 fichiers importe's.  Un e'le'ment de ce type est cre'e' pour chaque ligne
 du fichier importe'. Un sche'ma de structure comporte au plus une
 exception {\tt ImportLine} et s'il en contient une il ne doit pas contenir
 d'exception {\tt ImportParagraph}.
\item[{\tt ImportParagraph}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments. Elle indique
 que les e'le'ments de ce type doivent recevoir le texte contenu dans les
 fichiers importe's. Un e'le'ment de ce type est cre'e' pour chaque paragraphe
 du fichier importe'. Un paragraphe est une suite de lignes sans ligne vide.
 Un sche'ma de structure comporte au plus une exception {\tt ImportParagraph}
 et s'il en contient une il ne doit pas contenir d'exception {\tt ImportLine}.
\item[{\tt NoPaginate}]~:
 Cette exception ne peut s'appliquer qu'a` l'e'le'ment racine du sche'ma de
 structure, celui qui apparai^t apre`s le mot cle' {\tt STRUCTURE}. Elle
 indique que l'e'diteur ne doit pas proposer a` l'utilisateur  de paginer
 les documents construits selon ce sche'ma.
\item[{\tt ParagraphBreak}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Lorsque le curseur se trouve a` l'inte'rieur d'un e'le'ment du type auquel
 est associe' l'exception, c'est cet e'le'ment qui sera coupe' en deux lorsque
 l'utilisateur frappera la touche Return.
\item[{\tt HighlightChildren}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Lorsqu'un e'le'ment du type auquel est associe' l'exception est se'lectionne',
 l'e'diteur ne met pas en e'vidence cet e'le'ment lui-me^me, mais chacun de
 ses fils.
\item[{\tt ExtendedSelection}]~:
 Cette exception ne peut s'appliquer qu'aux types d'e'le'ments.
 Elle permet que la commande d'extension de se'lection de l'e'diteur (le bouton
 du milieu de la souris), au lieu d'e'tendre la se'lection courante jusqu'a`
 l'e'le'ment de'signe', ajoute simplement cet e'le'ment de'signe' a` ceux qui
 sont de'ja` dans le se'lection courante. Cela se produit lorsque l'e'le'ment
 de'signe' a l'exception ExtendedSelection.
\end{description}

\begin{example}
Soit un sche'ma de structure de'finissant des graphiques. Dans ce sche'ma,
on a de'fini le type d'e'le'ment Objet\_graphique qui peut porter les attributs
nume'riques Hauteur et Largeur. On veut
que la hauteur et la largeur des objets graphiques soit enregistre'es dans
les attributs Hauteur et Largeur lorsque les dimensions d'un
objet sont modifie'es a` l'aide de la souris. On veut de plus interdire que
les valeurs de ces me^mes attributs soient modifie'es directement a` travers
le menu Attributs. Pour obtenir cela, on e'crit les exceptions suivantes.

\begin{verbatim}
STRUCT
...
   Objet_graphique (ATTR Hauteur = Integer; Largeur = Integer)
       = GRAPHICS with Hauteur ?= 10, Largeur ?= 10;
...
EXCEPT
   Hauteur: NewHeight, Invisible;
   Largeur: NewWidth, Invisible;
\end{verbatim}
\end{example}

\section{Quelques exemples}

Pour illustrer a` la fois les principes du mode`le et la syntaxe du langage S,
on donne ici deux exemples de sche'mas de structure, l'un qui de'finit une
classe de documents, l'autre, une classe d'objets.

\subsection{Une classe de documents~: les articles}

Dans cet exemple, on de'crit une structure possible pour des articles
publie's par une revue. Les textes entre accolades sont des commentaires.

\begin{verbatim}
STRUCTURE Article;  {Ce schema definit la classe Article}
DEFPRES ArticleP;   {Le schema de presentation par defaut
                     est ArticleP}
ATTR                {Definition des attributs globaux}
   Type_de_mot = Definition, Mot_index, Titre_ouvrage;
   {Un seul attribut global est defini, avec trois valeurs}
STRUCT              {Definition de la structure generique}
   Article = BEGIN  {L'article a une structure d'agregat}
             Titre = BEGIN   {Le titre est un agregat}
                     Titre_francais = Text
                               WITH Langue = 'Fran\347ais';
                     Titre_anglais = Text
                               WITH Langue = 'English';
                     END;
             Auteurs = LIST OF (Auteur
                        (ATTR Type_auteur = principal,
                                            secondaire)
                        {le type Auteur a un attribut local}
                                 = BEGIN
                                   Nom_Auteur = Text;
                                   Curriculum = Paragraphes;
                        {Paragraphes est defini plus loin}
                                   Adresse    = Text;
                                   END
                               );
             Mots_Cles = Text;
                   {L'editeur du journal presente l'article
                    par une courte introduction, en francais
                    et en anglais}
             Presentation = BEGIN
                            Pres_Francais = Paragraphes
                                WITH Langue = 'Fran\347ais';
                            Pres_Anglais  = Paragraphes
                                WITH Langue = 'English';
                            END;
             Corps = Sections;
                             {Sections est defini plus loin}
              {Les annexes ne seront creees que sur demande}
           ? Annexes = LIST OF (Annexe =
                                 BEGIN
                                 Titre_Annexe  =Text;
                                 Contenu_Annexe=Paragraphes;
                                 END
                               );
             END;      {Fin de l'agregat Article}

    Sections = LIST [2..*] OF (Section =
                    {Au moins 2 sections}
                                 BEGIN
                                 Titre_Section   = Text;
                                 Contenu_Section =
                                    BEGIN
                                    Paragraphes;
                                    Sections; {Sections du
                                          niveau inferieur}
                                    END;
                                 END
                              );

    Paragraphes = LIST OF (Paragraphe = CASE OF
                               Enumeration = LIST [2..*] OF
                                      (Item = Paragraphes);
                               Formule_isolee = Formule;
                               LIST OF (UNIT);
                               END
                          );

ASSOC         {Definition des elements associes}

   Figure = BEGIN
            Legende_Figure = Text;
            Illustration   = NATURE;
            END;

   Citation_biblio = CASE OF
                        Ref_Article =
                           BEGIN
                           Auteurs_Bib   = Text;
                           Titre_Article = Text;
                           Journal       = Text;
                           Numeros_Pages = Text;
                           Date          = Text;
                           END;
                        Ref_Livre =
                           BEGIN
                           Auteurs_Bib; {Defini plus haut}
                           Titre_Livre   = Text;
                           Editeur       = Text;
                           Date;        {Defini plus haut}
                           END;
                       END;

   Note =  Paragraphes - (Ref_note);

UNITS      {Les elements utilisables dans les objets}

   Ref_note    = REFERENCE (Note);
   Ref_biblio  = REFERENCE (Citation_biblio);
   Ref_figure  = REFERENCE (Figure);
   Ref_formule = REFERENCE (Formule_isolee);

EXPORT     {Les elements de squelette}

   Titre,
   Figure with Legende_Figure,
   Section With Titre_Section;

 END           {Fin du schema de structure}
\end{verbatim}

Ce sche'ma est tre`s complet puisqu'il va jusqu'a` de'finir les paragraphes
et les citations bibliographiques. Ces types d'e'le'ments pourraient aussi bien
e^tre de'finis par d'autres sche'mas de structure, comme c'est le cas de la
classe Formule, explicitement de'signe'e ici. Toutes sortes d'autres
e'le'ments peuvent e^tre introduits dans un article, puisqu'un paragraphe
peut contenir des unite's quelconques. De me^me, les illustrations peuvent
e^tre de diffe'rentes classes et l'utilisateur choisira, pour chaque figure,
la classe la mieux adapte'e.

En ge'ne'ral un article ne contient pas d'annexes. Mais il est possible
d'en ajouter en le demandant explicitement~: c'est la signification du
point d'interrogation devant le mot Annexes.

Les e'le'ments Figure, Citation\_biblio et Note sont des e'le'ments associe's.
Ils ne sont donc utilise's que dans des instructions {\tt REFERENCE}.

Diffe'rents types de renvois peuvent e^tre utilise's dans les
paragraphes, mais aussi dans des objets faisant partie de l'article,
puisqu'ils sont de'finis comme unite's ({\tt UNITS}).

On a utilise' une restriction, pour empe^cher que des renvois a` des notes
(Ref\_note) apparai^ssent a` l'inte'rieur des notes.

On remarque que le langage S permet la de'finition de structures re'cursives,
comme les sections~: une section peut contenir des sections (qui sont alors
de niveau infe'rieur). Les paragraphes sont e'galement des e'le'ments re'cursifs,
puisqu'un paragraphe peut contenir une e'nume'ration dont chaque e'le'ment
(Item) est constitue' de paragraphes.

\subsection{Une classe d'objets~: les formules mathe'matiques}

L'exemple ci-dessous de'finit la classe Formule utilise'e notamment dans les
documents Article. Cette classe repre'sente les formules mathe'matiques avec
une structure assez simplifie'e, mais suffisante pour obtenir une image
correcte sur l'e'cran ou a` l'impression. Pour des traitements plus e'labore's
(calcul formel ou nume'rique), on peut de'finir une structure plus fine.
Cette classe n'utilise aucune autre classe et ne de'finit pas d'e'le'ment
associe' ni d'unite'.

\begin{verbatim}
STRUCTURE Formule;
DEFPRES FormuleP;

ATTR
   Type_chaine = Nom_de_fonction, Nom_de_variable;

STRUCT
   Formule      = Expression;
   Expression   = LIST OF (Construction);
   Construction = CASE OF
                  TEXT;      {Simple chaine de caracteres}
                  Indice   = Expression;
                  Exposant = Expression;
                  Fraction =
                        BEGIN
                        Numerateur   = Expression;
                        Denominateur = Expression;
                        END;
                  Racine = 
                        BEGIN
                      ? Ordre = TEXT;
                        Contenu_Racine = Expression;
                        END;
                  Integrale =
                        BEGIN
                        Symbole_integration = SYMBOL;
                        Borne_Inferieure    = Expression;
                        Borne_Superieure    = Expression;
                        END;
                  Triple =
                        BEGIN
                        Expression_Princ = Expression;
                        Expression_Inf   = Expression;
                        Expression_Sup   = Expression;
                        END;
                  Colonne = LIST [2..*] OF
                                  (Element = Expression);
                  Bloc_Parenthese =
                        BEGIN
                        Ouvrant = SYMBOL;
                        Contenu = Expression;
                        Fermant = SYMBOL;
                        END;
                  END;       {Fin du choix Construction}
END                          {Fin du schema de structure}
\end{verbatim}

Ce sche'ma de'finit un seul attribut global, qui permet de distinguer les
fonctions des variables, a` l'inte'rieur d'une formule. Dans le sche'ma de
pre'sentation cet attribut peut e^tre utilise' dans le choix des caracte`res
romains (pour les fonctions) et italiques (pour les variables).

Une formule a la structure d'une expression mathe'matique, qui est elle-me^me
forme'e d'une suite de de constructions mathe'matiques. Une construction
mathe'matique peut e^tre soit une simple chai^ne de caracte`res, soit un
indice, soit un exposant, soit une fraction, soit une racine, etc.
Chacune de ces constructions mathe'matiques a une structure propre qui fait
en ge'ne'ral intervenir une ou plusieurs expressions, ce qui rend re'cursive
la de'finition de la structure d'une formule.

Dans la plupart des cas, les racines qui apparaissent dans les formules sont
des racines carre'es et l'ordre (2) n'est pas indique'. C'est pourquoi le
composant Ordre est marque' comme facultatif par un point
d'interrogation. En le demandant explicitement, il est possible d'ajouter
un ordre dans une racine, par exemple pour les racines cubiques (ordre = 3).

Une inte'grale est forme'e d'un symbole d'inte'gration, choisi librement par
l'utilisateur (inte'grale simple, double, curviligne, etc.), et de deux bornes.
Un sche'ma plus fin ajouterait les composants inte'grande et variable
d'inte'gration. De la me^me fac,on que pour le signe d'inte'gration, la
construction Bloc\_Parenthese laisse a` l'utilisateur le choix des
symboles ouvrant et fermant, qui peuvent e^tre des crochets, des accolades,
des parenthe`ses, etc.


\chapter{Langage P}

\section{Pre'sentation des documents}

Gra^ce au mode`le adopte' pour Thot, la pre'sentation des documents est
clairement se'pare'e de leur structure et de leur contenu. Apre`s avoir
pre'sente' la structure logique des documents, nous de'taillons maintenant
les principes mis en oeuvre pour leur pre'sentation. La notion de
pre'sentation recouvre a` la fois ce que les typographes appellent la mise
en page, la composition et la maquette d'un document. C'est l'ensemble des
ope'rations qui conduisent a` l'affichage de l'image d'un document sur e'cran
ou a` son impression sur papier. Comme la structure logique, la pre'sentation
des documents est de'finie de fac,on ge'ne'rique a` l'aide d'un langage,
appele' P.

\subsection{Deux niveaux de pre'sentation}

Le lien entre structure et pre'sentation est clair~: l'organisation logique
d'un document est mise a` profit pour effectuer sa pre'sentation, puisque
la pre'sentation est justement faite pour mettre en e'vidence
l'organisation du document. Mais elle est e'galement de'pendante de l'appareil
utilise' pour la restitution. Certains effets de pre'sentation, comme
les changements de police ou de corps notamment, ne peuvent pas e^tre
obtenus sur toutes les imprimantes et sur tous les e'crans.
C'est pourquoi Thot utilise une approche a` deux niveaux, ou` la pre'sentation
est d'abord de'crite en termes abstraits, sans tenir compte d'aucun appareil
particulier, puis elle est re'alise'e en tenant compte des possibilite's d'un
appareil donne'.

La pre'sentation est donc de'crite uniquement en fonction de la structure des
documents et de l'image que l'on souhaite obtenir avec un appareil ide'al.
Pour cette raison, dans la description de la pre'sentation, on ne
fait re'fe'rence a` aucune caracte'ristique d'appareil~: il s'agit d'une
{\em pre'sentation abstraite} qui peut e^tre concre'tise'e sur des
appareils diffe'rents.

Il s'agit aussi d'une {\em pre'sentation ge'ne'rique}, puisqu'elle de'crit l'aspect
d'une classe de documents ou d'objets. Cette pre'sentation ge'ne'rique doit
e^tre applique'e a` des occurrences de documents ou d'objets, chacun e'tant
bien su^r conforme a` sa structure logique ge'ne'rique, mais avec toutes les
tole'rances e'voque'es plus haut~: e'le'ments manquants, e'le'ments construits
avec d'autres structures ge'ne'riques, etc.

Pour conserver l'homoge'ne'ite' entre documents et objets, la pre'sentation
se de'crit avec un ensemble unique d'outils, qui permettent la mise en page
d'un gros document aussi bien que la composition d'un objet comme un
graphique ou une formule. Cette unicite' des outils de description de la
pre'sentation s'oppose a` l'approche traditionnelle, qui s'inte'resse davantage
aux documents qu'aux objets, et se fonde donc sur les donne'es typographiques
habituelles, comme les positions des marges, les renfoncements, les espaces
verticaux, les longueurs de lignes, la justification, les changements de
police, etc.

\subsection{Boi^tes}

Pour assurer l'homoge'ne'ite' des outils, toute la pre'sentation dans Thot se
fonde, pour les documents comme pour les objets qu'ils contiennent, sur la
notion de {\em boi^te,} telle qu'elle a e'te' mise en oeuvre dans \TeX\ .

\`{A} chaque e'le'ment du document on fait correspondre une boi^te,
qui est le rectangle englobant l'e'le'ment sur le support d'affichage
(e'cran ou feuille de papier)~; le contour de ce rectangle n'est
normalement pas visible.
Les co^te's de la boi^te sont paralle`les aux bords de l'e'cran ou de la
feuille de papier. \`{A} titre d'exemple, une boi^te est associe'e a` une
chai^ne de caracte`res, a` une ligne de texte, a` une page, a` un paragraphe,
a` un titre, a` une formule mathe'matique, ou encore a` une expression a`
l'inte'rieur d'une formule, ou a` une cellule d'un tableau.

Quel que soit l'e'le'ment auquel elle se rapporte, chaque boi^te posse`de
quatre co^te's et quatre axes, que nous de'signons de la fac,on suivante
(voir figure~\ref{boite})~:

\begin{description}
\item[ {\tt  Top} ]~: le co^te' supe'rieur,
\item[ {\tt  Bottom} ]~: le co^te' infe'rieur,
\item[ {\tt  Left} ]~: le co^te' gauche,
\item[ {\tt  Right} ]~: le co^te' droit,
\item[ {\tt  VMiddle} ]~: l'axe vertical passant par le centre de la boi^te,
\item[ {\tt  HMiddle} ]~: l'axe horizontal passant par le centre de la boi^te,
\item[ {\tt  VRef} ]~: l'axe de re'fe'rence vertical,
\item[ {\tt  HRef} ]~: l'axe de re'fe'rence horizontal.
\end{description}

\begin{figure}
\begin{center}
\setlength{\unitlength}{1 mm}
\begin{picture}(105,55)
\thicklines
\put(26,4){\framebox(72,42)}
\thinlines
\put(19,46){\makebox(0,0)[r]{Top}}
\multiput(20,46)(2,0){3}{\line(1,0){1}}
\put(19,25){\makebox(0,0)[r]{HMiddle}}
\multiput(20,25)(2,0){42}{\line(1,0){1}}
\put(19,13){\makebox(0,0)[r]{HRef}}
\multiput(20,13)(2,0){42}{\line(1,0){1}}
\put(19,4){\makebox(0,0)[r]{Bottom}}
\multiput(20,4)(2,0){3}{\line(1,0){1}}
\put(26,54){\makebox(0,0)[t]{Left}}
\multiput(26,46)(0,2){2}{\line(0,1){1}}
\put(62,54){\makebox(0,0)[t]{VMiddle}}
\multiput(62,0)(0,2){25}{\line(0,1){1}}
\put(85,54){\makebox(0,0)[t]{VRef}}
\multiput(85,0)(0,2){25}{\line(0,1){1}}
\put(98,54){\makebox(0,0)[t]{Right}}
\multiput(98,46)(0,2){2}{\line(0,1){1}}
\end{picture}
\end{center}
\caption{Les co^te's et les axes des boi^tes}
\label{boite}
\end{figure}

Le ro^le principal des boi^tes est de dimensionner et de
positionner les images des diffe'rents e'le'ments d'un document les unes par
rapport aux autres, sur le support de restitution. Pour cela on de'finit,
entre les boi^tes des diffe'rents e'le'ments, des relations qui donnent les
dimensions et les positions relatives de ces boi^tes.

On distingue trois types de boi^tes~:

\begin{itemize}
\item
les boi^tes associe'es aux e'le'ments structuraux du document,
\item
les boi^tes de pre'sentation,
\item
les boi^tes de mise en page.
\end{itemize}

{\bf Les boi^tes associe'es aux e'le'ments du document} sont celles qui
correspondent a` chacun des e'le'ments (de base ou structure's) de la structure
logique du document. Une telle boi^te contient (de'limite sur le support
d'affichage) tout le contenu de l'e'le'ment auquel elle est associe'e (il y a
une exception, voir les re`gles {\tt VertOverflow} et {\tt HorizOverflow}).
Toutes ces boi^tes forment une structure arborescente, identique
a` celle des e'le'ments structuraux auxquels elles correspondent.
Cet arbre exprime les relations d'inclusion entre les boi^tes~:
une boi^te englobe toutes les boi^tes de son sous-arbre. En revanche il
n'y a pas de re`gle pre'de'finie pour les positions relatives des boi^tes
englobe'es. Si elles sont de me^me niveau, elles peuvent se chevaucher,
e^tre contigue"s, ou disjointes. Les re`gles exprime'es dans la pre'sentation
ge'ne'rique pre'cisent ces positions relatives.

{\bf Les boi^tes de pre'sentation} repre'sentent des e'le'ments qui ne figurent
pas dans la structure logique du document, mais qui sont ajoute'es pour
les besoins de la pre'sentation. Ces boi^tes sont relie'es aux e'le'ments de la
structure logique, qu'elles permettent de mieux faire ressortir.
Elles sont par exemple utilise'es pour ajouter la chai^ne de
caracte`res ``Re'sume'~:'' avant le re'sume' dans l'image d'un rapport, ou
pour repre'senter la barre de fraction dans une formule, ou encore pour
faire apparai^tre l'intitule' des champs d'un formulaire. Ces
e'le'ments, en effet, n'ont pas de ro^le dans la structure logique du
document~: si un e'le'ment est de type re'sume', il n'est pas ne'cessaire
de faire figurer, dans la structure, le mot ``Re'sume'''. De me^me, si un
e'le'ment est du type fraction et qu'il comporte deux autres e'le'ments
de type nume'rateur et de'nominateur, la barre n'a pas d'utilite'
structurale. En revanche, ces e'le'ments de pre'sentation sont importants
pour le lecteur du document restitue' ou pour l'utilisateur d'un e'diteur,
c'est pourquoi ils doivent figurer dans l'image du document.
C'est la pre'sentation ge'ne'rique qui spe'cifie les boi^tes de pre'sentation
a` ajouter, en indiquant leur contenu (un e'le'ment de base dont la valeur
est pre'cise'e) et la position qu'elles doivent prendre dans l'arbre des
boi^tes. Lors de l'e'dition, ces boi^tes ne peuvent pas e^tre modifie'es
par l'utilisateur.

{\bf Les boi^tes de mise en page} sont des boi^tes cre'e'es implicitement par
les re`gles de mise en page. Ces re`gles indiquent comment le contenu d'un
e'le'ment structure' doit e^tre de'coupe' en lignes ou en pages. \`{A} la
diffe'rence des boi^tes de pre'sentation, ces boi^tes lignes ou pages ne
de'pendent pas de la structure logique du document, mais pluto^t des
contraintes physiques du support de restitution~: taille des caracte`res,
largeur et hauteur de la fene^tre d'e'cran ou de la feuille de
papier. La pre'sentation ge'ne'rique n'indique que les re`gles qui doivent
e^tre suivies pour la construction de ces boi^tes, mais elle ne les cre'e pas
explicitement, a` la diffe'rence des boi^tes de pre'sentation.

\subsection{Vues et visibilite'}

Selon les traitements que l'on veut effectuer sur un document, on peut
souhaiter voir ce document de diffe'rentes fac,ons. Pour cette raison, il est
possible de de'finir plusieurs {\em vues} pour un me^me document, ou mieux,
pour tous les documents d'une me^me classe.
Une vue n'est pas une pre'sentation diffe'rente du document, mais pluto^t
un filtre qui permet de n'afficher que certaines parties du document. Par
exemple, on peut souhaiter ne voir que les titres de chapitres et de
sections, mais les voir tous, pour pouvoir se de'placer rapidement dans le
document~; on a alors besoin d'une vue ``table des matie`res''.
On peut aussi souhaiter ne voir que les formules mathe'matiques d'un document,
si on s'inte'resse plus au raisonnement mathe'matique lui-me^me qu'a` son
texte de pre'sentation. Il faut pour cela une vue ``mathe'matique'' du document.

Les vues, comme la pre'sentation, sont base'es sur la structure logique
ge'ne'rique. Chaque classe de document, et me^me chaque pre'sentation ge'ne'rique,
peut donc e^tre munie des vues qui lui sont spe'cifiquement utiles.
Pour chaque vue, on de'finit la {\em visibilite'} des e'le'ments, qui indique
si les e'le'ments doivent e^tre pre'sente's a` l'utilisateur ou non. La visibilite'
est calcule'e en fonction du type des e'le'ments et/ou de leur position
hie'rarchique dans la structure du document. Ainsi, pour une table des
matie`res, tous les e'le'ments ``Titre de chapitre'' et ``Titre de section''
sont rendus visibles, le niveau hie'rarchique pouvant e^tre utilise' pour
rendre les titres de section invisibles au-dessous d'un certain niveau seuil.
En faisant varier ce seuil, on peut faire varier la granularite' de la vue.
Dans la vue ``mathe'matique'', on rend visibles les seuls e'le'ments du type
formule, quel que soit leur niveau hie'rarchique.

Les vues e'tant surtout utilise'es pour donner une image synthe'tique du
document, il est ne'cessaire d'adapter la pre'sentation des e'le'ments
selon la vue dans laquelle ils apparaissent~: on ne change pas
de page a` chaque titre de chapitre dans la table des matie`res.
Les pre'sentations ge'ne'riques tiennent donc compte des vues possibles
et permettent de de'finir, pour chaque type d'e'le'ment, des pre'sentations
diffe'rentes selon les vues ou` leur image apparai^t.
\label{lesvues}

Les vues sont e'galement utilise'es, pendant l'e'dition des documents, pour
afficher les e'le'ments associe's. On peut ainsi avoir, en plus de la vue
principale du document, une vue ``notes'' et une vue ``figures'' qui
contiennent chacune les e'le'ments associe's du type note ou figure.
De cette fac,on, il est possible de voir (donc d'e'diter) en me^me temps
le texte qui fait re'fe'rence a` ces e'le'ments et les e'le'ments eux-me^mes,
me^me s'ils doivent e^tre se'pare's au moment de l'impression.

\subsection{Pages}

On peut de'finir des sche'mas de pre'sentation qui affichent le document
comme un long rouleau, sans rupture de page. Ce type de sche'ma convient
particulie`rement a` la phase initiale de travail sur un document, ou` les
sauts de pages seraient pluto^t une ge^ne a` la re'daction et a` la lecture
sur e'cran.
Dans ce cas les e'le'ments associe's, comme les notes, qui sont habituellement
affiche's en bas de page, sont pre'sente's dans une fene^tre spe'cifique.
Mais si, une fois le document e'crit, on souhaite l'imprimer tel qu'il est
affiche' a` l'e'cran, le sche'ma de pre'sentation choisi doit de'finir des
pages.

Le langage P permet de spe'cifier les dimensions des pages ainsi que leur
composition. Il permet d'engendrer des titres courants, des nume'ros
de pages, des zones de bas de page pour les notes, etc. L'e'diteur suit
ce mode`le et inse`re dans le document des marques de saut de page qui sont
utilise'es lors de l'impression, de fac,on que les pages sur papier soit
les me^mes qu'a` l'e'cran. 

Une fois qu'un document a e'te' e'dite' avec un sche'ma de pre'sentation
de'finissant des pages, il contient donc des marques de pages, mais il est
toujours possible de l'e'diter avec un sche'ma sans page. Dans ce cas, les
marques de page sont simplement ignore'es par l'e'diteur. Elles sont a` nouveau
conside're'es de`s qu'un sche'ma avec pages est utilise'. Ainsi l'utilisateur est
libre de choisir quand il le souhaite un sche'ma avec pages ou sans page.

Thot ne conside`re pas la page comme une boi^te, mais c'est le saut de page
qu'il traite comme une boi^te. Cette boi^te de saut de page contient tous
les e'le'ments de bas de page d'une page, un filet horizontal marquant la limite
physique de cette page, et tous les e'le'ments de haut de page de la page
suivante. Les e'le'ments de bas et de haut de page peuvent e^tre des titres
courants, des nume'ros de page, des e'le'ments associe's (par exemple des notes),
etc. Tous ces e'le'ments, aussi bien leur contenu que leur aspect graphique,
sont de'finis par la pre'sentation ge'ne'rique.

\subsection{Nume'rotation}

De nombreux e'le'ments sont nume'rote's dans les documents~: les pages, les
chapitres, les sections, les formules, les the'ore`mes, les notes, les figures,
les re'fe'rences bibliographiques, les exercices, les exemples, les lemmes, etc.
Avec la notion de structure logique de Thot, tous ces nume'ros (a` l'exception
des nume'ros de page) sont redondants avec la structure logique du document.
Ils ne constituent qu'un moyen de rendre plus visible la structure du
document. Ils font donc partie de la pre'sentation du document et sont calcule's
par l'e'diteur a` partir de la structure logique. La structure en tant que
telle ne comporte pas de nume'ros, elle de'finit seulement des positions
structurales relatives entre e'le'ments, donc des relations d'ordre entre
e'le'ments.

Si le sche'ma de structure de'finit le corps d'un document comme une suite
d'au moins deux chapitres~:
\begin{verbatim}
Corps = LIST [2..*] OF Chapitre ;
\end{verbatim}
la suite de'finie par le constructeur liste est ordonne'e et on peut
attribuer comme nume'ro a` chaque chapitre son rang dans la liste Corps.
Tous les e'le'ments constituant des listes dans la structure d'un document
sont donc nume'rotables, mais ce ne sont pas les seuls. La structure
arborescente induite par les constructeurs agre'gat, liste, et choix, a`
l'exclusion des re'fe'rences, permet de de'finir un ordre total entre tous
les e'le'ments de la structure principale du document. Il est donc possible
de de'finir une nume'rotation qui utilise cet ordre, en filtrant selon leur
type les e'le'ments qui doivent e^tre pris en compte. De cette fac,on, on
peut donc choisir de nume'roter ensemble, dans une me^me se'quence de nume'ros,
tous les the'ore`mes et les lemmes d'un chapitre, me^me s'ils ne font pas
partie d'une me^me construction liste et se trouvent a` des niveaux
hie'rarchiques diffe'rents~; mais on peut aussi, en changeant le filtre, les
nume'roter se'pare'ment~: une suite de nume'ros pour les the'ore`mes, une autre
pour les lemmes.

Les e'le'ments associe's posent un proble`me particulier, puisqu'ils ne font
pas partie de la structure principale du document, mais qu'ils y sont
attache's uniquement par des re'fe'rences, qui pre'cise'ment rompent l'ordre
total obtenu dans le document. Or ces e'le'ments associe's sont tre`s souvent
nume'rote's, justement parce que le nume'ro est un moyen efficace de visualiser
la re'fe'rence. Pour re'soudre ce proble`me, Thot regroupe  par types les
e'le'ments associe's, et pour chaque type il de'finit implicitement une
construction liste qui regroupe (et ordonne) tous les e'le'ments associe's
de me^me type. Les e'le'ments associe's peuvent ainsi e^tre nume'rote's par
type.

E'tant calcule's a` partir de la structure logique et uniquement pour les besoins
de la pre'sentation, les nume'ros sont donc des e'le'ments de pre'sentation,
de'crits par des boi^tes de pre'sentation, tout comme la barre de fraction
ou le mot ``Re'sume'''. Ils se diffe'rencient toutefois de ceux-ci par le fait
que leur contenu est variable d'une occurrence a` l'autre d'un me^me type,
alors que les barres de toutes les fractions sont des traits horizontaux
et que le me^me mot ``Re'sume''' apparai^t en te^te des re'sume's de tous les
documents de la classe.

\subsection{Parame`tres de pre'sentation}

Les principaux parame`tres qui de'terminent la pre'sentation des documents sont
les {\em positions} et {\em dimensions} des boi^tes, la {\em police}, le
{\em style}, la {\em taille}, le type de {\em soulignement} et la
{\em couleur} de leur contenu.
\`{A} partir de ces quelques parame`tres, et de quelques
autres de moindre importance, il est possible, pour les parties textuelles,
de repre'senter les parame`tres usuels de la typographie. Pour les e'le'ments
non-textuels, qui sont des e'le'ments bidimensionnels, et non pas line'aires
comme le texte, ces me^mes parame`tres permettent de de'crire leur ge'ome'trie.

Comme on l'a de'ja` vu, les positions des boi^tes respectent
toujours la re`gle d'englobement~: une boi^te de l'arbre englobe
toutes les boi^tes de niveau infe'rieur qui lui sont attache'es.
Les parame`tres de positionnement permettent de pre'ciser la position
de chaque boi^te par rapport a` la boi^te englobante ou aux boi^tes
soeurs (boi^tes attache'es directement, dans l'arbre des boi^tes, a` la
me^me boi^te englobante).

Les parame`tres de pre'sentation permettent e'galement de contro^ler les
dimensions des boi^tes. Les dimensions d'une boi^te peuvent de'pendre soit
de son contenu, soit de son environnement (les boi^tes soeurs et la
boi^te englobante), chaque dimension (hauteur ou largeur) pouvant
e^tre de'finie inde'pendamment de l'autre.

Gra^ce aux parame`tres de position et de dimension des boi^tes, on peut
effectuer ce qui est habituellement fait en typographie par des changements
de marges, des changements de longueur de ligne, des sauts d'espace
vertical ou horizontal. On peut aussi effectuer l'e'quivalent
des alignements, des centrages, etc.

Au contraire de la position ou de la dimension, la police, le style,
la taille, le soulignement et la couleur ne concernent pas la boi^te
elle-me^me (le rectangle de'limitant l'e'le'ment), mais son contenu.
Ces parame`tres indiquent les attributs typographiques qui doivent e^tre
applique's au texte contenu dans la boi^te, et, par extension, a` tous les
e'le'ments de base.

Pour le texte, la police permet d'obtenir des
changements de famille de caracte`res (Times, Helve'tica, Courier, etc.)~;
le style d'e'criture permet d'obtenir de l'italique ou du romain, du gras
ou du maigre~; la taille de'termine le corps des caracte`res~; le soulignement
de'finit le type et l'e'paisseur du trait que l'on peut tracer au-dessus,
en dessous ou en travers des caracte`res.

Pour le graphique, le style de trait se traduit par des traits continus,
pointille's, ou des tirets~; l'e'paisseur de trait contro^le la largeur
des trace's~; le motif de remplissage indique comment doivent e^tre remplies
les figures ge'ome'triques ferme'es.

Alors que ces parame`tres qui de'terminent l'aspect du contenu d'une boi^te
n'ont de sens que pour un type de contenu (texte ou graphique), d'autres
parame`tres s'appliquent indiffe'remment a` tous les types de contenus~:
ce sont les parame`tres de couleur. Ils permettent d'indiquer la couleur
des trace's et la couleur de fond.

\section{Langage de description de la pre'sentation}
\label{langp}

Une pre'sentation ge'ne'rique de'finit les valeurs des parame`tres de pre'sentation
(ou le mode de calcul de ces valeurs) pour une structure ge'ne'rique, ou plus
pre'cise'ment pour tous les types d'e'le'ments et tous les attributs (globaux et
locaux) de'finis dans cette structure ge'ne'rique.
Cette de'finition des parame`tres de pre'sentation
se fait a` l'aide du langage P. Un programme e'crit dans
ce langage, donc une pre'sentation ge'ne'rique exprime'e en P, est appele' un
{\em sche'ma de pre'sentation}. Nous de'crivons ici la syntaxe et la se'mantique
du langage, en utilisant le me^me me'ta-langage que pour la de'finition du
langage S (voir page~\pageref{metalang}).

Rappelons qu'il est possible d'e'crire plusieurs sche'mas de pre'sentation
diffe'rents pour la me^me classe de documents ou d'objets. Cela permet
d'offrir aux utilisateurs le choix de l'aspect graphique des documents
qui convient le mieux a` leur type de travail ou a` leur gou^t personnel.

\subsection{Organisation d'un sche'ma de pre'sentation}

Un sche'ma de pre'sentation commence par le mot {\tt PRESENTATION} et se
termine par le mot {\tt END}. Le mot {\tt PRESENTATION} est suivi du nom
de la structure ge'ne'rique dont la pre'sentation est de'finie par le sche'ma.
Ce nom doit e^tre le me^me que celui qui suit le mot cle'
{\tt STRUCTURE} dans le sche'ma de structure auquel est associe' le
sche'ma de pre'sentation.

Apre`s cette de'claration du nom de structure, apparaissent, dans l'ordre~:

\begin{itemize}
\item
les de'clarations
   \begin{itemize}
   \item
   des vues,
   \item
   des vues a` imprimer,
   \item
   des compteurs de nume'rotation,
   \item
   des constantes de pre'sentation,
   \item
   des variables,
   \end{itemize}
\item
les re`gles de pre'sentation par de'faut,
\item
les de'finitions des boi^tes de pre'sentation et de mise en page,
\item
les re`gles de pre'sentation des e'le'ments structure's,
\item
les re`gles de pre'sentation des attributs,
\item
les re`gles de transmission de valeurs aux attributs des documents inclus.
\end{itemize}

Chacune de ces sections est introduite par un mot cle' qui est suivi
d'une suite de de'clarations. Toutes ces sections sont facultatives.

\begin{verbatim}
     SchemaPres ='PRESENTATION' IdentElem ';'
               [ 'VIEWS' SuiteVues ]
               [ 'PRINT' SuiteVuesImpr ]
               [ 'COUNTERS' SuiteCompteurs ]
               [ 'CONST' SuiteConst ]
               [ 'VAR' SuiteVar ]
               [ 'DEFAULT' SuiteReglesVues ]
               [ 'BOXES' SuiteBoites ]
               [ 'RULES' SuitePresent ]
               [ 'ATTRIBUTES' SuitePresAttr ]
               [ 'TRANSMIT' SuiteTransmit ]
                 'END' .
     IdentElem  = NAME .
\end{verbatim}

\subsection{Vues}

Chacune des vues possibles doit e^tre de'clare'e dans le sche'ma de
pre'sentation. On a vu page~\pageref{lesvues} que les re`gles de pre'sentation
d'un type d'e'le'ment pouvaient varier suivant la vue dans laquelle
l'e'le'ment apparai^t~; c'est le nom de la vue qui sera utilise' pour
de'signer une vue dans les re`gles de pre'sentation (voir l'instruction
{\tt IN}, page~\pageref{instrin}). La de'finition du contenu de la vue est
disperse'e a` travers les re`gles de pre'sentation attache'es aux diffe'rents
types d'e'le'ments et d'attributs. La section {\tt VIEWS} est simplement
constitue'e de la suite des noms des vues se'pare's par des virgules et
termine'e par un point-virgule.

L'un des noms de vues (et un seul) peut e^tre suivi du mot cle' {\tt EXPORT}.
Ce mot cle' identifie la vue qui pre'sente les documents sous la forme de
leur squelette (voir section~\ref{squelette}). L'aspect graphique et le contenu
de cette  vue est de'fini comme pour toute autre vue, mais il est inutile
de spe'cifier des re`gles de pre'sentation concernant cette vue pour les
e'le'ments qui ne sont pas charge's sous la forme squelette.

On peut ne de'clarer aucune vue~; dans ce cas il y a ne'anmoins une (et une
seule) vue possible, qui n'a pas de nom. Si plusieurs vues sont de'clare'es,
celle dont le nom figure en te^te de liste est conside're'e comme la vue
principale, c'est-a`-dire celle a` laquelle se rapportent toutes les re`gles
de pre'sentation qui ne sont pas explicitement pre'ce'de'es d'une indication
de vue (voir l'instruction {\tt IN}, page~\pageref{instrin}).

C'est la vue principale, donc la premie`re de'clare'e, qui est pre'sente'e a`
l'e'cran par l'e'diteur de`s que l'utilisateur demande a` cre'er ou a` e'diter
un document. On a donc inte're^t a` mettre en te^te de la liste des vues celle
qui est le plus couramment utilise'e. Mais, si le sche'ma de structure
comporte des e'le'ments de squelette (voir section~\ref{squelette}), lorsqu'un
document est charge' sous la forme de son squelette, c'est la vue dont le
nom est suivi de {\tt EXPORT} qui est ouverte et les autres vues
ne peuvent pas e^tre ouvertes.

\begin{verbatim}
                     'VIEWS' SuiteVues
     SuiteVues      = DeclarationVue
                      < ',' DeclarationVue > ';' .
     DeclarationVue = IdentVue [ 'EXPORT' ] .
     IdentVue       = NAME .
\end{verbatim}

\begin{example}
Si, lors de l'e'dition d'un rapport, on de'sire une vue pour
la table des matie`res et une autre pour toutes les formules, en plus de la
vue principale qui montre le document dans son entier, on de'clare dans un
sche'ma de pre'sentation de la classe Rapport~:

\begin{verbatim}
VIEWS
     Texte_integral, Table_des_matieres, Formules;
\end{verbatim}

Le contenu de ces vues est pre'cise' dans les re`gles de pre'sentation du
sche'ma.
\end{example}

\subsection{Vues a` imprimer}

Lors de l'e'dition d'un document, chaque vue est pre'sente'e dans une
fene^tre diffe'rente. En plus des vues spe'cifie'es par l'instruction
{\tt VIEWS}, l'utilisateur peut faire afficher les e'le'ments associe's,
ceux-ci e'tant regroupe's selon leur type, avec une fene^tre pour chaque
type d'e'le'ment associe'.

Lors de l'impression d'un document, il est possible de faire imprimer
un nombre quelconque de vues, choisies parmi toutes celles que l'e'diteur
peut afficher (vues au sens strict ou e'le'ments associe's). Les vues a`
imprimer, ainsi que l'ordre dans lequel elle doivent e^tre imprime'es,
sont indique'es par l'instruction {\tt PRINT}. Celle-ci apparai^t
apre`s l'instruction {\tt VIEWS} et est forme'e du mot cle' {\tt PRINT}
suivi de la liste ordonne'e des noms de vues a` imprimer. Les noms de
vues a` imprimer sont se'pare's par des vigules et le dernier est suivi
d'un point-virgule. Un nom de vue a` imprimer est soit un nom de vue
de'clare' dans l'instruction {\tt VIEWS} soit un nom d'e'le'ments
associe's (nom de'clare' dans la section {\tt ASSOC} du sche'ma de structure,
termine' par un ``s'').

\begin{verbatim}
                    'PRINT' SuiteVuesImpr
     SuiteVuesImpr = VueImpr < ',' VueImpr > ';' .
     VueImpr =      IdentVue / IdentElem .
\end{verbatim}

Si l'instruction {\tt PRINT} est absente, le programme d'impression
n'imprime que la premie`re vue spe'cifie'e par l'instruction {\tt VIEWS}
ou, s'il n'y a pas d'instruction {\tt VIEWS}, l'unique vue possible du
document.

\begin{example}
Avec la de'claration des vues de l'exemple pre'ce'dent, on peut choisir de
ne pas imprimer la vue Formules, qui n'est utile que lors de l'e'dition,
mais d'imprimer, en plus des deux autres vues, les citations bibliographiques,
qui sont des e'le'ments associe's. On souhaite imprimer le texte inte'gral
d'abord, puis la bibliographie et enfin la table des matie`res. Pour obtenir
ce re'sultat a` l'impression, on e'crit dans le sche'ma de pre'sentation~:

\begin{verbatim}
PRINT
     Texte_integral, Citations, Table_des_matieres;
\end{verbatim}
\end{example}

\subsection{Compteurs de nume'rotation}

\`{A} chaque type de nume'rotation, le sche'ma de pre'sentation associe un
compteur. Tous les compteurs, donc tous les types de nume'rotation, utilise's
dans le sche'ma doivent e^tre de'clare's apre`s le mot cle' {\tt COUNTERS}.

Chaque de'claration de compteur est constitue'e d'un nom identifiant le
compteur, suivi de deux-points et de la fonction de comptage
a` appliquer au compteur. La de'claration d'un compteur se termine par un
point-virgule.

La fonction de comptage indique le mode de calcul de la valeur du compteur.
Trois fonctions de comptage sont disponibles. La premie`re s'applique au
comptage des e'le'ments de liste ou d'agre'gat~: elle affecte au compteur
le rang de l'e'le'ment dans la liste ou l'agre'gat. Plus pre'cise'ment,
la fonction
\begin{verbatim}
RANK OF IdentElem [ NiveauAsc ] [ INIT IdentAttr ]
        [ 'REINIT' AttrName ]
\end{verbatim}
indique que lorsqu'un e'le'ment cre'e, par une re`gle de cre'ation (voir
les instructions {\tt Create}, page~\pageref{creation}), une boi^te de
pre'sentation contenant la valeur du compteur, cette valeur est le rang de
l'e'le'ment cre'ateur, s'il est de type {\tt IdentElem}, sinon le rang du
premier e'le'ment de type {\tt IdentElem} qui englobe l'e'le'ment cre'ateur
dans la structure logique du document.

Le nom du type peut e^tre pre'ce'de' d'une e'toile, dans le cas particulier
ou` le sche'ma de structure de'finit une inclusion sans expansion ou avec
expansion partielle, inclusion de me^me
type qu'un e'le'ment du sche'ma (voir section~\ref{references}).
Pour lever cette ambigui"te', on met une e'toile lorsqu'il s'agit de
l'inclusion et on n'en met pas lorsqu'il s'agit du type de'fini dans le
sche'ma de structure.

Le nom du type {\tt IdentElem} peut e^tre suivi d'un nombre entier,
e'ventuellement ne'gatif. Ce nombre repre'sente le niveau relatif, parmi
les ascendants de l'e'le'ment cre'ateur, de l'e'le'ment dont on veut le
rang. Si ce niveau relatif {\it n} est non signe', on prend le rang du $n^e`me$
e'le'ment du type indique' que l'on rencontre sur le chemin qui va, dans
la structure logique du document, de la racine vers l'e'le'ment cre'ateur.
Si le niveau relatif est ne'gatif, on parcourt le me^me chemin en sens inverse,
de l'e'le'ment cre'ateur vers la racine.

La fonction {\tt RANK} peut comporter le mot cle' {\tt INIT} suivi du nom d'un
attribut nume'rique (et seulement d'un attribut nume'rique). Dans ce cas,
le rang du premier e'le'ment de la liste ou de l'agre'gat n'est pas 1, mais
la valeur de cet attribut, et le rang de tous les
autres e'le'ments est de'cale' de la me^me fac,on. L'attribut qui de'termine
la valeur initiale est recherche' sur l'e'le'ment a` nume'roter et sur ses
ascendants.

La fonction {\tt RANK} peut se terminer par le mot cle' {\tt REINIT} suivi du
nom d'un attribut nume'rique (et seulement d'un attribut nume'rique). Dans ce
cas, si l'un des e'le'ments a` nume'roter porte cet attribut, le compteur
prend, pour cet e'l'ement, la valeur de l'attribut et, pour les e'le'ments
suivants, les valeurs en se'quence.

Dans le cas ou` la fonction {\tt RANK} est e'crite
\begin{verbatim}
RANK OF Page [ IdentVue ] [ INIT IdentAttr ]
\end{verbatim}
({\tt Page} est un mot cle' du langage P), le compteur auquel elle s'applique
prend pour valeur le nume'ro, depuis le de'but du document, de la page ou` se
trouve l'e'le'ment qui cre'e une boi^te de pre'sentation utilisant le compteur.
Tout se passe comme si les pages du document formaient une liste pour chaque
vue. Le compteur ne tient compte que des pages de la vue concerne'e,
c'est-a`-dire la vue a` laquelle appartient la boi^te de pre'sentation dont le
contenu prend la valeur du compteur. Toutefois, si le mot {\tt Page} est suivi,
entre parenthe`ses, du nom d'une vue, ce sont les pages de cette vue qui sont
prises en compte. Comme dans la forme pre'ce'dente, la fonction {\tt RANK}
applique'e a` des pages peut se terminer par le mot cle' {\tt INIT} suivi
d'un nom d'attribut nume'rique, dont la valeur de'termine le nume'ro de la
premie`re page. Cet attribut doit e^tre un attribut local du document
lui-me^me, et non pas de l'un de ses composants.

La deuxie`me fonction de comptage permet de compter les occurrences d'un
certain type d'e'le'ment dans un contexte pre'cise'. L'instruction
\begin{verbatim}
SET n ON Type1 ADD m ON Type2 [ INIT IdentAttr ]
\end{verbatim}
signifie que, lorsqu'on parcourt le document du de'but a` la fin, dans l'ordre
induit par la structure logique arborescente, on affecte au compteur la valeur
{\tt n} chaque fois qu'on rencontre un e'le'ment de type {\tt Type1}, quelle
que soit la valeur courante du compteur, et on ajoute la valeur {\tt m} a`
la valeur courante du compteur chaque fois qu'on rencontre un e'le'ment de
type {\tt Type2}.

Comme dans la fonction {\tt RANK}, les noms de type peuvent e^tre pre'ce'de's
d'une e'toile pour lever l'ambigui"te' des e'le'ments inclus.

Si la fonction se termine par le mot cle' {\tt INIT} suivi du nom d'un
attribut, c'est la valeur de l'attribut qui est prise a` la place de {\tt n}.
L'attribut doit e^tre de type nume'rique et il est recherche' sur l'e'le'ment
a` nume'roter et sur ses ascendants.

Cette fonction peut e'galement e^tre utilise'e avec le mot cle' {\tt Page} a`
la place de {\tt Type1} ou {\tt Type2}. Dans le premier cas, le compteur est
re'initialise' a` chaque page avec la valeur {\tt n}, dans le second cas, il
est incre'mente' de {\tt m} a` chaque page. Comme avec la fonction de comptage
pre'ce'dente, le mot {\tt Page} peut e^tre suivi d'un nom de vue entre
parenthe`ses. Dans ce cas, ce sont les pages de cette vue, qui sont prises
en compte.

La de'finition du compteur peut comporter plusieurs fonctions {\tt
SET} avec chacun une valeur diffe'rente et plusieurs fonctions {\tt
ADD} avec chacun une valeur diffe'rente. Le nombre total de fonctions
du compteur ne doit pas e^tre supe'rieur a` 6.

La troisie`me fonction de comptage permet de compter les e'le'ments
d'un type donne' qui englobent l'e'le'ment cre'ateur, celui-ci compris.
Cette fonction s'e'crit
\begin{verbatim}
RLEVEL OF Type
\end{verbatim}
ou` {\tt Type} repre'sente le type des e'le'ments que l'on prend en compte.

La de'finition formelle des de'clarations de compteurs s'e'crit~:

\begin{verbatim}
                     'COUNTERS' SuiteCompteurs
     SuiteCompteurs = Compteur < Compteur > .
     Compteur       = IdentCompteur ':' FonctCompteur ';' .
     IdentCompteur  = NAME .
     FonctCompteur  ='RANK' 'OF' TypeOuPage [ SNiveauAsc ]
                     [ 'INIT' IdentAttr ] [ 'REINIT' IdentAttr ] /
                      SetFonction < SetFonction >
                      AddFonction < AddFonction >
                     [ 'INIT' IdentAttr ] /
                     'RLEVEL' 'OF' IdentElem .
     SNiveauAsc     = [ '-' ] NiveauAsc .
     NiveauAsc      = NUMBER .
     SetFonction    ='SET' ValeurCompt 'ON' TypeOuPage .
     AddFonction    ='ADD' ValeurCompt 'ON' TypeOuPage .
     TypeOuPage     ='Page' [ '(' IdentVue ')' ] / 
                     [ '*' ] IdentElem .
     ValeurCompt    = NUMBER .
\end{verbatim}

\begin{example}
Si le corps d'un chapitre est de'fini, dans le sche'ma de
structure, comme une se'quence de sections~:

\begin{verbatim}
Corps_Chapitre = LIST OF (Section = 
                            BEGIN
                            Titre_Section = Text;
                            Corps_Section = Paragraphes;
                            END
                         );
\end{verbatim}
le compteur de sections est de'clare'~:

\begin{verbatim}
CptSection : RANK OF Section;
\end{verbatim}
et l'affichage du nume'ro de section devant chaque titre de section est
obtenu par une re`gle {\tt CreateBefore} (voir page~\pageref{creation}),
attache'e au type {\tt Titre\_Section}, qui cre'e une boi^te de pre'sentation
dont le contenu est la valeur du compteur {\tt CptSection} (voir
l'instruction {\tt Content}, page~\pageref{content}).

Pour nume'roter des formules chapitre par chapitre, le compteur de formules
est de'clare'~:

\begin{verbatim}
CptFormule : SET 0 ON Chapitre ADD 1 ON Formule;
\end{verbatim}
et l'affichage du nume'ro de formule le long de la marge droite, en
face de chaque formule, est obtenu par une instruction {\tt CreateAfter},
attache'e au type {\tt Formule}, qui cre'e une boi^te de pre'sentation dont
le contenu est la valeur du compteur {\tt CptFormule}.

Pour nume'roter les pages chapitre par chapitre, la premie`re page de chaque
chapitre portant le nume'ro 1, on utilise le compteur
\begin{verbatim}
CptPageChapitre : SET 0 ON Chapitre ADD 1 ON Page;
\end{verbatim}
Si, en plus on de'finit un compteur de chapitre
\begin{verbatim}
CptChapitre : RANK OF Chapitre;
\end{verbatim}
on peut de'finir le contenu (voir page~\pageref{content}) d'une boi^te de
pre'sentation a` cre'er en haut de chaque page~:
\begin{verbatim}
Content : (VALUE(CptChapitre, URoman) TEXT '-'
           VALUE(CptPageChapitre, Arabic));
\end{verbatim}
La boi^te de pre'sentation contient ainsi le nume'ro du chapitre en chiffres
romains, suivi d'un tiret et du nume'ro de la page dans le chapitre,
en chiffres arabes.
\end{example}

\begin{example}
Pour compter conjointement les tableaux et les figures d'un document
de type chapitre, on de'finira le compteur
\begin{verbatim}
CptCommun : SET 0 ON Chapitre ADD 1 ON Tableau
            ADD 1 ON Figure;
\end{verbatim}
\end{example}

\subsection{Constantes de pre'sentation}
\label{constpres}

Les constantes de pre'sentation permettent de de'finir le contenu des
boi^tes de pre'sentation. Ce contenu est utilise' dans les de'finitions de
variables (voir page~\pageref{variables}) et dans la re`gle {\tt Content}
(voir page~\pageref{content}). Les seules constantes de pre'sentation qui
peuvent e^tre utilise'es sont des chai^nes de caracte`res, des symboles
mathe'matiques, des e'le'ments graphiques et des images, c'est-a`-dire des
e'le'ments de base.

Les constantes peuvent e^tre de'finies directement dans les variables ou
les boi^tes de pre'sentation (re`gle {\tt Content}) qui les utilisent.
Mais on a inte're^t a` de'clarer une seule fois, dans la section des
de'clarations de constantes, les constantes qui sont utilise'es dans plusieurs
variables ou boi^tes. Chaque constante ainsi de'clare'e porte un nom,
qui permet de la de'signer lorsqu'on l'utilise, un type (l'un des quatre
types de base) et une valeur (une chai^ne de caracte`res ou un caracte`re
unique pour les symboles et les e'le'ments graphiques).

Apre`s le mot cle' {\tt CONST} apparaissent toutes les de'clarations de
constantes. Chacune est constitue'e du nom de la constante, d'un signe {\tt =},
d'un mot cle' repre'sentant son type ({\tt Text}, {\tt Symbol}, {\tt Graphics}
ou {\tt Picture}) et de la chai^ne repre'sentant sa valeur~; elle se termine
par un point-virgule.

Dans le cas d'une chai^ne de caracte`res, le mot cle' {\tt Text} peut e^tre
suivi d'un nom d'alphabet (par exemple, {\tt Grec} ou {\tt Latin}) qui
indique dans quel alphabet est exprime' le texte de la constante. Si
l'indication d'alphabet est absente, il s'agit de l'alphabet latin. Dans
le cas ou` elle est pre'sente, seule la premie`re lettre du nom de l'alphabet
est interpre'te'e. Ainsi les mots {\tt Greek} et {\tt Grec} de'signent le
me^me alphabet. Dans la version actuelle de Thot, seuls les alphabet latin
et grecs sont disponibles.

\begin{verbatim}
                 'CONST' SuiteConst
     SuiteConst = Const < Const > .
     Const      = IdentConst '=' TypeConst ValeurConst ';' .
     IdentConst = NAME .
     TypeConst  ='Text' [ Alphabet ] / 'Symbol' /
                 'Graphics' / 'Picture' .
     ValeurConst= STRING .
     Alphabet   = NAME .
\end{verbatim}

Dans le cas d'une chai^ne de caracte`res dans l'alphabet latin (jeu de
carate`res ISO-Latin 1), les caracte`res dont le code est supe'rieur a` 127
(de'cimal) sont repre'sente's par leur code octal.

Dans le cas d'un symbole ou d'un e'le'ment graphique, la valeur ne comporte
qu'un seul caracte`re, entre apostrophes, qui indique la forme de l'e'le'ment
qui doit e^tre trace' dans la boi^te dont la constante est le contenu. Le
symbole ou l'e'le'ment graphique prend les dimensions de la boi^te, qui sont
de'termine'es par les re`gles {\tt Height} et {\tt Width}. La table de codage
des symboles et e'le'ments graphiques est donne'e page~\pageref{codesymbole}.

Dans le cas d'une image (type {\tt Picture}), la valeur de la constante est le
nom du fichier qui contient l'image, et non l'image nume'rise'e elle-me^me.

\begin{example}
Les constantes ``Re'sume'~:'' et barre de fraction dont on a
parle' plus haut se de'clarent~:

\begin{verbatim}
CONST
     CsteResume = Text 'R\351sum\351 :';
     Barre      = Graphics 'h';
\end{verbatim}
(Dans le jeu de caracte`res ISO-Latin 1, le code octal du caracte`re ``e''' est
351.)
\end{example}

\subsection{Variables}
\label{variables}

Les variables permettent de de'finir, pour les boi^tes de pre'sentation, un
contenu calcule'. C'est la re`gle {\tt Content} (voir page~\pageref{content})
qui associe une variable a` une boi^te de pre'sentation~; mais avant d'e^tre
utilise'e dans une re`gle {\tt Content}, une variable peut e^tre de'finie
dans la section {\tt VAR}. Il est e'galement possible de de'finir une
variable, comme pour une constante, lors de son utilisation dans une re`gle
{\tt Content}.

Une variable porte un nom et a une valeur qui est une chai^ne de caracte`res
re'sultant de la concate'nation des valeurs d'une suite de fonctions.
Chaque de'claration de variable est constitue'e du nom de la variable suivi
de deux-points et de la suite des fonctions qui produisent sa valeur, simplement
se'pare'es par des espaces. Elle se termine par un point-virgule.

\begin{verbatim}
                     'VAR' SuiteVar
     SuiteVar       = Variable < Variable > .
     Variable       = IdentVar ':' SuiteFonctions ';' .
     IdentVar       = NAME .
     SuiteFonctions = Fonction < Fonction > .
\end{verbatim}

Plusieurs fonctions sont disponibles. Les deux premie`res donnent, sous la forme
d'une chai^ne de caracte`res, la date du jour, l'une en anglais ({\tt DATE}),
l'autre en franc,ais ({\tt FDATE}).

Deux autres fonctions, {\tt DocName} et {\tt DirName}, donnent respectivement
le nom du document et le re'pertoire ou` il est stocke'.

La fonction {\tt ElemName} donne le type de l'e'le'ment qui cre'e la boi^te
de pre'sentation dont la variable est le contenu.

Une autre fonction donne simplement la valeur d'une constante de
pre'sentation. S'il s'agit d'une constante pre'alablement de'clare'e dans la
section {\tt CONST}, il suffit d'indiquer le nom de la
constante~; sinon, il faut fournir le type et la valeur de la constante,
sous la me^me forme que dans une de'claration de constante (voir
page~\pageref{constpres}). Si la constante n'est pas de type texte (types
{\tt Symbol}, {\tt Graphics} ou {\tt Picture}), elle doit figurer seule
dans la variable~; seules les constantes de type {\tt Text} peuvent
e^tre combine'es avec d'autres fonctions.

Il est possible e'galement d'obtenir la valeur d'un attribut, simplement
en mentionnant le nom de l'attribut. On obtient ainsi la valeur de l'attribut
indique' porte' par l'e'le'ment qui cre'e la boi^te de pre'sentation dont
la variable est le contenu. Si l'e'le'ment en question ne porte pas l'attribut
indique', la valeur est une chai^ne vide. Dans le cas d'un attribut
nume'rique, la valeur de l'attribut est traduite en un nombre de'cimal en
chiffres arabes~; si une autre forme est souhaite'e, il faut utiliser la
fonction {\tt VALUE}.

La dernie`re fonction disponible donne, sous la forme d'une chai^ne de
caracte`res, la valeur d'un compteur, d'un attribut ou d'un nume'ro de page.
Cette valeur peut e^tre pre'sente'e selon diffe'rents styles.
Le mot cle' {\tt VALUE} est suivi entre parenthe`ses du nom du compteur, du
nom de l'attribut ou du mot cle' {\tt PageNumber} et du style de'sire',
les deux parame`tres e'tant se'pare's par une virgule. Le style
est un mot cle' qui indique si la valeur doit e^tre pre'sente'e
en chiffres arabes ({\tt Arabic}), en chiffres romains minuscules
({\tt LRoman}) ou majuscules ({\tt URoman}), ou par une lettre majuscule
({\tt Uppercase}) ou minuscule ({\tt Lowercase}).

Dans le cas d'un compteur de pages, le mot cle' {\tt PageNumber} peut
e^tre suivi entre parenthe`ses du nom de la vue pour laquelle on veut
le nume'ro de page. Par de'faut, il s'agit de la premie`re vue de'clare'e
dans la section {\tt VIEWS}. La valeur obtenue est le nume'ro de la page
dans laquelle se trouve l'e'le'ment qui utilise la variable par une re`gle
{\tt Content}.

Dans le cas d'un compteur ordinaire, le nom du compteur peut e^tre pre'ce'de'
du mot cle' {\tt MaxRangeVal} ou {\tt MinRangeVal}. Dans ce cas,
il ne s'agit pas de la valeur que prend le compteur pour l'e'le'ment
qui cre'e la boi^te de pre'sentation dont la variable est le contenu,
mais de la la valeur maximum ou minimum que prend le compteur dans
l'ensemble du document.

\begin{verbatim}
     Fonction =     'DATE' / 'FDATE' /
                    'DocName' / 'DirName' /
		    'ElemName' / 'AttributeName' /
                     IdentConst / TypeConst ValeurConst /
                     IdentAttr /
                    'VALUE' '(' ComptAttrPage ','
                                StyleCompteur ')' .
     ComptAttrPage ='PageNumber' [ '(' IdentVue ')' ] /
                     [ MinMax ] IdentCompteur / IdentAttr .
     StyleCompteur ='Arabic' / 'LRoman' / 'URoman' /
                    'Uppercase' / 'Lowercase' .
     MinMax =       'MaxRangeVal' / 'MinRangeVal' .
\end{verbatim}

\begin{example}
Pour faire apparai^tre la date du jour en haut de la premie`re page d'un
rapport, une re`gle {\tt CREATE} (voir page~\pageref{creation}) associe'e au
type Titre\_Rapport engendre une boi^te de pre'sentation dont le contenu
(spe'cifie' par la re`gle {\tt Content} de cette boi^te de pre'sentation) est la
variable~:

\begin{verbatim}
VAR
     Date_du_jour : TEXT 'Version du ' FDATE;
\end{verbatim}
Si on de'finit les deux compteurs

\begin{verbatim}
COUNTERS
     CptChapitre : RANK OF Chapitre;
     CptSection :  RANK OF Section;
\end{verbatim}
on produit devant chaque titre de section le nume'ro (en chiffres arabes)
de la section pre'ce'de' du nume'ro (en chiffres romains) du chapitre, en faisant
cre'er par le titre de section une boi^te de pre'sentation dont le contenu est
la variable~:

\begin{verbatim}
VAR
     NumSection : VALUE (CptChapitre, URoman) TEXT '-'
                  VALUE (CptSection, Arabic);
\end{verbatim}

Pour faire apparai^tre, dans la vue table des matie`res, en face de chaque
titre de section, le nume'ro de la page ou` ce titre apparai^t dans la vue
principale, on fait cre'er par les titres de section une boi^te de
pre'sentation, visible uniquement dans la vue table des matie`res, dont
le contenu est la variable~:

\begin{verbatim}
VAR
     NumPageTitre :
           VALUE (PageNumber(VuePrincipale), Arabic);
\end{verbatim}
\end{example}

\subsection{Re`gles de pre'sentation par de'faut}
\label{reglesdefaut}

Pour e'viter de spe'cifier, pour chaque type d'e'le'ment de'fini dans le
sche'ma de structure, les valeurs de tous les parame`tres de pre'sentation,
qui sont nombreux, on de'finit, apre`s le mot cle' {\tt DEFAULT}, un ensemble
de re`gles de pre'sentation qui s'appliquent par de'faut a` toutes les boi^tes
des e'le'ments de'finis dans le sche'ma de structure et a` toutes les boi^tes
de pre'sentation ou de mise en page de'finies dans le sche'ma de pre'sentation
courant. Seules les re`gles qui diffe`rent de ces re`gles par de'faut sont
spe'cifie'es dans la suite du sche'ma pour chaque boi^te de pre'sentation ou
de mise en page et pour chaque type d'e'le'ment.

Pour la vue principale, les re`gles par de'faut peuvent de'finir tous les
parame`tres de pre'sentation, mais pas les fonctions de pre'sentation (voir
page~\pageref{fonctpres}), ni les conditions de coupure (re`gles
{\tt NoBreak1}, {\tt NoBreak2} et {\tt Gather}, voir
page~\pageref{condcoupure}).

La section des re`gles de pre'sentation par de'faut peut e^tre absente d'un
sche'ma de pre'sentation~; dans ce cas, le mot cle' {\tt DEFAULT} est
e'galement absent et les re`gles suivantes sont conside're'es comme les
re`gles par de'faut~:

\begin{verbatim}
   Visibility: Enclosing =;
   VertRef: * . Left;
   HorizRef: Enclosed . HRef;
   Height: Enclosed . Height;
   Width: Enclosed . Width;
   VertPos: Top = Previous . Bottom;
   HorizPos: Left = Enclosing . Left;
   VertOverflow: No;
   HorizOverflow: No;
   Size: Enclosing =;
   Style: Enclosing =;
   Font: Enclosing =;
   Underline: Enclosing =;
   Thickness: Enclosing =;
   Indent: Enclosing =;
   LineSpacing: Enclosing =;
   Adjust: Enclosing =;
   Justify: Enclosing =;
   Hyphenate: Enclosing =;
   PageBreak: Yes;
   LineBreak: Yes;
   InLine: Yes;
   Depth: 0;
   LineStyle: Enclosing =;
   LineWeight: Enclosing =;
   FillPattern: Enclosing =;
   Background: Enclosing =;
   Foreground: Enclosing =;
\end{verbatim}

Si d'autres valeurs des re`gles par de'faut sont souhaite'es, elle doivent
e^tre de'finies explicitement dans la section des re`gles par de'faut. Il est
e'videmment possible de ne de'finir dans cette section que certaines re`gles,
celles qui ne sont pas de'finies prenant alors les valeurs ci-dessus.

On peut en plus spe'cifier des re`gles pour les autres vues que la vue
principale, qui seront alors applique'es comme re`gles par de'faut pour ces
vues. Sinon, ce sont les re`gles par de'faut de la vue principale qui
s'appliqueront aux autres vues.

Les re`gles par de'faut s'expriment de la me^me fac,on que les re`gles
explicites des e'le'ments. Elles sont pre'sente'es page~\pageref{reglepres}.

\subsection{Boi^tes de pre'sentation et de mise en page}

Dans la pre'sentation on utilise des e'le'ments qui ne font pas partie de la
structure logique du document, comme des pages (ce sont des
boi^tes de mise en page) ou encore des filets, des nume'ros ou des mots
introduisant certaines parties, comme ``Re'sum\'{e}'', ``Annexes'',
``Bibliographie'', etc. (ce sont des boi^tes de pre'sentation). Ces boi^tes
sont de'finies, dans le sche'ma de pre'sentation, dans la section {\tt BOXES}.

Apre`s le mot cle' {\tt BOXES}, chaque boi^te de pre'sentation ou de mise en page
est de'finie par son nom et une suite de re`gles de pre'sentation qui indiquent
comment elle doit e^tre affiche'e. Ces re`gles sont les me^mes que celles qui
de'finissent les boi^tes associe'es aux e'le'ments de la structure logique du
document, a` l'exception d'une seule, la re`gle {\tt Content} (voir
page~\pageref{content}) qui n'est utilise'e que pour les boi^tes de
pre'sentation, pour en pre'ciser le contenu. Le contenu des boi^tes associe'es
aux e'le'ments de la structure du document est de'fini dans chaque document
ou objet, et n'est donc pas spe'cifie' dans le sche'ma de pre'sentation, qui
s'applique a` tous les documents ou objets d'une classe.

Parmi les re`gles qui de'finissent une boi^te de pre'sentation, certaines
peuvent faire re'fe'rence a` une autre boi^te de pre'sentation (par exemple dans
leurs re`gles de positionnement). Si la boi^te de'signe'e est de'finie apre`s la
boi^te qui la de'signe, une instruction {\tt FORWARD} avec le nom de la
boi^te de'signe'e doit apparai^tre avant la de'signation.

\begin{verbatim}
                  'BOXES' SuiteBoites
     SuiteBoites = Boite < Boite > .
     Boite       ='FORWARD' IdentBoite ';' /
                   IdentBoite ':' SuiteReglesVues .
     IdentBoite  = NAME .
\end{verbatim}

\subsection{Pre'sentation des e'le'ments structure's}

Apre`s le mot cle' {\tt RULES}, le sche'ma de pre'sentation donne les re`gles
de pre'sentation a` appliquer aux e'le'ments dont les types sont de'finis dans
le sche'ma de structure et qui n'utilisent pas l'ensemble des re`gles par
de'faut, (voir page~\pageref{reglesdefaut}). En effet, on ne fait figurer
dans la section {\tt RULES} que les types d'e'le'ments auxquels ne
s'appliquent pas toutes les re`gles par de'faut.

Pour chaque type d'e'le'ment, on donne le nom du type, tel qu'il est de'fini
dans le sche'ma de structure, suivi de deux-points et de l'ensemble des re`gles
spe'cifiques a` ce type d'e'le'ment, c'est-a`-dire les re`gles qui diffe`rent
des re`gles par de'faut.

Le nom du type peut e^tre pre'ce'de' d'une e'toile, dans le cas particulier
ou le sche'ma de structure de'finit une inclusion sans expansion (ou avec
expansion partielle) de me^me
type qu'un e'le'ment du sche'ma (voir section~\ref{references}).

Dans le cas ou` il s'agit d'une paire de marques (voir section~\ref{paires}),
mais uniquement dans ce cas, le nom du type doit e^tre pre'ce'de' du mot cle'
{\tt First} ou {\tt Second}. Ce mot cle' indique alors si les re`gles qui
suivent doivent s'appliquer a` la premie`re ou la deuxie`me marque de la paire.

\begin{verbatim}
                   'RULES' SuitePresent
     SuitePresent = Present < Present > .
     Present      = [ '*' ] [ FirstSec ] IdentElem ':'
                    SuiteReglesVues .
     FirstSec     = 'First' / 'Second' .
\end{verbatim}

Un sche'ma de pre'sentation peut de'finir des re`gles de pre'sentation pour
les e'le'ments de base, de'finis implicitement dans les sche'mas de structure.
Avec la version anglaise du compilateur de sche'mas de pre'sentation,
les noms des types de base sont les me^mes que dans le langage S, mais ils
sont termine's par le suffixe {\tt \_UNIT}~: \\
{\tt TEXT\_UNIT}, {\tt PICTURE\_UNIT}, {\tt SYMBOL\_UNIT},
{\tt GRAPHICS\_UNIT}. \\
Avec la version franc,aise du compilateur, les types de base sont~: \\
{\tt TEXTE}, {\tt IMAGE}, {\tt SYMBOLE}, {\tt GRAPHIQUE}. \\
Quelle que soit la version du compilateur utilise'e, les noms des types de
base sont e'crits en majuscules.

\subsection{Pre'sentation des attributs logiques}
\label{presattributs}

Apre`s le mot cle' {\tt ATTRIBUTES}, tous les attributs qui entrai^nent une
modification de la pre'sentation de l'e'le'ment sur lequel ils portent doivent
e^tre mentionne's, avec les re`gles de pre'sentation correspondantes. Il s'agit
aussi bien des attributs globaux (qui peuvent porter sur tous les types
d'e'le'ments) que des attributs locaux (qui ne peuvent porter que sur certains
types d'e'le'ments).

On mentionne e'galement dans cette section tous les attributs
qui entrai^nent une modification sur les e'le'ments faisant partie du
sous arbre de l'e'le'ment sur lequel ils portent. La pre'sentation de
ces descendants peut e^tre modifie'e en fonction de la valeur de
l'attribut dont ils he'ritent, bien qu'ils ne le portent pas directement.

Pour chacun de ces attributs, on donne le nom de l'attribut suivi
e'ventuellement d'une indication de valeur et, obligatoirement, apre`s un
signe {\tt ':'}, d'un ensemble de re`gles qui peut se re'duire a` une seule
re`gle.

Lorsqu'il n'y a pas d'indication de valeur,
les re`gles sont applique'es a` tous les e'le'ments qui portent l'attribut,
quelle que soit sa valeur. Dans le cas ou` les re`gles ne doivent e^tre
applique'es que lorsque l'attribut prend certaine(s) valeur(s), ces valeurs
doivent e^tre indique'es. Un me^me attribut peut donc figurer plusieurs fois,
avec des indications de valeurs diffe'rentes. Toutefois, les attributs de type
re'fe'rence ne peuvent pas avoir d'indication de valeur, et de ce fait ils ne
peuvent apparai^tre qu'une fois dans la section {\tt ATTRIBUTES}.

Pour mentioner que les re`gles de pre'sentation de'crites portent sur
les descendants de l'e'le'ment, on
indique entre parenthe`ses, apre`s le nom de l'attribut, le type de
l'e'le'ment concerne' par ces re`gles. Ainsi les re`gles de
pre'sentation de l'attribut seront applique'es a` l'e'le'ment
portant l'attribut, s'il est du type indique', mais aussi a` tous ses descendants du type indique'.
Dans le cas ou` ce type est une paire de marques (voir section~\ref{paires}),
mais uniquement dans ce cas, le nom du type doit e^tre pre'ce'de' du mot cle'
{\tt First} ou {\tt Second}. Ce mot cle' indique alors si les re`gles qui
suivent doivent s'appliquer a` la premie`re ou la deuxie`me marque de la paire.
Si ces re`gles doivent s'appliquer a` plusieurs types d'e'le'ments
diffe'rents, il faut les re'pe'ter pour chaque type d'e'le'ment.

Selon le type de l'attribut, les valeurs auxquelles correspondent les re`gles
sont indique'es de fac,on diffe'rente~:
\begin{description}
\item{attribut nume'rique :}
Si les re`gles ne doivent s'appliquer que pour une valeur, le nom de l'attribut
est suivi du signe {\tt '='} et de cette valeur.
Si les re`gles doivent s'appliquer pour toutes les valeurs infe'rieures (resp.
supe'rieures) a` une valeur seuil, celle-ci exclue, le nom de l'attribut est
suivi du signe {\tt '<'} (resp. {\tt '>'}) et de la valeur seuil.
Si les re`gles doivent s'appliquer pour un intervalle de valeurs, le nom de
l'attribut est suivi du mot {\tt 'IN'} et des deux bornes de l'intervalle
entre crochets et se'pare'es par deux points {\tt '..'}. Dans ce dernier
cas, les re`gles s'appliquent e'galement quand l'attribut prend pour
valeur les bornes de l'intervalle.

La valeur seuil de comparaison peut e^tre la valeur d'un attribut
porte'e par un e'le'ment ascendant. Dans ce cas, au lieu de spe'cifier une
constante on donne le nom d'un attribut. Si la re`gle ne doit
s'appliquer que lorsque la valeur de l'attribut est e'gale a` la
valeur de l'autre attribut pose' sur un e'le'ment ascendant on fait
suivre le nom de l'attribut du mot cle' {\tt EQUAL} et du nom de cet
attribut auquel on le compare.
Si la re`gle doit s'appliquer lorsque la valeur de l'attribut est
infe'rieure strictement a` la
valeur de l'attribut pose' sur l'e'le'ment ascendant on utilise le mot cle'
{\tt LESS}. 
Pour appliquer la re`gle dans le cas ou` la valeur de l'attribut est
supe'rieure strictement a` celle de l'attribut pose' sur l'e'le'ment ascendant on
utilise le mot cle' {\tt GREATER}.
\item{attribut textuel :}
Si les re`gles ne s'appliquent que pour une valeur de l'attribut, le nom
de l'attribut est suivi du signe {\tt '='} et de la chai^ne qui repre'sente
la valeur, entre apostrophes.
\item{attribut re'fe'rence :}
Il n'y a jamais d'indication de valeur~; les re`gles s'appliquent quel que soit
l'e'le'ment de'signe' par l'attribut.
\item{attribut e'nume're' :}
Si les re`gles doivent s'appliquer pour une valeur particulie`re de l'attribut,
le nom de l'attribut est suivi du signe {\tt '='} et du nom de la valeur.
\end{description}

L'ordre dans lequel sont de'finies les re`gles associe'es a` un attribut
nume'rique est important. Lorsque plusieurs ensembles de re`gles peuvent e^tre
applique's, c'est le premier de'clare' qui est retenu.

Les re`gles concernant les attributs sont prioritaires sur les re`gles par
de'faut et les re`gles associe'es aux types des e'le'ments. Les re`gles des
attributs s'appliquent a` l'e'le'ment sur lequel porte l'attribut. Ce sont les
re`gles qui s'appliquent aux e'le'ments environnants (et notamment aux
descendants) qui de'terminent l'effet des re`gles des attributs sur
l'environnement (et notamment sur les e'le'ments terminaux de la structure).

\begin{verbatim}
                    'ATTRIBUTES' SuitePresAttr
     SuitePresAttr = PresAttr < PresAttr > .
     PresAttr      = IdentAttr [ '(' [ FirstSec ] IdentElem ')' ]
                     [ AttrRelation ] ':' SuiteReglesVues .
     IdentAttr     = NAME .
     AttrRelation  ='=' ValAttr /
                    '>' [ '-' ] ValeurMin /
                    '<' [ '-' ] ValeurMax /
                    'IN' '[' [ '-' ] BorneInf '..'
                    [ '-' ] BorneSup ']' /
                    'GREATER' IdentAttr /
                    'EQUAL' IdentAttr /
                    'LESS' IdentAttr .
     ValAttr       = [ '-' ] NumEgal / TexteEgal /
                     ValeurAttr .
     ValeurMin     = NUMBER .
     ValeurMax     = NUMBER .
     BorneInf      = NUMBER .
     BorneSup      = NUMBER.
     NumEgal       = NUMBER .
     TexteEgal     = STRING .
     ValeurAttr    = NAME .
\end{verbatim}

Dans les re`gles de pre'sentation associe'es a` un attribut nume'rique (et
uniquement dans ces re`gles), on peut utiliser le nom de l'attribut a` la
place d'une valeur nume'rique. C'est alors la valeur de l'attribut qui est
prise en compte dans l'application de la re`gle. Ainsi, l'attribut peut
repre'senter le rapport ou la diffe'rence de dimension entre deux boi^tes,
la hauteur ou la largeur d'une boi^te, la hauteur d'une zone ou` les
coupures de page sont interdites, la distance entre deux boi^tes,
la position d'un axe de re'fe'rence d'une boi^te, l'interligne, le renfoncement
de la premie`re ligne, la visibilite', la profondeur de recouvrement, ou encore
le corps des caracte`res.

Dans les re`gles de pre'sentation associe'es aux attributs re'fe'rences, il
est possible d'utiliser l'e'le'ment de'signe' par l'attribut comme boi^te de
re'fe'rence dans un positionnement ou un dimensionnement. Cet e'le'ment est
repre'sente' dans la re`gle de position ou de dimension par le mot cle'
{\tt Referred} (voir sections~\ref{position} et \ref{dimension}).

\begin{example}
Dans tous les sche'mas de structure, un attribut global Langue est de'fini
de la fac,on suivante~:

\begin{verbatim}
ATTR
     Langue = TEXT;
\end{verbatim}
On peut faire afficher le texte franc,ais en caracte`res romains et le texte
anglais en italique par les re`gles suivantes~:

\begin{verbatim}
ATTRIBUTES
     Langue = 'Fran\347ais' :
              Style : Roman;
     Langue = 'Anglais' :
              Style : Italics;
\end{verbatim}
Avec ces re`gles, lorsque l'utilisateur met l'attribut Langue avec la valeur
Anglais sur le re'sume' d'un document, toutes les chai^nes de caracte`res
(e'le'ments terminaux) contenues dans le re'sume' sont affiche'es en italique.
La re`gle {\tt Style} est pre'sente'e page~\pageref{style}.
\end{example}

\begin{example}
On de'finit dans le sche'ma de structure un attribut nume'rique qui repre'sente
l'importance de la partie de document sur laquelle il porte~:
\begin{verbatim}
ATTR
     Importance = INTEGER;
\end{verbatim}
Dans le sche'ma de pre'sentation, on traduit l'importance par le choix du corps
des caracte`res, avec les re`gles suivantes~:

\begin{verbatim}
ATTRIBUTES
     Importance < 2 :
              Size : 1;
     Importance IN [2..4] :
              Size : Importance;
     Importance = 10 :
              Size : 5;
     Importance > 4 :
              Size : 4;
\end{verbatim}
Le corps des caracte`res croit ainsi avec la valeur de l'attribut
Importance~; il prend la valeur de cet attribut lorsqu'elle est comprise
entre 2 et 4 (compris), il vaut 1 pour les valeurs infe'rieures de
l'importance et 4 pour les valeurs supe'rieures. Il y a un cas particulier~:
quand l'importance vaut 10 le corps est de 5. Ce cas doit bien e^tre place'
avant le cas {\tt Importance~>~4}, sinon ce serait la re`gle de ce cas qui
s'apliquerait en priorite' et le corps ne pourrait jamais e^tre supe'rieur a` 4.
\end{example}

\begin{example}
On de'finit dans le sche'ma de structure un e'le'ment liste pouvant
porter un attribut de'finissant le type de la liste (liste nume'rote'e
ou non) :
\begin{verbatim}
STRUCT
    liste (ATTR type_liste = enumeration, tiret)
         = LIST OF (item_liste = TEXT);
\end{verbatim}
Dans le sche'ma de pre'sentation on utilise l'attribut pose' sur
l'e'le'ment liste pour mettre soit un tiret soit un nume'ro devant
chaque e'le'ment de la liste :
\begin{verbatim}
ATTRIBUTES
   type_liste (item_liste) = enumeration :
        CreateBefore (BoiteNume'ro);
   type_liste (item_liste) = tiret :
        CreateBefore (BoiteTiret);
\end{verbatim}
\end{example}

\begin{example}
On de'finit dans le sche'ma de structure un attribut nume'rique global re'vision. On de'finit e'galement sur la racine du document un
attribut nume'rique re'vison\_document :
\begin{verbatim}
STRUCTURE Document
ATTR
    revision = INTEGER;
STRUCT
    Document (ATTR revison_document = INTEGER) =
        BEGIN
        Debut ;
        ...
        Fin ;
        END ;
...
\end{verbatim}
On souhaite que le sche'ma de pre'sentation indique par une barre de
re'vision dans la marge les e'le'ments dont l'attribut de re'vision a
une valeur e'gale a` l'attribut re'vision\_document de la racine et
indique par une e'toile dans la marge les e'le'ments dont l'attribut de
re'vision a` une valeur strictement infe'rieure a` l'attribut
re'vision\_document de la racine :
\begin{verbatim}
ATTRIBUTES
    revision EQUAL revision_document :
        CreateBefore (BarreDeRevision) ;
    revision LESS revision_document :
        CreateBefore (BoiteEtoile) ;
\end{verbatim}
\end{example}

\subsection{Re`gles de transmission de valeurs}

La dernie`re section d'un sche'ma de pre'sentation, qui est optionnelle,
sert a` de'finir la fac,on dont un document transmet certaines valeurs
a` ses sous-documents. Un sous-document est un document inclus sans
expansion ou avec expansion partielle (voir page~\pageref{inclusion}).
Le document principal peut en effet transmettre a` ses sous-documents
les valeurs de certains de ses compteurs ou le contenu textuel de certains
de ses e'le'ments, en fonction de leur type.

Les sous-documents rec,oivent ces valeurs dans des attributs qui doivent
e^tre de'finis dans leur sche'ma de structure comme des attributs locaux
de l'e'le'ment racine. Le type de ces attributs doit correspondre au type
de la valeur qu'ils rec,oivent~: attribut nume'rique pour recevoir la
valeur d'un compteur, attribut textuel pour recevoir le contenu d'un
e'le'ment.

Dans le sche'ma de structure du document principal, apparai^t a` la fin,
apre`s le mot cle' {\tt TRANSMIT}, une suite de re`gles de transmission.
Chaque re`gle commence par le nom du compteur a` transmettre ou du type
d'e'le'ment dont on veut transmettre le contenu textuel. Ce nom est suivi
du mot cle' {\tt To} et du nom de l'attribut du sous-document auquel la
valeur est transmise. La classe du sous-document est indique'e entre
parenthe`ses apre`s le nom de l'attribut. La re`gle de transmission se
termine par un point-virgule.

\begin{verbatim}
     SuiteTransmit =  Transmit < Transmit > .
     Transmit      =  TypeOuCompteur 'To' AttrExterne
                      '(' IdentElem ')' ';' .
     TypeOuCompteur=  IdentCompteur / IdentElem .
     AttrExterne   =  NAME .
\end{verbatim}

\begin{example}

On de'finit une classe de documents Livre et une classe Chapitre, un livre
incluant des chapitres. Leurs sche'mas de structure sont les suivants~:

\begin{verbatim}
STRUCTURE Livre
STRUCT
   Livre = BEGIN
           Titre = Text;
           Corps = LIST OF (Chapitre INCLUDED);
           END;
   ...

STRUCTURE Chapitre
STRUCT
   Chapitre (ATTR NumeroPremPage = Integer;
                  NumeroChapitre = Integer;
                  TitreCourant   = Text) =
           BEGIN
           TitreChapitre = Text;
           ...
           END;
   ...
\end{verbatim}

Dans le sche'ma de pre'sentation des livres, on de'finit un compteur de
chapitre et un compteur de pages. Pour transmettre a` chaque chapitre la
valeur des trois attributs porte's par leur racine, on e'crit les
re`gles de transmission suivantes~:

\begin{verbatim}
PRESENTATION Livre;
VIEWS
   Texte_integral;
COUNTERS
   CptChapitre: Rank of Chapitre;
   CptPage: Rank of Page(TexteIntegral);
...
TRANSMIT
   CptPage TO NumeroPremPage(Chapitre);
   CptChapitre TO NumeroChapitre(Chapitre);
   Titre TO TitreCourant(Chapitre);
END
\end{verbatim}

Ainsi, chaque chapitre inclus dans un livre pourra nume'roter ses pages
en fonction des nume'ros de pages du livre, faire apparai^tre devant les
nume'ros de sections le nume'ro du chapitre dans le livre ou` il est
inclus ou re'pe'ter en haut des pages paires le titre du livre.
\end{example}

\subsection{Re`gles de pre'sentation}

Que ce soit pour de'finir l'aspect d'une boi^te de pre'sentation ou
de mise en page, d'un type d'e'le'ment ou d'une valeur d'attribut,
dans tous les cas, l'ensemble de re`gles de pre'sentation a` appliquer
est de'fini de la me^me fac,on.

Un tel ensemble de re`gles est normalement compris entre les mot cle's
{\tt BEGIN} et {\tt END}, le mot cle' {\tt END} e'tant suivi d'un point-virgule.
Dans ce bloc, il y a d'abord la suite des re`gles qui s'appliquent a` la vue
principale, si les re`gles par de'faut (voir page~\pageref{reglesdefaut})
ne conviennent pas toutes. Puis viennent
les re`gles qui s'appliquent spe'cifiquement aux autres vues, avec une suite de
re`gles pour chaque vue dont les re`gles par de'faut ne sont pas satisfaisantes.
Si les re`gles par de'faut des vues non principales
conviennent, il n'y a pas de re`gles spe'cifiques pour ces vues.
Si on ne mentionne qu'une re`gle, toutes vues confondues, alors les
mots cle's {\tt BEGIN} et {\tt END} ne figurent pas.

Pour chaque vue on ne pre'cise que les re`gles qui diffe`rent des re`gles
par de'faut de la vue, de sorte que, pour certaines vues (ou me^me toutes),
il est possible qu'il n'y ait pas de re`gle spe'cifique.

\label{instrin}
Les re`gles spe'cifiques a` une vue non principale sont introduites par le
mot {\tt IN}, suivi du nom de la vue. Les re`gles concernant cette vue
suivent, de'limite'es par les mots cle's {\tt BEGIN} et {\tt END}, ou sans
ces deux mots cle's s'il n'y a qu'une re`gle.

{\bf Note~:} le nom de vue qui suit le mot cle' {\tt IN} ne doit pas e^tre
celui de la vue principale, puisque les re`gles concernant cette vue sont
regroupe'es avant les re`gles concernant les autres vues.

A` l'inte'rieur de chacun de ces blocs de re`gles concernant une vue
(principale ou non), il peut y avoir encore d'autres blocs de'limite's
par les me^mes mots cle's {\tt BEGIN} et {\tt END}, chacun de ces
blocs regroupant les re`gles qui, dans la vue concerne'e, ne peuvent
s'appliquer que lorsqu'une condition particulie`re est satisfaite.
Chacun de ces blocs est donc pre'ce'de' par une condition introduite
par le mot cle' {\tt IF}. S'il un tel bloc conditionnel ne comporte
qu'une re`gle, les mots cle's {\tt BEGIN} et {\tt END} peuvent e^tre
omis.

Bien que la syntaxe autorise n'importe quelle re`gle de presentation
dans un bloc conditionnel, seules les re`gles de cre'ation (voir
section~\ref{creation}) sont autorise'es apre`s n'importe quelle
condition et seules les conditions {\tt Within} et celles qui portent
sur le type des elements peuvent contro^ler
n'importe quelle re`gle. De plus, les re`gles suivantes ne peuvent
e^tre pre'ce'de'es d'aucune condition:
{\tt PageBreak, LineBreak, Inline, Gather}.

Pour une vue, les re`gles qui s'appliquent sans aucune condition doivent
figurer avant le premier bloc de re`gles conditionnelles. Si certaines
re`gles doivent e^tre applique'es seulement si aucune des conditions
spe'cifie'es n'est satisfaite, elles sont regroupe'es dans un bloc
introduit par le seul mot cle' {\tt Otherwise}, et ce bloc doit apparai^tre
apre`s le dernier bloc conditionnel concernant la me^me vue.

\begin{verbatim}
     SuiteReglesVues ='BEGIN' < ReglesEtCond > < ReglesVue >
                      'END' ';' /
                       ReglesVue / ReglesCond / Regle .
     ReglesEtCond    = ReglesCond / Regle .
     ReglesVue       ='IN' IdentVue SuiteReglesCond .
     SuiteReglesCond ='BEGIN' < ReglesEtCond > 'END' ';' /
                       ReglesCond / Regle .
     ReglesCond      = RegleCond < RegleCond >
                      [ 'Otherwise' SuiteRegles ] .
     RegleCond       = 'IF' SuiteCondition SuiteRegles .
     SuiteRegles     ='BEGIN' Regle < Regle > 'END' ';' /
                       Regle .
\end{verbatim}

\begin{example}
Pour que le titre d'un rapport soit visible
dans la vue principale et invisible dans la table des matie`res et dans
la vue des formules, on donne l'ensemble des re`gles de pre'sentation de la
vue principale et une seule re`gle, qui supprime la visibilite', pour les
deux autres vues (la re`gle {\tt Visibility} est pre'sente'e
page~\pageref{visib})~:

\begin{verbatim}
Titre : BEGIN
        Visibility : 1;
        ...    {Autres regles pour la vue principale}
        IN Table_des_matieres
           Visibility : 0;
        IN Formules
           Visibility : 0;
        END;
\end{verbatim}
\end{example}

\subsection{Conditions d'application des re`gles de pre'sentation}

Plusieurs conditions peuvent s'appliquer aux re`gles de
pre'sentation. Cela permet de n'appliquer certaines re`gles de pre'sentation
que dans certains cas. Les conditions peuvent porter sur la position
structural de l'e'le'ment concerne' par la re`gle.
Elles peuvent concerner la pre'sence ou le type des refe'rences ou des
attributs, le type de page, le fait que l'e'le'ment soit vide ou non.
Elles peuvent e'galement porter sur la valeur d'un compteur.

Il est possible de spe'cifier plusieurs conditions, qui doivent
toutes e^tre ve'rifie'es pour que les re`gles de pre'sentation soient
applique'e.

Un ensemble de conditions d'application de re`gle est indique'e par le mot cle' {\tt IF}.
Ce mot est suivi de la suite des conditions e'le'mentaires, se'pare'es les unes des autres par le mot cle'
{\tt AND}. Chacune des conditions est indique'e par un mot cle' qui de'finit
le type de condition. Dans certains cas, ce mot cle' peut e^tre est suivi
d'autres e'le'ments qui pre'cisent la condition.

Une condition e'le'mentaire peut e^tre ne'gative~; elle est alors pre'ce'de'e
du mot cle' {\tt NOT}.

Dans le cas ou` il s'agit d'un e'le'ment re'fe'rence ou d'un attribut
re'fe'rence, une condition e'le'mentaire peut aussi porter sur l'e'le'ment
de'signe' par cette re'fe'rence. On utilise pour cela le mot cle' {\tt Target}
place' avant le mot cle' qui identifie le type de la condition a` appliquer
a` cet e'le'ment re'fe'rence'.

\begin{verbatim}
     RegleCond      = 'IF' SuiteCondition SuiteRegles .
     SuiteCondition = Condition < 'AND' Condition > .
     Condition      = [ 'NOT' ] [ 'Target' ] ConditionElem .
     ConditionElem  ='First' / 'Last' /
		      [ 'Immediately' ] 'Within' [ NbParent ]
                                     IdentElem [ StructExt ]/
                      IdentElem /
                     'Referred' / 'FirstRef' / 'LastRef' /
                     'ExternalRef' / 'InternalRef' / 'CopyRef' /
                     'AnyAttributes' / 'FirstAttr' / 'LastAttr' /
                     'UserPage' / 'StartPage' / 'ComputedPage' /
                     'Empty' /
                     '(' [ MinMax ] CounterName CondCompteur ')' /
                      CondPage '(' IdentCompteur ')' .
     NbParent       = [ InfSup ] NParent .
     InfSup         = '>' / '<' .
     NParent        = NUMBER.
     StructExt      = '(' IdentElem ')' .
     CondCompteur   ='<' MaxCptVal / '>' MinCptVal /
                     '=' EqCptVal / 
                     'IN' '[' ['-'] MinCptInter '.' '.'
                      ['-'] MaxCptInter ']' .
     CondPage       ='Even' / 'Odd' / 'One' .
     MaxCptVal      = NUMBER .
     MinCptVal      = NUMBER .
     EqCptVal       = NUMBER .
     MaxCptInter    = NUMBER .
     MinCptInter    = NUMBER .
\end{verbatim}

\subsubsection{Conditions sur la position de l'e'le'ment dans la structure
logique}

La condition peut porter sur la position de l'e'le'ment dans l'arbre de la
structure logique du document. On peut ainsi tester si l'e'le'ment est le
premier ({\tt First}) ou le dernier ({\tt Last}) parmi ses fre`res, ou s'il
n'est pas le premier ({\tt NOT First}) ou pas le dernier ({\tt NOT Last}).
Ces conditions ne peuvent contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

On peut e'galement tester si l'e'le'ment concerne' par la condition est
contenu dans un e'le'ment d'un type donne' ({\tt Within}) ou s'il ne l'est
pas ({\tt NOT Within}). Le type en question doit suivre le mot cle'
{\tt Within}. Ce type peut e^tre de'fini dans un autre sche'ma de structure
que celui auquel correspond le sche'ma de pre'sentation. Le nom du type
doit alors e^tre suivi, entre parenthe`ses, du nom de sche'ma de structure
ou` ce type est de'fini.

Si le mot {\tt Within} est pre'ce'de' de {\tt Immediately},
la condition n'est satisfaite que si le {\em pe`re} de l'e'le'ment concerne'
par la condition est du type indique'. Si le mot {\tt Immediately} est absent,
la condition est satisfaite si n'importe quel {\em ascendant} de l'e'le'ment
est du type indique'.

Un entier $n$ peut apparai^tre entre le mot {\tt Within} et le type.
Il indique le nombre d'ascendants du type indique' qui doivent e^tre
pre'sents pour que la condition soit satisfaite. Si le mot cle'
{\tt Immediately} est e'galement pre'sent, il faut alors que les $n$
ascendants imme'diats de l'e'le'ment soient tous du type indique'.
La valeur de $n$ doit e^tre positive ou nulle. Elle peut e^tre pre'ce'de'e
du signe {\tt <} ou {\tt >} pour indiquer un nombre maximum ou minimum
d'ascendants. A` de'faut de ces signes, la condition n'est satisfaite que
s'il existe exactement $n$ ascendants. L'absence du nombre $n$ est
interpre'te'e comme > 0.

Si la condition s'applique a` des re`gles de pre'sentation associe'es a`
un attribut, c'est a` dire dans la partie {\tt ATTRIBUTES} du sche'ma de
pre'sentation), la condition peut e^tre simplement constitue'e du nom
d'un type d'e'le'ment. Les re`gles de pre'sentation s'appliquent alors
seulement si l'attribut est porte' par un e'le'ment du type indique'.
Le nom de type peut e^tre pre'ce'de' de {\tt NOT} pour indiquer que
les re`gles de pre'sentation ne s'applquent que si le type de l'e'le'ment
n'est pas celui indique'.

\subsubsection{Conditions sur les re'fe'rences}

Les re'fe'rences peuvent e^tre prises en compte dans les conditions, qui
peuvent porter sur le fait que l'e'le'ment, ou l'un de ses ascendants, est
de'signe' par au moins une re'fe'rence ({\tt Referred}) ou par aucune
({\tt NOT Referred}).

Si l'e'le'ment ou l'attribut auquel est associe' la
condition est une re'fe'rence, la condition peut porter sur le fait qu'il
s'agit de la premie`re re'fe'rence a` l'e'le'ment de'signe' ({\tt FirstRef})
ou de la dernie`re ({\tt LastRef}) ou encore d'une re'fe'rence qui de'signe
un e'le'ment appartenant a` un document diffe'rent ({\tt ExternalRef}) ou
au me^me document ({\tt InternalRef}).

La condition peut aussi porter sur la fait que l'e'le'ment est une
copie par inclusion voir page~\pageref{inclusion}). Ceci est note'
({\tt CopyRef}).

Comme toutes les conditions, les conditions sur les re'fe'rences peuvent
e^tre inverse'es par le mot cle' {\tt NOT}.
Ces conditions ne peuvent contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

\subsubsection{Conditions sur les attributs logiques}

La condition peut porter sur la pre'sence ou l'absence
d'attributs associe's a` l'e'le'ment, quels que soient ces attributs
et leurs valeurs. C'est le mot cle' {\tt AnyAttributes} qui exprime cette
condition.

Si la condition apparai^t dans les re`gles de pre'sentation d'un attribut,
les mots cle's {\tt FirstAttr} et {\tt LastAttr} peuvent e^tre utilise's
pour indiquer que les re`gles ne doivent e^tre applique'es que si cet
attribut est le premier attribut porte' par l'e'le'ment ou que si
c'est le dernier. Ces conditions peuvent aussi e^tre inverse'es par {\tt NOT}.
Ces conditions ne peuvent contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

Il est e'galement possible de n'appliquer certaines re`gles de
pre'sentation que lorsque l'e'le'ment traite' ou l'un de ses ascendants porte
un certain attribut avec e'ventuellement une certaine valeur. Ceci se fait
dans la section {\tt ATTRIBUTES} du sche'ma de pre'sentation (voir
section~\ref{presattributs}).

\subsubsection{Conditions sur les sauts de page}

Le type de base saut de page (et uniquement ce type) peut
utiliser les conditions suivantes~:\\
{\tt ComputedPage}, {\tt StartPage} et {\tt UserPage}.
La condition {\tt ComputedPage} indique qu'il faut appliquer la (ou les)
re`gle(s) de pre'sentation si le saut de page a e'te' calcule'
automatiquement par Thot~; la condition {\tt StartPage} 
si le saut de page est engendre' en de'but d'e'le'ment par une re`gle
{\tt Page}; et la
condition {\tt UserPage} si le saut de page
a e'te' inse're' par l'utilisateur.

Ces conditions ne peuvent contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

\subsubsection{Conditions sur le contenu de l'e'le'ment}

La condition peut porter sur le fait que l'e'le'ment est vide ou non.
Un e'le'ment qui n'a pas de descendants ou dont toutes les feuilles
sont vides est conside're' comme vide.
Cette condition s'exprime simplement par le mot cle' {\tt Empty}
e'ventuellement pre'ce'de' du mot {\tt NOT}.
Cette condition ne peut contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

\subsubsection{Conditions sur les compteurs}

On peut tester si un compteur vaut un, s'il a une valeur
paire ou impaire, s'il est e'gal, supe'rieur ou infe'rieur a` une
valeur donne'e ou s'il appartient a` un intervalle de valeurs. Ceci
est particulie`rement utile pour la cre'ation des boi^tes 
de haut et bas de page, qui ne sont pas les me^mes sur la premie`re page
ou les suivantes, sur les pages paires et les pages impaires.
Ces conditions ne peuvent contro^ler que des re`gles de cre'ation
(voir section~\ref{creation}).

Pour comparer la valeur d'un compteur a` une
valeur donne'e on indique entre
parenthe`ses le nom du compteur suivi du caracte`re {\tt =},
{\tt <} ou {\tt >} puis la valeur a` laquelle on veut comparer le
compteur.
Pour tester l'appartenance a` un intervalle on indique entre
parenthe`ses le nom du compteur suivi du mot cle' {\tt IN} et de la
de'finition entre crochets de l'intervalle.
Les mot cle's {\tt Even}, {\tt Odd} et {\tt One}
permettent de tester la valeur d'un compteur et sont suivis, entre
parenthe`ses, du nom du compteur a` tester.

La liste des conditions sur les compteurs est donc la suivante~:

\begin{description}
\item[ {\tt Even (Compt) :} ]la boi^te est cre'e'e seulement si le compteur a
une valeur paire.
\item[ {\tt Odd (Compt) :} ]la boi^te est cre'e'e seulement si le compteur a
une valeur impaire.
\item[ {\tt One (Compt) :} ]la boi^te est cre'e'e seulement si le compteur
vaut 1.
\item[ {\tt NOT One (Compt) :} ]la boi^te est cre'e'e, sauf si le compteur
vaut 1.
\item[ {\tt (Compt < Value) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur strictement infe'rieure a` Value.
\item[ {\tt (Compt > Value) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur strictement supe'rieure a` Value.
\item[ {\tt (Compt = Value) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur e'gale a` Value.
\item[ {\tt NOT (Compt = Value) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur diffe'rente de Value.
\item[ {\tt (Compt IN [MinValue..MaxValue]) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur appartenant a` l'intervalle MinValue, MaxValue,
bornes comprises.
\item[ {\tt NOT (Compt IN [MinValue..MaxValue]) :} ] la boi^te est cre'e'e seulement si le
compteur a une valeur n'appartenant pas a` l'intervalle MinValue, MaxValue,
bornes comprises.
\end{description}

Note : les conditions {\tt NOT Even} et {\tt NOT Odd} sont syntaxiquement
correctes mais peuvent e^tre exprime'es plus simplement par {\tt Odd}
et {\tt Even} respectivement.

\subsection{Une re`gle de pre'sentation}
\label{reglepres}

Une re`gle de pre'sentation de'finit soit un parame`tre de pre'sentation,
soit une fonction de pre'sentation.
Les parame`tres sont~:

\begin{itemize}
\item la position des axes de re'fe'rence vertical et horizontal de la boi^te,
\item la position de la boi^te par rapport aux autres boi^tes,
\item la hauteur et la largeur de la boi^te, avec les exceptions de de'bordement
\item les caracte'ristiques des lignes contenues dans la boi^te~: interligne,
    renfoncement de la premie`re ligne, justification, coupure des mots en fin
    de ligne,
\item les conditions de coupure de la boi^te,
\item le degre' de visibilite' de la boi^te,
\item les caracte'ristiques des caracte`res contenus dans la boi^te~: taille,
    police, style, soulignement,
\item la profondeur de la boi^te parmi les boi^tes superpose'es.
\item les caracte'ristiques des e'le'ments graphiques contenus dans la boi^te~:
    style et e'paisseur des traits, motif de remplissage des surfaces,
\item les couleurs dans lesquelles sont affiche's ou imprime's les textes,
    graphiques, images et symboles contenus dans la boi^te,
\item le contenu de la boi^te, pour les boi^tes de pre'sentation uniquement.
\end{itemize}
Les fonctions de pre'sentation sont~:
\label{fonctpres}

\begin{itemize}
\item la cre'ation d'une boi^te de pre'sentation,
\item le mode de mise en lignes ou en pages,
\item la copie d'une autre boi^te.
\end{itemize}

Pour chaque boi^te et dans chaque vue, tous les parame`tres de pre'sentation
sont de'finis une fois et une seule, soit explicitement, soit par les re`gles
par de'faut (voir page~\pageref{reglesdefaut}). En revanche, les fonctions
de pre'sentation ne sont pas
obligatoires ou peuvent figurer plusieurs fois pour le me^me e'le'ment.
Par exemple, un e'le'ment peut cre'er plusieurs boi^tes de pre'sentation.
Un autre e'le'ment peut n'utiliser aucune fonction de pre'sentation.

Chaque re`gle de'finissant un parame`tre de pre'sentation commence par un
mot cle' suivi de deux-points. Le mot cle' indique le parame`tre concerne' par
la re`gle. Suivant ce mot cle', le reste de la re`gle varie. Toutes
les re`gles sont termine'es par un point-virgule.

\begin{verbatim}
     Regle     = ParamPres ';' / FonctPres ';' .
     ParamPres ='VertRef' ':' PositionHoriz /
                'HorizRef' ':' PositionVert /
                'VertPos' ':' PosV /
                'HorizPos' ':' PosH /
                'Height' ':' Dimension /
                'Width' ':' Dimension /
                'VertOverflow' ':' Booleen /
                'HorizOverflow' ':' Booleen /
                'LineSpacing' ':' DistanceHerit /
                'Indent' ':' DistanceHerit /
                'Adjust' ':' AjusteHerit /
                'Justify' ':' HeritageBool /
                'Hyphenate' ':' HeritageBool /
                'PageBreak' ':' Booleen /
                'LineBreak' ':' Booleen /
                'InLine' ':' Booleen /
                'NoBreak1' ':' DistAbs /
                'NoBreak2' ':' DistAbs /
                'Gather' ':' Booleen /
                'Visibility' ':' NombreHerit /
                'Size'  ':' TailleHerit /
                'Font' ':' NomHerit /
                'Style' ':' StyleHerit /
                'Underline' ':' SouligneHerit /
                'Thickness' ':' EpaisseurHerit /
                'Depth' ':' NombreHerit /
                'LineStyle' ':' StyleTraitHerit /
                'LineWeight' ':' DistanceHerit /
                'FillPattern' ':' NomHerit /
                'Background' ':' NomHerit /
                'Foreground' ':' NomHerit .
                'Content' ':' VarConst .
     FonctPres = Creation '(' IdentBoite ')' /
                'Line' /
                'NoLine' /
                'Page' '(' IdentBoite ')' /
                'Copy' '(' BoiteTypeACopier ')' .
\end{verbatim}

\subsection{Axes des boi^tes}

La position des axes me'dians {\tt VMiddle} et {\tt HMiddle} par rapport a`
leur boi^te est toujours calcule'e automatiquement en fonction de la hauteur
et de la largeur de la boi^te et n'est donc pas pre'cise'e
par des re`gles de pre'sentation. Dans le sche'ma de pre'sentation, ces axes
me'dians ne sont utilise's que pour positionner leur boi^te par
rapport a` une autre, en spe'cifiant la distance entre l'axe me'dian et
un axe ou un co^te' d'une autre boi^te (voir les positionnements relatifs
page~\pageref{position}).

Les axes de re'fe'rence d'une boi^te sont eux aussi utilise's
pour positionner la boi^te par rapport a` une autre, mais, au contraire
des axes me'dians, le sche'ma de pre'sentation doit expliciter leur position,
soit par rapport a` un co^te' ou a` l'axe me'dian de la boi^te elle-me^me,
soit par rapport a` un co^te' ou un axe d'une boi^te incluse.

Seules les boi^tes des e'le'ments de base ont des axes de re'fe'rence pre'de'finis.
Pour les boi^tes chai^nes de caracte`res, l'axe de re'fe'rence horizontal
est la ligne de base des caracte`res (la ligne qui passe par le bas des
lettres majuscules, Q excepte') et l'axe de re'fe'rence vertical est sur
le co^te' gauche du premier caracte`re de la chai^ne.

Les positions des axes de re'fe'rence d'une boi^te sont de'finies par les
re`gles {\tt VertRef} et {\tt HorizRef} qui pre'cisent la distance entre
l'axe de re'fe'rence et un axe ou un co^te' paralle`le de la me^me boi^te ou d'une
boi^te incluse (voir page~\pageref{distance} comment spe'cifier cette
distance).

\begin{verbatim}
               'VertRef' ':' PositionHoriz
               'HorizRef' ':' PositionVert
\end{verbatim}

\begin{example}
Si dans le sche'ma de structure des formules la fraction est
de'finie par

\begin{verbatim}
Fraction = BEGIN
           Numerateur   = Expression;
           Denominateur = Expression;
           END;
\end{verbatim}
on peut positionner l'axe de re'fe'rence horizontal de la fraction sur le haut
du de'nominateur par la re`gle~:

\begin{verbatim}
Fraction :
     BEGIN
     HorizRef : Enclosed Denominateur . Top;
     ...
     END;
\end{verbatim}
Pour placer l'axe de re'fe'rence horizontal d'une colonne sur son milieu~:

\begin{verbatim}
Colonne :
     BEGIN
     HorizRef : * . HMiddle;
     ...
     END;
\end{verbatim}
\end{example}


\subsection{Unite's de distance}
\label{unites}

Des distances et dimensions interviennent dans de nombreuses re`gles d'un
sche'ma de pre'sentation, notamment dans les re`gles  de positionnement
({\tt VertPos, HorizPos}), dans les re`gles de'finissant les axes de re'fe'rence
des boi^tes ({\tt VertRef, HorizRef}), dans les re`gles de dimensionnement des
boi^tes ({\tt Height, Width}), dans les re`gles de'finissant les lignes
({\tt LineSpacing, Indent}), dans les re`gles indiquant les conditions
de coupure de page ({\tt NoBreak1, NoBreak2}) et dans les re`gles
spe'cifiant l'e'paisseur des traits ({\tt LineWeight}).

Dans toutes ces re`gles, la distance ou la dimension peut e^tre exprime'e
\begin{itemize}
   \item soit dans une unite' relative, qui de'pend de la taille des
         caracte`res de la police courante~: cadratin ou hauteur du {\it x},
   \item soit dans une unite' absolue~: centime`tre, millime`tre, pouce,
         point typographique, pica ou pixel d'e'cran.
\end{itemize}
Les unite's peuvent e^tre choisies sans contrainte. Ainsi il est
possible d'utiliser dans une re`gle l'unite' relative, dans la suivante le
centime`tre et dans une autre le point typographique.

Le choix de l'unite' permet de fixer de fac,on rigide l'aspect graphique
des documents, en choisissant les unite's absolues, ou au contraire d'autoriser
des changements d'e'chelle, en choisissant les unite's relatives. L'e'diteur
permet de changer dynamiquement la valeur des unite's relatives, ce qui, pour
toutes les boi^tes qui utilisent ces unite's, fait changer a` la fois, et dans
les me^mes proportions, les tailles des caracte`res et e'le'ments graphiques
contenus, les distances entre boi^tes et leurs dimensions.

\label{distance}
Une distance ou une dimension est note'e par un nombre suivi ou non d'une
indication d'unite'. S'il s'agit d'une unite' relative, cette indication
d'unite' est absente, et le nombre est conside're' comme un nombre de hauteurs
de caracte`re (cadratin) de la police courante. L'unite' est indique'e par un
mot cle' se'pare' du nombre par au moins un espace :

\begin{itemize}
   \item {\tt em} : cadratin, hauteur de la police de caracte`res,
   \item {\tt ex} : hauteur du caracte`re 'x',
   \item {\tt cm} : centime`tre,
   \item {\tt mm} : millime`tre,
   \item {\tt in} : pouce (1 in = 2.54 cm),
   \item {\tt pt} : point typographique (1 pt = 1/72 in),
   \item {\tt pc} : pica (1 pc = 12 pt),
   \item {\tt px} : pixel.
\end{itemize}

Quelle que soit l'unite' choisie, relative ou absolue, le nombre n'est pas
ne'cessairement un entier et peut e^tre exprime' en virgule fixe, la
``virgule'' e'tant note'e par un point.

Si la distance apparai^t dans une re`gle de pre'sentation d'un attribut
nume'rique, le nombre peut e^tre remplace' par le nom de l'attribut. Dans ce
cas, c'est la valeur de l'attribut qui est utilise'e. Avec un nom d'attribut,
il n'y a e'videmment pas de partie de'cimale, mais on peut spe'cifier une
unite'. Le choix des unite's est toutefois limite' a` la hauteur de la
police (em) ou du 'x' (ex), au point typographique (pt), et au pixel (px).

\begin{verbatim}
     Distance      = [ Signe ] DistAbs .
     Signe         ='+' / '-' .
     DistAbs       = PartieEntiereA [ '.' PartieDecimale ]
                     [ Unite ].
     PartieEntiereA= PartieEntiere / IdentAttr .
     PartieEntiere = NUMBER .
     PartieDecimale= NUMBER .
     Unite         ='em' / 'ex' / 'cm' / 'mm' / 'in' / 'pt' /
                    'pc' / 'px' / '%' .
\end{verbatim}

\begin{example}
Pour une boi^te ayant une hauteur de 10,5 centime`tres et une largeur de
5,3 cadratins, on e'crit les re`gles~:
\begin{verbatim}
Height : 10.5 cm;
Width : 5.3;
\end{verbatim}
\end{example}

\subsection{Positionnements relatifs}
\label{position}

Le positionnement des boi^tes utilise les huit axes et co^te's, les co^te's
e'tant en ge'ne'ral utilise's pour de'finir des juxtapositions (verticales ou
horizontales) de boi^tes, les axes me'dians pour de'finir des centrages,
et les axes de re'fe'rence des alignements.

Deux re`gles permettent de positionner une boi^te par rapport aux autres.
La re`gle {\tt VertPos} positionne la boi^te verticalement, la re`gle
{\tt HorizPos} la positionne horizontalement. Il est possible que la
position d'une boi^te soit entie`rement de'termine'e par les autres boi^tes
positionne'es par rapport a` elle. Dans ce cas, la position est implicite
et le mot {\tt nil} permet de ne pas spe'cifier de re`gle de positionnement.
Dans les autres cas, il faut donner une re`gle explicite, ou`
on indique l'axe ou le co^te' qui de'finit la position de la boi^te,
puis un signe {\tt =}, et la distance entre cet axe ou co^te' et un axe ou
co^te' paralle`le d'une autre boi^te, appele'e boi^te de re'fe'rence.
La boi^te de re'fe'rence est la boi^te par rapport a` laquelle se positionne
la boi^te concerne'e par la re`gle de positionnement.

\begin{verbatim}
                'VertPos' ':' PosV
                'HorizPos' ':' PosH
     PosH     = 'nil' / AxeVert '=' PositionHoriz
                [ 'UserSpecified' ].
     PosV     = 'nil' / AxeHoriz '=' PositionVert
                [ 'UserSpecified' ].
     AxeVert  = 'Left' / 'VMiddle' / 'VRef' / 'Right' .
     AxeHoriz = 'Top' / 'HMiddle' / 'HRef' / 'Bottom' .
\end{verbatim}

La boi^te de re'fe'rence est une boi^te proche~: englobante, englobe'e ou soeur.
Dans le cas d'une re`gle associe'e a` un attribut de type re'fe'rence (et
uniquement dans ce cas), ce peut e^tre une boi^te de l'e'le'ment de'signe' par
l'attribut. La boi^te de re'fe'rence peut e^tre soit une boi^te de pre'sentation
pre'alablement de'finie dans la section {\tt BOXES} du sche'ma, et cre'e'e par
une fonction de cre'ation, soit la boi^te associe'e a` un e'le'ment structure'.

La position structurale de la boi^te de re'fe'rence par rapport a` la
boi^te concerne'e par la re`gle est indique'e par un mot cle'~: {\tt Enclosing},
{\tt Enclosed}, ou, s'il s'agit d'une boi^te soeur,
{\tt Previous} ou {\tt Next}. Pour les attributs re'fe'rences, ou les boi^tes
de pre'sentation cre'e'es par un attribut re'fe'rence, on peut en plus
utiliser {\tt Referred}, qui de'signe l'e'le'ment pointe' par l'attribut.
Dans une boi^te de pre'sentation, on peut aussi utiliser le mot cle'
{\tt Creator}, qui de'signe la boi^te de l'e'le'ment qui cre'e cette boi^te
de pre'sentation. On peut enfin utiliser le mot cle' {\tt Root}, pour
de'signer la boi^te de l'e'le'ment racine.

Dans le cas ou` le mot cle' est ambigu, il est suivi d'un nom de type ou
de boi^te de pre'sentation qui le`ve l'ambigui"te' (cette possibilite' ne
concerne pas les mots cle's {\tt Creator} et {\tt Root} qui ne sont jamais
ambigus).
Si ce nom de type ou de boi^te n'est pas indique', c'est la premie`re boi^te
rencontre'e qui sera prise comme boi^te de re'fe'rence. Il est aussi possible
d'utiliser simplement un nom de type ou de boi^te de pre'sentation, sans le
faire pre'ce'der d'un mot cle'. Il s'agit alors d'un e'le'ment ou d'une
boi^te soeur de ce type.
Si le nom de boi^te ou de type est pre'ce'de' du mot {\tt NOT}, il s'agit
alors d'une boi^te d'un type quelconque, a` l'exclusion du type indique'.
A la place du nom de type ou de boi^te, on peut faire figurer le mot cle'
{\tt AnyElem} ou le mot cle' {\tt AnyBox}, qui repre'sentent respectivement
n'importe quelle boi^te d'un e'le'ment structure' ou n'importe quelle
boi^te de pre'sentation.
Dans le cas d'un nom de type, ce nom peut e^tre pre'ce'de' d'une e'toile,
pour lever l'ambigui"te' dans le cas particulier ou` le sche'ma de structure
de'finit une inclusion sans expansion (ou avec expansion partielle)
de me^me type qu'un e'le'ment du sche'ma (voir section~\ref{references}).
Dans le cas ou` le nom de type est celui d'une paire de marques (voir
section~\ref{paires}), mais uniquement dans ce cas, le nom du type doit e^tre
pre'ce'de' du mot cle' {\tt First} ou {\tt Second}. Ce mot cle' indique alors
s'il s'agit de la premie`re ou la deuxie`me marque de la paire.

L'e'toile {\tt *} utilise'e seule permet de de'signer la boi^te
a` laquelle s'applique la re`gle (dans ce cas il est e'videmment inutile de
pre'ciser le type de la boi^te de re'fe'rence).

Les mots {\tt Enclosing} et {\tt Enclosed} peuvent e^tre utilise's quel
que soit le constructeur du type auquel est associe' la re`gle.
S'il s'applique a` l'e'le'ment repre'sentant tout le document,
{\tt Enclosing} de'signe la fene^tre ou la page
dans laquelle est affiche'e l'image du document pour la vue concerne'e
par la re`gle. Le nom de boi^te ou de type sans mot cle'
est utilise' pour les e'le'ments d'agre'gat et de'signe un autre e'le'ment du
me^me agre'gat. On peut aussi l'utiliser pour de'signer une boi^te de
pre'sentation ou de mise en page.
Les mots {\tt Previous} et {\tt Next} sont utilise's principalement pour les
e'le'ments de liste, mais ils peuvent aussi e^tre utilise's pour les e'le'ments
d'agre'gats.

Dans la re`gle de positionnement, la position structurale relative de la
boi^te de re'fe'rence est suivie, apre`s un point, du nom d'un axe ou d'un
co^te'.
Celui-ci indique le co^te' ou l'axe concerne' dans la boi^te de re'fe'rence.
Enfin vient la distance, qui indique la distance avec le co^te' ou l'axe
de la boi^te de re'fe'rence. Si cette distance doit e^tre nulle, elle
ne figure pas, sinon, c'est un nombre positif ou ne'gatif, le signe
n'e'tant obligatoire que pour les nombres ne'gatifs. Le signe tient compte
de l'orientation des axes de coordonne'es~: de haut en bas pour l'axe vertical
et de gauche a` droite pour l'axe horizontal. Ainsi une distance ne'gative
dans un positionnement vertical indique que le co^te' ou l'axe spe'cifie'
dans la re`gle est au-dessus du co^te' ou de l'axe de re'fe'rence.

La distance peut e^tre suivie du mot cle' {\tt UserSpecified} (me^me si
la distance est nulle et ne figure pas, le mot cle' {\tt UserSpecified}
peut e^tre utilise'). Il indique que lorsque l'e'le'ment auquel s'applique
la re`gle de positionnement sera cre'e', l'e'diteur demandera a` l'utilisateur
de choisir lui-me^me la distance, a` l'aide de la souris. Dans ce cas, la
distance indique'e dans la re`gle est une distance par de'faut qui est
propose'e a` l'utilisateur et qu'il peut modifier comme il le souhaite.
Le mot {\tt UserSpecified} peut e^tre utilise' soit dans la re`gle de position
verticale, soit dans la re`gle de position horizontale, soit dans les deux
re`gles.

\begin{verbatim}
     PositionVert  = Reference '.' AxeHoriz [ Distance ] .
     PositionHoriz = Reference '.' AxeVert [ Distance ] .
     Reference     ='Enclosing' [ NBoiteType ] /
                    'Enclosed' [ NBoiteType ] /
                    'Previous' [ NBoiteType ] /
                    'Next' [ NBoiteType ] /
                    'Referred' [ NBoiteType ] /
                    'Creator' /
                    'Root' /
                    '*' /
                     BoiteType .
     BoiteType     = IdentBoite /
                     [ '*' ] [ FirstSec ] IdentElem /
                    'AnyElem' / 'AnyBox' .
     NBoiteType    = [ 'NOT' ] BoiteType .
\end{verbatim}

\label{expos1}
\begin{example}
Si un rapport est de'fini par le sche'ma de structure suivant~:

\begin{verbatim}
Rapport = BEGIN
          Titre  = Text;
          Resume = Text;
          MotsCles = Text;
          ...
          END;
\end{verbatim}
on peut e'crire dans le sche'ma de pre'sentation~:

\label{exemplerapp}
\begin{verbatim}
Rapport : BEGIN
          VertPos  : Top = Enclosing . Top;
          HorizPos : Left = Enclosing . Left;
          ...
          END;
\end{verbatim}
Le rapport est ainsi place' dans le coin supe'rieur gauche de sa boi^te
englobante, qui est la fene^tre ou` le document est e'dite'.

\begin{verbatim}
Titre :   BEGIN
          VertPos  : Top = Enclosing . Top + 1;
          HorizPos : VMiddle = Enclosing . VMiddle;
          ...
          END;
\end{verbatim}
Le haut du titre est a` 1 ligne (une ligne a la hauteur des caracte`res du
titre) du haut du rapport, donc de la fene^tre d'e'dition. Le titre est centre'
horizontalement dans la fene^tre (voir figure~\ref{posdim}).

\begin{verbatim}
Resume :  BEGIN
          VertPos  : Top = Titre . Bottom + 1.5;
          HorizPos : Left = Enclosing . Left + 2 cm;
          ...
          END;
\end{verbatim}
Le haut du re'sume' est place' une ligne et demie en dessous du bas du titre et
il est de'cale' a` gauche de 2 centime`tres par rapport au bord de la fene^tre.
\end{example}

\label{expos2}
\begin{example}
On de'finit une structure logique Dessin qui contient des e'le'ments
graphiques~:

\begin{verbatim}
Dessin = LIST OF (ElemGraph = GRAPHICS);
\end{verbatim}

Pour que l'utilisateur puisse choisir librement, lors de leur cre'ation, la
position de chaque e'le'ment graphique, on e'crit les re`gles de pre'sentation
suivantes~:
\begin{verbatim}
ElemGraph =
   BEGIN
   VertPos : Top = Enclosing . Top + 1 cm UserSpecified;
   HorizPos: Left = Enclosing . Left UserSpecified;
   ...
   END;
\end{verbatim}
Ainsi, de`s qu'un e'le'ment graphique est cre'e', il est place' par de'faut
a` gauche du dessin, a` 1 cm du haut et, en de'plac,ant simplement la souris,
l'utilisateur peut le de'placer imme'diatement.

\end{example}

\subsection{Dimensions des boi^tes}
\label{dimension}

Les dimensions (hauteur et largeur) de chaque boi^te sont de'finies par les
deux re`gles {\tt Height} et {\tt Width}. Il y a trois types de dimensions~:
les dimensions fixes, relatives et e'lastiques.

\subsubsection{Dimensions fixes}

Une dimension fixe impose la hauteur ou la largeur de la boi^te
inde'pendemment des dimensions de toute autre boi^te. Elle est exprime'e
en unite's de distance (voir page~\pageref{unites}).
La distance peut e^tre suivie du mot cle' {\tt UserSpecified} qui indique
que lorsque l'e'le'ment auquel s'applique la re`gle de dimension sera cre'e',
l'e'diteur demandera a` l'utilisateur de choisir lui-me^me la dimension,
a` l'aide de la souris. Dans ce cas, la distance indique'e dans la re`gle
est une dimension par de'faut qui est propose'e a` l'utilisateur et
qu'il peut modifier comme il le souhaite. Le mot {\tt UserSpecified} peut
e^tre utilise' soit dans la re`gle {\tt Width}, soit dans la re`gle
{\tt Height}, soit dans les deux re`gles.

Une re`gle de dimension fixe peut se terminer par le mot cle' {\tt Min},
pour signifier que la valeur indique'e est un minimum et que, si le
contenu de la boi^te ne'cessite une plus grande dimension, c'est celle-ci
qui sera prise par la boi^te.

\begin{verbatim}
                'Height' ':' Dimension
                'Width' ':' Dimension
     Dimension = DistAbs [ 'UserSpecified' ]  [ 'Min' ] /
                 ...
\end{verbatim}

\begin{example}
Pour comple'ter l'exemple de la page~\pageref{expos2}, on autorise
l'utilisateur a` choisir librement dans un dessin la dimension de chaque
e'le'ment graphique, au moment de leur cre'ation~:

\begin{verbatim}
ElemGraph : BEGIN
            Width : 2 cm UserSpecified;
            Height : 1 cm UserSpecified;
            ...
            END;
\end{verbatim}

Ainsi, de`s qu'un e'le'ment graphique est cre'e', il est trace' par de'faut
avec une largeur de 2 cm et une hauteur de 1 cm et, en de'plac,ant simplement
la souris, l'utilisateur peut le retailler imme'diatement.
\end{example}

\begin{example}
On veut que le re'sume' des articles ait une hauteur de 5 cm de fac,on que
l'e'le'ment suivant, les mots cle's (dont la position verticale est de'finie
en fonction du bas de la boi^te re'sume'), soit a` une position fixe dans la
page. Cependant, si le re'sume' est particulie`rement long, on veut que sa
boi^te puisse de'passer les 5 cm. de haut et prenne la hauteur ne'cessaire
pour englober tout son contenu, ce qui a alors pour effet de de'caler les
mots cle's vers le bas, e'vitant ainsi un recouvrement des deux e'le'ments.
Pour obtenir ce comportement, on e'crit~:

\begin{verbatim}
Resume :   BEGIN
           Height : 5 cm Min;
           ...
           END;
MotsCles : BEGIN
           VertPos : Top = Resume . Bottom;
           ...
           END;
\end{verbatim}
\end{example}

\subsubsection{Dimensions relatives}

Une dimension relative permet de de'terminer la dimension d'une boi^te en
fonction de la dimension d'une autre boi^te, de la me^me fac,on qu'un
positionnement relatif place une boi^te par rapport a` une autre. La
boi^te qui sert de re'fe'rence est de'signe'e comme dans un
positionnement relatif. Elle est suivie d'un point et du mot cle' {\tt Height}
ou {\tt Width}, selon qu'on se re'fe`re a` sa hauteur ou a` sa largeur.
Vient ensuite le rapport entre la dimension que l'on de'finit et celle
de la boi^te de re'fe'rence. Ce rapport peut e^tre soit un pourcentage soit
une diffe'rence.

Un pourcentage est indique' par une e'toile (le symbole de la multiplication)
suivie par la valeur nume'rique du pourcentage (qui peut e^tre indiffe'remment
supe'rieure ou infe'rieure a` 100) et par le caracte`re {\tt \%}. Une diffe'rence
est simplement indique'e par une distance signe'e.

Si la re`gle apparai^t dans les re`gles de pre'sentation d'un attribut
nume'rique, la valeur du pourcentage peut e^tre remplace'e par le nom de
l'attribut. Dans ce cas, c'est la valeur de l'attribut qui est utilise'e comme
pourcentage. S'il s'agit d'une diffe'rence, la diffe'rence peut e^tre
exprime'e en fonction de l'attribut (voir page~\pageref{distance}).

Comme pour une dimension fixe, une re`gle de dimension relative peut se
terminer par le mot cle' {\tt Min}, pour signifier que
la dimension indique'e est un minimum et que, si le contenu de la boi^te
ne'cessite une plus grande dimension, c'est celle-ci qui sera prise par
la boi^te.

Un cas particulier de dimensionnement relatif est~:
\begin{verbatim}
Height : Enclosed . Height;
\end{verbatim}
ou
\begin{verbatim}
Width  : Enclosed . Width;
\end{verbatim}
qui signifie que la boi^te prend une hauteur (ou une largeur) telle qu'elle
englobe exactement toutes les boi^tes qu'elle contient, a` l'exception des
boi^tes qui ont une re`gle {\tt VertOverflow: Yes;} ou {\tt HorizOverflow:Yes;}.

{\bf Note :} les chai^nes de caracte`res (type {\tt TEXT\_UNIT}) doivent
ge'ne'ralement prendre pour largeur la somme des largeurs des caracte`res qui
les composent, ce qui s'exprime par la re`gle~:
\begin{verbatim}
TEXT_UNIT :
   Width  : Enclosed . Width;
\end{verbatim}
Si cette re`gle n'est pas la re`gle de largeur par de'faut, elle doit figurer
explicitement dans la section {\tt RULES} qui de'finit les re`gles de
pre'sentation des e'le'ments logiques.

\begin{verbatim}
                  'Height' ':' Dimension
                  'Width' ':' Dimension
     Dimension   = Reference '.' HautLarg [ Rapport ]
                   [ 'Min' ] / ...
     HautLarg    ='Height' / 'Width' .
     Rapport     ='*' RapportDimA '%' / Distance .
     RapportDimA = RapportDim / IdentAttr .
     RapportDim  = NUMBER .
\end{verbatim}

\begin{example}
Pour comple'ter l'exemple de la page~\pageref{expos1}, on peut indiquer que
le rapport prend la largeur de la fene^tre ou` on l'e'dite et la hauteur
ne'cessaire pour son contenu (cette hauteur peut e'videmment e^tre plus
grande que celle de la fene^tre)~:

\begin{verbatim}
Rapport : BEGIN
          Width : Enclosing . Width;
          Height : Enclosed . Height;
          ...
          END;
\end{verbatim}
Le titre occupe 60\% de la largeur du rapport (donc de la fene^tre) et est
de'coupe' sur cette largeur en lignes centre'es (voir la re`gle {\tt Line},
page~\pageref{regleline}) par les re`gles~:

\begin{verbatim}
Titre :   BEGIN
          Width : Enclosing . Width * 60%;
          Height : Enclosed . Height;
          Line;
          Adjust : VMiddle;
          ...
          END;
\end{verbatim}
Le re'sume' occupe toute la largeur de la fene^tre, a` l'exception de la marge
de 2 centime`tres qui a e'te' re'serve'e par la re`gle de positionnement
horizontal~:

\begin{verbatim}
Resume :  BEGIN
          Width : Enclosing . Width - 2 cm;
          Height : Enclosed . Height;
          ...
          END;
\end{verbatim}
L'ensemble de ces re`gles, ajoute'es aux re`gles de positionnement donne'es
page~\pageref{exemplerapp}, produisent l'agencement des boi^tes de la
figure~\ref{posdim}.

\begin{figure}
\begin{center}
\setlength{\unitlength}{1 mm}
\begin{picture}(100,54)
\thicklines
\multiput(0,0)(0,2){2}{\line(0,1){1}}
\multiput(15,0)(0,2){2}{\line(0,1){1}}
\multiput(100,0)(0,2){2}{\line(0,1){1}}
\put(0,4){\line(0,1){25}}
\put(15,4){\line(0,1){7}}
\put(15,11){\line(1,0){85}}
\put(15,0){\makebox(85,11){Re'sume'}}
\put(100,4){\line(0,1){25}}
\put(20,26){\line(0,1){3}}
\put(80,26){\line(0,1){3}}
\put(20,26){\line(1,0){60}}
\multiput(0,29)(0,2){6}{\line(0,1){1}}
\multiput(20,29)(0,2){6}{\line(0,1){1}}
\multiput(80,29)(0,2){6}{\line(0,1){1}}
\multiput(100,29)(0,2){6}{\line(0,1){1}}
\put(20,41){\line(0,1){3}}
\put(80,41){\line(0,1){3}}
\put(20,44){\line(1,0){60}}
\put(20,34){\makebox(60,10){Titre}}
\put(0,41){\line(0,1){13}}
\put(100,41){\line(0,1){13}}
\put(0,54){\line(1,0){100}}
\put(3,51){\makebox(0,0)[tl]{Fene^tre et Rapport}}
\thinlines
\put(7.5,5.5){\vector(-1,0){7}}
\put(7.5,5.5){\vector(1,0){7}}
\put(7.5,7){\makebox(0,0)[b]{2 cm}}
\put(50,18.5){\vector(0,1){7}}
\put(50,18.5){\vector(0,-1){7}}
\put(51.5,18.5){\makebox(0,0)[l]{1.5 ligne}}
\put(50,29){\vector(-1,0){29.5}}
\put(50,29){\vector(1,0){29.5}}
\put(50,30.5){\makebox(0,0)[b]{60\%}}
\put(10,35){\vector(-1,0){9.5}}
\put(10,35){\vector(1,0){9.5}}
\put(10,36.5){\makebox(0,0)[b]{20\%}}
\put(90,35){\vector(-1,0){9.5}}
\put(90,35){\vector(1,0){9.5}}
\put(90,36.5){\makebox(0,0)[b]{20\%}}
\put(50,49){\vector(0,1){4.5}}
\put(50,49){\vector(0,-1){4.5}}
\put(51.5,49){\makebox(0,0)[l]{1 ligne}}
\end{picture}
\end{center}
\caption{Position et dimensions des boi^tes}
\label{posdim}
\end{figure}
\end{example}

\subsubsection{Dimensions e'lastiques}

Le dernier type de dimension est la dimension e'lastique.
Une seule dimension d'une boi^te ou les deux peuvent e^tre e'lastiques.
Une boi^te a une dimension e'lastique lorsque deux de ses co^te's oppose's
sont lie's par des contraintes de distances a` deux co^te's ou axes de deux
autres boi^tes.

L'un des co^te's de la boi^te e'lastique est lie' par une re`gle de
positionnement {\tt VertPos} ou {\tt HorizPos} a` une boi^te voisine. L'autre
co^te' est lie' a` une autre boi^te par une re`gle {\tt Height} ou {\tt Width},
qui prend la me^me forme qu'une re`gle de positionnement. Pour la boi^te
e'lastique elle-me^me, les notions de co^te' gauche ou droit, infe'rieur ou
supe'rieur sont floues, puisque
le de'placement d'une des deux boi^tes de re'fe'rence peut faire passer par
exemple le co^te' gauche de la boi^te e'lastique a` droite de son co^te' droit.
Cela n'a pas d'importance. Il faut seulement que les deux co^te's de la boi^te
e'lastique indique's dans la re`gles de position d'une part et dans la
re`gle de dimension d'autre part soient oppose's.

\begin{verbatim}
                  'Height' ':' Dimension
                  'Width' ':' Dimension
     Dimension   = PosH / PosV / ...
\end{verbatim}

\begin{example}
On veut tracer une fle`che ou un trait e'lastique entre le milieu du co^te' infe'rieur de
la boi^te A et le coin supe'rieur gauche de la boi^te B. On de'finit pour cela
une boi^te de type graphique dont le coin supe'rieur gauche coi"ncide avec le
milieu infe'rieur de A (re`gles de position) et le coin infe'rieur droit
coi"ncide avec le coin supe'rieur gauche de B (re`gles de dimension)~:
\begin{verbatim}
BoiteLien :
   BEGIN
   VertPos : Top = A .Bottom;
   HorizPos : Left = A . VMiddle;
   Height : Bottom = B . Top;
   Width : Right = B . Left;
   END;
\end{verbatim}
\end{example}

\begin{example}
L'e'le'ment Titre\_section cre'e une boi^te de pre'sentation Num\_section qui
contient le nume'ro de la section. On veut que les deux boites Num\_section et
Titre\_section soient aligne'es horizontalement, que la boi^te Num\_section
prenne la largeur de son contenu (le nume'ro de la section), que la boi^te
Titre\_section commence a` 0.5 cm a` droite de la boi^te Num\_section et
qu'elle s'e'tende jusqu'au bord droit de sa boi^te englobante. Ainsi,
la boi^te Titre\_section est e'lastique puisque sa largeur est de'finie par
la position de ses co^te's gauche et droit.
Pour obtenir ce re'sultat, on e'crit~:
\begin{verbatim}
Num_section :
   BEGIN
   HorizPos : Left = Enclosing . Left;
   Width : Enclosed . Width;
   ...
   END;

Titre_section :
   BEGIN
   HorizPos : Left = Num_section . Right + 0.5 cm;
   Width : Right = Enclosing . Right;
   ...
   END;
\end{verbatim}
\end{example}

\subsection{De'bordement}

En principe, chaque boi^te d'un e'le'ment de structure englobe comple`tement
les boi^tes des e'le'ments du sous-arbre correspondant. Il peut e^tre
ne'cessaire, dans certains cas, de laisser une boi^te de'border de la boi^te
de son e'le'ment ascendant. Deux re`gles de pre'sentation permettent
d'obtenir cela, une pour les de'bordements horizontaux, l'autre pour les
de'bordements verticaux.

Chacune de ces re`gles est simplement constitue'e d'un mot cle' de'finissant
le type de re`gle, suivi de deux-points et du mot {\tt Yes} ou {\tt No}.

\begin{verbatim}
               'VertOverflow' ':' Booleen /
               'HorizOverflow' ':' Booleen .
     Booleen = 'Yes' / 'No' .
\end{verbatim}

\subsection{He'ritage}

Un parame`tre de pre'sentation peut e^tre de'fini par re'fe'rence au me^me
parame`tre d'une
autre boi^te de l'arbre des boi^tes. La parente' exprime ce lien structural.
La boi^te de re'fe'rence peut e^tre celle de l'e'le'ment imme'diatement
au-dessus dans la structure ({\tt Enclosing}), au deuxie`me niveau au-dessus
({\tt GrandFather}), imme'diatement au-dessous ({\tt Enclosed})
ou imme'diatement pre'ce'dent au me^me niveau ({\tt Previous}).
Dans le cas d'une boi^te de pre'sentation, et uniquement dans ce cas, on peut
aussi faire re'fe'rence a` la boi^te de l'e'le'ment qui cre'e cette boi^te de
pre'sentation ({\tt Creator}).

La parente' s'exprime
par rapport a` la structure logique du document, et non par rapport a` l'arbre
des boi^tes. Ainsi, les boi^tes de pre'sentation ne peuvent transmettre aucun
de leurs parame`tres par he'ritage~; seules les boi^tes des e'le'ments structure's
peuvent le faire. A titre d'exemple, prenons un e'le'ment B de la structure
logique qui suit, dans cette structure, un e'le'ment A. L'e'le'ment B cre'e
une boi^te de pre'sentation P devant lui, par la re`gle {\tt CreateBefore}
(voir les re`gles de cre'ation, page~\pageref{creation}). Si la boi^te de
l'e'le'ment B he'rite le style de ses caracte`res par la parente' {\tt Previous},
elle prend le style des caracte`res de la boi^te de A (boi^te de re'fe'rence)
et non de la boi^te P. L'he'ritage se comporte donc diffe'remment des
positionnements et dimensionnements qui, eux, peuvent faire re'fe'rence a`
des boi^tes de pre'sentation.

La valeur du parame`tre he'rite' peut e^tre la me^me que celle que prend ce parame`tre
pour la boi^te de re'fe'rence. Cela est indique' par le signe {\tt =}.
Mais, pour les parame`tres qui ont une valeur nume'rique, elle peut aussi
e^tre obtenue en ajoutant ou retranchant (selon que le signe est {\tt +}
ou {\tt -}) un nombre a` la valeur du me^me parame`tre de la boi^te
de re'fe'rence. Pour maintenir la valeur du parame`tre dans certaines limites,
il est possible d'imposer une valeur maximum (si le signe est {\tt +})
ou minimum (si le signe est {\tt -}).

S'il s'agit d'une re`gle de pre'sentation d'un attribut nume'rique, le nombre
a` ajouter ou retrancher peut e^tre remplace' par le nom de l'attribut, de
me^me que la valeur maximum ou minimum. Dans ce cas, c'est la valeur de
l'attribut qui est utilise'e.

\begin{verbatim}
     Heritage    = Parente  ValeurHerit .
     Parente     ='Enclosing' / 'GrandFather' / 'Enclosed' /
                  'Previous' / 'Creator' .
     ValeurHerit ='+' EntierPosA [ 'Max' maximumA ] /
                  '-' EntierNegA [ 'Min' minimumA ] /
                  '=' .
     EntierPosA  = EntierPos / IdentAttr .
     EntierPos   = NUMBER .
     EntierNegA  = EntierNeg / IdentAttr .
     EntierNeg   = NUMBER .
     maximumA    = maximum / IdentAttr .
     maximum     = NUMBER .
     minimumA    = minimum / IdentAttr .
     minimum     = NUMBER .
\end{verbatim}

Les parame`tres qui peuvent e^tre obtenus par he'ritage sont la justification,
la coupure des mots en fin de ligne,
l'interligne, la police de caracte`res, le style, la taille, la visibilite',
le renfoncement, le soulignement, le cadrage des lignes, le plan de
superposition, le style et l'e'paisseur des traits, le motif de remplissage et
les couleurs de trace' et de fond.

\subsection{Mise en lignes}
\label{regleline}

La re`gle {\tt Line} indique que le contenu de la boi^te doit e^tre mis
en lignes~: les boi^tes incluses dans la boi^te a` laquelle se rapporte la
re`gle sont affiche'es les unes a` la suite des autres, de gauche a` droite,
leurs axes de re'fe'rence horizontaux (de'finis par la re`gle {\tt HorizRef})
e'tant aligne's, de fac,on a` former des lignes. La longueur des lignes est
e'gale a` la largeur de la boi^te a' laquelle s'applique la re`gle {\tt Line}.

Lorsqu'une boi^te incluse de'borde de la ligne courante, elle est soit reporte'e
en de'but de ligne suivante, soit coupe'e, soit laisse'e telle quelle.
La re`gle {\tt LineBreak} (voir page~\pageref{condcoupure}) permet d'autoriser
ou d'interdire la coupure des boi^tes incluses.
Si la boi^te incluse n'est pas secable mais de taille infe'rieure a` la ligne,
elle est reporte'e en de'but de ligne suivante.
Si la boi^te incluse n'est pas se'cable mais de taille supe'rieure a` la ligne,
elle est laisse'e telle quelle.
Quand une boi^te chai^ne de caracte`res est se'cable, la coupure du texte
s'effectue sur un espace se'cable ou e'ventuellement sur un mot
(voir page~\pageref{reglehyphenate}).
Quand une boi^te compose'e est se'cable, cette boi^te devient transparente
vis-a`-vis de la mise en lignes.
Les boi^tes incluses dans la boi^te compose'e sont traite'es comme des
boi^tes incluses de la boi^te qui porte la re`gle {\tt LineBreak}.
Il est possible ainsi de descendre toute une hie'rarchie de boi^tes pour mettre
en lignes les feuilles de texte d'une structure complexe.

Les re`gles de positionnement relatif des boi^tes incluses sont ignore'es,
les boi^tes e'tant place'es selon la re`gle de mise en lignes.

La re`gle {\tt Line} ne comporte pas de parame`tre. Les caracte'ristiques
des lignes a` construire sont de'termine'es
par les re`gles {\tt LineSpacing}, {\tt Indent}, {\tt Adjust}, {\tt Justify}
et {\tt Hyphenate}.
De plus, la re`gle {\tt InLine} (voir page~\pageref{regleinline}) permet
d'exclure certains e'le'ments de la mise en lignes.

Lorsque la re`gle {\tt Line} se trouve dans la suite de re`gles d'une vue
non principale, elle ne s'applique que pour cette vue, mais
lorsque la re`gle {\tt Line} se trouve dans la suite de re`gles de la vue
principale, elle s'applique aussi par de'faut aux autres vues,
sauf a` celles ou` figure explicitement une re`gle {\tt NoLine}.
La re`gle {\tt NoLine} permet ainsi d'annuler pour une vue non principale
l'effet de la re`gle {\tt Line} associe'e a` la vue principale.
La re`gle {\tt NoLine} ne doit pas e^tre utilise'e pour la vue principale,
l'absence de re`gle {\tt Line} ayant le me^me effet.
Comme la re`gle {\tt Line}, la re`gle {\tt NoLine} ne comporte pas de
parame`tre.

\begin{verbatim}
                 'Line'
                 'NoLine'
\end{verbatim}

\subsubsection{Interligne}
\label{interligne}

La re`gle {\tt LineSpacing} de'finit l'interligne a` utiliser dans une mise en
lignes. L'interligne est la distance
entre les lignes de base (axes de re'fe'rence horizontaux) des lignes
successives produites par la re`gle {\tt Line}. La valeur de l'interligne
peut e^tre imme'diate ou he'rite'e. Elle s'exprime dans les diffe'rentes
unite's de distance disponibles (voir page~\pageref{unites}).

L'he'ritage permet de prendre la valeur d'interligne de l'e'le'ment dont on
he'rite, sans changement (signe {\tt =} apre`s le mot cle' repre'sentant
l'e'lement dont on he'rite) ou avec une diffe'rence positive (signe {\tt +})
ou ne'gative (signe {\tt -}). En cas de diffe'rence, le signe {\tt +} ou
{\tt -} est suivi de la valeur de cette diffe'rence, exprime'e comme une
distance (voir page~\pageref{distance}).

\begin{verbatim}
                      'LineSpacing' ':' DistanceHerit
     DistanceHerit =   Parente DistanceHeritee / Distance .
     DistanceHeritee = '=' / '+' DistAbs / '-' DistAbs .
\end{verbatim}

Lorsque la valeur de l'interligne (ou sa diffe'rence dans l'he'ritage) est
exprime'e en unite's relatives, elle change avec le corps des caracte`res.
Ainsi, lorsqu'on choisira, lors de l'e'dition d'un document, un corps plus
important, pour une partie du document,
l'interligne de cette partie augmentera dans la me^me proportion.
Au contraire, lorsque la valeur de l'interligne (ou sa diffe'rence) est
exprime'e en unite's
absolues (centime`tres, pouces, points typographiques), elle est inde'pendante
des caracte`res, ce qui permet de conserver un espacement re'gulier, quel que
soit le corps des caracte`res. Selon l'effet recherche', on peut choisir
l'une ou l'autre solution.

\subsubsection{Renfoncement de la premie`re ligne}

La re`gle {\tt Indent} indique le renfoncement de la premie`re ligne des
e'le'ments mis en lignes par la fonction {\tt Line}. Le renfoncement
de'termine le de'calage horizontal du de'but de la premie`re ligne de l'e'le'ment
par rapport au de'but des autres lignes du me^me e'le'ment. Le renfoncement peut e^tre
indique' par une valeur imme'diate ou par he'ritage. La valeur imme'diate
est un nombre entier ne'gatif (de'calage a` gauche), nul (pas de de'calage) ou
positif (de'calage a` droite, le signe est facultatif). Toutes les unite's
de distances pre'sente'es page~\pageref{unites} sont utilisables.

S'il n'est applique' qu'aux e'le'ments mis en lignes, le renfoncement peut
ne'anmoins e^tre de'fini pour n'importe quelle boi^te, et transmis par
he'ritage jusqu'aux e'le'ments mis en ligne. L'amplitude du renfoncement
s'exprime comme l'interligne (voir section~\ref{interligne}).

\begin{verbatim}
                 'Indent' ':' DistanceHerit
\end{verbatim}

\subsubsection{Ajustement des lignes}

Le mode d'ajustement des lignes construites par la mise en lignes est
de'fini par la re`gle {\tt Adjust}. La valeur de l'ajustement peut e^tre
imme'diate ou he'rite'e. La valeur imme'diate est simplement indique'e par
un mot cle'~:
\begin{itemize}
   \item {\tt Left} : au fer a` gauche,
   \item {\tt Right} : au fer a` droite,
   \item {\tt VMiddle} : centre'.
   \item {\tt LeftWithDots} : au fer a` gauche avec des pointille's pour
         comple'ter la dernie`re ligne jusqu'au co^te' droit de la boi^te
         mise en lignes.
\end{itemize}
L'he'ritage ne peut e^tre que {\tt =}, signifiant que la boi^te a` laquelle
se rapporte la re`gle prend la me^me valeur pour le parame`tre ajustement
que la boi^te dont elle he'rite, indique'e par le lien de parente'.

\begin{verbatim}
                  'Adjust' ':' AligneHerit
     AligneHerit = Parente '=' / Alignement .
     Alignement  ='Left' / 'Right' / 'VMiddle' /
                  'LeftWithDots' .
\end{verbatim}

\subsubsection{Justification}

La re`gle {\tt Justify} indique si les lignes contenues dans la boi^te et
produites par une re`gle {\tt Line} doivent ou non e^tre e'tendues
horizontalement pour occuper toute la largeur de leur boi^te englobante.
La premie`re et la dernie`re ligne sont traite'es de fac,on particulie`re~:
la position du de'but de la premie`re ligne est fixe'e par la re`gle {\tt Indent}
et la dernie`re ligne n'est pas e'tendue. Le parame`tre de justification de'fini
par cette re`gle prend une valeur boole'enne, qui peut e^tre imme'diate ou
he'rite'e. La valeur imme'diate du boole'en est simplement indique'e par un
mot cle' {\tt Yes} ou {\tt No}. L'he'ritage ne peut e^tre que {\tt =},
signifiant que la boi^te a` laquelle se rapporte la re`gle prend la me^me
valeur pour le parame`tre justification que la boi^te dont elle he'rite,
indique'e par le lien de parente'.

\begin{verbatim}
                   'Justify' ':' HeritageBool
     HeritageBool = Booleen / Parente '=' .
     Booleen      ='Yes' / 'No' .
\end{verbatim}

Lorsque les lignes sont justifie'es, le parame`tre d'ajustement indique' dans
la re`gle {\tt Adjust} n'a pas d'influence, sauf sur la dernie`re ligne
produite. En effet, les autres sont e'tendues jusqu'aux limites de la boi^te
et le mode d'ajustement n'est plus perceptible.

\begin{example}
L'he'ritage permet notamment de faire varier les caracte'ristiques des
lignes d'un type d'e'le'ment (par exemple Paragraphe) selon l'environnement
englobant (par exemple Re'sume' ou Section), et ainsi d'obtenir une mise
en lignes diffe'rente des me^mes e'le'ments lorsqu'ils se trouvent dans des
environnements diffe'rents. On peut indiquer que les paragraphes he'ritent
leur ajustement, leur mode de justification et leur interligne~:
\begin{verbatim}
Paragraphe :
   BEGIN
   Justify : Enclosing = ;
   LineSpacing : Enclosing = ;
   Adjust : Enclosing =;
   Line;
   END;
\end{verbatim}
Si on fixe l'ajustement, la justification et l'interligne des e'le'ments
Section et Re'sume'~:
\begin{verbatim}
Section :
   BEGIN
   Adjust : Left;
   Justify : Yes;
   LineSpacing : 1;
   END;
Resume :
   BEGIN
   Adjust : VMiddle;
   Justify : No;
   LineSpacing : 1.3;
   END;
\end{verbatim}
les paragraphes apparaissant dans les sections sont justifie's avec un
interligne simple et ceux du re'sume' ne sont pas justifie's, sont centre's
et ont un interligne plus important. Il s'agit ne'anmoins de paragraphes
de'finis par la me^me re`gle dans le sche'ma de structure logique.
\end{example}

\subsubsection{Coupure des mots}
\label{reglehyphenate}

La re`gle {\tt Hyphenate} indique si on veut que les mots soient coupe's
en fin de ligne ou non. Il s'agit des lignes contenues dans la boi^te a`
laquelle se rapporte la re`gle et qui sont produites par une re`gle {\tt Line}.

Le parame`tre coupure des mots de'fini
par cette re`gle prend une valeur boole'enne, qui peut e^tre imme'diate ou
he'rite'e. La valeur imme'diate du boole'en est simplement indique'e par un
mot cle' {\tt Yes} ou {\tt No}. L'he'ritage ne peut e^tre que {\tt =},
signifiant que la boi^te a` laquelle se rapporte la re`gle prend la me^me
valeur pour le parame`tre coupure des mots que la boi^te dont elle he'rite,
indique'e par le lien de parente'.

\begin{verbatim}
                   'Hyphenate' ':' HeritageBool
     HeritageBool = Booleen / Parente '=' .
     Booleen      ='Yes' / 'No' .
\end{verbatim}

\subsubsection{E'chappement a` la mise en lignes}
\label{regleinline}

La re`gle {\tt InLine} permet d'indiquer qu'une boi^te qui doit participer
a` la mise en lignes demande'e par la re`gle {\tt Line} d'une boi^te
englobante, e'chappe en fait a` cette mise en ligne et se positionne bien
selon les re`gles {\tt HorizPos} et {\tt VertPos} qui lui correspondent.
Lorsque le re`gle {\tt InLine} s'applique a` une boi^te qui ne fait pas
partie d'une mise en lignes, elle est simplement sans effet.

La re`gle est forme'e du mot cle' {\tt InLine} suivi de deux-points et du
mot {\tt Yes}, si la boi^te doit participer a` la mise en ligne, ou du
mot {\tt No} si elle ne doit pas y participer. C'est la seule forme
possible~: cette re`gle ne peut pas e^tre he'rite'e. De plus, elle ne peut
apparai^tre que dans les re`gles de la vue principale et elle s'applique a`
toutes les vues de'finies dans le sche'ma de pre'sentation.

\begin{verbatim}
               'InLine' ':' Booleen .
     Booleen = 'Yes' / 'No' .
\end{verbatim}

\begin{example}
Le sche'ma de structure de'finit un attribut logique {\tt Nouveau} qui permet
d'identifier dans un document les passages qui ont e'te' modifie's. On veut
que le sche'ma de structure fasse apparai^tre dans la marge gauche un filet
vertical en face de chaque passage portant l'attribut {\tt Nouveau}.
Un passage nouveau peut e^tre aussi bien un e'le'ment complet, comme un
paragraphe ou une section, que quelques mots au milieu d'un paragraphe.
On associe donc a` l'attribut {\tt Nouveau} une re`gle de cre'ation qui
engendre une boi^te de pre'sentation {\tt FiletVertical}.
 
Lorsque l'attribut {\tt Nouveau} est porte' par une chai^ne de caracte`res
qui se trouve a` l'inte'rieur d'un e'le'ment mis en lignes (a` l'inte'rieur
d'un paragraphe par
exemple), le filet est l'un des e'le'ments qui participent a` la mise
en lignes et il se place donc normalement dans la ligne courante, a` la suite
de la chai^ne qui porte l'attribut. Pour e'viter cela, on utilise la re`gle
{\tt InLine} de la fac,on suivante~:

\begin{verbatim}
BOXES
  FiletVertical:
     BEGIN
     Content: Graphics 'l';
     HorizPos: Left = Root . Left;
     VertPos: Top = Creator . Top;
     Height: Bottom = Creator . Bottom;
     Width: 1 pt;
     InLine: No;
     ...
     END;
...
ATTRIBUTES
  Nouveau:
     BEGIN
     CreateAfter(FiletVertical);
     END;
\end{verbatim}
\end{example}

\subsection{Conditions de coupure}
\label{condcoupure}

Les pages sont construites par l'e'diteur en suivant le mode`le indique'
par une re`gle {\tt Page} (voir page~\pageref{page}). Le mode`le de page
ne de'crit que la composition des pages mais n'exprime aucune re`gle de
coupure des diffe'rents types d'e'le'ments. Or il est possible que certains
e'le'ments ne doivent pas e^tre coupe's par un saut de page ou ne puissent
pas e^tre coupe's n'importe ou`. Les conditions de coupures de certains
types d'e'le'ments par des sauts de page peuvent e^tre indique'es par des
re`gles {\tt PageBreak}, {\tt NoBreak1} et {\tt NoBreak2} associe'es a` ces
types d'e'le'ments.

La re`gle {\tt PageBreak} permet d'indiquer si la boi^te peut e^tre coupe'e
ou non lors de la construction des pages. Si la coupure est autorise'e,
la boi^te peut e^tre coupe'e, une partie en bas d'une page et l'autre partie
en haut de la page suivante. La re`gle est forme'e du mot cle'
{\tt PageBreak} suivi de deux-points et du mot {\tt Yes}, si la coupure est
autorise'e, ou du mot {\tt No} si elle ne l'est pas. C'est la seule forme
possible~: cette re`gle ne peut pas e^tre he'rite'e. De plus, elle ne peut
apparai^tre que dans les re`gles de la vue principale et elle s'applique a`
toutes les vues de'finies dans le sche'ma de pre'sentation.

La coupure par des sauts de lignes peut e^tre contro^le'e de fac,on
similaire, par la re`gle {\tt LineBreak}. Cette re`gle permet d'indiquer si
la boi^te peut e^tre coupe'e ou non lors de la construction des lignes.
Si la coupure est autorise'e, la boi^te peut e^tre coupe'e, une partie a`
la fin d'une ligne, l'autre partie au de'but de la ligne suivante.
La re`gle est forme'e du mot cle' {\tt LineBreak} suivi de deux-points et
du mot {\tt Yes}, si la coupure est autorise'e, ou du mot {\tt No} si elle
ne l'est pas. C'est la seule forme possible~: cette re`gle ne peut pas e^tre
he'rite'e. De plus, elle ne peut apparai^tre que dans les re`gles de la vue
principale et elle s'applique a` toutes les vues de'finies dans le sche'ma
de pre'sentation.

\begin{verbatim}
               'PageBreak' ':' Booleen .
               'LineBreak' ':' Booleen .
     Booleen = 'Yes' / 'No' .
\end{verbatim}

Lorsque la coupure par un saut de page est autorise'e, il se peut qu'un saut
de page tombe a` un endroit peu approprie', provoquant par exemple une veuve
ou un orphelin, ou
se'parant le titre d'une section du premier paragraphe qui suit. Les re`gles
{\tt NoBreak1} et {\tt NoBreak2} permettent d'e'viter cela. Elles indiquent
que la boi^te du type d'e'le'ment auquel elles se rapportent ne peut pas e^tre
coupe'e dans une certaine zone en haut (re`gle {\tt NoBreak1}) ou en bas
(re`gle {\tt NoBreak2}). Ces deux re`gles pre'cisent la hauteur des zones ou`
les sauts de page sont interdits.

Les re`gles {\tt NoBreak1} et {\tt NoBreak2} donnent la hauteur de la zone
de coupure interdite sous une forme imme'diate (pas d'he'ritage possible),
avec toutes les unite's disponibles, absolues ou relatives (voir
page~\pageref{unites}).

\begin{verbatim}
                   'NoBreak1' ':' DistAbs .
                   'NoBreak2' ':' DistAbs .
\end{verbatim}

\begin{example}
Pour e'viter les veuves et les orphelins dans un paragraphe, on donne les
deux re`gles~:
\begin{verbatim}
Paragraphe :
   BEGIN
   NoBreak1 : 2;
   NoBreak2 : 2;
   END;
\end{verbatim}
Pour e'viter qu'un titre de section soit se'pare' du premier paragraphe, on
interdit la coupure au de'but de la section par la re`gle~:
\begin{verbatim}
Section :
   NoBreak1 : 1.5 cm;
\end{verbatim}

Pour e'viter qu'une figure soit coupe'e par un saut de page, on e'crit~:
\begin{verbatim}
Figure :
   PageBreak : No;
\end{verbatim}
\end{example}

L'e'diteur Thot construit dynamiquement les images de documents affiche'es a`
l'e'cran. Lorsque l'utilisateur se de'place dans un document ou lorsqu'il fait
de'filer un document dans une fene^tre, l'e'diteur construit l'image a` afficher
par petits bouts, de fac,on a` ``boucher les trous'' qui peuvent se produire
dans l'image lors de ces ope'rations. Il cesse de comple'ter l'image de`s qu'un
e'le'ment atteint la limite de la fene^tre ou` se trouvait le trou. Si l'aspect
graphique du document est complexe, il est possible que, tout en atteignant
la limite de la fene^tre, l'image affiche'e soit incomple`te, par exemple
lorsqu'un e'le'ment doit e^tre pre'sente' a` co^te' du dernier e'le'ment affiche'
et que son image n'est pas construite. L'utilisateur ne sait pas alors si
l'e'le'ment est re'ellement absent ou si son image n'est simplement pas
construite.

La re`gle {\tt Gather} permet de reme'dier a` ce proble`me. Lorsque la re`gle
{\tt Gather : Yes;} est associe'e a` un type d'e'le'ment, l'image des e'le'ments
de ce type est construite d'un bloc par l'e'diteur : elle n'est jamais
fractionne'e.

La re`gle {\tt Gather} ne doit pas apparai^tre dans les re`gles par de'faut
(voir page~\pageref{reglesdefaut}).
Les e'le'ments qui ne portent pas de re`gle {\tt Gather} sont conside're's comme
suceptibles d'e^tre fractionne's lors de l'affichage. Il n'est donc pas
ne'cessaire d'utiliser la forme {\tt Gather : No;} qui est implicite.
En fait seuls les e'le'ments dont l'image ne doit pas e^tre fractionne'e
portent une re`gle {\tt Gather}, sous la forme {\tt Gather : Yes;}. Cette
re`gle doit e^tre utilise'e avec prudence et uniquement pour les types
d'e'le'ments qui en ont vraiment besoin. Si elle est utilise'e a` tort, elle
risque d'augmenter inutilement la taille de l'image construite par l'e'diteur
et donc d'immobiliser une partie importante de la me'moire.

Comme les re`gles {\tt PageBreak} et {\tt LineBreak}, la re`gle {\tt Gather}
ne peut apparai^tre que dans les re`gles de la vue principale et elle
s'applique a` toutes les vues de'finies dans le sche'ma de pre'sentation.

\begin{verbatim}
                   'Gather' ':' Booleen .
\end{verbatim}

\subsection{Visibilite'}
\label{visib}

La visibilite' permet de contro^ler les e'le'ments qui doivent e^tre affiche's
et ceux qui ne doivent pas l'e^tre, en fonction du contexte. Un e'le'ment peut
avoir des visibilite's diffe'rentes dans les diffe'rentes vues. Si la visibilite'
d'un e'le'ment est nulle pour une vue, cet e'le'ment n'est pas affiche' dans cette
vue et n'y occupe aucune place (ses dimensions sont nulles).

La visibilite' prend des valeurs entie`res, positives ou nulles. Si des valeurs
supe'rieures a` 1 sont utilise'es, elles permettent a` l'utilisateur, lors
de l'e'dition, de spe'cifier le degre' de visibilite' qui l'inte'resse, et ainsi
de ne voir que les boi^tes dont le degre' de visibilite' est supe'rieur a` un
certain seuil. L'utilisateur a alors le contro^le de la granularite' des
images qui sont affiche'es.

La visibilite' peut e^tre de'finie par une valeur imme'diate ou he'rite'e.
Si elle est de'finie par he'ritage, l'he'ritage ne peut pas se faire depuis
le descendant ni depuis le pre'ce'dent. La visibilite' ne peut s'he'riter que de
l'ascendant.

S'il s'agit d'une re`gle de pre'sentation d'un attribut nume'rique, la visibilite'
peut e^tre indique'e par le nom de l'attribut. Dans ce cas, c'est la valeur de
l'attribut qui est utilise'e comme visibilite'.

\begin{verbatim}
                  'Visibility' ':' NombreHerit
     NombreHerit = Entier / IdentAttr / Heritage .
     Entier      = NUMBER .
\end{verbatim}

\begin{example}
Si on ne veut afficher dans la vue {\tt Vue\_Math} que les e'le'ments
du type {\tt Formule}, on met dans les re`gles par de'faut~:

\begin{verbatim}
DEFAULT
     IN Vue_Math Visibility:0;
\end{verbatim}
ce qui assure que tous les e'le'ments seront invisibles dans la vue
{\tt Vue\_Math}. Mais on associe au type {\tt Formule} la re`gle~:

\begin{verbatim}
Formule :
     IN Vue_Math Visibility:5;
\end{verbatim}

qui rend les formules, et uniquement les formules, visibles.

\end{example}

\subsection{Choix des caracte`res}

Quatre parame`tres de'terminent le choix des caracte`res utilise's
pour afficher 
le texte. Ce sont la taille, la police, le style et le soulignement.

\subsubsection{Taille des caracte`res}

La taille est utilise'e d'une part pour spe'cifier les unite's re'elles de
distance et de dimension lorsqu'on travaille en unite's relatives (voir
page~\pageref{unites}), et d'autre part pour de'finir la force de corps des
caracte`res contenus dans la boi^te.

Comme une distance ou une longueur, la taille peut e^tre exprime'e en
unite's abstraites ou absolues. Elle peut aussi e^tre he'rite'e. Si elle
n'est pas he'rite'e, elle est simplement indique'e sous la forme d'un
nombre entier suivi e'ventuellement du mot cle' {\tt pt}, indiquant que
la taille est exprime'e en points typographiques. L'absence du mot cle'
{\tt pt} indique qu'il s'agit d'unite's abstraites, la valeur 1 repre'sentant
la plus petite taille, la valeur maximum e'tant fixe'e a` 16. La correspondance
entre ces tailles abstraites et des forces de corps re'elles est contro^le'e
par une table qui peut e^tre modifie'e statiquement ou me^me dynamiquement
pendant l'exe'cution de l'e'diteur Thot.

S'il s'agit d'une re`gle de pre'sentation d'un attribut nume'rique, la taille
peut e^tre indique'e par le nom de l'attribut. Dans ce cas, c'est la valeur de
l'attribut qui est utilise'e comme taille.

{\bf Attention :} la seule unite' absolue offerte pour la taille est le
point typographique. On ne peut utiliser ni le centime`tre ni le pouce.

Si la taille est he'rite'e, la re`gle donne le lien de parente' de la boi^te
dont la valeur est he'rite'e et la diffe'rence par rapport a` cette valeur.
La diffe'rence peut e^tre exprime'e en points typographiques ou en unite's
abstraites. La valeur maximum ou minimum de la taille peut e'galement
e^tre indique'e, mais sans pre'ciser l'unite'~: c'est la me^me que pour la
diffe'rence.

Dans une re`gle de pre'sentation d'un attribut nume'rique, la diffe'rence de
taille peut e^tre indique'e par le nom de l'attribut. C'est alors la valeur de
l'attribut qui est utilise'e comme diffe'rence. De me^me l'attribut peut e^tre
utilise' pour la taille maximum ou minimum.

\begin{verbatim}
                    'Size' ':' TailleHerit
     TailleHerit   = TailleA [ 'pt' ] /
                     Parente TailleHeritee .
     TailleHeritee ='+' TailleA [ 'pt' ]
                     [ 'Max' TailleMaxA ] /
                    '-' TailleA [ 'pt' ]
                     [ 'Min' TailleMinA ] /
                    '=' .
     TailleA       = Taille / IdentAttr .
     Taille        = NUMBER .
     TailleMaxA    = TailleMax / IdentAttr .
     TailleMax     = NUMBER .
     TailleMinA    = TailleMin / IdentAttr .
     TailleMin     = NUMBER .
\end{verbatim}

\begin{example}
La re`gle
\begin{verbatim}
Size : Enclosing - 2 pt Min 7;
\end{verbatim}
signifie que le corps des caracte`res est de 2 points infe'rieur a` celui
de la boi^te englobante, mais qu'il ne peut pas e^tre infe'rieur a` 7 points,
quelle que soit la valeur du corps de la boi^te englobante.

Si on veut que le texte d'un rapport soit affiche' avec des caracte`res
de taille moyenne (par exemple la taille 5), mais que le titre soit affiche'
avec des caracte`res plus gros et le re'sume' avec des caracte`res plus petits on
e'crit les re`gles~:

\begin{verbatim}
Rapport :
     Size : 5;
Titre :
     Size : Enclosing + 2;
Resume :
     Size : Enclosing - 1;
\end{verbatim}
Ainsi il suffit de changer la valeur du parame`tre taille du rapport pour
changer toutes les tailles de caracte`res dans le document, tout en conservant
les me^mes diffe'rences de taille de caracte`res entre les diffe'rents e'le'ments.
\end{example}

\subsubsection{Police et style des caracte`res}
\label{style}

La re`gle {\tt Font} de'termine la famille de polices qui doit e^tre utilise'e
pour afficher les caracte`res contenus dans la boi^te, et la re`gle {\tt Style}
de'termine leur style. Thot reconnai^t trois
familles de polices de caracte`res (Times, Helvetica et Courier) et six
styles~: romain (Roman), italique (Italics), gras (Bold), gras italique
(BoldItalics), oblique (Oblique) et gras oblique (BoldOblique).

La famille de polices et le style peuvent e^tre indique's imme'diatement sous
la forme d'un nom, ou ils peuvent e^tre he'rite's. Pour le nom de la
famille de polices seul le premier caracte`re est utilise'.

Seul l'he'ritage identique est autorise'~: la boi^te prend la me^me police
ou le me^me style que la boi^te dont elle he'rite. Cela est marque', apre`s
l'indication du lien de parente', par le signe {\tt =}.

\begin{verbatim}
                     'Font' ':' NomHerit
                     'Style' ':' StyleHerit
     NomHerit       = Parente '=' / NomStylePolice .
     NomStylePolice = NAME .
     StyleHerit     = Parente ' =' / 
                      'Roman' / 'Bold' / 'Italics' / 
                      'BoldItalics' / 'Oblique' /
                      'BoldOblique' .
\end{verbatim}

\begin{example}
Pour indiquer que le re'sume' utilise la famille de caracte`res du document,
mais en italique, on e'crit les re`gles~:

\begin{verbatim}
Resume :
   BEGIN
   Font : Enclosing =;
   Style : Italics;
   END;
\end{verbatim}
\end{example}

\subsubsection{Soulignement}
\label{underline}

La re`gle {\tt Underline} est utilise'e pour pre'ciser si les
caracte`res contenus dans la boi^te doivent e^tre souligne's ({\tt
Underlined}), surligne's ({\tt Overlined}), biffe's ({\tt CrossedOut})
ou inchange's ({\tt NoUnderline}). La re`gle {\tt Thickness} pre'cise
alors l'e'paisseur du trait : fin ({\tt Thin}) ou e'pais ({\tt
Thick}).

Comme pour police et style, seul l'he'ritage identique est autorise'~:
la boi^te prend le me^me type de soulignement que la boi^te dont elle
he'rite. Cela est marque', apre`s
l'indication du lien de parente', par le signe {\tt =}.

\begin{verbatim}
               'Underline' ':' SouligneHerit /
               'Thickness' ':' EpaisseurHerit /

SouligneHerit = Parente '=' / 'NoUnderline' / 'Underlined' / 
                 'Overlined' / 'CrossedOut' .
EpaisseurHerit = Parente '=' / 'Thick' / 'Thin' .
\end{verbatim}

\subsection{Profondeur de superposition}

La re`gle {\tt Depth} permet de de'terminer l'ordre de superposition des
boi^tes terminales lorsque plusieurs boi^tes se recouvrent au moins
partiellement. Cette re`gle de'finit le mode de calcul du parame`tre
profondeur, qui est un entier positif ou nul. Le parame`tre profondeur a
une valeur pour toutes les boi^tes. Pour les boi^tes terminales de la
structure et pour les boi^tes de pre'sentation, la valeur de la profondeur
est utilise'e lors de l'affichage et de l'impression~: les boi^tes dont le
parame`tre profondeur a la valeur la plus faible recouvrent celles qui ont
une profondeur de valeur supe'rieure. Pour les boi^tes non terminales,
la profondeur n'est pas interpre'te'e lors de l'affichage, mais elle permet
de calculer par he'ritage la profondeur des boi^tes terminales.

Comme la plupart des autres re`gles, la re`gle de profondeur est
de'finie dans les re`gles par de'faut de chaque sche'ma de pre'sentation
(voir page~\pageref{reglesdefaut}).
La profondeur a donc toujours une valeur, alors qu'elle n'est pas
ne'cessaire dans tous les cas ou` il n'y a pas de superposition. Pour
e'viter des traitements inutiles, on convient qu'une valeur nulle de la
profondeur signifie qu'il n'y a aucun proble`me de superposition.

La re`gle de profondeur a la me^me forme que la re`gle de visibilite' (voir
section~\ref{visib}). Elle peut e^tre de'finie par he'ritage ou par une
valeur nume'rique. Dans le cas ou` elle correspond a` un attribut nume'rique,
elle peut prendre la valeur de cet attribut.

\begin{verbatim}
                'Depth' ':' NombreHerit
\end{verbatim}

\begin{example}
Pour un document purement textuel, ou` ne se pose aucun proble`me de
superposition, on peut n'utiliser qu'une re`gle {\tt Depth} dans tout le
sche'ma de pre'sentation~:
\begin{verbatim}
DEFAULT
    Depth : 0;
    ...
\end{verbatim}

Si on veut faire apparai^tre le texte des exemples sur un fond bleu clair, on
de'finit une boi^te de pre'sentation~:
\begin{verbatim}
BOXES
   FondBleu :
      BEGIN
      Content : Graphics 'R';
      Background : LightBlue3;
      FilPattern: backgroundcolor;
      Depth : 2;
      ...
      END;
\end{verbatim}
et on associe a` l'e'le'ment Exemple les re`gles~:
\begin{verbatim}
RULES
   Exemple :
      BEGIN
      CreateFirst (FondBleu);
      Depth : 1;
      ...
      END;
\end{verbatim}
De cette fac,on, le texte des exemples (s'il he'rite la profondeur de son
ascendant) se superposera au fond bleu, et non l'inverse.
\end{example}

\subsection{Style des traits}
\label{styletrait}

La re`gle {\tt LineStyle} de'termine le style de trait qui doit e^tre utilise'
pour tracer tous les e'le'ments graphiques contenus dans la boi^te.
Le style de trait peut e^tre indique' imme'diatement sous la forme d'un nom
({\tt Solid}, {\tt Dashed}, {\tt Dotted}) ou il peut e^tre he'rite'.
Seuls les e'le'ments de base de type graphique sont affecte's par cette re`gle,
mais elle peut e^tre associe'e a` n'importe quelle boi^te, et transmise par
he'ritage jusqu'aux e'le'ments graphiques.

Seul l'he'ritage identique est autorise'~: la boi^te prend le me^me style
de trait que la boi^te dont elle he'rite. Cela est marque', apre`s
l'indication du lien de parente', par le signe {\tt =}.

\begin{verbatim}
                      'LineStyle' ':' StyleTraitHerit
     StyleTraitHerit = Parente '=' /
                      'Solid' / 'Dashed' / 'Dotted' .
\end{verbatim}

\begin{example}
Pour indiquer que, dans les figures, les parties graphiques doivent e^tre
trace'es en traits continus, on e'crit la re`gle~:

\begin{verbatim}
Figure :
   LineStyle : Solid;
\end{verbatim}
et on associe aux e'le'ments qui composent les figures la re`gle~:
\begin{verbatim}
   LineStyle : Enclosing =;
\end{verbatim}
\end{example}

\subsection{E'paisseur des traits}

La re`gle {\tt LineWeight} de'termine l'e'paisseur de traits de tous les
e'le'ments graphiques qui apparaissent dans la boi^te, quel que soit leur
style de trait.
L'e'paisseur de trait peut e^tre indique'e par une valeur imme'diate ou par
he'ritage. La valeur imme'diate est un nombre positif suivi d'une indication
d'unite' facultative (absente dans le cas ou` on travaille en unite's
relatives). Toutes les unite's de distance pre'sente'es page~\pageref{unites}
sont utilisables. L'e'paisseur des traits s'exprime comme l'interligne
(voir section~\ref{interligne}).

\begin{verbatim}
                 'LineWeight' ':' DistanceHerit
\end{verbatim}

Seuls les e'le'ments de base de type graphique sont affecte's par cette
re`gle, mais elle peut e^tre associe'e a` n'importe quelle boi^te, et
transmise par he'ritage jusqu'aux e'le'ments graphiques.

\begin{example}
Pour indiquer que, dans les figures, les parties graphiques doivent e^tre
trace'es avec des traits de 3/10 de point d'e'paisseur, on e'crit la re`gle~:

\begin{verbatim}
Figure :
   LineWeight : 0.3 pt;
\end{verbatim}
et on associe aux e'le'ments qui composent les figures la re`gle~:
\begin{verbatim}
   LineWeight : Enclosing =;
\end{verbatim}
\end{example}

\subsection{Motif de remplissage}
\label{remplissage}

La re`gle {\tt FillPattern} de'termine le motif a` utiliser pour remplir
les formes graphiques ferme'es (cercles, rectangles, etc.) qui apparaissent
dans la boi^te. Ce motif peut e^tre indique' par une valeur imme'diate ou
par he'ritage. La valeur imme'diate est un nom qui identifie l'un des motifs
disponibles dans Thot. Les noms des motifs disponibles sont~:
nopattern, foregroundcolor, backgroundcolor, gray1, gray2, gray3, gray4, gray5, gray6,
gray7, horiz1, horiz2, horiz3, vert1, vert2, vert3, left1, left2, left3,
right1, right2, right3, square1, square2, square3, lozenge, brick, tile, sea,
basket.

Comme les autres re`gles propres au graphique, {\tt LineStyle} et
{\tt LineWeight}, la re`gle {\tt FillPattern} n'affecte que les e'le'ments
de base de type graphique, mais elle peut e^tre associe'e a` n'importe quelle
boi^te, et transmise par he'ritage jusqu'aux e'le'ments graphiques.
Comme pour les autres re`gles spe'cifiques au graphique, seul l'he'ritage
avec la me^me valeur est autorise'.

La re`gle {\tt FillPattern} peut aussi e^tre utilise'e pour de'terminer
si le fond des caracte`res de texte, des symboles et des bit-maps doit e^tre
colorie' ou non. Pour ces types d'e'le'ments (texte, symboles et images),
les seules valeurs valides sont nopattern, foregroundcolor et
backgroundcolor. Lorsque {\tt FillPattern} a la valeur {\tt backgroundcolor}
le fond des caracte`res, des symboles et des bit-maps prend la couleur
de'termine'e par la re`gle {\tt Background} (voir section~\ref{couleurs}) qui
s'applique a` ces e'le'ments. Lorsque {\tt FillPattern} a la valeur
{\tt foregroundcolor}, le fond des caracte`res, des symboles et des bit-maps
prend la couleur de'termine'e par la re`gle {\tt Foreground} (voir
section~\ref{couleurs}) qui s'applique a` ces e'le'ments. Dans tous les autres
cas, le fond des caracte`res n'est pas colorie'.

\begin{verbatim}
                 'FillPattern' ':' NomHerit
\end{verbatim}

\begin{example}
Pour indiquer que, dans les figures, les formes graphiques ferme'es doivent
e^tre remplies avec un motif repre'sentant un mur de briques, on e'crit la
re`gle~:

\begin{verbatim}
Figure :
   FillPattern : brick;
\end{verbatim}
et on associe aux e'le'ments qui composent les figures la re`gle~:
\begin{verbatim}
   FillPattern : Enclosing =;
\end{verbatim}
\end{example}

\subsection{Couleurs}
\label{couleurs}

Les re`gles {\tt Foreground} et {\tt Background} de'terminent les couleurs
a` utiliser respectivement pour le premier plan et le fond de tous les
e'le'ments de base qui apparaissent dans la boi^te. Ces couleurs peuvent
e^tre indique'es par une valeur imme'diate ou par he'ritage. La valeur
imme'diate est un nom qui identifie l'une des couleurs disponibles dans
Thot\footnote{Les noms des couleurs disponibles se trouvent dans le fichier
{\tt thot.color}.}. 

A la diffe'rence des re`gles pre'ce'dentes, les re`gles de couleur affectent
de la me^me fac,on tous les e'le'ments de base, quel que soit leur type
(texte, graphiques, images, symboles), mais seulement les e'le'ments de base.
Les re`gles de couleur peuvent ne'anmoins e^tre associe'es a` n'importe
quelle boi^te, et transmise par he'ritage jusqu'aux e'le'ments de base.
Comme pour les re`gles pre'ce'dentes, seul l'he'ritage avec la me^me valeur
est autorise'.

\begin{verbatim}
                 'Foreground' ':' NomHerit
                 'Background' ':' NomHerit
\end{verbatim}

Attention~: la couleur de fond n'apparai^t que pour les e'le'ments dont
le motif de remplissage n'empe^che pas la coloration du fond (voir
section~\ref{remplissage}).

\begin{example}
Pour indiquer que, dans les figures, tout doit e^tre trace' en bleu sur fond
jaune uni, on e'crit les re`gles~:

\begin{verbatim}
Figure :
   BEGIN
   Foreground : Blue;
   Background : Yellow;
   Fillpattern : backgroundcolor;
   END;
\end{verbatim}
et on associe aux e'le'ments qui composent les figures les re`gles~:
\begin{verbatim}
   Foreground : Enclosing =;
   Background : Enclosing =;
   Fillpattern : Enclosing =;
\end{verbatim}
\end{example}

\subsection{Contenu des boi^tes de pre'sentation}
\label{content}

La re`gle {\tt Content} s'applique aux boi^tes de pre'sentation.
Elle indique le contenu impose' a` une boi^te. Ce contenu est soit
la valeur d'une variable, soit la valeur d'une constante.
Dans le cas particulier des boi^tes de haut ou de bas de page (voir
page~\pageref{page}), le contenu peut aussi e^tre un type d'e'le'ment
structure'.

S'il s'agit d'une constante, on peut, comme dans une de'claration de variable,
indiquer soit le nom d'une constante de'clare'e dans la section {\tt CONST},
soit directement le type et la valeur du contenu de la boi^te.

De me^me, s'il s'agit d'une variable, on peut soit donner le nom de la
variable si elle a e'te' de'clare'e dans la section {\tt VAR},
soit de'finir la variable entre parenthe`ses. Le contenu de la
parenthe`se est alors constitue' de la me^me fac,on qu'une de'claration
de variable (voir page~\pageref{variables}).

S'il s'agit d'un type d'e'le'ment structure', le nom du type est simplement
indique' apre`s les deux-points. Dans ce cas, la boi^te a pour contenu tous
les e'le'ments de ce type qui sont de'signe's par des re'fe'rences faisant
partie de la page ou` se trouve la boi^te de haut ou de bas de page dont la
re`gle {\tt Content} indique le contenu.
Seuls des e'le'ments associe's peuvent figurer dans une re`gle {\tt Content},
et a` condition que le sche'ma de structure pre'voit des re'fe'rences a`
ces e'le'ments. De plus, la boi^te dont ils constituent le contenu doit e^tre
une boi^te de haut ou de bas de page engendre'e par une boi^te page de la
vue principale.

\begin{verbatim}
               'Content' ':' VarConst
     VarConst = IdentConst / TypeConst ValeurConst /
                IdentVar / '(' SuiteFonctions ')' /
                IdentElem .
\end{verbatim}

Une boi^te de pre'sentation ne peut avoir qu'une re`gle {\tt Content}, ce qui
veut dire que le contenu d'une boi^te de pre'sentation ne peut pas varier
d'une vue a` une autre. Cependant, si on recherche cet effet, on peut cre'er
plusieurs boi^tes de pre'sentation, avec chacune un contenu diffe'rent, et
chacune visible dans une seule vue.

La re`gle {\tt Content} peut e'galement s'appliquer aux e'le'ments de'finis
comme des re'fe'rences dans le sche'ma de structure. Dans ce cas,
le contenu de'fini par la re`gle doit e^tre une constante. C'est ce
contenu qui apparai^tra a` l'e'cran ou sur le papier pour repre'senter les
re'fe'rences du type auquel s'applique la re`gle.
Une re'fe'rence ne peut avoir qu'une re`gle {\tt Content} ou {\tt Copy}
(voir section~\ref{regleCopy}) pour chaque vue. Si elle n'a aucune de ces
deux re`gles, elle apparai^t sous la forme {\tt [*]}, ce qui est e'quivalent
a` la re`gle~:

\begin{verbatim}
     Content: Text '[*]';
\end{verbatim}


\begin{example}
Le contenu de la boi^te de pre'sentation cre'e'e pour faire apparai^tre le
nume'ro de chapitre et le nume'ro de section devant chaque titre de section
peut e^tre de'fini par~:

\begin{verbatim}
BOXES
     BoiteNumSection :
          BEGIN
          Content : NumSection;
          ...
          END;
\end{verbatim}
si la variable {\tt NumSection} a e'te' de'finie dans la section des de'finitions
de variables du sche'ma de pre'sentation. Sinon la re`gle content s'e'crit~:

\begin{verbatim}
BOXES
     BoiteNumSection :
          BEGIN
          Content : (VALUE (CptChapitre, Roman) TEXT '.'
                     VALUE (CptSection, Arabic));
          ...
          END;
\end{verbatim}

Pour indiquer qu'une boi^te de bas de page doit contenir tous les e'le'ments
de type {\tt Note} qui ont une re'fe'rence dans la page, on e'crit la re`gle~:
\begin{verbatim}
BOXES
     BoiteNotesBasPage :
          BEGIN
          Content : Note;
          ...
          END;
\end{verbatim}
{\tt Note} est de'fini comme un e'le'ment associe' dans le sche'ma de
structure et la boi^te {\tt BoiteNotesBasPage} est cre'e'e par une boi^te
page de la vue principale.
\end{example}

\subsection{Cre'ation de boi^tes de pre'sentation}
\label{creation}

Une re`gle de cre'ation indique qu'une boi^te de pre'sentation doit e^tre cre'e'e
quand apparai^t dans le document un e'le'ment du type auquel se rapporte
la re`gle.

Un mot cle' indique la position que prendra dans la
structure la boi^te a` cre'er, par rapport a` la boi^te de l'e'le'ment concerne'
par la re`gle~:

\begin{description}
\item[ {\tt CreateFirst} ]indique que la boi^te doit e^tre cre'e'e comme premie`re
boi^te du niveau infe'rieur (par rapport a` la boi^te cre'atrice), avant les
boi^tes qui existent de'ja`, et seulement si le de'but de l'e'le'ment cre'ateur
est visible~;

\item[ {\tt CreateLast} ]indique que la boi^te doit e^tre cre'e'e comme dernie`re
boi^te du niveau infe'rieur (par rapport a` la boi^te cre'atrice), apre`s les
boi^tes qui existent de'ja`, et seulement si la fin de l'e'le'ment cre'ateur
est visible~;

\item[ {\tt CreateBefore} ]indique que la boi^te doit e^tre cre'e'e au me^me
niveau que la boi^te cre'atrice, devant elle, et seulement si le de'but de
l'e'le'ment cre'ateur est visible~;

\item[ {\tt CreateAfter} ]indique que la boi^te doit e^tre cre'e'e au me^me
niveau et apre`s la boi^te cre'atrice, et seulement si la fin de l'e'le'ment
cre'ateur est visible~;

\item[ {\tt CreateEnclosing} ]indique que la boi^te doit e^tre cre'e'e au
niveau supe'rieur par rapport a` la boi^te cre'atrice, et qu'elle doit
englober cette boi^te cre'atrice ainsi que toutes les autres boi^tes de
pre'sentation cre'e'es par la me^me boi^te cre'atrice.

\end{description}

Ce mot cle' peut e^tre suivi du mot cle' {\tt Repeated} pour indiquer que
la boi^te doit e^tre cre'e'e pour chaque partie de l'e'le'ment cre'ateur.
Ces parties sont le re'sultat de la division de l'e'le'ment par des sauts
de page ou des changements de colonne. Si le mot cle' {\tt Repeated} est
absent, la boi^te n'est cre'e'e que pour la premie`re partie de l'e'le'ment
cre'ateur (re`gles {\tt CreateFirst} et {\tt CreateBefore}) ou que pour
la dernie`re partie (re`gles {\tt CreateLast} et {\tt CreateAfter}).

Le type de la boi^te de pre'sentation qui doit e^tre cre'e'e est indique'
en fin de re`gle, entre parenthe`ses.

Les re`gles de cre'ation ne peuvent pas figurer dans les re`gles de
pre'sentation par de'faut (voir page~\pageref{reglesdefaut}). Les boi^tes
cre'e'es doivent ne'cessairement posse'der une re`gle {\tt Content} qui
indique leur contenu (voir page~\pageref{content}).

Les re`gles de cre'ation ne peuvent apparai^tre que dans un bloc de re`gles qui
se rapporte a` la vue principale~; la cre'ation est provoque'e par un e'le'ment du
document et pour toutes les vues. Cependant, pour chaque vue, la boi^te
de pre'sentation n'est cre'e'e que si l'e'le'ment cre'ateur a lui-me^me une
boi^te dans la vue. De plus, dans les re`gles de'finissant la pre'sentation
de la boi^te cre'e'e, on peut jouer sur la visibilite' dans chaque vue pour
contro^ler la cre'ation de la boi^te de pre'sentation vue par vue.

\begin{verbatim}
                      Creation '(' IdentBoite ')'
     Creation       = Cree [ 'Repeated' ] .
     Cree           ='CreateFirst' / 'CreateLast' /
                     'CreateBefore' / 'CreateAfter' /
                     'CreateEnclosing' .
\end{verbatim}

\begin{example}
On de'finit un type d'objet, appele' Table, qui est constitue' d'une suite de
colonnes de me^me largeur, fixe, les colonnes e'tant se'pare'es les unes des
autres par des filets verticaux. Il y a un filet a` gauche de la premie`re
colonne et un a` droite de la dernie`re. Chaque colonne a un nombre variable
de cellules, positionne'es l'une en dessous de l'autre et se'pare'es par des
filets horizontaux. Il n'y a pas de filet au-dessus le la premie`re cellule
d'une colonne ni au-dessous de la dernie`re. Le texte contenu dans chaque
cellule est de'coupe' en lignes et ces lignes sont centre'es horizontalement
dans la cellule. La structure logique de cet objet est de'finie par~:

\begin{verbatim}
Table   = LIST OF (Colonne);
Colonne = LIST OF (Cellule = Text);
\end{verbatim}

\begin{figure}
\begin{center}
\setlength{\unitlength}{1 mm}
\begin{picture}(90,45)
\put(0,0){\line(0,1){45}}
\put(30,0){\line(0,1){45}}
\put(60,0){\line(0,1){45}}
\put(90,0){\line(0,1){45}}
\put(0,15){\line(1,0){30}}
\put(30,20){\line(1,0){30}}
\put(0,25){\line(1,0){30}}
\put(60,30){\line(1,0){30}}
\put(30,40){\line(1,0){30}}
\put(1,1){\shortstack{xxx xxxx xx x\\xx xxxxx xxxx x\\xx xxx xxxxx x\\xxx x
 xxxxx xx\\xxxx xx}}
\put(31,3){\shortstack{xxx xxxxx xx\\xx xxx x xxxxxx\\xx xxxx x xxxx\\
 xxxxx xx xxxxx\\xxxx xx xxxxx\\xxxxxx}}
\put(61,4){\shortstack{xx xxxx xxxxx\\xxx xxxxx xx\\xx xxxx xxxxxx\\xxxx x xxx
\\xxxxx xx xxx xx\\x xxx xxxx xx\\xxxx xx xxxx xx\\xxxxx xx xxxx\\xxxx xx}}
\put(2,18){\shortstack{xxxx xxx x xxx\\xxx x xxxx xx}}
\put(32,21){\shortstack{xx xx xxxx xx\\x xxx xxx xxxx\\xx xxxxx x x\\xxxxx xx
xxx\\xxxxx xx xxx\\x xxx xxxx xx\\xxxxx x}}
\put(61,31){\shortstack{x xxx xxx xxx\\xxx xxx x xxxxx\\xxxx x xx xxx\\
x xx xxxx x\\xxx}}
\put(1,28){\shortstack{xx xxxxx xxxx\\xxxx xxx x xxxx\\xxx xx x xxx\\xx xxxxx
xx x\\xxx xx xxx x\\xxx}}
\put(31,42){\shortstack{x xxx xxx xxxxx}}
\end{picture}
\end{center}
\caption{L'image d'une table}
\label{table}
\end{figure}
La pre'sentation de la table doit ressembler au dessin de la
figure~\ref{table}. Elle est de'finie par l'extrait de sche'ma de
pre'sentation suivant~:

\begin{verbatim}
BOXES
     FiletVert : BEGIN
                 Width : 0.3 cm;
                 Height : Enclosing . Height;
                 VertPos : Top = Enclosing . Top;
                 HorizPos : Left = Previous . Right;
                 Content : Graphics 'v';
                 END;

     FiletHoriz: BEGIN
                 Width : Enclosing . Width;
                 Height : 0.3 cm;
                 VertPos : Top = Previous . Bottom;
                 HorizPos : Left = Enclosing . Left;
                 Content : Graphics 'h';
                 END;

RULES
     Colonne : BEGIN
               CreateBefore (FiletVert);
               IF LAST CreateAfter (FiletVert);
               Width : 2.8 cm;
               Height : Enclosed . Height;
               VertPos : Top = Enclosing . Top;
               HorizPos : Left = Previous . Right;
               END;

     Cellule : BEGIN
               IF NOT FIRST CreateBefore (FiletHoriz);
               Width : Enclosing . Width;
               Height : Enclosed . Height;
               VertPos : Top = Previous . Bottom;
               HorizPos : Left = Enclosing . Left;
               Line;
               Adjust : VMiddle;
               END;
\end{verbatim}
On remarque que la re`gle de positionnement horizontal du premier filet
vertical ne peut pas e^tre applique'e, puisqu'il n'y a pas de boi^te
pre'ce'dente. Dans ce cas, la boi^te est simplement positionne'e sur le co^te'
gauche de sa boi^te englobante.

\end{example}

\subsection{Mise en page}
\label{page}

Les mode`les de page indique's dans la re`gle {\tt Page} sont de'finis par des
boi^tes de'clare'es dans la section {\tt BOXES} du sche'ma de pre'sentation.
Les pages ne sont pas de'crites comme des cadres qui seraient remplis par le
texte du document, mais comme des e'le'ments qui s'inse`rent dans le fil du
document et qui marquent les ruptures de page. Chacun de ces e'le'ments sauts
de page comporte des boi^tes de pre'sentation qui repre'sentent les boi^tes de
bas de page d'une page, suivies des boi^tes de haut de page de la page
suivante. La boi^te page elle-me^me est le simple filet qui se'pare deux
pages a` l'e'cran. Les boi^tes de bas de page se placent par rapport a` cette
boi^te de se'paration de page, au-dessus d'elle, et les boi^tes de haut de
page se placent e'galement par rapport a` cette boi^te, mais au-dessous.

Les boi^tes cre'e'es par une boi^te page sont des boi^tes de haut et de bas
de page et ne peuvent se placer verticalement que par rapport a` la boi^te
page elle-me^me (qui est en fait la se'paration entre deux pages). C'est
d'ailleurs leur re`gle de positionnement vertical qui de'termine si ce sont des boi^tes
de haut ou de bas de page. Les boi^tes de bas et de haut de page doivent
ne'cessairement porter une re`gle de positionnement vertical explicite (elle
ne doivent pas utiliser la re`gle par de'faut) et ce positionnement doit se
faire par rapport a` la boi^te page (se'parateur de pages).

Les boi^tes de bas de page doivent avoir une hauteur absolue ou he'riter de
la hauteur de leur contenu~:
\begin{verbatim}
Height : Enclosed . Height;
\end{verbatim}

Une boi^te page doit ne'cessairement porter une re`gle de hauteur et une re`gle
de largeur, et ces deux re`gles doivent indiquer des valeurs imme'diates,
exprime'es en centime`tres, en pouces ou en points typographiques. Ces deux
re`gles sont interpre'te'es d'une fac,on particulie`re pour les boi^tes pages~:
elles de'terminent la largeur de la page et la distance verticale entre deux
se'parateurs de pages, c'est-a`-dire la hauteur de toute la page, boi^tes de
haut et de bas de page comprises.

Une boi^te page doit e'galement porter une re`gle de position verticale et une
re`gle de position horizontale, et ces deux re`gles doivent indiquer la
position dans la feuille de papier du rectangle englobant tout le contenu
d'une page. Ces deux re`gles doivent ne'cessairement positionner le coin
supe'rieur gauche du rectangle englobant par rapport au coin supe'rieur gauche
de la feuille de papier, conside're'e comme l'e'le'ment englobant. Dans ces deux
re`gles, les distances doivent e^tre exprime'es en unite's fixes~: centime`tres
({\tt cm}), pouces ({\tt in}) ou points typographiques ({\tt pt}). Dans les
re`gles d'une boi^te page, on doit donc trouver des re`gles semblables aux
suivantes~:

\begin{verbatim}
BOXES
   LaPage :
      BEGIN
      VertPos : Top = Enclosing . Top + 3 cm;
      HorizPos : Left = Enclosing . Left + 2.5 cm;
      Width : 16 cm;
      Height : 22.5 cm;
      END;
\end{verbatim}

Lorsqu'un document doit e^tre de'coupe' en pages, on de'finit dans la section
{\tt BOXES} du sche'ma de pre'sentation les mode`les des pages a` construire en
de'clarant les boi^tes pages et les boi^tes de haut et de bas de page, et
on indique par la re`gle {\tt Page} a` quelle partie du document ou a` quelles
vues s'applique chaque mode`le.

La re`gle {\tt Page} n'a qu'un parame`tre, indique' entre parenthe`ses apre`s le
mot cle' {\tt Page}. Ce parame`tre est le nom de la boi^te qui doit servir de
mode`le a` la construction des pages. Lorsqu'une re`gle {\tt Page} est associe'e
a` un type d'e'le'ment, chaque fois qu'un e'le'ment de ce type apparai^t dans un
document, un saut a` la page a lieu et le mode`le de page indique' dans la
re`gle s'applique a` tout ce qui suit, jusqu'au prochain e'le'ment auquel est
associe' une re`gle {\tt Page}.

La re`gle {\tt Page} s'applique a` une seule vue~; si elle figure dans
les re`gles de la vue principale, une re`gle {\tt Page} ne s'applique qu'a`
cette vue. On peut ainsi de'finir des pages diffe'rentes pour l'ensemble du
document et pour sa table des matie`res, qui est une autre vue du me^me
document. On peut aussi de'finir des vues sans pages et des vues avec pages
pour le me^me document.

\begin{verbatim}
                   'Page' '(' IdentBoite ')'
\end{verbatim}

\subsection{Copies de boi^tes}
\label{regleCopy}

La re`gle {\tt Copy} peut e^tre utilise'e pour un e'le'ment qui est de'fini
comme une re'fe'rence dans le sche'ma de structure. Dans ce cas, la re`gle
indique, entre parenthe`ses, le nom de la boi^te (de'clare'e dans la section
{\tt BOXES}) qui doit e^tre produite lorsque cette re'fe'rence apparai^t dans
la structure d'un document. La boi^te produite est une copie (me^me contenu,
mais pre'sentation e'ventuellement diffe'rente) de la boi^te du type indique'
en parame`tre entre parenthe`ses, et qui est dans l'e'le'ment de'signe' par
la re'fe'rence.
A` la place d'un nom de boi^te, on peut mettre un nom de type. C'est alors le
contenu de l'e'le'ment de ce type, a` l'inte'rieur de l'e'le'ment
de'signe' par la re'fe'rence, qui est copie'.

Qu'il s'agisse d'un nom de boi^te ou d'un nom de type, ce nom peut e^tre
suivi, entre parenthe`ses, du nom d'un sche'ma de structure. Cela signifie
que la boi^te ou le type est de'fini dans le sche'ma de structure indique'
dans la parenthe`se, et non dans celui auquel est associe' le sche'ma de
pre'sentation ou` se trouve la re`gle.

La re`gle {\tt Copy} peut aussi e^tre applique'e a` une boi^te de
pre'sentation. S'il s'agit d'une boi^te de pre'sentation cre'e'e par un
attribut re'fe'rence, la re`gle s'applique comme dans le cas d'un e'le'ment
re'fe'rence~: le contenu de la boi^te qui porte la re`gle {\tt Copy} de'pend
de l'e'le'ment de'signe' par l'attribut re'fe'rence.
Dans les autres cas de boi^te de pre'sentation, la re`gle {\tt Copy} accepte
en parame`tre un nom de type, qui peut aussi e^tre suivi entre parenthe`ses
du nom d'un sche'ma de structure ou` ce type est de'fini, s'il n'est pas
de'fini dans le me^me sche'ma.
La boi^te qui porte cette re`gle a alors pour contenu une copie de
l'e'le'ment de ce type qui se trouve dans l'e'le'ment cre'ant la boi^te
de pre'sentation, ou a` de'faut celui qui pre'ce`de la boi^te de pre'sentation.
Cette dernie`re facilite' est par exemple utilise'e pour de'finir les titres
courants de haut ou de bas de page.

\begin{verbatim}
               'Copy' '(' BoiteTypeACopier ')' .
  BoiteTypeACopier = IdentBoite [ StructExt ] /
                     IdentElem [ StructExt ] .
  StructExt        = '(' IdentElem ')' .
\end{verbatim}

Comme les re`gles de cre'ation, la re`gle {\tt Copy} ne peut pas figurer dans
les re`gles de pre'sentation par de'faut (voir page~\pageref{reglesdefaut}).
De plus, cette re`gle ne peut apparai^tre que dans un bloc de re`gles qui
se rapporte a` la vue principale~; la copie est applique'e  pour toutes les
vues.

\begin{example}
Si on a, dans le sche'ma de structure, les de'finitions suivantes~:

\begin{verbatim}
Corps = LIST OF (Chapitre =
                     BEGIN
                     Titre_Chapitre = Text;
                     Corps_Chapitre = Suite_Sections;
                     END);
Ref_Chapitre = REFERENCE (Chapitre);
\end{verbatim}
on peut spe'cifier les re`gles de pre'sentation suivantes, parmi les autres
re`gles du sche'ma de pre'sentation~:

\begin{verbatim}
COUNTERS
   Cpt_Chapitre : RANK OF Chapitre;
BOXES
   Numero_Chapitre :
      BEGIN
      Content : (VALUE (Cpt_Chapitre, URoman));
      ...
      END;
RULES
   Chapitre :
      BEGIN
      CreateFirst (Numero_Chapitre);
      ...
      END;
   Ref_Chapitre :
      BEGIN
      Copy (Numero_Chapitre);
      ...
      END;
\end{verbatim}
qui ont pour effet de faire apparai^tre, a` la place de la re'fe'rence a` un
chapitre, le nume'ro, en chiffres romains, du chapitre de'signe' par la
re'fe'rence. Mais si on souhaite pluto^t faire apparai^tre le titre du chapitre
a` la place de la re'fe'rence, la re`gle {\tt Copy} doit e^tre e'crite~:

\begin{verbatim}
      Copy (Titre_Chapitre);
\end{verbatim}

Pour de'finir une boi^te de haut de page, de nom {\tt Titre\_Courant}, qui
contient le titre du chapitre courant, on de'finit le contenu de cette boi^te
de la fac,on suivante~:
\begin{verbatim}
BOXES
   Titre_Courant :
      Copy (Titre_Chapitre);
\end{verbatim}

\end{example}


\chapter{Langage T}

\section{Traduction des documents}

Gra^ce au mode`le retenu, Thot peut produire des documents sous une forme
abstraite de haut niveau. Cette forme, appele'e forme pivot, est spe'cifique
a` Thot~; elle est bien adapte'e aux manipulations que fait l'e'diteur, mais
elle ne convient pas ne'cessairement aux autres traitements que l'on
souhaiterait appliquer aux documents. C'est pourquoi l'e'diteur Thot propose
de sauver les documents dans son format propre (format pivot) ou dans l'un
des formats de'finis par l'utilisateur. Dans ce dernier cas, le document
Thot est traite' par le programme de traduction --- ou d'exportation,
destine' a` convertir les documents dans d'autres formalismes.

\subsection{Principes de la traduction}

La traduction des documents permet de les exporter vers d'autres syste`mes
qui n'acceptent pas en entre'e la forme pivot de Thot. Parmi ces syste`mes,
on peut notamment citer les formateurs, comme \TeX, \LaTeX, Scribe ou Troff.
On peut aussi traduire les documents dans des formalismes normalise's, comme
{\sc sgml} ou {\sc html}. Pour ouvrir tre`s largement les possibilite's d'exportation,
Thot n'impose pas un choix limite' de traductions, mais permet au contraire
a` chaque utilisateur de de'finir les formalismes vers lesquels
il veut traduire ses documents.

Pour chaque classe de documents ou d'objets, on peut de'finir un ensemble
de re`gles de traduction qui spe'cifient comment on passe de la forme pivot
a` un formalisme donne'. Ces re`gles de traduction sont regroupe'es dans des
{\em sche'mas de traduction}, chaque sche'ma contenant les re`gles
ne'cessaires a` la traduction d'une structure logique ge'ne'rique (structure
de document ou d'objet) vers un formalisme donne'. Pour une me^me structure
logique ge'ne'rique on peut disposer de plusieurs sche'mas de traduction qui
de'finissent chacun les re`gles de traduction vers un formalisme diffe'rent.
On peut aussi, par plusieurs sche'mas de traduction, de'finir les conversions
de diffe'rentes structures logiques ge'ne'riques vers le me^me formalisme.

Comme les sche'mas de pre'sentation, les sche'mas de traduction se placent au
niveau ge'ne'rique. Ils s'appliquent donc a` toute une classe de documents ou
d'objets et permettent de traduire tous les documents ou objets de cette
classe.

\subsection{Mise en oeuvre de la traduction}

Le traducteur travaille sur la structure logique spe'cifique du document
qu'il traduit. Il parcourt l'arbre principal de cette structure logique dans
l'ordre pre'fixe' et, a`
chaque noeud rencontre', il applique les re`gles de traduction correspondantes
de'finies dans le sche'ma de traduction. Des re`gles de traduction peuvent
e^tre associe'es
\begin{itemize}
\item aux types d'e'le'ments de'finis dans le sche'ma de structure,
\item aux attributs (globaux ou locaux) de'finis dans le sche'ma de structure,
\item aux re`gles de pre'sentation spe'cifique,
\item au contenu des feuilles de la structure (caracte`res, symboles et
 e'le'ments graphiques).
\end{itemize}
Ainsi, pour chaque noeud, le traducteur applique toutes les re`gles
associe'es au type de l'e'le'ment, toutes les re`gles associe'es a` chaque
attribut (global ou local) porte' par l'e'le'ment,
toutes les re`gles associe'es aux re`gles de pre'sentation spe'cifique
porte'es par l'e'le'ment,
et, si l'e'le'ment est une
feuille de l'arbre, il applique de plus les re`gles de traduction des
caracte`res, des symboles ou des e'le'ments graphiques, selon le type de la
feuille.

Les re`gles associe'es aux types d'e'le'ments,
aux re`gles de pre'sentation spe'cifique
et aux attributs sont les me^mes.
Les re`gles associe'es au contenu des feuilles sont d'une nature diffe'rente~:
elles indiquent seulement comment traduire les chai^nes de caracte`res, les
symboles et les e'le'ments graphiques.

Les re`gles applicables aux e'le'ments de structure,
aux re`gles de pre'sentation spe'cifique
et aux attributs permettent principalement
\begin{itemize}
\item d'engendrer un texte constant ou variable avant ou apre`s le contenu
d'un e'le'ment,
\item de modifier l'ordre dans lequel les e'le'ments apparaissent apre`s
traduction,
\item de supprimer un e'le'ment dans le document traduit,
\item d'e'crire des messages sur le terminal de l'utilisateur, pendant la
traduction.
\end{itemize}

\section{Langage de de'finition des traductions}

Les sche'mas de traduction sont e'crits dans un langage adapte', le langage T.
C'est ce langage qui est de'crit dans la suite de ce chapitre. On utilise ici
le me^me me'ta-langage que pour les langages S et P (voir
page~\pageref{metalang}) et les sche'mas de traduction s'e'crivent avec les
me^mes conventions d'e'criture que les sche'mas de structure ou de
pre'sentation. Rappelons notamment que les mots cle's du langage T
(les chai^nes entre apostrophes dans les re`gles syntaxiques suivantes)
peuvent e^tre e'crits aussi bien en majuscules qu'en minuscules ou dans un
me'lange de majuscules et de minuscules, mais que les identificateurs cre'e's
par le programmeur, eux, doivent toujours e^tre e'crits de la me^me fac,on.

\subsection{Organisation d'un sche'ma de traduction}

Un sche'ma de traduction commence par le mot {\tt TRANSLATION} et se termine
par le mot {\tt END}. Le mot {\tt TRANSLATION} est suivi du nom de la
structure ge'ne'rique dont le sche'ma de'finit la traduction, et d'un
point-virgule. Ce nom doit e^tre identique a` celui qui figure apre`s le
mot cle' {\tt STRUCTURE} dans le sche'ma de structure auquel est associe' le
sche'ma de traduction.

Apre`s cette de'claration du nom de structure, apparaissent, dans l'ordre~:
\begin{itemize}
\item la longueur des lignes produites par la traduction,
\item le caracte`re de'limitant la fin de la ligne,
\item la chai^ne de caracte`res que le traducteur inse`rera s'il doit
mettre en lignes le texte traduit,
\item les de'clarations
   \begin{itemize}
   \item des buffers,
   \item des compteurs,
   \item des constantes,
   \item des variables~;
   \end{itemize}
\item les re`gles de traduction associe'es aux types des e'le'ments,
\item les re`gles de traduction associe'es aux attributs,
\item les re`gles de traduction associe'es aux re`gles de pre'sentation
      spe'cifique,
\item les re`gles de traduction des chai^nes de caracte`res, des symboles et
      des e'le'ments graphiques.
\end{itemize}

Chacune de ces sections est introduite par un mot cle' suivi d'une suite de
de'clarations. Toutes ces sections sont facultatives, a` l'exception des
re`gles de traduction associe'es aux types d'e'le'ments. Plusieurs sections
{\tt TEXTTRANSLATE} peuvent apparai^tre, chacune de'finissant les re`gles
de transcodage des chai^nes de caracte`res d'un alphabet donne'.

\begin{verbatim}
     SchemaTrad ='TRANSLATION' IdentElem ';'
               [ 'LINELENGTH' LongueurLigne ';' ]
               [ 'LINEEND' CARACTERE ';' ]
               [ 'LINEENDINSERT' STRING ';' ]
               [ 'BUFFERS' SuiteBuffers ]
               [ 'COUNTERS' SuiteCompteurs ]
               [ 'CONST' SuiteConst ]
               [ 'VAR' SuiteVariables ]
                 'RULES' LesRegles
               [ 'ATTRIBUTES' SuiteAttr ]
               [ 'PRESENTATION' SuitePres ]
               < 'TEXTTRANSLATE' SuiteTradTexte >
               [ 'SYMBTRANSLATE' SuiteTrad ]
               [ 'GRAPHTRANSLATE' SuiteTrad ]
                 'END' .
\end{verbatim}

\subsection{Longueur des lignes produites}
\label{longueurligne}

Si une instruction {\tt LINELENGTH} est pre'sente apre`s la de'claration de
structure, le traducteur divisera en lignes le texte qu'il produit, chaque
ligne ayant une longueur au plus e'gale au nombre entier qui suit le mot
{\tt LINELENGTH}. Cette longueur maximum de ligne est exprime'e en nombre de
caracte`res. La fin d'une ligne est marque'e par le caracte`re de'fini
par l'instruction {\tt LINEEND}.
Le traducteur coupe les lignes sur un caracte`re espace du texte
engendre', cet espace e'tant remplace' par la chai^ne de caracte`res
de'finie au moyen de l'instruction {\tt LINEENDINSERT}.

Si l'instruction {\tt LINEEND} n'est pas de'finie le caracte`re saut
de ligne (code octal 12) est pris comme marque de fin de ligne par de'faut.
Si l'instruction {\tt LINEENDINSERT} n'est pas de'finie le caracte`re saut
de ligne est inse're' a` la fin des lignes produites.
S'il n'y a pas d'instruction {\tt LINELENGTH}, le texte traduit n'est pas
divise' en lignes. Toutefois, si les re`gles de traduction engendrent des
marques de fin de ligne, ces marques restent
dans le texte traduit, mais la longueur des lignes n'est pas contro^le'e
par le traducteur.

\begin{verbatim}
     LongueurLigne = NUMBER .
\end{verbatim}

\begin{example}
Si on veut limiter les lignes produites par le traducteur a` une longueur
de 80 caracte`res, on e'crit au de'but du sche'ma de traduction~:
\begin{verbatim}
LineLength 80;
\end{verbatim}
\end{example}

\subsection{Buffers}

Un buffer est un espace de me'moire ge're' par le traducteur, qui peut
contenir soit un texte lu au terminal pendant la traduction (voir la re`gle
{\tt Read}), soit le nom de la dernie`re image (bit-map) rencontre'e par le
traducteur dans son parcours du document. Rappelons que les images sont
conserve'es dans des fichiers se'pare's des fichiers documents et que la
forme pivot ne contient que les noms des fichiers ou` se trouvent les images.

Il y a donc deux types de buffers~: les buffers de lecture pour le terminal
(remplis par la re`gle {\tt Read}) et le buffer des noms d'image (contenant
le nom de la dernie`re image rencontre'e). Un sche'ma de traduction peut
utiliser aucun, un ou plusieurs buffers de lecture et e'ventuellement un
(et un seul) buffer de nom d'image.

Si au moins un buffer est utilise', le mot cle' {\tt BUFFERS} doit e^tre
pre'sent, suivi des de'clarations de tous les buffers utilise's dans le
sche'ma de traduction. Chaque de'claration de buffer est constitue'e seulement
du nom de ce buffer, choisi librement par le programmeur. Le buffer de nom
d'image est identifie' par le mot cle' {\tt Picture}, entre parenthe`ses, a`
la suite du nom du buffer. Le mot cle' {\tt Picture} ne peut apparai^tre
qu'une fois. Chaque de'claration de buffer est termine'e par un point-virgule.

\begin{verbatim}
     SuiteBuffers = Buffer < Buffer > .
     Buffer       = IdentBuffer [ '(' 'Picture' ')' ] ';' .
     IdentBuffer  = NAME .
\end{verbatim}

\begin{example}
Si on a besoin d'un buffer de nom d'image, que l'on veut nommer {\tt NomImage},
et d'un buffer de lecture au terminal, que l'on veut nommer {\tt NomDest}, on
e'crit~:
\begin{verbatim}
BUFFERS
     NomImage (Picture); NomDest;
\end{verbatim}
\label{nomdest}
\end{example}

\subsection{Compteurs}
\label{compteurs}

Certaines re`gles de traduction engendrent un texte qui peut varier selon le
contexte de l'e'le'ment auquel elles s'appliquent. Ces textes variables sont
de'finis soit dans la section {\tt VAR} du sche'ma de traduction (voir
section~\ref{sectvar}) soit dans la re`gle elle-me^me (voir notamment les
re`gles {\tt Create} et {\tt Write}). Ils font appel aux compteurs pour
le calcul des parties variables.

Il y a deux types de compteurs~: ceux dont la valeur est calcule'e
explicitement par application des re`gles {\tt Set} et {\tt Add} du
sche'ma de traduction (voir section~\ref{setandadd}) et ceux dont la
valeur est calcule'e par une fonction associe'e au compteur. Ces
fonctions permettent le me^me type de calcul que dans les sche'mas de
pre'sentation.
Comme dans un sche'ma de pre'sentation, les compteurs doivent e^tre de'finis
dans la section {\tt COUNTERS} du sche'ma de traduction avant d'e^tre
utilise's.

Lorsque des compteurs sont utilise's dans un sche'ma de traduction, le
mot cle' {\tt COUNTERS} est suivi de la de'claration de tous les compteurs
utilise's. Chaque de'claration est forme'e du nom du compteur, suivi
e'ventuellement de deux-points et de la fonction de comptage a` appliquer
au compteur. La de'claration se termine par un point-virgule. S'il s'agit
d'un compteur dont la valeur est calcule'e explicitement par application de
re`gles {\tt Set} et {\tt Add}, aucune fonction de comptage n'est indique'e.
Si une fonction de comptage est indique'e, aucune re`gle {\tt Set}
ou {\tt Add} ne doit e^tre applique'e a` ce compteur.

La fonction de comptage indique le mode de calcul de la valeur du compteur.
Trois fonctions sont disponibles~: {\tt Rank}, {\tt Rlevel} et {\tt Set}.

\begin{itemize}
\item
{\tt Rank of IdentElem} indique que le compteur prend pour valeur le rang de
l'e'le'ment pour lequel on e'value le compteur, dans le cas ou` cet e'le'ment est de
type {\tt IdentElem}, et, dans le cas contraire, le rang de l'e'le'ment de type
{\tt IdentElem} qui englobe l'e'le'ment pour lequel on e'value le compteur. Cette
fonction est principalement utilise'e lorsque l'e'le'ment {\tt IdentElem} fait
partie d'un agre'gat ou d'une liste~; elle donne pour valeur au compteur le
rang de l'e'le'ment dans sa liste ou son agre'gat. Notons que, a` la diffe'rence
de la fonction {\tt Rank} des sche'mas de pre'sentation, on ne peut pas
utiliser le mot {\tt Page} a` la place de {\tt IdentElem}.

Le nom du type {\tt IdentElem} peut e^tre suivi d'un nombre entier,
e'ventuellement ne'gatif. Ce nombre repre'sente le niveau relatif, parmi
les ascendants de l'e'le'ment concerne', de l'e'le'ment dont on veut le
rang. Si ce niveau relatif {\it n} est non signe', on prend le rang du $n^e`me$
e'le'ment du type indique' que l'on rencontre sur le chemin qui va, dans
la structure logique du document, de la racine vers l'e'le'ment concerne'.
Si le niveau relatif est ne'gatif, on parcourt le me^me chemin en sens inverse,
de l'e'le'ment cconcerne' vers la racine.

\item
{\tt Rlevel of IdentElem} indique que le compteur prend pour valeur le
niveau relatif dans l'arbre de l'e'le'ment pour lequel on e'value le compteur.
Le compteur compte le nombre d'e'le'ments de type {\tt IdentElem} qui se
trouvent sur le chemin entre la racine de l'arbre de la structure logique
du document et l'e'le'ment concerne', lui-me^me compris.

\item
{\tt Set n on Type1 Add m on Type2} indique que la valeur du compteur est
calcule'e comme si, en parcourant le document depuis le de'but jusqu'a`
l'e'le'ment pour lequel on e'value le compteur, on affectait au compteur la
valeur {\tt n} chaque fois qu'on rencontre un e'le'ment de type {\tt Type1}
et qu'on incre'mentait le compteur de {\tt m} chaque fois qu'on rencontre
un e'le'ment de type {\tt Type2}. La valeur initiale {\tt n} et l'incre'ment
{\tt m} sont des entiers.
\end{itemize}

Comme dans un sche'ma de pre'sentation, les fonctions {\tt Rank} et
{\tt Set} peuvent e^tre modifie'es par un attribut nume'rique qui change
la valeur initiale. Cela est indique' par le mot cle' {\tt Init} suivi du
nom de l'attribut nume'rique. Dans le cas de la fonction {\tt Set}, c'est
alors la valeur de l'attribut qui est prise a` la place de {\tt ValeurInit},
si l'attribut est pre'sent dans le document traite'.
Dans le cas de la fonction {\tt Rank}, si l'attribut est pre'sent, le rang
du premier e'le'ment de la liste n'est pas 1, mais la valeur de cet attribut,
et le rang de tous les autres e'le'ments est de'cale' de la me^me fac,on.
Dans les deux cas, l'attribut doit e^tre de type nume'rique et il doit e^tre
un attribut local de la racine du document lui-me^me.

\begin{verbatim}
     SuiteCompteurs = Compteur < Compteur > .
     Compteur       = IdentCompteur
                          [ ':' FonctCompteur ] ';' .
     IdentCompteur  = NAME .
     FonctCompteur  ='Rank' 'of' IdentElem [ SNiveauAsc ]
                      [ 'Init' IdentAttr ] /
                     'Rlevel' 'of' IdentElem /
                     'Set' ValeurInit 'On' IdentElem
                     'Add' Increment 'On' IdentElem
                      [ 'Init' IdentAttr ] .
     SNiveauAsc     = [ '-' ] NiveauAsc .
     NiveauAsc      = NUMBER .
     ValeurInit     = NUMBER .
     Increment      = NUMBER .
     IdentElem      = NAME .
\end{verbatim}

\begin{example}
Si le corps d'un chapitre est de'fini dans le sche'ma de structure par~:
\begin{verbatim}
Corps_Chapitre = LIST OF
         (Section = BEGIN
                    Titre_Section = Text;
                    Corps_Section = BEGIN
                                    Paragraphes;
                                    Section;
                                    END;
                    END
         );
\end{verbatim}
(la section a une de'finition re'cursive), on peut de'finir un compteur
donnant le nume'ro d'une section a` l'inte'rieur son niveau hie'rarchique~:
\begin{verbatim}
COUNTERS
   NumeroSection : Rank of Section;
\end{verbatim}
\label{numsect}
un compteur donnant le niveau hie'rarchique d'une section~:
\begin{verbatim}
   NiveauSection : Rlevel of Section;
\end{verbatim}
un compteur nume'rotant se'quentiellement toutes les sections du document,
quel que soit leur niveau hie'rarchique~:
\begin{verbatim}
   NumUniqueSect : Set 0 on Document Add 1 on Section;
\end{verbatim}
\label{numunique}
\end{example}

\subsection{Constantes}

Les re`gles de traduction permettent notamment d'engendrer un texte constant.
Ce texte peut e^tre de'fini dans la re`gle me^me qui l'engendre (voir par
exemple les re`gles {\tt Create} et {\tt Write})~; mais il peut aussi e^tre
de'fini une fois dans la section des de'clarations de constantes et utilise'
plusieurs fois dans des re`gles diffe'rentes. Cette dernie`re solution est
pre'fe'rable de`s qu'un me^me texte est utilise' dans plusieurs re`gles ou
plusieurs variables (voir section~\ref{sectvar}).

Le mot cle' {\tt CONST} pre'ce`de toutes les de'clarations de constante.
Il doit e^tre omis si aucune constante n'est de'clare'e. Chaque de'claration
de constante est forme'e d'un nom, le nom donne' a` la constante, d'un signe
{\tt =} et de la valeur de la constante, qui est une chai^ne de caracte`res
entre apostrophes. Une de'claration de constante se termine par un
point-virgule.

\begin{verbatim}
     SuiteConst  = Const < Const > .
     Const       = IdentConst '=' ValeurConst ';' .
     IdentConst  = NAME .
     ValeurConst = STRING .
\end{verbatim}

\label{txtniveau}
\begin{example}
Pour donner le nom {\tt TxtNiveau} a` la chai^ne de caracte`res ``Niveau'',
on e'crit~:
\begin{verbatim}
CONST
     TxtNiveau = 'Niveau';
\end{verbatim}
\end{example}

\subsection{Variables}
\label{sectvar}

Les variables permettent de de'finir les noms des fichiers a` produire ou
les textes variables qui sont engendre's par les re`gles {\tt Create} et
{\tt Write}. Les variables peuvent e^tre de'finies soit dans la section
{\tt VAR} du sche'ma de traduction, soit directement dans les re`gles qui
les utilisent. Les variables qui de'finissent des noms de fichiers doivent
e^tre de'clare'es dans la section {\tt VAR} et de`s qu'une me^me variable est
utilise'e plusieurs fois dans le sche'ma de traduction, on a inte're^t a` la
de'finir globalement dans la section {\tt VAR}. Cette section n'est pre'sente
que si au moins une variable est de'finie globalement.

Apre`s le mot cle' {\tt VAR}, chaque variable globale est de'finie par son
nom, le se'parateur deux-points et une suite de fonctions (au moins une fonction).
Chaque variable se termine par un point-virgule.
Les fonctions de'terminent les diffe'rents constituants qui donnent la valeur
de la variable. La valeur est obtenue par concate'nation des chai^nes produites
par chacune des fonctions. Sept types de fonctions sont disponibles. Dans
chaque variable on peut utiliser aucune, une ou plusieurs fonctions de
chaque type.

\begin{itemize}
\item
La fonction {\tt Value(Compteur)} produit une chai^ne repre'sentant la
valeur que prend le compteur lorsqu'on l'e'value pour l'e'le'ment auquel
s'applique la re`gle qui utilise la variable. Le compteur doit avoir e'te'
de'clare' dans la section {\tt COUNTERS} du sche'ma de traduction. Lorsque
le compteur doit e^tre exprime' en chiffres arabes, le nom
du compteur peut e^tre suivi de deux-points et d'un entier qui indique la
longueur minimum (nombre de caracte`res) de la chai^ne a` produire~; si
la valeur du compteur s'exprime avec un nombre de chiffres infe'rieur a`
la longueur demande'e, des 0 sont ajoute's en te^te pour obtenir cette
longueur.

Par de'faut, la valeur d'un compteur est produite sous la forme d'un nombre
en chiffres arabes. Si une autre forme est souhaite'e, il faut faire
suivre le nom du compteur d'une virgule et d'un des mots cle's suivants~:
  \begin{itemize}
  \item
  {\tt Arabic} : chiffres arabes (par de'faut),
  \item
  {\tt LRoman} : chiffres romains minuscules,
  \item
  {\tt URoman} : chiffres romains majuscules,
  \item
  {\tt Uppercase} : lettre majuscule, selon l'ordre alphabe'tique,
  \item
  {\tt Lowercase} : lettre minuscule, selon l'ordre alphabe'tique.
  \end{itemize}

\item
La fonction {\tt FileDir}, sans parame`tre, produit une chai^ne
repre'sentant le nom du re'pertoire du fichier de sortie qui a e'te'
passe' a` l'appel du programme de traduction. Ce nom comporte un
caracte`re '/' a` la fin.

\item
La fonction {\tt FileName}, sans parame`tre, produit une chai^ne
repre'sentant le nom du fichier de sortie qui a e'te' passe' a` l'appel
du programme de traduction. Ce nom ne comporte pas l'e'ventuelle
extension (ou suffixe).

\item
La fonction {\tt Extension}, sans parame`tre, produit une chai^ne
repre'sentant l'extension du nom du fichier de sortie qui a e'te' passe'
a` l'appel du programme de traduction. Cette chai^ne est vide si
aucune extension n'a e'te' fournie, sinon, elle comporte toujours un
point en premier caracte`re.

\item
La fonction {\tt DocumentName}, sans parame`tre, produit une chai^ne
repre'sentant le nom du document en cours de traduction.

\item
La fonction {\tt DocumentDir}, sans parame`tre, produit une chai^ne
repre'sentant le nom du re'pertoire ou` se trouve le fichier contenant
le document en cours de traduction.

\item
La fonction forme'e par un simple nom de constante produit la valeur de cette
constante.

\item
La fonction forme'e par une chai^ne de caracte`res entre apostrophes produit
cette chai^ne.

\item
La fonction forme'e d'un nom de buffer produit le contenu de ce buffer,
c'est-a`-dire le nom de la dernie`re image rencontre'e si c'est le buffer de
nom d'image, ou un texte pre'alablement lu au terminal si c'est un buffer de
lecture. Si le buffer est vide (on n'a pas rencontre' d'image ou on n'a pas
exe'cute' de re`gle {\tt Read} pour ce buffer), la chai^ne produite est vide.

\item
La fonction forme'e d'un nom d'attribut donne la valeur de l'attribut
indique' pour l'e'le'ment auquel s'applique la variable. Si l'e'le'ment
ne porte pas l'attribut indique', on cherche un e'le'ment ascendant qui
porte cet attribut et on prend la valeur de l'attribut pour cet ascendant.
Si aucun e'le'ment ascendant ne porte l'attribut, la valeur de la fonction
est une chai^ne vide.
\end{itemize}

\begin{verbatim}
     SuiteVariables = Variable < Variable > .
     Variable       = IdentVar ':' Fonction
                      < Fonction > ';' .
     IdentVar       = NAME .
     Fonction       ='Value' '(' IdentCompteur [ ':' Longueur ]
                               [ ',' StyleCompteur ] ')' /
                     'FileDir' / 'FileName' / 'Extension' /
                     'DocumentName' / 'DocumentDir' /
                      IdentConst / ChaineCar / 
                      IdentBuffer / IdentAttr .
     Longueur       = NUMBER .
     StyleCompteur  ='Arabic' / 'LRoman' / 'URoman' /
                     'Uppercase' / 'Lowercase' .
     ChaineCar      = STRING .
\end{verbatim}

\begin{example}
Si on veut cre'er au de'but de chaque section du document traduit un texte
forme' de la chai^ne ``Section'' suivie du nume'ro de la section, on de'finit la variable~:
\begin{verbatim}
VAR
     VarSection : 'Section' Value(NumeroSection);
\end{verbatim}
\label{varsect}
(voir la de'finition de {\tt NumeroSection} page~\pageref{numsect}).

Si on veut cre'er au de'but de chaque section un texte forme' de la chai^ne
``Niveau'' suivie du niveau hie'rarchique de la section, on de'finit la
variable (en utilisant la constante de'finie plus haut)~:
\begin{verbatim}
     VarNiveau : TxtNiveau Value(NiveauSection);
\end{verbatim}
(voir les de'finitions de {\tt NiveauSection} page~\pageref{numsect}
et {\tt TxtNiveau} page~\pageref{txtniveau}).

Si on veut sortir chaque section dans un fichier diffe'rent (voir la
re`gle {\tt ChangeMainFile}, p.~\pageref{changemainfile}), on peut
de'finir le nom de ces fichiers par la variable~:
\label{varnomfichier}
\begin{verbatim}
     VarNomFichier : FileName Value(NumeroSection) Extension;
\end{verbatim}
Ainsi, si a` l'appel du programme de traduction, on fournit
{\tt output.txt} comme nom de fichier de sortie, les sections
seront produites dans les fichiers {\tt output1.txt},
{\tt output2.txt}, etc.
\end{example}

\subsection{Traduction des e'le'ments de structure}

Le mot cle' {\tt RULES} introduit les re`gles de traduction a` appliquer aux
diffe'rents types d'e'le'ments structure's. On peut spe'cifier des re`gles de
traduction pour chacun des types d'e'le'ments de'finis dans le sche'ma de
structure, y compris pour les types de base de'finis implicitement, dont les
noms sont {\tt TEXT\_UNIT}, {\tt PICTURE\_UNIT}, {\tt SYMBOL\_UNIT},
{\tt GRAPHICS\_UNIT} et {\tt PAGE\_UNIT} si on travaille avec la version
anglaise de Thot ou {\tt TEXTE}, {\tt IMAGE}, {\tt SYMBOLE}, {\tt GRAPHIQUE}
et {\tt PAGE} 
si on travaille avec la version franc,aise. Mais il n'est pas obligatoire de
spe'cifier des re`gles pour chaque type de'fini.

Si un type d'e'le'ment n'a pas de re`gles de traduction, le traducteur
traitera quand me^me les e'le'ments qu'il contient (et qui, eux, ont
peut-e^tre des re`gles), mais il ne produira rien pour l'e'le'ment lui-me^me.
Si on veut que le traducteur ignore comple`tement le contenu d'un type
d'e'le'ment, il faut le demander explicitement par une re`gle {\tt Remove}
(voir page~\pageref{remove}).

Pour chaque type d'e'le'ment dont on veut de'finir les re`gles de traduction,
on e'crit le nom du type, tel qu'il figure dans le sche'ma de structure, et
on le fait suivre de deux-points et de la liste des re`gles a` lui appliquer.
Dans le cas ou` il s'agit d'une paire de marques (voir section~\ref{paires}),
mais uniquement dans ce cas, le nom du type doit e^tre pre'ce'de' du mot cle'
{\tt First} ou {\tt Second}. Ce mot cle' indique alors si les re`gles qui
suivent doivent s'appliquer a` la premie`re ou la dernie`re marque de la paire.

La liste de re`gles peut se limiter a` une simple re`gle, non
conditionnelle. Elle peut aussi e^tre forme'e d'une condition suivie d'une ou
plusieurs re`gles simples, ou encore d'un bloc de re`gles commenc,ant par le
mot cle' {\tt BEGIN} et termine' par le mot cle' {\tt END} suivi d'un
point-virgule. Ce bloc de re`gles peut contenir une ou plusieurs re`gles
simples et/ou une ou plusieurs conditions, suivies chacune d'une ou plusieurs
re`gles simples.

\begin{verbatim}
     LesRegles     = TradType < TradType > .
     TradType      =[ FirstSec ] IdentElem ':' SuiteRegles .
     FirstSec      = 'First' / 'Second' .
     SuiteRegles   = Regle / 'BEGIN' < Regle > 'END' ';' .
     Regle         = RegleSimple / BlocCondition .
     BlocCondition = 'IF' SuiteConditions SuiteRSimples .
     SuiteRSimples = 'BEGIN' < RegleSimple > 'END' ';' / 
                     RegleSimple .
\end{verbatim}

\subsection{Re`gles conditionnelles}
\label{tradcond}

Dans un sche'ma de traduction, les re`gles de traduction sont associe'es soit
aux types d'e'le'ments, soit aux valeurs des attributs,
soit a` la pre'sentation spe'cifique.
Elles sont applique'es
par le traducteur a` chaque fois qu'un e'le'ment du type correspondant est
rencontre' dans le document traduit ou a` chaque fois que la valeur
d'attribut est porte'e par un e'le'ment,
ou encore a` chaque fois que la pre'sentation spe'cifique est attache'e
a` un e'le'ment.
Cette
application syste'matique des re`gles peut e^tre assouplie~: il est
possible d'adjoindre une condition a` une ou plusieurs re`gles, de sorte que
ces re`gles ne sont applique'es que si la condition est ve'rifie'e.

Une condition est introduite par le mot cle' {\tt IF}, suivi
d'une suite de conditions e'le'mentaires. Les conditions e'le'mentaires sont
se'pare'es les unes des autres par le mot cle' {\tt AND}. S'il n'y a qu'une
condition e'le'mentaire, ce mot cle' est absent. Les re`gles ne sont
applique'es que si toutes les conditions e'le'mentaires sont ve'rifie'es.
Une condition e'le'mentaire peut e^tre ne'gative~; elle est alors pre'ce'de'e
du mot cle' {\tt NOT}.

Dans le cas ou` les re`gles de traduction contro^le'es par la condition
s'appliquent a` un e'le'ment re'fe'rence ou a` un attribut
re'fe'rence, une condition e'le'mentaire peut aussi porter sur l'e'le'ment
de'signe' par cette re'fe'rence. On utilise pour cela le mot cle' {\tt Target}
place' avant le mot cle' qui identifie le type de la condition a` appliquer
a` cet e'le'ment re'fe'rence'.

Selon leur type, certaines conditions peuvent porter soit sur l'e'le'ment
me^me auquel s'appliquent les re`gles de traduction contro^le'es par la
condition, soit sur l'un de ses ascendants. Pour indiquer qu'il s'agit
d'un ascendant, on utilise le mot cle' {\tt Ancestor} suivi
\begin{itemize}
\item soit d'un entier repre'sentant le nombre de niveaux dans l'arbre
  entre l'e'le'ment traite' et l'ance^tre concerne',
\item soit du type de l'ance^tre concerne'. Si ce type est de'fini dans
  un autre sche'ma de structure, le nom de ce sche'ma de structure soit
  e^tre indique' entre parenthe`ses, apre`s le nom du type.
\end{itemize}
Il existe un raccourci d'expression, le mot cle' {\tt Parent}, qui est
e'quivalent a` {\tt Ancestor 1}.

Seules les conditions {\tt First}, {tt Last}, {tt Referred}, {tt Within},
{tt Attributes}, {tt Presentation}, {tt Comment} et celles qui concernent
sur un attribut donne' ou une pre'sentation spe'cifique donne'e peuvent
porter sur un ascendant. Les conditions {\tt Defined}, {\tt FirstRef},
{\tt LastRef}, {\tt ExternalRef}, {\tt Alphabet}, {\tt FirstAttr},
{\tt LastAttr}, {\tt ComputedPage}, {\tt StartPage}, {\tt UserPage},
{\tt ReminderPage}, {\tt Empty} ne peuvent pas e^tre pre'ce'de'es de
ces mots cle's {\tt Parent} ou {\tt Ancestor}.

Dans le cas de la condition {\tt Referred} et de celle qui porte sur un
attribut nomme', on peut trouver a` la place de ces mots cle's le symbole
{\tt *} qui indique que la condition porte seulement sur l'e'le'ment
lui-me^me. En l'absence de ce symbole, on conside`re non seulement
l'e'le'ment, mais aussi ses ascendants de quelque niveau que ce soit.

La forme d'une condition e'le'mentaire varie selon le type de condition.

\subsubsection{Conditions sur la position de l'e'le'ment dans la structure
logique}

La condition peut porter sur la position de l'e'le'ment dans l'arbre de la
structure logique du document. On peut ainsi tester si l'e'le'ment est le
premier ({\tt First}) ou le dernier ({\tt Last}) parmi ses fre`res, ou s'il
n'est pas le premier ({\tt NOT First}) ou pas le dernier ({\tt NOT Last}).

On peut e'galement tester si l'e'le'ment est contenu dans un e'le'ment d'un
type donne' ({\tt Within} Type) ou s'il ne l'est pas ({\tt NOT Within} Type).
Dans ce dernier cas, le type en question peut e^tre de'fini dans un autre
sche'ma de structure que celui auquel correspond le sche'ma de traduction.
Le nom du type d'e'le'ment doit alors e^tre suivi, entre parenthe`ses, du
nom de sche'ma de structure ou` ce type est de'fini.

Si le mot {\tt Within} est pre'ce'de' de {\tt Immediately},
la condition n'est satisfaite que si le {\em pe`re} de l'e'le'ment concerne'
par la condition est du type indique'. Si le mot {\tt Immediately} est absent,
la condition est satisfaite si n'importe quel {\em ascendant} de l'e'le'ment
est du type indique'.

Un entier $n$ peut apparai^tre entre le mot {\tt Within} et le type.
Il indique le nombre d'ascendants du type indique' qui doivent e^tre
pre'sents pour que la condition soit satisfaite. Si le mot cle'
{\tt Immediately} est e'galement pre'sent, il faut alors que les $n$
ascendants imme'diats de l'e'le'ment soient tous du type indique'.
La valeur de $n$ doit e^tre positive ou nulle. Elle peut e^tre pre'ce'de'e
du signe {\tt <} ou {\tt >} pour indiquer un nombre maximum ou minimum
d'ascendants. A` de'faut de ces signes, la condition n'est satisfaite que
s'il existe exactement $n$ ascendants. L'absence du nombre $n$ est
interpre'te'e comme > 0.

\subsubsection{Conditions sur les re'fe'rences}

Les re'fe'rences peuvent e^tre prises en compte dans les conditions, qui
peuvent porter sur le fait que l'e'le'ment, ou l'un de ses ascendants
(a` moins que le symbole {\tt *} soit pre'sent), est
de'signe' par au moins une re'fe'rence ({\tt Referred}) ou par aucune
({\tt NOT Referred}). Si l'e'le'ment ou l'attribut auquel est associe' la
condition est une re'fe'rence, la condition peut porter sur le fait qu'il
s'agit de la premie`re re'fe'rence a` l'e'le'ment de'signe' ({\tt FirstRef})
ou de la dernie`re ({\tt LastRef}) ou encore d'une re'fe'rence qui de'signe
un e'le'ment appartenant a` un document diffe'rent ({\tt ExternalRef}).
Comme toutes les conditions, les conditions sur les re'fe'rences peuvent
e^tre inverse'es par le mot cle' {\tt NOT}.

\subsubsection{Conditions sur les parame`tres}

Les e'le'ments qui sont des parame`tres (voir page~\pageref{param}) peuvent
e^tre dote's d'une condition particulie`re qui porte sur le fait que le
parame`tre posse`de une valeur ({\tt Defined}) dans le document traite' ou
qu'il n'en posse`de pas ({\tt NOT Defined}).

\subsubsection{Conditions sur les alphabets}

Le type de base chai^ne de caracte`res (et uniquement ce type) peut
utiliser la condition {\tt Alphabet = a} qui indique qu'il ne faut
appliquer la (ou les) re`gle(s) de traduction que si l'alphabet
de l'e'le'ment chai^ne de caracte`res est (ou n'est pas, s'il y a {\tt NOT})
l'alphabet indique' apre`s le signe {\tt =}. Cette condition ne peut pas
e^tre associe'e aux re`gles de traduction d'un attribut.

Dans la version actuelle de Thot, les deux seuls alphabets disponibles
sont l'alphabet latin (Latin) et l'alphabet grec (Greek).

\subsubsection{Conditions sur les sauts de page}

Le type de base saut de page (et uniquement ce type) peut
utiliser les conditions suivantes~: {\tt ComputedPage}, {\tt StartPage},
{\tt UserPage} et {\tt ReminderPage}.
La condition {\tt ComputedPage} indique qu'il faut appliquer la (ou les)
re`gle(s) de traduction si le saut de page a e'te' calcule'
automatiquement par Thot ; la condition {\tt StartPage} 
si le saut de page est engendre' en de'but d'e'le'ment par une re`gle
{\tt Page} du langage P~; la
condition {\tt UserPage} si le saut de page
a e'te' inse're' par l'utilisateur ; et la condition {\tt ReminderPage}
si le saut de page est un rappel de saut de page.

\subsubsection{Conditions sur le contenu de l'e'le'ment}

La condition peut porter sur le fait que l'e'le'ment est vide ou non.
Un e'le'ment qui n'a pas de descendants ou dont toutes les feuilles
sont vides est conside're' comme vide.
Cette condition s'exprime simplement par le mot cle' {\tt Empty}
e'ventuellement pre'ce'de' du mot {\tt NOT}.

\subsubsection{Conditions sur la pre'sence des commentaires}

La condition peut porter sur la pre'sence ou l'absence de commentaires
associe's a` l'e'le'ment traduit. Cette condition s'exprime simplement par
le mot cle' {\tt Comment} e'ventuellement pre'ce'de' du mot {\tt NOT}.

\subsubsection{Conditions sur la pre'sence de pre'sentation spe'cifique}

La condition peut porter sur la pre'sence ou l'absence de re`gles de
pre'sentation spe'cifique associe'e a` l'e'le'ment traduit, quelles que
soient ces re`gles, leur valeur ou leur nombre. Cette condition s'exprime
simplement par le mot cle' {\tt Presentation} e'ventuellement pre'ce'de'
du mot {\tt NOT}.

\subsubsection{Conditions sur la pre'sence d'attributs logique}

De la me^me fac,on, la condition peut porter sur la pre'sence ou l'absence
d'attributs associe's a` l'e'le'ment traduit, quels que soient ces attributs
et leurs valeurs. C'est le mot cle' {\tt Attributes} qui exprime cette
condition.

\subsubsection{Conditions sur les attributs logiques}

Si la condition apparai^t dans les re`gles de traduction d'un attribut,
les mots cle's {\tt FirstAttr} et {\tt LastAttr} peuvent e^tre utilise's
pour indiquer que les re`gles ne doivent e^tre applique'es que si cet
attribut est le premier attribut porte' par l'e'le'ment traduit ou que si
c'est le dernier. Ces conditions peuvent aussi e^tre inverse'es par {\tt NOT}.

Un autre type de condition permet de n'appliquer des re`gles de
traduction que lorsque l'e'le'ment traite' (ou l'un de ses ascendants
si le symbole {\tt *} est absent) porte
un certain attribut avec e'ventuellement une certaine valeur, ou, au
contraire, lorsqu'il ne porte pas cet attribut avec cette valeur.
La condition s'e'crit simplement en faisant suivre le mot cle' {\tt IF}
ou {\tt AND}, et e'ventuellement le mot cle' {\tt NOT} qui
inverse la condition, du nom de l'attribut concerne'. Si les re`gles de
traduction doivent e^tre applique'es de`s que l'e'le'ment porte cet attribut
(ou ne le porte pas, s'il y a {\tt NOT}) quel qu'en soit la valeur, la
condition s'arre^te la`. Si au contraire la condition porte sur une ou
plusieurs valeurs particulie`res de l'attribut, celles-ci sont indique'es
apre`s le nom de l'attribut, sauf pour les attributs de type re'fe'rence
pour lesquels on ne peut pas indiquer de valeur.

\label{relatattr}
La repre'sentation des valeurs d'un attribut dans une condition de'pendent
du type de l'attribut. Pour les attributs de type e'nume're' ou textuel, la
valeur (un nom ou une chai^ne de caracte`res entre apostrophes,
respectivement) est simplement pre'ce'de'e d'un signe {\tt =}. Pour les
attributs de type nume'rique, la condition peut porter sur une valeur unique
ou une plage de valeurs. Dans le cas d'une valeur unique, cette valeur
(un entier) est e'galement simplement pre'ce'de'e du signe {\tt =}. Dans
le cas d'une plage de valeurs, il peut s'agir de
\begin{itemize}
\item
toutes les valeurs infe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt <}),
\item
toutes les valeurs supe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt >}),
\item
toutes les valeurs comprises dans un intervalle, bornes comprises. La plage
des valeurs est alors note'e {\tt IN [}Minimum {\tt ..} Maximum{\tt]}, Minimum
et Maximum e'tant des entiers.
\end{itemize}
Toutes ces valeurs nume'riques peuvent e^tre ne'gatives. L'entier est alors
pre'ce'de' du signe {\tt -}.

Les attributs locaux comme les attributs globaux peuvent e^tre utilise's dans
les conditions.

\subsubsection{Conditions sur la presentation spe'cifique}

Il est possible de n'appliquer des re`gles de traduction que lorsque
l'e'le'ment traite' porte une certaine re`gle de pre'sentation spe'cifique,
avec e'ventuellement une certaine valeur, ou au contraire, lorsqu'il ne porte
pas cette re`gle de pre'sentation, e'ventuellement avec cette valeur.
La condition s'e'crit simplement en faisant suivre le mot cle' {\tt IF}
ou {\tt AND}, et e'ventuellement le mot cle' {\tt NOT} qui inverse
la condition, du nom de la re`gle de pre'sentation concerne'e. Si les re`gles
de traduction doivent e^tre applique'es de`s que l'e'le'ment porte cette
re`gle de pre'sentation spe'cifique (ou ne la porte pas, s'il y a {\tt NOT})
quel qu'en soit la valeur, la condition s'arre^te la`. Si au contraire la
condition porte sur une ou plusieurs valeurs particulie`res de la re`gle
de pre'sentation, ces valeurs sont indique'es apre`s le nom de la re`gle
de pre'sentation.

La repre'sentation des valeurs d'une re`gle de pre'sentation spe'cifique
dans une condition est semblable a` celle des valeurs d'attributs.
La repre'sentation de ces valeurs de'pend du type de la re`gle de
pre'sentation. Il y a trois cate'gories de re`gles de pre'sentation~:
\begin{itemize}
\item
celles qui prennent des valeurs nume'riques ({\tt Size, Indent, LineSpacing, LineWeight}),
\item
celles dont les valeurs sont prises dans une liste pre'de'finie ({\tt Adjust,
Justify, Hyphenate, Style, Font, Underline, Thickness, LineStyle}),
\item
celles dont la valeur est un nom ({\tt FillPattern, Background, Foreground}).
\end{itemize}

Pour les re`gles de pre'sentation qui prennent des valeurs nume'riques,
la condition peut porter sur une valeur unique ou une plage de valeurs.
Dans le cas d'une valeur unique, cette valeur (un entier) est e'galement
simplement pre'ce'de'e du signe {\tt =}. Dans le cas d'une plage de
valeurs, il peut s'agir de
\begin{itemize}
\item
toutes les valeurs infe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt <}),
\item
toutes les valeurs supe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt >}),
\item
toutes les valeurs comprises dans un intervalle, bornes comprises. La plage
des valeurs est alors note'e {\tt IN [}MinIntrevalPres {\tt ..}
MaxIntervalPres{\tt]}, MinIntervalPres et MaxIntervalPres e'tant des entiers.
\end{itemize}
Dans le cas d'une re`gle {\tt Indent} ces valeurs nume'riques peuvent e^tre
ne'gatives. L'entier est alors pre'ce'de' du signe {\tt -} et repre'sente
l'amplitude de l'avance'e de la premie`re ligne a` gauche des autres lignes.

Pour les re`gles de pre'sentation dont les valeurs sont prises dans une
liste pre'de'finie, la valeur qui satisfait la condition est simplement
indique'e par le signe {\tt =} suivi du nom de cette valeur.

Pour les re`gles de pre'sentation dont les valeurs sont des noms, la valeur
qui satisfait la condition est simplement indique'e par le signe {\tt =}
suivi du nom de cette valeur\footnote{Les noms de motifs de remplissage
(re`gle {\tt FillPattern}) et de couleurs (re`gles {\tt Foreground} et
{\tt Background}) connus de Thot sont les me^mes que dans le langage P.}.

La syntaxe des conditions portant sur la pre'sentation spe'cifique est la
me^me que la syntaxe qui permet d'exprimer la traduction des re`gles de
pre'sentation spe'cifique (voir page~\pageref{prestrans}).

Lorsqu'une condition ne porte que sur une re`gle, la condition est simplement
suivie de la re`gle sur laquelle elle porte. Si elle porte sur plusieurs
re`gles, celles-ci sont regroupe'es, apre`s la condition, entre les
mots cle's {\tt BEGIN} et {\tt END}.

\begin{verbatim}
     SuiteConditions= Condition [ 'AND' Condition ] .
     Condition     = [ 'NOT' ] [ 'Target' ] Cond .
     Cond          =  CondElem / CondAscend .
     CondElem      ='FirstRef' / 'LastRef' /
                    'ExternalRef' /
                    'Defined' /
                    'Alphabet' '=' Alphabet /
                    'ComputedPage' / 'StartPage' / 
                    'UserPage' / 'ReminderPage' /
                    'Empty' /
                    'FirstAttr' / 'LastAttr' .
     CondAscend    = [ Ascend ] CondSurAscend .
     Ascend        = '*' / 'Parent' / 'Ancestor' NiveauOuType .
     NiveauOuType  = CondNivAscend / IdentElem [ StructExt ] .
     CondNivAscend = NUMBER .
     CondSurAscend ='First' / 'Last' /
                    'Referred' /
                    [ 'Immediately' ] 'Within' [ NbParent ]
                                  IdentElem [ StructExt ] /
                    'Attributes' /
                     IdentAttr [ RelatAttr ] /
                    'Presentation' /
                     ReglePres /
                    'Comment' .		    
     NbParent      = [ InfSup ] NParent .
     InfSup        = '>' / '<' .
     NParent       = NUMBER.
     RelatAttr     ='=' Valeur /
                    '>' [ '-' ] Minimum /
                    '<' [ '-' ] Maximum /
                    'IN' '[' [ '-' ] MinInterval '..'
                             [ '-' ] MaxInterval ']' .
     Minimum       = NUMBER .
     Maximum       = NUMBER .
     MinInterval   = NUMBER .
     MaxInterval   = NUMBER .
     Valeur        = [ '-' ] ValEntiere / ValTexte /
                     ValeurAttr .
     ValEntiere    = NUMBER .
     ValTexte      = STRING .
     ValeurAttr    = NAME .
\end{verbatim}

\begin{example}
On veut produire, apre`s le titre d'une section, le texte
{\tt $\backslash$label\{SectX\} }ou` {\tt X} repre'sente le nume'ro unique
de la section, mais seulement si la section est de'signe'e par une ou
plusieurs re'fe'rences dans le document. On e'crit alors la re`gle
conditionnelle~:
\begin{verbatim}
RULES
  Titre_Section :
    IF Referred
      Create ('\label{Sect' Value(NumUniqueSect) '}\12')
      After;
\end{verbatim}
(voir page~\pageref{numunique} la de'claration du compteur
{\tt NumUniqueSect}). La chai^ne {\tt $\backslash$12} repre'sente un saut
de ligne.
\end{example}

\begin{example}
Pour les e'le'ments de type Elmnt, on veut produire un caracte`re selon
la valeur de l'attribut nume'rique Niveau associe' a` l'e'le'ment~: un ``A''
pour toutes les valeurs de Niveau infe'rieures a` 3, un ``B'' pour les valeurs
entre 3 et 10 et un ``C'' pour les valeurs supe'rieures. Au type Elmnt, on
associe les re`gles suivantes~:
\begin{verbatim}
RULES
  Elmnt :
    BEGIN
    IF Niveau < 3
      Create 'A';
    IF Niveau IN [3..10]
      Create 'B';
    IF Niveau > 10
      Create 'C';
    END;
\end{verbatim}
\end{example}

\subsection{Re`gles de traduction}

Treize types de re`gles de traduction peuvent e^tre associe'es aux types
d'e'le'ments et aux valeurs d'attributs. Ce sont les re`gles {\tt Create},
{\tt Write}, {\tt Read}, {\tt Include}, {\tt Get}, {\tt Copy}, {\tt Use},
{\tt Remove}, {\tt NoTranslation}, {\tt NoLineBreak}, {\tt ChangeMainFile},
{\tt Set} et {\tt Add}.
Chaque re`gle a une syntaxe propre, bien qu'elles soient
toutes construites sur des mode`les tre`s voisins.

\begin{verbatim}
     RegleSimple ='Create' [ 'IN' IdentVar ] Objet
                           [ Position ] ';' /
                  'Write' Objet [ Position ] ';' /
                  'Read' IdentBuffer [ Position ] ';' /
                  'Include' Fichier [ Position ] ';' /
                  'Get' [ PositionRel ] IdentElem 
                        [ StructExt ] 
                        [ Position ] ';' /
                  'Copy' [ PositionRel ] IdentElem 
                        [ StructExt ] 
                        [ Position ] ';' /
                  'Use' SchemaTr [ 'For' IdentElem ] ';' /
                  'Remove' ';' /
                  'NoTranslation' ';' /
                  'NoLineBreak' ';' /
                  'ChangeMainFile' IdentVar
                        [ Position ] ';' /
                  'Set' IdentCompteur ValeurInit
                        [ Position ] ';' /
                  'Add' IdentCompteur Increment
                        [ Position ] ';' .
\end{verbatim}

\subsection{Re`gle {\tt Create}}
\label{create}

La re`gle la plus utilise'e est sans doute la re`gle {\tt Create}, qui
engendre dans le fichier de sortie un texte fixe ou variable (appele' objet)
avant ou apre`s le contenu de l'e'le'ment auquel elle s'applique. Apre`s le
mot cle' {\tt Create}, on indique l'objet et, par un mot cle', la position a`
laquelle doit e^tre engendre' l'objet~: avant ({\tt Before}) ou apre`s
({\tt After}) le contenu de l'e'le'ment. Si la position n'est pas indique'e,
l'objet sera engendre' avant le contenu de l'e'le'ment. La re`gle, comme
toutes les re`gles de traduction, se termine par un point-virgule.

Le mot cle' {\tt Create} peut e^tre suivi du mot cle' {\tt IN} et d'un
nom de variable. Cela signifie que le texte engendre' par la re'gle ne
doit pas e^tre e'crit dans le fichier de sortie principal, mais dans le
fichier dont le nom est spe'cifie' par la variable indique'e.

On peut ainsi produire, en une seule passe de traduction, des sorties dans
diffe'rents fichiers. Il n'est pas ne'cessaire de de'clarer ou d'ouvrir
explicitement ces fichiers, ni de les fermer. De`s que le traducteur
exe'cute une re`gle {\tt Create} pour un fichier qui n'est pas encore
ouvert, il l'ouvre et le fichier reste ouvert jusqu'a` la fin de la
traduction.

\begin{verbatim}
               'Create' [ 'IN' IdentVar ] Objet [ Position ] ';'
     Objet    = IdentConst / ChaineCar /
                IdentBuffer /
                IdentVar /
               '(' Fonction < Fonction > ')' /
                IdentAttr / 'Value' /
               'Content' / 'Comment' / 
               'Attributes' / 'Presentation' /
               'RefId' / 'PairId' /
	       'FileDir' / 'FileName' / 'Extension' /
               'DocumentName' / 'DocumentDir' /
                [ 'Referred' ] ObjetRefer .
     Position ='After' / 'Before' .

     ObjetRefer = IdentVar /
                IdentElem [ StructExt ] /
               'RefId' /
               'DocumentName' / 'DocumentDir' .
\end{verbatim}

L'objet a` engendrer peut e^tre~:
\begin{itemize}
\item une chai^ne constante, indique'e par son nom si elle est de'clare'e dans
 la section {\tt CONST} du sche'ma, ou donne'e directement par sa valeur entre
 apostrophes sinon~;

\item le contenu d'un buffer, de'signe' par le nom du buffer~;

\item une variable, de'signe'e par son nom si elle est de'clare'e dans la
 section {\tt VAR} du sche'ma de traduction, ou donne'e directement entre
 parenthe`ses sinon. Le texte engendre' est la valeur de la variable pour
 l'e'le'ment auquel s'applique la re`gle.

\item la valeur d'un attribut, si l'e'le'ment auquel s'applique la re`gle
 porte cet attribut. L'attribut dont on prend la valeur est de'signe' par
 son nom~;

\item la valeur d'une re`gle de pre'sentation spe'cifique, seulement si la
 re`gle de traduction concerne une re`gle de pre'sentation spe'cifique (voir
 page~\pageref{valpres}). Cela est indique' par le mot cle' {\tt Value}~;

\item le contenu de l'e'le'ment, c'est-a`-dire l'ensemble des feuilles du
 sous-arbre de l'e'le'ment sur lequel porte la re`gle. Cela est indique'
 par le mot cle' {\tt Content}~;

\item le commentaire attache' a` l'e'le'ment (dans le cas ou` l'e'le'ment
 ne porte pas de commentaire, rien n'est engendre'). Cela est indique' par
 le mot cle' {\tt Comment}~;

\item la traduction de tous les attributs de l'e'le'ment (cela permet en
 particulier d'appliquer les re`gles de traduction des attributs avant celles
 du type de l'e'le'ment (voir section~\ref{ordreappli})). Cela est indique'
 par le mot cle' {\tt Attributes}~;

\item la traduction de toutes les re`gles de pre'sentation spe'cifique
 porte'es par l'e'le'ment (cela permet en particulier d'appliquer les
 re`gles de traduction de la pre'sentation spe'cifique avant celles
 du type de l'e'le'ment ou de ses attributs (voir section~\ref{ordreappli})).
 Cela est indique' par le mot cle' {\tt Presentation}~;

\item la valeur de l'identificateur de re'fe'rence. A` chaque e'le'ment d'un
 document, Thot associe un identificateur unique dans le document. Cet
 identificateur (appele' {\it identificateur de re'fe'rence} ou {\it label})
 est une chai^ne de caracte`res forme'e de la lettre `L' suivie de chiffres.
 Cet identificateur est notamment utilise' dans les re'fe'rences pour
 de'signer l'e'le'ment re'fe'rence'. \\
 Le mot cle' {\tt RefId} produit l'identificateur de  re'fe'rence de
 l'e'le'ment auquel s'applique la re`gle de traduction ou du premier
 e'le'ment ascendant qui est de'signe' par une re'fe'rence ou
 qui peut l'e^tre~;

\item la valeur de l'identificateur unique de la paire, seulement dans le cas
 d'une paire de marques (voir section~\ref{paires}). Cela est indique' par le
 mot cle' {\tt PairId}~;

\item le re'pertoire contenant le fichier de sortie en cours (ce nom
se termine par un caracte`re '/' s'il n'est pas vide). Cela est indique'
par le mot cle' {\tt FileDir}~;

\item le nom du fichier de sortie en cours (seulement le nom, sans re'pertoire
ni extension). Cela est indique' par le mot cle' {\tt FileName}~;

\ l'extension du fichier de sortie en cours (cette chai^ne de caracte`res
commence par un point si elle n'est pas vide). Cela est indique' par le mot
cle' {\tt Extension}~;

\item le nom du document en cours de traduction. Cela est indique' par le
 mot cle' {\tt DocumentName}~;

\item le nom du re'pertoire ou` se trouve le fichier contenant le document
 en cours de traduction. Cela est indique' par le mot cle' {\tt DocumentDir}.
\end{itemize}

Dans le cas ou` la re`gle s'applique a` un e'le'ment ou un attribut
re'fe'rence, elle peut engendrer un texte relatif a` l'e'le'ment
de'signe' par cette re'fe'rence. Le nom de la re`gle est alors suivi
du mot cle' {\tt Referred} et d'une indication de l'objet a` engendrer
pour l'e'le'ment de'signe'. Cette indication peut e^tre~:

\begin{itemize}
\item le nom d'une variable. La re`gle produit la valeur de la variable,
 calcule'e pour l'e'le'ment de'signe' par la re'fe'rence~;

\item un type d'e'le'ment. La re`gle produit la traduction de l'e'le'ment
 du type indique', qui se trouve dans le sous-arbre de l'e'le'ment
 de'signe' par la re'fe'rence.
 Si le type d'e'le'ment n'est pas de'fini dans le sche'ma de structure qui
 correspond au sche'ma de traduction, (cas d'un objet d'une autre nature),
 le nom du type de cet e'le'ment doit e^tre suivi, entre parenthe`ses,
 du nom du sche'ma de structure qui le de'finit.

\item le mot cle' {\tt RefId}. La re'gle produit l'identificateur de
 l'e'le'ment de'signe' par la re'fe'rence.

\item le mot cle' {\tt DocumentName}. La re'gle produit le nom du
 document auquel appartient l'e'le'ment de'signe' par la re'fe'rence.

\item le mot cle' {\tt DocumentDir}.  La re'gle produit le nom du
 re'pertoire qui contient le document auquel appartient l'e'le'ment
 de'signe' par la re'fe'rence.
\end{itemize}

\subsection{Re`gle {\tt Write}}

Le re`gle {\tt Write} a la me^me syntaxe que la re`gle {\tt Create}. Elle
produit le me^me effet, mais le texte qu'elle engendre est affiche' sur le
terminal de l'utilisateur lors de la traduction d'un document, au lieu
d'e^tre produit dans le document traduit. Elle permet notamment de tenir
l'utilisateur au courant du travail effectue' par le traducteur ou d'afficher
un texte au terminal avant de lancer une lecture par la re`gle {\tt Read}.

\begin{verbatim}
               'Write' Objet [ Position ] ';'
\end{verbatim}

\begin{example}
Si on veut afficher sur le terminal de l'utilisateur, lors de la traduction
des documents, le nume'ro de chaque section traite'e, on associe au type
{\tt Section} la re`gle~:
\begin{verbatim}
Section : BEGIN
          Write VarSection;
          ...
          END;
\end{verbatim}
(voir page~\pageref{varsect} la de'finition de {\tt VarSection}).

Si on veut afficher un texte au terminal avant de lancer une lecture
par la re`gle {\tt Read}, on peut e'crire :
\begin{verbatim}
BEGIN
Write 'Entrez le nom du destinataire : ';
...
END;
\end{verbatim}
\end{example}

\subsection{Re`gle {\tt Read}}

La re`gle {\tt Read} lance une lecture au terminal lors de la traduction
d'un document et conserve le texte lu dans un des buffers de'clare's dans
la section {\tt BUFFERS} du sche'ma. Le buffer a` utiliser est indique' par
son nom, apre`s le mot cle' {\tt READ}. Ce nom peut e^tre suivi, comme pour
une re`gle {\tt Create} ou {\tt Write}, d'un mot cle' indiquant si la
lecture doit e^tre effectue'e avant le traitement du contenu de l'e'le'ment
({\tt Before}) ou apre`s ({\tt After}). Si ce mot cle' est absent, la
lecture a lieu avant. Le texte lu dans le buffer y reste jusqu'a` ce qu'une
re`gle utilisant le me^me buffer --- e'ventuellement la me^me re`gle --- soit
applique'e.

\begin{verbatim}
               'Read' IdentBuffer [ Position ] ';'
\end{verbatim}

\begin{example}
La suite de re`gles suivante permet d'indiquer a` l'utilisateur que le
traducteur attend qu'il entre un texte, de lire ce texte dans un buffer et
de copier le texte lu dans le document traduit.
\begin{verbatim}
BEGIN
Write 'Entrez le nom du destinataire : ';
Read NomDest;
Create NomDest;
...
END;
\end{verbatim}
(voir la de'finition de {\tt NomDest} page~\pageref{nomdest}).
\end{example}

\subsection{Re`gle {\tt Include}}

La re`gle {\tt Include}, comme la re`gle {\tt Create}, permet de produire
un texte dans le document traduit. Il s'agit la` d'un texte constant, mais
qui n'est pas de'fini dans le sche'ma lui-me^me~; il est pris dans un fichier
qui est indique', apre`s le mot cle' {\tt Include}, soit par une chai^ne
de caracte`res entre apostrophes repre'sentant le nom du fichier, soit
par le nom d'un des buffers de'clare's dans la section {\tt BUFFERS} du
sche'ma. Dans ce dernier cas, c'est ce buffer qui est sense' contenir
le nom du fichier. Cela permet notamment de ne spe'cifier le fichier a`
inclure qu'au moment de la traduction~: il suffit que la re`gle {\tt Include}
soit pre'ce'de'e d'une re`gle {\tt Read} qui mette dans le buffer le nom
du fichier voulu par l'utilisateur.

Apre`s le fichier, on indique, comme
dans les autres re`gles, si ce fichier doit e^tre inclus avant ou apre`s
le contenu de l'e'le'ment auquel se rapporte la re`gle (par de'faut, avant).
L'inclusion du fichier n'est faite qu'au moment de la traduction, et non pas
lors de la compilation du sche'ma de traduction. Le fichier a` inclure peut
donc ne pas exister lors de la compilation, mais il doit e^tre accessible
au moment de la traduction. Son contenu peut e'galement e^tre modifie' entre
deux traductions, produisant ainsi des re'sultats diffe'rents, me^me si le
document n'est pas modifie' ni le sche'ma de traduction.

Lors de la traduction, le fichier a` inclure est cherche' dans le re'pertoire
courant des sche'mas (indique' par la variable d'environnement {\tt THOTSCH}).
Le nom de fichier
ne comporte normalement qu'un simple nom, sans indication de chemin d'acce`s.

\begin{verbatim}
                 'Include' Fichier [ Position ] ';'
     Fichier    = NomFichier / IdentBuffer .
     NomFichier = STRING .
\end{verbatim}

\begin{example}
On veut faire imprimer les documents de la classe Article par un formateur
qui demande un certain nombre de de'clarations et de de'finitions en te^te de
fichier. On cre'e un fichier de nom {\tt DeclarArt} qui contient toutes ces
de'clarations et de'finitions et on associe au type {\tt Article} la re`gle~:
\begin{verbatim}
Article : BEGIN
          Include 'DeclarArt' Before;
          ...
          END;
\end{verbatim}
\end{example}

\subsection{Re`gle {\tt Get}}

La re`gle {\tt Get} permet de changer l'ordre dans lequel apparaissent les
e'le'ments dans le document traduit. Plus pre'cise'ment, elle produit la
traduction d'un e'le'ment spe'cifie', avant ou apre`s la traduction du contenu
de l'e'le'ment auquel elle s'applique. C'est le mot cle' {\tt Before} ou
{\tt After} terminant la re`gle qui indique si l'ope'ration doit e^tre faite
avant ou apre`s (par de'faut, avant). Le type de l'e'le'ment a` de'placer doit
e^tre indique' apre`s le mot cle' {\tt Get}, e'ventuellement pre'ce'de' d'un mot cle'
indiquant ou` il se trouve dans la structure logique du document~:
\begin{description}
\item[ {\tt Included}~: ]
 L'e'le'ment a` de'placer est le premier e'le'ment du type indique' qui se trouve
 a` l'inte'rieur de l'e'le'ment auquel s'applique la re`gle.
\item[ {\tt Referred}~: ]
 Ce mot cle' ne peut e^tre utilise' que si la re`gle s'applique a` un e'le'ment
 re'fe'rence. L'e'le'ment a` de'placer est soit l'e'le'ment de'signe' par la re'fe'rence
 s'il est du type voulu, soit le premier e'le'ment du type voulu contenu dans
 l'e'le'ment de'signe' par la re'fe'rence.
\item[ mot cle' absent~: ]
 Si l'e'le'ment a` de'placer est un e'le'ment associe', de'fini dans la section
 {\tt ASSOC} du sche'ma de structure (voir page~\pageref{elemassoc}), tous les
 e'le'ments associe's de ce type qui n'ont pas encore e'te' traduits sont traite's.
 Certains e'le'ments peuvent en effet avoir de'ja` e'te' traite's par une re`gle
 {\tt Get Referred}.

 Si l'e'le'ment a` de'placer n'est pas un e'le'ment associe', le traducteur prend le
 premier  e'le'ment du type indique' parmi les e'le'ments fre`res de l'e'le'ment
 auquel s'applique la re`gle. Cela est utilise' notamment pour changer l'ordre
 des composants d'un me^me agre'gat.
\end{description}

Si l'e'le'ment a` de'placer est de'fini dans un sche'ma de structure qui n'est
pas celui qui correspond au sche'ma de traduction (cas d'un objet d'une
autre nature), le nom du type de cet e'le'ment doit e^tre suivi, entre
parenthe`ses, du nom du sche'ma de structure qui le de'finit.

\begin{verbatim}
                  'Get' [ PositionRel ] IdentElem 
                        [ StructExt ]
                        [ Position ] ';' /
     PositionRel ='Included' / 'Referred' .
     StructExt   ='(' IdentElem ')' .
\end{verbatim}

La re`gle {\tt Get} est sans effet si l'e'le'ment qu'elle doit de'placer a
de'ja` e'te' traite'. On e'vite ainsi de dupliquer un e'le'ment. Il faut donc
associer la re`gle au premier e'le'ment qui sera rencontre' par le traducteur
dans son parcours du document. On permute notamment deux e'le'ments {\tt A} et
{\tt B}, qui font partie d'un me^me agre'gat et qui se suivent dans cet ordre,
en associant une re`gle {\tt Get B before} au type d'e'le'ment {\tt A}, et non
l'inverse.
De me^me une re`gle de la forme {\tt Get Included X After}, bien que
syntaxiquement correcte, n'a pas de sens puisque, lorsqu'elle sera applique'e,
apre`s le traitement du contenu de l'e'le'ment auquel elle est associe'e,
l'e'le'ment {\tt X} aura de'ja` e'te' traite'.

La re`gle {\tt Get} est le seul moyen d'obtenir la traduction des e'le'ments
associe's. En effet le traducteur ne parcourt que l'arbre principal du document
et ne traduit donc pas les e'le'ments associe's, sauf si leur traitement est
explicitement demande' par une re`gle {\tt Get Referred Type} ou {\tt Get Type}
ou` {\tt Type} est un type d'e'le'ment associe'.

\begin{example}
Le sche'ma de structure de'finit les figures comme des e'le'ments associe's qui
sont compose's, dans l'ordre, d'un contenu et d'une le'gende. De plus, il est
possible de faire re'fe'rence aux figures, gra^ce aux e'le'ments de type
{\tt RefFigure}~:
\begin{verbatim}
     ...
     RefFigure = REFERENCE(Figure);
ASSOC
     Figure = BEGIN
              Contenu = NATURE;
              Legende = Text;
	      END;
     ...
\end{verbatim}
Dans le document traduit, on veut faire apparai^tre une figure a` l'endroit
du texte ou` est faite la premie`re re'fe'rence a` cette figure. Si certaines
figures ne sont pas re'fe'rence'es, on veut les inse'rer a` la fin du document.
Dans chaque figure produite, on veut e'galement faire apparai^tre la le'gende
avant le contenu. Dans le sche'ma de traduction on e'crit~:
\begin{verbatim}
Article :   BEGIN
            ...
            Get Figures After;
            END;
RefFigure : BEGIN
            If FirstRef Get Referred Figure;
            ...
            END;
Contenu :   BEGIN
            Get Legende Before;
            ...
            END;
\end{verbatim}
\end{example}

\subsection{Re`gle {\tt Copy}}

La re`gle {\tt Copy} fonctionne comme la re`gle {\tt Get}~: elle produit
la traduction d'un e'le'ment spe'cifie' de la me^me fac,on que dans la
re`gle {\tt Get}, mais elle agit me^me si l'e'le'ment a de'ja` e'te'
traite' et elle n'empe^che pas que l'e'le'ment soit traite' ulte'rieurement.
Elle a la me^me syntaxe que la re`gle {\tt Get}.

\begin{verbatim}
             'Copy' [ PositionRel ] IdentElem 
                    [ StructExt ] [ Position ] ';'
\end{verbatim}

\subsection{Re`gle {\tt Use}}

La re`gle {\tt Use} spe'cifie le sche'ma de traduction a` appliquer aux objets
d'une certaine classe qui font partie du document. Cette re`gle ne peut
apparai^tre que dans les re`gles de l'e'le'ment racine du document (le premier
type de'fini apre`s le mot cle' {\tt STRUCT} dans le sche'ma de structure) ou dans
les re`gles d'un e'le'ment de'fini par une structure externe (par un autre
sche'ma de structure). De plus, la re`gle {\tt Use} ne peut pas e^tre
conditionnelle.

Si la re`gle s'applique a` un e'le'ment de'fini par une structure externe,
le mot cle' {\tt Use} est simplement suivi du nom du sche'ma de traduction a`
utiliser pour les e'le'ments construits selon cette structure externe. Si elle
s'applique a` l'e'le'ment racine du document, elle est forme' du mot cle' {\tt Use}
suivi d'un nom de sche'ma de traduction, du mot cle' {\tt For} et enfin du nom
de la structure externe a` laquelle il faut appliquer le sche'ma de traduction
indique'.

\begin{verbatim}
               'Use' SchemaTr [ 'For' IdentElem ] ';'
     SchemaTr = NAME .
\end{verbatim}

Si aucune re`gle {\tt Use} ne de'finit le sche'ma de traduction a` utiliser pour
une structure externe qui apparai^t dans un document, le traducteur demande
a` l'utilisateur, au moment de la traduction du document, quel sche'ma il
doit utiliser. Il n'est donc pas ne'cessaire de faire figurer dans le sche'ma
de traduction une re`gle {\tt Use} pour chaque structure externe utilise'e,
surtout si on veut laisser a` l'utilisateur du traducteur le choix des
sche'mas de traduction.

\begin{example}
Le sche'ma de structure {\tt Article} utilise la structure externe
{\tt Formule}, de'finie par un autre sche'ma de structure, pour les formules
mathe'matiques~:
\begin{verbatim}
STRUCTURE Article;
   ...
STRUCT
   Article = ...
   ...
   Formule_dans_texte = Formule;
   Formule_isolee     = Formule;
   ...
END
\end{verbatim}
Si on veut utiliser le sche'ma de traduction {\tt FormuleT} pour les formules
d'un article, on peut exprimer cela de deux fac,ons diffe'rentes, dans le
sche'ma de traduction de la classe {\tt Article}, soit~:
\begin{verbatim}
RULES
    Article :
       Use FormuleT for Formule;
\end{verbatim}
soit~:
\begin{verbatim}
RULES
    ...
    Formule :
       Use FormuleT;
\end{verbatim}
\end{example}

\subsection{Re`gle {\tt Remove}}
\label{remove}

La re`gle {\tt Remove} indique qu'il ne faut rien engendrer, dans le document
traduit, pour le contenu de l'e'le'ment auquel elle s'applique. Le contenu de
cet e'le'ment est alors simplement ignore' par le traducteur. Cela n'empe^che
pas d'engendrer un texte pour l'e'le'ment lui-me^me, avec les re`gles
{\tt Create} ou {\tt Include}, par exemple.

Le re`gle {\tt Remove} s'e'crit simplement avec le mot cle' {\tt Remove}. Elle
se termine, comme toutes les re`gles, par un point-virgule.

\begin{verbatim}
               'Remove' ';'
\end{verbatim}

\subsection{Re`gle {\tt NoTranslation}}
\label{notrans}

La re`gle {\tt NoTranslation} indique au traducteur qu'il ne faut pas traduire
le contenu des feuilles de l'e'le'ment auquel elle s'applique. A la
diffe'rence de la re`gle {\tt Remove}, elle ne supprime pas le contenu de
l'e'le'ment, mais elle inhibe la traduction des chai^nes de caracte`res, des
symboles et des e'le'ments graphiques contenus dans l'e'le'ment. Ceux-ci se
retrouvent donc tels quels apre`s traduction du document, les re`gles des
sections {\tt TEXTTRANSLATE}, {\tt SYMBTRANSLATE} et {\tt GRAPHTRANSLATE}
(voir page~\pageref{texttrans}) ne leur e'tant pas applique'es.

Comme la re`gle {\tt Remove}, la re`gle {\tt NoTranslation} s'e'crit
simplement avec le mot cle' du nom de la re`gle suivi d'un point-virgule.

\begin{verbatim}
               'NoTranslation' ';'
\end{verbatim}

\subsection{Re`gle {\tt NoLineBreak}}
\label{nolinebreak}

La re`gle {\tt NoLineBreak} indique au traducteur qu'il ne faut pas introduire
de sauts de ligne supple'mentaires dans la sortie produite pour l'e'le'ment
auquel elle s'applique. Tout se passe comme si, pour cet e'le'ment, la
premie`re instruction du sche'ma de traduction e'tait {\tt LINELENGTH 0;}
(voir page~\pageref{longueurligne}).

La re`gle {\tt NoLineBreak} s'e'crit
simplement avec le mot cle' {\tt NoLineBreak} suivi d'un point-virgule.

\begin{verbatim}
               'NoLineBreak' ';'
\end{verbatim}

\subsection{Re`gle {\tt ChangeMainFile}}
\label{changemainfile}

Lorsque le traducteur de'marre, il ouvre un fichier de sortie principal,
dont le nom est donne' comme parame`tre de lancement du programme.
Toutes les re`gles {\tt Create} sans indication explicite de fichier de
sortie (voir p.~\pageref{create}) e'crivent se'quentiellement dans ce
fichier. Lorsqu'une re`gle {\tt ChangeMainFile} est exe'cute'e,
le fichier de sortie principal est ferme' et un autre le remplace, dont
le nom est indique' dans la re`gle {\tt ChangeMainFile}. Les re`gles
{\tt Create} sans indication de fichier de sortie qui sont exe'cute'es
ensuite e'crivent dans ce nouveau fichier. Plusieurs re`gles
{\tt ChangeMainFile} peuvent e^tre exe'cute'es au cours de la me^me
traduction, pour fragmenter la sortie pincipale en plusieurs fichiers.

La re`gle de changement de fichier principal est constitue'e du mot cle'
{\tt ChangeMainFile} suivi du nom de la variable qui de'finit le nom
du nouveau fichier principal. Elle peut comporter ensuite le mot cle'
{\tt Before} ou {\tt After}, pour indiquer si elle doit e^tre exe'cute'e
avant ou apre`s la traduction du contenu de l'e'le'ment auquel elle
s'applique~; en l'absence de ce mot cle', elle est exe'cute'e avant
la traduction du contenu. Un point-virgule doit terminer la re`gle.

\begin{verbatim}
                'ChangeMainFile' IdentVar [ Position ] ';'
\end{verbatim}

\begin{example}
Si on veut sortir chaque section dans un fichier diffe'rent, on peut
associer au type {\tt Section} la re`gle suivante, qui utilise la
variable {\tt VarNomFichier} de'finie p.~\pageref{varnomfichier}.
\begin{verbatim}
     Section :
         ChangeMainFile VarNomFichier Before;
\end{verbatim}
Ainsi, si a` l'appel du programme de traduction, on fournit
{\tt output.txt} comme nom de fichier de sortie, les sections
seront produites dans les fichiers {\tt output1.txt},
{\tt output2.txt}, etc.
\end{example}

\subsection{Re`gles {\tt Set} et {\tt Add}}
\label{setandadd}

Les re`gles {\tt Set} et {\tt Add} sont utilise'es pour modifier la
valeur des compteurs auxquels aucune fonction de comptage n'est
associe'e lors de la de'claration (voir p.~\pageref{compteurs}).
Elles ne peuvent s'appliquer qu'a` ces compteurs.

Les deux re`gles ont la me^me syntaxe~: apre`s le mot cle' identifiant
la re`gle apparaissent le nom du compteur concerne' et la valeur
a` mettre dans le compteur (re`gle {\tt Set}) ou a` ajouter au compteur
(re`gle {\tt Add}). Le mot cle' {\tt Before} ou {\tt After} peut suivre
cette valeur, pour indiquer si la re`gle doit e^tre applique'e avant
ou apre`s la traduction du contenu de l'e'le'ment. Un point-virgule termine
la re`gle.

\begin{verbatim}
                'Set' IdentCompteur ValeurInit
                      [ Position ] ';' /
                'Add' IdentCompteur Increment
                      [ Position ] ';'
\end{verbatim}

\subsection{Ordre d'application des re`gles}
\label{ordreappli}

Le traducteur traite les e'le'ments qui composent le document dans l'ordre
induit par la structure arborescente, sauf exception du^e a` la re`gle
{\tt Get}. Pour chaque e'le'ment, il applique d'abord toutes les re`gles
relatives a` son type et qui doivent s'appliquer avant la traduction du
contenu (re`gles termine'es par le mot cle' {\tt Before} ou sans mot cle' de
position). Si plusieurs re`gles re'pondent a` ce crite`re, il les applique
dans l'ordre ou` elles figurent dans le sche'ma de traduction.

Il applique ensuite toutes les re`gles relatives aux attributs que porte
l'e'le'ment (voir section~\ref{tradattr}) et qui doivent e^tre applique'es
avant le traitement du contenu de l'e'le'ment (mot cle' {\tt Before} ou pas
de mot cle' de position).
Pour une valeur d'attribut, il applique ces re`gles dans l'ordre ou` elles
sont de'finies dans le sche'ma de traduction.

Il fait ensuite de me^me avec les re`gles de traduction relatives a`
la pre'sentation spe'cifique.

Il traite ensuite le contenu de l'e'le'ment, a` moins qu'une re`gle {\tt Remove}
ne s'applique.

Il applique ensuite toutes les re`gles relatives a` la pre'sentation
spe'cifique de l'e'le'ment et qui doivent e^tre applique'es apre`s le
traitement du contenu (mot cle' {\tt After} a` la fin de la re`gle), et pour
chaque type de re`gle de pre'sentation ou chaque valeur, dans l'ordre ou`
les re`gles de traduction sont de'finies dans le sche'ma.

Puis il fait de me^me avec les re`gles de traduction relatives aux attributs
porte's par l'e'le'ment.

Enfin, il applique les re`gles relatives au type de l'e'le'ment et qui doivent
s'appliquer apre`s traitement du contenu. Ces re`gles sont applique'es dans
l'ordre ou` elles apparaissent dans le sche'ma de traduction. Le traitement
de l'e'le'ment e'tant termine', le traducteur proce`de de me^me avec
l'e'le'ment suivant.

Cet odre peut e^tre change' avec les options {\tt Attributes} et
{\tt Presentation} de la re`gle {\tt Create} (voir section~\ref{create}).

\subsection{Traduction des attributs logiques}
\label{tradattr}

Apre`s les re`gles attache'es aux types des e'le'ments, le sche'ma de
traduction de'finit les re`gles attache'es aux valeurs des attributs. Cette
section est introduite par le mot cle' {\tt ATTRIBUTES} et est forme'e d'une
suite de blocs de re`gles pre'ce'de's chacun par un nom d'attribut et
e'ventuellement une valeur ou une plage de valeurs.

Si le nom d'attribut figure seul avant le bloc de re`gles, ces re`gles
sont applique'es a` tous les e'le'ments qui portent l'attribut, quelle
que soit la valeur prise par l'attribut. Dans ce cas, le nom de l'attribut
est suivi du caracte`re deux-points avant le de'but du bloc de re`gles.

Le nom de l'attribut peut e^tre suivi, entre parenthe`ses, d'un nom de type
d'e'le'ment. Cela veut dire, comme dans les sche'mas de pre'sentation, que
le bloc de re`gles qui suit s'applique non pas a` l'e'le'ment me^me qui
porte l'attribut, mais a` ses descendants du type indique' entre parenthe`ses.

Si des valeurs sont indique'es apre`s le nom d'attribut
(ou apre`s l'e'ventuel nom de type), les re`gles sont applique'es seulement
lorsque l'attribut a les valeurs
indique'es. Dans ce cas un me^me attribut peut apparai^tre plusieurs
fois, avec des valeurs diffe'rentes et des re`gles de traduction diffe'rentes.
Les valeurs des attributs sont indique'es sous la me^me forme que dans les
conditions (voir section~\ref{tradcond}) et elles sont suivies du caracte`re
deux-points avant le de'but du bloc de re`gles.

Le bloc de re`gles associe' a` un attribut est soit une simple re`gle, soit
une suite de re`gles de'limite'e par les mot cle's {\tt BEGIN} et {\tt END}.
Rappelons que les re`gles associe'es a` des valeurs d'attribut ne peuvent pas
e^tre conditionnelles.

Il n'est pas ne'cessaire que tous les attributs de'finis dans un sche'ma de
structure, avec toutes leurs valeurs, posse`dent des re`gles de traduction.
Seuls ceux pour lesquels le traducteur doit exe'cuter une action particulie`re
doivent avoir des re`gles. Ces re`gles sont celles qui sont pre'sente'es dans
les sections~\ref{create} a` \ref{notrans}.

\begin{verbatim}
     SuiteAttr     = TradAttr < TradAttr > .
     TradAttr      = IdentAttr [ '(' IdentElem ')' ] 
                     [ RelatAttr ] ':' SuiteRegles .
     IdentAttr     = NAME .
     ValeurAttr    = NAME .
     SuiteRSimples ='BEGIN' < RegleSimple > 'END' ';' / 
                     RegleSimple .
\end{verbatim}

\begin{example}
Le sche'ma de structure de'finit un attribut ``Langue'' qui peut prendre les
valeurs ``Franc,ais'' et ``Anglais''. Dans le document traduit, on veut faire
disparai^tre toutes les parties en franc,ais et on ne veut pas transcoder
le texte des parties en anglais~:
\begin{verbatim}
ATTRIBUTES
   Langue=Francais :
      Remove;
   Langue=Anglais :
      NoTranslation;
\end{verbatim}
\end{example}

\subsection{Traduction de la pre'sentation spe'cifique}
\label{prestrans}

Apre`s les re`gles attache'es aux attributs, le sche'ma de traduction
de'finit les re`gles attache'es a` la pre'sentation spe'cifique. Cette
section est introduite par le mot cle' {\tt PRESENTATION} et est forme'e
d'une suite de blocs de re`gles de traduction pre'ce'de's chacun par un
nom de re`gle de pre'sentation, accompagne' e'ventuellement d'une partie
qui de'pend de la re`gle de pre'sentation concerne'e.

Chacun de ces blocs de re`gles de traduction est applique' lorsque le
traducteur traite un e'le'ment qui porte une re`gle de pre'sentation
spe'cifique du type indique' en te^te du bloc. Selon le type de re`gle de
pre'sentation spe'cifique, on peut spe'cifier les valeurs de la re`gle de
pre'sentation pour lesquelles le bloc de re`gles de traduction doit e^tre
applique'.

Il y a trois cate'gories de re`gles de pre'sentation~:
\begin{itemize}
\item
celles qui prennent des valeurs nume'riques ({\tt Size, Indent, LineSpacing, LineWeight}),
\item
celles dont les valeurs sont prises dans une liste pre'de'finie ({\tt Adjust,
Justify, Hyphenate, Style, Font, Underline, Thickness, LineStyle}),
\item
celles dont la valeur est un nom ({\tt FillPattern, Background, Foreground}).
\end{itemize}

Pour les re`gles de pre'sentation de la premie`re cate'gorie, les valeurs
qui provoquent l'application des re`gles de traduction  sont indique'es
de la me^me fac,on que pour les attributs nume'riques (voir
page~\pageref{relatattr}). Il peut s'agir soit d'une valeur unique soit
d'une plage de valeurs. Dans le cas d'une valeur unique, cette valeur
(un entier) est simplement pre'ce'de'e du signe {\tt =}. Dans le cas
d'une plage de valeurs, il peut s'agir de
\begin{itemize}
\item
toutes les valeurs infe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt <}),
\item
toutes les valeurs supe'rieures a` une valeur donne'e (cette valeur est
pre'ce'de'e du signe {\tt >}),
\item
toutes les valeurs comprises dans un intervalle, bornes comprises. La plage
des valeurs est alors note'e {\tt IN [}MinIntervalPres {\tt ..}
MaxIntervalPres{\tt]}, MinIntervalPres et MaxIntervalPres e'tant des entiers.
\end{itemize}
Toutes ces valeurs nume'riques peuvent e^tre ne'gatives. L'entier est alors
pre'ce'de' du signe {\tt -}. Toutes ces valeurs doivent e^tre donne'es
en points typographiques.

Pour les re`gles de pre'sentation dont les valeurs sont prises dans une
liste pre'de'finie, la valeur qui provoque l'application des re`gles de
traduction est simplement indique'e par le signe {\tt =} suivi du nom de
cette valeur.

Pour les re`gles de pre'sentation dont les valeurs sont des noms,
la valeur qui provoque l'application des re`gles de traduction est
simplement indique'e par le signe {\tt =} suivi du nom de cette
valeur\footnote{Les noms de motifs de remplissage
(re`gle {\tt FillPattern}) et de couleurs (re`gles {\tt Foreground} et
{\tt Background}) connus de Thot sont les me^mes que dans le langage P.}.

\begin{verbatim}
     SuitePres     = TradPres < TradPres > .
     TradPres      = ReglePres ':' SuiteRegles .
     ReglePres     = 'Size' [ PresRelat ] /
                     'Indent' [ RelatPres ] /
                     'LineSpacing' [ RelatPres ] /
                     'Adjust' [ '=' ValAjuste ] /
                     'Justify' [ '=' ValBool ] /
                     'Hyphenate' [ '=' ValBool ] /
                     'Style' [ '=' ValStyle ] /
                     'Font' [ '=' ValFonte ] /
                     'Underline' [ '=' ValSouligne ] /
                     'Thickness' [ '=' ValStyleSoul ] /
                     'LineStyle' [ '=' ValStyleTrait ] /
                     'LineWeight' [ PresRelat ] /
                     'FillPattern' [ '=' Motif ] /
                     'Background' [ '=' Couleur ] /
                     'Foreground' [ '=' Couleur ] .

     RelatPres     = '=' ValeurPres /
                     '>' [ '-' ] MinimumPres /
                     '<' [ '-' ] MaximumPres /
                     'IN' '[' [ '-' ] MinIntervalPres '..'
                              [ '-' ] MaxIntervalPres ']' .
     ValAjuste     = 'Left' / 'Right' / 'VMiddle' / 
                     'LeftWithDots' .
     ValBool       = 'Yes' / 'No' .
     ValStyle      = 'Bold' / 'Italics' / 'Roman' /
                     'BoldItalics' / 'Oblique' /
                     'BoldOblique' .
     ValFonte      = 'Times' / 'Helvetica' / 'Courier' .
     ValSouligne   = 'NoUnderline' / 'Underlined' /
                     'Overlined' / 'CrossedOut' .
     ValStyleSoul  = 'Thick' / 'Thin' .
     ValStyleTrait =  'Solid' / 'Dashed' / 'Dotted' .
     Motif         = NAME .
     Couleur       = NAME .
     MinimumPres   = NUMBER .
     MaximumPres   = NUMBER .
     MinIntervalPres= NUMBER .
     MaxIntervalPres= NUMBER .
     ValeurPres    = [ '-' ] ValPres .
     ValPres       = NUMBER .
\end{verbatim}

\label{valpres}
Les re`gles de traduction associe'es aux re`gles de pre'sentation spe'cifiques
peuvent utiliser la valeur de la re`gle de pre'sentation spe'cifique qui
provoque leur application. Celle-ci est simplement de'signe'e par le mot cle'
{\tt Value}. Lorsqu'il s'agit d'une re`gle de pre'sentation a` valeur
nume'rique c'est la valeur nume'rique qui est produite. Dans les autres cas,
c'est le nom de la valeur qui est produit.

Il est a` noter que les modifications de la ge'ome'trie des e'le'ments du
document obtenues dans l'e'diteur par la combinaison de la touche Ctrl et
d'un bouton de la souris ne peuvent pas
donner lieu a` l'application de re`gles de traduction.

\begin{example}
On veut traduire le corps des caracte`res exprime' sous forme de
pre'sentation spe'cifique en engendrant la chai^ne {\tt pointsize=n} ou`
{\it n} est le corps exprime' en points typographiques, mais on veut que
{\it n} reste dans l'intervalle compris entre 10 et 18. Pour obtenir ce
re'sultat, on e'crit les re`gles suivantes~:
\begin{verbatim}
PRESENTATION
   Size < 10 :
        Create 'pointsize=10';
   Size in [10..18] :
        BEGIN
        Create 'pointsize=';
        Create Value;
        END;
   Size > 18 :
        Create 'pointsize=18';
\end{verbatim}
\end{example}

\subsection{Transcodage des caracte`res, symboles et graphiques}
\label{texttrans}

Le codage des caracte`res, des e'le'ments graphiques et des symboles tel qu'il
est de'fini dans Thot ne correspond pas ne'cessairement a` celui qui est requis
par une application vers laquelle on veut exporter un document de Thot.
Pour cette raison, le traducteur peut transcoder ces e'le'ments
terminaux de la structure des documents. Les sections qui terminent
un sche'ma de traduction sont destine'es a` cet usage, chacune spe'cifiant les
re`gles de transcodage d'un type d'e'le'ment terminal.

Les re`gles de transcodage des chai^nes de caracte`res sont regroupe'es
par alphabets. Il y a un groupe de re`gles pour chaque alphabet du document
Thot qui doit e^tre traduit. Un tel groupe de re`gles commence par le
mot cle' {\tt TEXTTRANSLATE}, suivi de l'indication de l'alphabet a` traduire
et des re`gles de transcodage, comprises entre les mots cle's {\tt BEGIN} et
{\tt END} a` moins qu'il n'y ait qu'une re`gle de transcodage pour l'alphabet.
L'indication de l'alphabet n'est pas obligatoire~: par de'faut il s'agit de
l'alphabet latin (jeu de caracte`res ISO Latin-1).

Chaque re`gle de transcodage est forme'e d'une chai^ne source entre
apostrophes et d'une chai^ne cible, e'galement entre apostrophes, les
deux chai^nes e'tant se'pare'es par le symbole {\tt ->}, forme' des deux
caracte`res ``moins'' et ``supe'rieur''. La re`gle se termine par un
point-virgule.

\begin{verbatim}
     SuiteTradTexte = [ Alphabet ] SuiteTrad .
     Alphabet       = NAME .
     SuiteTrad      ='BEGIN' < Traduction > 'END' ';' /
                      Traduction .
     Traduction     = Source [ '->' Cible ] ';' .
     Source         = STRING .
     Cible          = STRING .
\end{verbatim}

Une telle re`gle signifie que lorsque la chai^ne source apparai^t dans une
feuille de texte du document a` traduire, le traducteur doit la remplacer,
dans le document traduit, par la chai^ne cible. La chai^ne source et
la chai^ne cible peuvent avoir des longueurs diffe'rentes et la chai^ne
cible peut e^tre vide. Dans ce dernier cas, le traducteur supprime purement
et simplement toute occurence de la chai^ne source dans le document traduit.

Pour un alphabet donne',
l'ordre des re`gles n'a pas d'importance et est sans signification, le
compilateur du langage T re'ordonnant les re`gles de fac,on a` acce'le'rer le
travail du traducteur. Le nombre total de re`gles de traduction est limite'
par le compilateur ainsi que la longueur maximum des chai^nes sources
et cibles.

Les re`gles de transcodage des symboles et des e'le'ments graphiques
s'expriment de la me^me fac,on que les re`gles de transcodage des chai^nes
de caracte`res. Elles sont respectivement pre'ce'de'es des mots cle's
{\tt SYMBTRANSLATE} et {\tt GRAPHTRANSLATE} et ne comportent aucune indication
d'alphabet. Leur chai^ne source est
limite'e a` un caracte`re, puisque, pour Thot, chaque symbole et chaque
e'le'ment graphique est code' par un seul caracte`re. Le codage des symboles et
e'le'ments graphiques est de'fini page~\pageref{codage}, de me^me que le
codage des caracte`res non standard.

\begin{example}
Dans un sche'ma de traduction produisant des documents destine's au
formateur \LaTeX, on veut faire traduire tous les caracte`res latins ``e'''
(code octal 351 pour Thot) et ``e`'' (code octal 350) dans leur repre'sentation
en \LaTeX~:
\begin{verbatim}
TEXTTRANSLATE	Latin
     BEGIN
     '\350' -> '\`{e}';    {e accent grave}
     '\351' -> '\''{e}';   {e accent aigu}
     END;
\end{verbatim}
\end{example}


\chapter{Grammaires des langages}

Ce chapitre donne les grammaires comple`tes des langages de Thot. Les
grammaires sont pre'sente'es et commente'es dans les chapitres pre'ce'dents,
qui pre'cisent la se'mantique des langages. On ne trouve ici que la syntaxe.

\section{Me'ta-langage M}

Les grammaires des langages de Thot sont toutes exprime'es dans
le me^me formalisme, le me'ta-langage M. Il est ici de'fini par lui-me^me.

\begin{verbatim}
{Les textes entre accolades sont des commentaires}
Grammaire    = Regle < Regle > 'END' .
               {Les signes < et > indiquent une repetition 
                (zero, une ou plusieurs fois)}
               {END marque la fin de la grammaire}
Regle        = Ident '=' PartieDroite '.' .
               {Le point indique la fin d'une regle}
PartieDroite = DrTerminal / DrIntermed .
               {La barre oblique indique une alternative}
DrTerminal   ='NAME' / 'STRING' / 'NUMBER' .
               {Partie droite d'une regle terminale}
DrIntermed   = Possibilite < '/' Possibilite > .
               {Partie droite d'une regle intermediaire}
Possibilite  = ElRepetOpt < ElRepetOpt > .
ElRepetOpt   = Element / '[' Element < Element > ']' /
              '<' Element < Element > '>'  .
               {Les crochets delimitent une partie
                facultative}
Element      = Ident / MotCle .
Ident        = NAME .
               {Identificateur, suite de caracteres}
MotCle       = STRING .
               {Chaine de caracteres delimitee par 
                des apostrophes}
END
\end{verbatim}

\section{Langage S}

Le langage S est utilise' pour l'e'criture des sche'mas de structure, qui
contiennent les structures logiques ge'ne'riques des classes de documents
et d'objets. Il est de'crit ici dans le me'ta-langage M.

\begin{verbatim}
SchemaStruct  = 'STRUCTURE' [ 'EXTENSION' ] IdentElem ';'
                'DEFPRES' IdentPres ';'
              [ 'ATTR' SuiteAttr ]
              [ 'PARAM' SuiteRegles ]
              [ 'STRUCT' SuiteRegles ]
              [ 'EXTENS' SuiteRegleExtens ]
              [ 'ASSOC' SuiteRegles ]
              [ 'UNITS' SuiteRegles ]
              [ 'EXPORT' SuiteSquelette ]
              [ 'EXCEPT' SuiteExcept ]
                'END' .

IdentElem     = NAME .
IdentPres     = NAME .

SuiteAttr     = Attribut < Attribut > .
Attribut      = IdentAttr '=' TypeAttr ';' .
TypeAttr      = 'INTEGER' / 'TEXT' /
                'REFERENCE' '(' TypeRef ')' /
                SuiteValeurs .
TypeRef       = 'ANY' /
                [ FirstSec ] IdentElem [ StructExt ] .
SuiteValeurs  = ValAttr < ',' ValAttr > .
IdentAttr     = NAME .
FirstSec      = 'First' / 'Second' .
StructExt     = '(' IdentElem ')' .
ValAttr       = NAME .

SuiteRegles   = Regle < Regle > .
Regle         = IdentElem [ SuiteAttrLoc ] '='
                DefAvecAttr ';' .
SuiteAttrLoc  = '(' 'ATTR' AttrLocal < ';' AttrLocal > ')' .
AttrLocal     = [ '!' ] IdentAttr [ '=' TypeAttr ] .
DefAvecAttr   = Definition
                [ '+' '(' SuiteExtension ')' ]
                [ '-' '(' SuiteRestrict ')' ]
                [ 'WITH' SuiteAttrFixes ] .
SuiteExtension= ElemExtension < ',' ElemExtension > .
ElemExtension = IdentElem / 'TEXT' / 'GRAPHICS' /
                'SYMBOL' / 'PICTURE' .
SuiteRestrict = ElemRestrict < ',' ElemRestrict > .
ElemRestrict  = IdentElem / 'TEXT' / 'GRAPHICS' /
                'SYMBOL' / 'PICTURE' .
SuiteAttrFixes= AttrFixe < ',' AttrFixe > .
AttrFixe      = IdentAttr [ ValFixeOuModif ] .
ValFixeOuModif= [ '?' ] '=' ValeurFixe .
ValeurFixe    = [ '-' ] ValeurNum / ValeurTexte / ValAttr .
ValeurNum     = NUMBER .
ValeurTexte   = STRING .

Definition    = TypeDeBase [ SuiteAttrLoc ] / Constr /
                Element .
TypeDeBase    = 'TEXT' / 'GRAPHICS' / 'SYMBOL' / 'PICTURE' /
                'UNIT' / 'NATURE' .
Element       = IdentElem [ ExtOuDef ] .
ExtOuDef      = 'EXTERN' / 'INCLUDED' /
                [ SuiteAttrLoc ] '=' Definition .

Constr        = 'LIST' [ '[' min '..' max ']' ] 'OF'
                        '(' DefAvecAttr ')' /
                'BEGIN' SuiteDefOpt 'END' /
                'AGGREGATE' SuiteDefOpt 'END' /
                'CASE' 'OF' SuiteDef 'END' /
                'REFERENCE' '(' TypeRef ')' /
                'PAIR' .

min           = Entier / '*' .
max           = Entier / '*' .
Entier        = NUMBER .

SuiteDefOpt   = DefOpt ';' < DefOpt ';' > .
DefOpt        = [ '?' ] DefAvecAttr .

SuiteDef      = DefAvecAttr ';' < DefAvecAttr ';' > .

SuiteSquelette= ElemSquelette < ',' ElemSquelette > ';' .
ElemSquelette = IdentElem [ 'WITH' Contenu ] .
Contenu       = 'Nothing' / IdentElem [ StructExt ] .

SuiteExcept   = Except ';' < Except ';' > .
Except        = [ 'EXTERN' ] [ FirstSec ] TypeOuAttrExc ':'
                SuiteValExc .
TypeOuAttrExc = IdentElem / IdentAttr .
SuiteValExc   = ValeurExc < ',' ValeurExc > .
ValeurExc     = 'NoCut' / 'NoCreate' /
                'NoHMove' / 'NoVMove' / 'NoMove' /
                'NoHResize' / 'NoVResize' / 'NoResize' /
                'NewWidth' / 'NewHeight' /
                'NewHPos' / 'NewVPos' /
                'Invisible' / 'NoSelect' /
                'Hidden' / 'ActiveRef' /
		'ImportLine' / 'ImportParagraph' /
		'NoPaginate' / 'HighlightChildren' /
		'ExtendedSelection' .

SuiteRegleExtens = RegleExtens ';' < RegleExtens ';' > .
RegleExtens =   RootOuElem [ SuiteAttrLoc ]
                [ '+' '(' SuiteExtension ')' ]
                [ '-' '(' SuiteRestrict ')' ]
                [ 'WITH' SuiteAttrFixes ] .
RootOuElem =    'Root' / IdentElem .

END
\end{verbatim}

\section{Langage P}

Le langage P est utilise' pour l'e'criture des sche'mas de pre'sentation, qui
de'finissent les re`gles de pre'sentation graphique a` appliquer aux diffe'rentes
classes de documents et d'objets. Il est de'crit ici dans le me'ta-langage M.

\begin{verbatim}
SchemaPres    = 'PRESENTATION' IdentElem ';'
              [ 'VIEWS' SuiteVues ]
              [ 'PRINT' SuiteVuesImpr ]
              [ 'COUNTERS' SuiteCompteurs ]
              [ 'CONST' SuiteConst ]
              [ 'VAR' SuiteVar ]
              [ 'DEFAULT' SuiteReglesVues ]
              [ 'BOXES' SuiteBoites ]
              [ 'RULES' SuitePresent ]
              [ 'ATTRIBUTES' SuitePresAttr ]
              [ 'TRANSMIT' SuiteTransmit ]
                'END' .

IdentElem     = NAME .

SuiteVues     = DeclarationVue < ',' DeclarationVue > ';' .
DeclarationVue= IdentVue [ 'EXPORT' ] .
IdentVue      = NAME .

SuiteVuesImpr = VueImpr < ',' VueImpr > ';' .
VueImpr       = IdentVue / IdentElem .

SuiteCompteurs= Compteur < Compteur > .
Compteur      = IdentCompteur ':' FonctCompteur ';' .
IdentCompteur = NAME .
FonctCompteur = 'RANK' 'OF' TypeOuPage  [ SNiveauAsc ]
                [ 'INIT' IdentAttr ] [ 'REINIT' IdentAttr ] /
                SetFonction < SetFonction >
                AddFonction < AddFonction >
                [ 'INIT' IdentAttr ] /
                'RLEVEL' 'OF' IdentElem .
SNiveauAsc    = [ '-' ] NiveauAsc .
NiveauAsc     = NUMBER .
SetFonction   = 'SET' ValeurCompt 'ON' TypeOuPage .
AddFonction   = 'ADD' ValeurCompt 'ON' TypeOuPage .
TypeOuPage    = 'Page' [ '(' IdentVue ')' ] /
                [ '*' ] IdentElem .
ValeurCompt   = NUMBER .

SuiteConst    = Const < Const > .
Const         = IdentConst '=' TypeConst ValeurConst ';' .
IdentConst    = NAME .
TypeConst     = 'Text' [ Alphabet ] / 'Symbol' /
                'Graphics' / 'Picture' .
ValeurConst   = STRING .
Alphabet      = NAME .

SuiteVar      = Variable < Variable > .
Variable      = IdentVar ':' SuiteFonctions ';' .
IdentVar      = NAME .
SuiteFonctions= Fonction < Fonction > .
Fonction      = 'DATE' / 'FDATE' /
                'DocName' / 'DirName' /
		'ElemName' / 'AttributeName' /
                IdentConst / TypeConst ValeurConst /
                IdentAttr /
                'VALUE' '(' ComptAttrPage ','
                 StyleCompteur ')' .
ComptAttrPage = 'PageNumber' [ '(' IdentVue ')' ] /
                [ MinMax ] IdentCompteur / IdentAttr .
StyleCompteur = 'Arabic' / 'LRoman' / 'URoman' /
                'Uppercase' / 'Lowercase' .
MinMax =        'MaxRangeVal' / 'MinRangeVal' .

SuiteBoites   = Boite < Boite > .
Boite         = 'FORWARD' IdentBoite ';' /
                IdentBoite ':' SuiteReglesVues .
IdentBoite    = NAME .

SuitePresent  = Present < Present > .
Present       = [ '*' ] [ FirstSec ] IdentElem ':'
                SuiteReglesVues .
FirstSec      = 'First' / 'Second' .

SuitePresAttr = PresAttr < PresAttr > .
PresAttr      = IdentAttr [ '(' [ FirstSec ] IdentElem ')' ] 
                [ AttrRelation ] ':' SuiteReglesVues .
IdentAttr     = NAME .
AttrRelation  = '=' ValAttr /
                '>' [ '-' ] ValeurMin /
                '<' [ '-' ] ValeurMax /
                'IN' '[' [ '-' ] BorneInf '..' 
                [ '-' ] BorneSup ']' /
                'GREATER' IdentAttr /
                'EQUAL' IdentAttr /
                'LESS' IdentAttr .
ValAttr       = [ '-' ] NumEgal / TexteEgal / ValeurAttr .
ValeurMin     = NUMBER .
ValeurMax     = NUMBER .
BorneInf      = NUMBER .
BorneSup      = NUMBER.
NumEgal       = NUMBER .
TexteEgal     = STRING .
ValeurAttr    = NAME .

SuiteReglesVues ='BEGIN' < ReglesEtCond > < ReglesVue >
               'END' ';' /
                ReglesVue / ReglesCond / Regle .
ReglesEtCond  = ReglesCond / Regle .
ReglesVue     ='IN' IdentVue SuiteReglesCond .
SuiteReglesCond ='BEGIN' < ReglesEtCond > 'END' ';' /
                ReglesCond / Regle .
ReglesCond    = RegleCond < RegleCond >
                [ 'Otherwise' SuiteRegles ] .
RegleCond     = 'IF' SuiteCondition SuiteRegles .
SuiteRegles   = 'BEGIN' Regle < Regle > 'END' ';' / Regle .

SuiteCondition = Condition < 'AND' Condition > .
Condition     = [ 'NOT' ] [ 'Target' ] ConditionElem .
ConditionElem = 'First' / 'Last' /
		[ 'Immediately' ] 'Within' [ NbParent ]
                              IdentElem [ StructExt ] /
                 IdentElem /
                'Referred' / 'FirstRef' / 'LastRef' /
                'ExternalRef' / 'InternalRef' / 'CopyRef' /
                'AnyAttributes' / 'FirstAttr' / 'LastAttr' /
                'UserPage' / 'StartPage' / 'ComputedPage' /
                'Empty' /
                '(' [ MinMax ] CounterName CondCompteur ')' /
                CondPage '(' IdentCompteur ')' .
NbParent      = [ InfSup ] NParent .
InfSup        = '>' / '<' .
NParent       = NUMBER.
CondCompteur  = '<' MaxCptVal / '>' MinCptVal /
                '=' EqCptVal / 
                'IN' '[' ['-'] MinCptInter '..' 
                 ['-'] MaxCptInter ']' .
CondPage      = 'Even' / 'Odd' / 'One' .
MaxCptVal     = NUMBER .
MinCptVal     = NUMBER .
EqCptVal      = NUMBER .
MaxCptInter   = NUMBER .
MinCptInter   = NUMBER .

Regle         = ParamPres ';' / FonctPres ';' .
ParamPres     = 'VertRef' ':' PositionHoriz /
                'HorizRef' ':' PositionVert /
                'VertPos' ':' PosV /
                'HorizPos' ':' PosH /
                'Height' ':' Dimension /
                'Width' ':' Dimension /
                'VertOverflow' ':' Booleen /
                'HorizOverflow' ':' Booleen /
                'LineSpacing' ':' DistanceHerit /
                'Indent' ':' DistanceHerit /
                'Adjust' ':' AligneHerit /
                'Justify' ':' HeritageBool /
                'Hyphenate' ':' HeritageBool /
                'PageBreak' ':' Booleen /
                'LineBreak' ':' Booleen /
                'InLine' ':' Booleen /
                'NoBreak1' ':' DistAbs /
                'NoBreak2' ':' DistAbs /
                'Gather' ':' Booleen /
                'Visibility' ':' NombreHerit /
                'Size'  ':' TailleHerit /
                'Font' ':' NomHerit /
                'Style' ':' StyleHerit /
                'Underline' ':' SouligneHerit /
                'Thickness' ':' EpaisseurHerit /
                'Depth' ':' NombreHerit /
                'LineStyle' ':' StyleTraitHerit /
                'LineWeight' ':' DistanceHerit /
                'FillPattern' ':' NomHerit /
                'Background' ':' NomHerit /
                'Foreground' ':' NomHerit .
                'Content' ':' VarConst .
FonctPres     = Creation '(' IdentBoite ')' /
                'Line' /
                'NoLine' /
                'Page' '(' IdentBoite ')' /
                'Copy' '(' BoiteTypeACopier ')' .

BoiteTypeACopier = IdentBoite [ StructExt ] /
                   IdentElem [ StructExt ] .
StructExt     = '(' IdentElem ')' .

Distance      = [ Signe ] DistAbs .
Signe         = '+' / '-' .
DistAbs       = PartieEntiereA [ '.' PartieDecimale ]
                [ Unite ] .
PartieEntiereA= PartieEntiere / IdentAttr .
PartieEntiere = NUMBER .
PartieDecimale= NUMBER .
Unite         = 'em' / 'ex' / 'cm' / 'mm' / 'in' / 'pt' /
                'pc' / 'px' / '%' .

PosH          = 'nil' / AxeVert '=' PositionHoriz 
                [ 'UserSpecified' ] .
PosV          = 'nil' / AxeHoriz '=' PositionVert 
                [ 'UserSpecified' ] .
AxeVert       = 'Left' / 'VMiddle' / 'VRef' / 'Right' .
AxeHoriz      = 'Top' / 'HMiddle' / 'HRef' / 'Bottom' .

PositionVert  = Reference '.' AxeHoriz [ Distance ] .
PositionHoriz = Reference '.' AxeVert [ Distance ] .
Reference     = 'Enclosing' [ NBoiteType ] /
                'Enclosed' [ NBoiteType ] /
                'Previous' [ NBoiteType ] /
                'Next' [ NBoiteType ] /
                'Referred' [ NBoiteType ] /
                'Creator' /
                'Root' /
                '*' /
                BoiteType .
BoiteType     = IdentBoite /
                [ '*' ] [ FirstSec ] IdentElem /
                'AnyElem' / 'AnyBox' .
NBoiteType    = [ 'NOT' ] BoiteType .

Dimension     = Reference '.' HautLarg
                [ Rapport ] [ 'Min' ] /
                DistAbs [ 'UserSpecified' ] [ 'Min' ] /
                PosH / PosV .
HautLarg      = 'Height' / 'Width' .
Rapport       = '*' RapportDimA '%' / Distance .
RapportDimA   = RapportDim / IdentAttr .
RapportDim    = NUMBER .

Heritage      = Parente  ValeurHerit .
Parente       = 'Enclosing' / 'GrandFather'/ 'Enclosed' /
                'Previous' / 'Creator' .
ValeurHerit   = '+' EntierPosA [ 'Max' maximumA ] /
                '-' EntierNegA [ 'Min' minimumA ] /
                '=' .
EntierPosA    = EntierPos / IdentAttr .
EntierPos     = NUMBER .
EntierNegA    = EntierNeg / IdentAttr .
EntierNeg     = NUMBER .
maximumA      = maximum / IdentAttr .
maximum       = NUMBER .
minimumA      = minimum / IdentAttr .
minimum       = NUMBER .

AligneHerit   = Parente '=' / Alignement .
Alignement    = 'Left' / 'Right' / 'VMiddle' /
                'LeftWithDots' .

DistanceHerit = Parente DistanceHeritee / Distance .
DistanceHeritee = '=' / '+' DistAbs / '-' DistAbs .

HeritageBool  = Booleen / Parente '=' .
Booleen       = 'Yes' / 'No' .

NombreHerit   = Entier / IdentAttr / Heritage .
Entier        = NUMBER .

StyleTraitHerit = Parente '=' / 'Solid' / 'Dashed' /
                'Dotted' .

TailleHerit   = TailleA [ 'pt' ] / Parente TailleHeritee .
TailleHeritee = '+' TailleA [ 'pt' ] [ 'Max' TailleMaxA ] /
                '-' TailleA [ 'pt' ] [ 'Min' TailleMinA ] /
                '=' .
TailleA       = Taille / IdentAttr .
Taille        = NUMBER .
TailleMaxA    = TailleMax / IdentAttr .
TailleMax     = NUMBER .
TailleMinA    = TailleMin / IdentAttr .
TailleMin     = NUMBER .

NomHerit      = Parente '=' / NomStylePolice .
NomStylePolice= NAME .
StyleHerit    = Parente '=' / 'Roman' / 'Bold' / 'Italics' / 
                'BoldItalics' / 'Oblique' / 'BoldOblique' .
SouligneHerit = Parente '=' / 'NoUnderline' / 'Underlined' / 
                'Overlined' / 'CrossedOut' .
EpaisseurHerit= Parente '=' / 'Thick' / 'Thin' .

VarConst      = IdentConst / TypeConst ValeurConst /
                IdentVar / '(' SuiteFonctions ')' /
                IdentElem .

Creation      = Cree [ 'Repeated' ] .
Cree          = 'CreateFirst' / 'CreateLast' /
                'CreateBefore' / 'CreateAfter' /
                'CreateEnclosing' .

SuiteTransmit = Transmit < Transmit > .
Transmit      = TypeOuCompteur 'To' AttrExterne
                '(' IdentElem ')' ';' .
TypeOuCompteur= IdentCompteur / IdentElem .
AttrExterne   = NAME .

END
\end{verbatim}

\section{Langage T}

Le langage T est utilise' pour l'e'criture des sche'mas de traduction, qui
de'finissent les re`gles de traduction a` appliquer aux diffe'rentes classes
de documents et d'objets. Il est de'crit ici dans le me'ta-langage M.

\begin{verbatim}
SchemaTrad     = 'TRANSLATION' IdentElem ';'
               [ 'LINELENGTH' LongueurLigne ';' ]
               [ 'LINEEND' CARACTERE ';' ]
               [ 'LINEENDINSERT' STRING ';' ]
               [ 'BUFFERS' SuiteBuffers ]
               [ 'COUNTERS' SuiteCompteurs ]
               [ 'CONST' SuiteConst ]
               [ 'VAR' SuiteVariables ]
                 'RULES' LesRegles
               [ 'ATTRIBUTES' SuiteAttr ]
               [ 'PRESENTATION' SuitePres ]
               < 'TEXTTRANSLATE' SuiteTradTexte >
               [ 'SYMBTRANSLATE' SuiteTrad ]
               [ 'GRAPHTRANSLATE' SuiteTrad ]
                 'END' .

LongueurLigne  = NUMBER .

SuiteBuffers   = Buffer < Buffer > .
Buffer         = IdentBuffer [ '(' 'Picture' ')' ] ';' .
IdentBuffer    = NAME .

SuiteConst     = Const < Const > .
Const          = IdentConst '=' ValeurConst ';' .
IdentConst     = NAME .
ValeurConst    = STRING .

SuiteCompteurs = Compteur < Compteur > .
Compteur       = IdentCompteur [ ':' FonctCompteur ] ';' .
IdentCompteur  = NAME .
FonctCompteur  = 'Rank' 'of' IdentElem [ SNiveauAsc ]
                 [ 'Init' IdentAttr ] /
                 'Rlevel' 'of' IdentElem /
                 'Set' ValeurInit 'On' IdentElem
                 'Add' Increment 'On' IdentElem
                 [ 'Init' IdentAttr ] .
SNiveauAsc     = [ '-' ] NiveauAsc .
NiveauAsc      = NUMBER .
ValeurInit     = NUMBER .
Increment      = NUMBER .
IdentElem      = NAME .

SuiteVariables = Variable < Variable > .
Variable       = IdentVar ':' Fonction < Fonction > ';' .
IdentVar       = NAME .

Fonction       = 'Value' '(' IdentCompteur [ ':' Longueur ]
                            [ ',' StyleCompteur ] ')' /
                 'FileDir' / 'FileName' / 'Extension' /
                 'DocumentName' / 'DocumentDir' /
                 IdentConst / ChaineCar /
                 IdentBuffer / IdentAttr .
Longueur       = NUMBER .
StyleCompteur  = 'Arabic' / 'LRoman' / 'URoman' /
                 'Uppercase' / 'Lowercase' .
ChaineCar      = STRING .

LesRegles      = TradType < TradType > .
TradType       = [ FirstSec ] IdentElem ':' SuiteRegles .
FirstSec       = 'First' / 'Second' .
SuiteRegles    = Regle / 'BEGIN' < Regle > 'END' ';' .
Regle          = RegleSimple / BlocCondition .

BlocCondition  = 'IF' SuiteConditions SuiteRSimples .
SuiteConditions= Condition < 'AND' Condition > .
Condition      = [ 'NOT' ] [ 'Target' ] Cond .
Cond           = CondElem / CondAscend .
CondElem       = 'FirstRef' / 'LastRef' /
                 'ExternalRef' /
                 'Defined' /
                 'Alphabet' '=' Alphabet /
                 'ComputedPage' / 'StartPage' / 
                 'UserPage' / 'ReminderPage' /
                 'Empty' /
                 'FirstAttr' / 'LastAttr' .
CondAscend     = [ Ascend ] CondSurAscend .
Ascend         = '*' / 'Parent' / 'Ancestor' NiveauOuType .
NiveauOuType   = CondNivAscend / IdentElem [ StructExt ] .
CondNivAscend  = NUMBER .
CondSurAscend  = 'First' / 'Last' /
                 'Referred' /
                 [ 'Immediately' ] 'Within' [ NbParent ]
                               IdentElem [ StructExt ] /
                 'Attributes' /
                  IdentAttr [ RelatAttr ] /
                 'Presentation' /
                  ReglePres /
                 'Comment' .		    
NbParent       = [ InfSup ] NParent .
InfSup         = '>' / '<' .
NParent        = NUMBER.
IdentAttr      = NAME .
RelatAttr      = '=' Valeur /
                 '>' [ '-' ] Minimum /
                 '<' [ '-' ] Maximum /
                 'IN' '[' [ '-' ] MinInterval '..'
                          [ '-' ] MaxInterval ']' .
Valeur         = [ '-' ] ValEntiere / ValTexte /
                 ValeurAttr .
Minimum        = NUMBER .
Maximum        = NUMBER .
MinInterval    = NUMBER .
MaxInterval    = NUMBER .
ValEntiere     = NUMBER .
ValTexte       = STRING .
ValeurAttr     = NAME .

SuiteRSimples  = 'BEGIN' < RegleSimple > 'END' ';' / 
                 RegleSimple .

RegleSimple    = 'Create' [ 'IN' IdentVar ] Objet
                    [ Position ] ';' /
                 'Write' Objet [ Position ] ';' /
                 'Read' IdentBuffer [ Position ] ';' /
                 'Include' Fichier [ Position ] ';' /
                 'Get' [ PositionRel ] IdentElem 
                    [ StructExt ] [ Position ] ';' /
                 'Copy' [ PositionRel ] IdentElem 
                    [ StructExt ] [ Position ] ';' /
                 'Use' SchemaTr [ 'For' IdentElem ] ';' /
                 'Remove' ';' /
                 'NoTranslation' ';' /
		 'NoLineBreak' ';' /
                 'ChangeMainFile' IdentVar
                    [ Position ] ';' /
                 'Set' IdentCompteur ValeurInit
                    [ Position ] ';' /
                 'Add' IdentCompteur Increment
                    [ Position ] ';' .

Objet          = IdentConst / ChaineCar /
                 IdentBuffer /
		 IdentVar /
                 '(' Fonction < Fonction > ')' /
                 IdentAttr / 'Value' /
                 'Content' / 'Comment' / 
                 'Attributes' / 'Presentation' /
                 'RefId' / 'PairId' /
		 'FileDir' / 'FileName' / 'Extension' /
                 'DocumentName' / 'DocumentDir' /
                 [ 'Referred' ] ObjetRefer .
Position       = 'After' / 'Before' .

ObjetRefer     = IdentVar /
                 IdentElem [ StructExt ] /
                 'RefId' /
		 'DocumentName' / 'DocumentDir' .

PositionRel    = 'Included' / 'Referred' .
StructExt      = '(' IdentElem ')' .
SchemaTr       = NAME .
Fichier        = NomFichier / IdentBuffer .
NomFichier     = STRING .

SuiteAttr      = TradAttr < TradAttr > .
TradAttr       = IdentAttr [ '(' IdentElem ')' ] 
                 [ RelatAttr ] ':' SuiteRegles .

SuitePres      = TradPres < TradPres > .
TradPres       = ReglePres ':' SuiteRegles .
ReglePres      = 'Size' [ PresRelat ] /
                 'Indent' [ RelatPres ] /
                 'LineSpacing' [ RelatPres ] /
                 'Adjust' [ '=' ValAjuste ] /
                 'Justify' [ '=' ValBool ] /
                 'Hyphenate' [ '=' ValBool ] /
                 'Style' [ '=' ValStyle ] /
                 'Font' [ '=' ValFonte ] /
                 'Underline' [ '=' ValSouligne ] /
                 'Thickness' [ '=' ValStyleSoul ] /
                 'LineStyle' [ '=' ValStyleTrait ] /
                 'LineWeight' [ PresRelat ] /
                 'FillPattern' [ '=' Motif ] /
                 'Background' [ '=' Couleur ] /
                 'Foreground' [ '=' Couleur ] .
RelatPres      = '=' ValeurPres /
                 '>' [ '-' ] MinimumPres /
                 '<' [ '-' ] MaximumPres /
                 'IN' '[' [ '-' ] MinIntervalPres '..'
                          [ '-' ] MaxIntervalPres ']' .
ValAjuste      = 'Left' / 'Right' / 'VMiddle' /
                 'LeftWithDots' .
ValBool        = 'Yes' / 'No' .
ValStyle       = 'Bold' / 'Italics' / 'Roman' /
                 'BoldItalics' / 'Oblique' / 'BoldOblique' .
ValFonte       = 'Times' / 'Helvetica' / 'Courier' .
ValSouligne    = 'NoUnderline' / 'Underlined' /
                 'Overlined' / 'CrossedOut' .
ValStyleSoul   = 'Thick' / 'Thin' .
ValStyleTrait  = 'Solid' / 'Dashed' / 'Dotted' .
Motif          = NAME .
Couleur        = NAME .
MinimumPres    = NUMBER .
MaximumPres    = NUMBER .
MinIntervalPres= NUMBER .
MaxIntervalPres= NUMBER .
ValeurPres     = [ '-' ] ValPres .
ValPres        = NUMBER .

SuiteTradTexte = [ Alphabet ] SuiteTrad .
Alphabet       = NAME .
SuiteTrad      = 'BEGIN' < Traduction > 'END' ';' /
                 Traduction .
Traduction     = Source [ '->' Cible ] ';' .
Source         = STRING .
Cible          = STRING .

END
\end{verbatim}

\chapter{Codage des caracte`res}
\label{codage}

\section{Caracte`res}

Les caracte`res de l'alphabet Latin suivent l'encodage de'fini dans la norme
ISO 8859-1 (ISO Latin 1). Les caracte`res de l'alphabet Grec suivent
l'encodage de'fini par Adobe pour sa police Symbol (Adobe FontSpecific).

Les caracte`res dont le code octal est supe'rieur ou e'gal a` 0200 sont
e'crits sous la forme de leur code octal 
pre'ce'de' d'un caracte`re ``$\backslash$''. Par exemple, le mot Re'sume'
s'e'crit {\tt R$\backslash$351sum$\backslash$351}.

Le code ISO 8859-1 a e'te' modifie' pour tenir compte des ligatures
\oe et des diffe'rents espaces offerts par Thot. Les codes octals
correspondant sont les suivants~:\\
{\tt 212} : rupture de ligne\\
{\tt 240} : espace dur\\
{\tt 201} : fine\\
{\tt 202} : demi-cadratin\\
{\tt 230} : $\div$\\
{\tt 231} : $\times$\\
{\tt 367} : \oe\\
{\tt 327} : \OE 

Le caracte`re {\tt 212} est un caracte`re ``rupture de ligne'' qui provoque
un saut de ligne force'.
Le caracte`re {\tt 240} est un ``espace dur'', qui ne peut pas donner lieu a`
un saut de ligne.

\section{Symboles}
\label{codesymbole}

Le tableau ci-dessous donne le codage des symboles de Thot. Les symboles
peuvent e^tre utilise's notamment dans les constantes des sche'mas de
pre'sentation et dans les re`gles de transcodage des sche'mas de traduction.
Chaque symbole est repre'sente' par un seul caracte`re.

\begin{description}
\item{ {\tt r }}: un radical $\surd$
\item{ {\tt i }}: une inte'grale simple $\int$
\item{ {\tt c }}: une inte'grale curviligne $\oint$
\item{ {\tt d }}: une inte'grale double $\int\int$
\item{ {\tt t }}: une inte'grale triple $\int\int\int$
\item{ {\tt S }}: le symbole de la somme $\sum$
\item{ {\tt P }}: le symbole du produit $\prod$
\item{ {\tt U }}: le symbole de l'union $\cup$
\item{ {\tt I }}: le symbole de l'intersection $\cap$
\item{ {\tt > }}: une fle`che a` droite $\rightarrow$
\item{ {\tt < }}: une fle`che a` gauche $\leftarrow$
\item{ {\tt \^{ } }}:  une fle`che vers le haut $\uparrow$
\item{ {\tt V }}: une fle`che vers le bas $\downarrow$
\item{ {\tt ( }}: une parenthe`se ouvrante (
\item{ {\tt ) }}: une parenthe`se fermante )
\item{ {\tt \{ }}: une accolade ouvrante \{
\item{ {\tt \} }}: une accolade fermante \}
\item{ {\tt [ }}: un crochet ouvrant [
\item{ {\tt ] }}: un crochet fermant ]
\end{description}

\section{E'le'ments graphiques}

Le tableau ci-dessous donne le codage des e'le'ments graphiques de Thot. Ces
e'le'ments peuvent e^tre utilise's notamment dans les constantes des sche'mas
de pre'sentation et dans les re`gles de transcodage des sche'mas de
traduction. Chaque e'le'ment graphique est repre'sente' par un seul
caracte`re.

\begin{description}
\item{ {\tt c }}: une ellipse inscrite dans la boi^te $\bigcirc$
\item{ {\tt R }}: un rectangle qui est le contour de la boi^te
\item{ {\tt C }}: un rectangle aux coins arrondis
\item{ {\tt t }}: un trait horizontal, le co^te' supe'rieur de la boi^te ---
\item{ {\tt h }}: un trait horizontal de la longueur de la boi^te, au milieu
de la boi^te ---
\item{ {\tt b }}: un trait horizontal, le co^te' infe'rieur de la boi^te \_\_
\item{ {\tt > }}: une fle`che vers la droite au milieu de la boi^te, de la longueur de la boi^te $\rightarrow$
\item{ {\tt < }}: une fle`che vers la gauche au milieu de la boi^te, de la longueur de la boi^te $\leftarrow$
\item{ {\tt l }}: un trait vertical, le co^te' gauche de la boi^te $\mid$
\item{ {\tt v }}: un trait vertical au milieu de la boi^te, de la hauteur de la boi^te $\mid$
\item{ {\tt r }}: un trait vertical, le co^te' droit de la boi^te $\mid$
\item{ {\tt \^{ } }}: une fle`che vers le haut au milieu de la boi^te, de la hauteur de la boi^te $\uparrow$
\item{ {\tt V }}: une fle`che vers le bas au milieu de la boi^te, de la hauteur de la boi^te $\downarrow$
\item{ {\tt / }}: la diagonale Sud-Ouest Nord-Est de la boi^te /
\item{ $\backslash$ }: la diagonale Nord-Ouest Sud-Est de la boi^te $\backslash$
\item{ {\tt O }}: la diagonale Nord-Ouest Sud-Est de la boi^te, avec une fle`che en haut $\nwarrow$
\item{ {\tt e }}: la diagonale Nord-Ouest Sud-Est de la boi^te, avec une fle`che en bas $\searrow$
\item{ {\tt E }}: la diagonale Sud-Ouest Nord-Est de la boi^te, avec une fle`che en haut $\nearrow$
\item{ {\tt o }}: la diagonale Sud-Ouest Nord-Est de la boi^te, avec une fle`che en bas $\swarrow$
\item{ {\tt espace }}: un e'le'ment transparent
\item{ {\tt P }}: un rectangle aux coins arrondis avec une barre horizontale en haut
\item{ {\tt Q }}: une ellipse avec une barre horizontale en haut~: $\bigcirc$
\item{ {\tt L }}: un losange
\item{ {\tt W }}: le coin sup\'{e}rieur droit~: $\rceil$
\item{ {\tt X }}: le coin inf\'{e}rieur droit~: $\rfloor$
\item{ {\tt Y }}: le coin inf\'{e}rieur gauche~: $\lfloor$
\item{ {\tt Z }}: le coin sup\'{e}rieur gauche~: $\lceil$
\item{ {\tt p }}: un polygone
\item{ {\tt S }}: une ligne brise'e ouverte
\item{ {\tt N }}: une ligne brise'e commenc,ant par une fle`che
\item{ {\tt U }}: une ligne brise'e termine'e par une fle`che
\item{ {\tt M }}: une ligne brise'e avec une fle`che a` chaque extre'mite'
\item{ {\tt s }}: une courbe ferme'e
\item{ {\tt B }}: une courbe ouverte
\item{ {\tt F }}: une courbe ouverte commenc,ant par une fle`che
\item{ {\tt A }}: une courbe ouverte termine'e par une fle`che
\item{ {\tt D }}: une courbe ouverte avec une fle`che a` chaque extre'mite'
\end{description}

\tableofcontents
\listoffigures

\end{document}
