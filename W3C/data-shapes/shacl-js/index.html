<!DOCTYPE html>
<html>
	<head>
		<title>SHACL JavaScript Extensions</title>
		<meta charset="utf-8">
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
		
			var prepareSyntaxRules = function() {
				$("[data-syntax-rule]").each(function(index, element) {
					var ruleId = $(element).attr("data-syntax-rule");
					var tr = $("<tr class=\"syntax-rule-tr\"><td class=\#syntax-rule-id\"><a class=\"syntax-rule-id-a\" href=\"#syntax-rule-" + ruleId + "\">" + ruleId + "</a></td><td>" + $(element).html() + "</td></tr>");
					tr.find("dfn").replaceWith(function(el) { return $("<a>" + $(this).text() + "</a>"); });
					$("#syntax-rules-table").append(tr);
					$(element).attr("id", "syntax-rule-" + ruleId);
				});
			};
		
			var respecConfig = {
			
				localBiblio: {
					"shacl-af": {
						title: "SHACL Advanced Features",
						authors: [ "Holger Knublauch", "Dean Allemang", "Simon Steyskal" ],
						href: "https://www.w3.org/TR/shacl-af/",
						status: "WG-NOTE",
						publisher: "W3C"
					}
				},

				edDraftURI: "https://w3c.github.io/data-shapes/shacl-js/",
				issueBase: "http://www.w3.org/2014/data-shapes/track/issues/",
				specStatus: "FPWD-NOTE",
				preProcess : [ prepareSyntaxRules ],
				shortName:  "shacl-js",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Pano Maria",
						company:    "Taxonic",
						companyURL: "http://taxonic.com"
					}
				],
				publishDate: "2017-05-30",
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes/",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",
				noHighlightCSS: true
			};
		</script>
		<style>


			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}
			
			/* Attempt at fixing unwanted line breaks in some browsers */
			pre {
				word-wrap: normal;
			}

			/* example pre taken / adapted from R2RML */
			pre.shapes, pre.example-shapes, pre.example-data, pre.example-js, pre.example-results, pre.example-other { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; }
			pre.example-shapes:before, pre.example-data:before, pre.example-js:before, pre.example-results:before, pre.example-other:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.shapes, pre.example-shapes { background: #deb; }
			pre.shapes, pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #cca; }
			pre.example-results:before { color: #997; content: "Example validation results"; width: 13em; }
			pre.example-other { background: #bed; }
			pre.example-other, pre.example-other:before { border: 1px solid #ddd; }
			pre.example-other:before { color: #888; content: "Example"; width: 13em; }

			pre.example-js { background: #eeccbe; }
			pre.example-js, pre.example-js:before { border: 1px solid #c9c; }
			pre.example-js:before { color: #996; content: "Example JavaScript"; width: 13em; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id="abstract">
			<p>
				This document defines a JavaScript-based extension mechanism for the Shapes Constraint Language (SHACL).
				It defines a syntax for declaring constraints, constraint components, functions, rules and targets in JavaScript.
				Using this syntax, SHACL shapes can benefit from the rich expressive power of JavaScript.
				In order to ensure that the resulting JavaScript code can be executed across platforms,
				this document defines a (minimalistic) JavaScript API that needs to be implemented by supporting engines.
			</p>
		</section>

		<section id="sotd">
			<p>
				Future revisions of this document may be produced by a SHACL W3C Community Group.
			</p>
		</section>
		
		<section class="introductory">
			<h2>Document Conventions</h2>
			<p>
				Some examples in this document use Turtle [[!turtle]].
				The reader is expected to be familiar with SHACL [[!shacl]] and the SHACL Advanced Features [[!shacl-af]].
			</p>
			<p>
				Within this document, the following namespace prefix bindings are used:
			</p>
			<table class="term-table">
				<tr>
					<th>Prefix</th>
					<th>Namespace</th>
				</tr>
				<tr>
					<td><code>rdf:</code></td>
					<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
				</tr>
				<tr>
					<td><code>rdfs:</code></td>
					<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
				</tr>
				<tr>
					<td><code>sh:</code></td>
					<td><code>http://www.w3.org/ns/shacl#</code></td>
				</tr>
				<tr>
					<td><code>xsd:</code></td>
					<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
				</tr>
				<tr>
					<td><code>ex:</code></td>
					<td><code>http://example.com/ns#</code></td>
				</tr>
			</table>
			<p>
				Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
				These fragments of Turtle documents use the prefix bindings given above.
			</p>
			<pre class="example-shapes">
# This box represents a shapes graph
&lt;s&gt; &lt;p&gt; &lt;o&gt; .</pre>

			<pre class="example-js">
// This box contains JavaScript code</pre>

			<pre class="example-data">
# This box represents a data graph.</pre>

			<pre class="example-results">
# This box represents an output results graph</pre>

			<p>
				Formal definitions appear in blue boxes:
			</p>
			<div class="def def-sparql">
				<div class="def-header">TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains textual definitions. </pre>
			</div>
				
			<p class="syntax">
				Grey boxes such as this include syntax rules that apply to the shapes graph.
			</p>
				
			<p>
				<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
				<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
			</p>
		</section>
				
		<section class="introductory">
			<h2>Terminology</h2>
			<p>
				The terminology used throughout this document is consistent with the definitions in the
				main SHACL [[!shacl]] specification, which references terms from RDF [[!rdf11-concepts]].
				This includes the terms
				<dfn data-lt="blank nodes"><a href="https://www.w3.org/TR/shacl/#dfn-blank-node">blank node</a></dfn>,
				<dfn data-lt="conforms"><a href="https://www.w3.org/TR/shacl/#dfn-conforms">conformance</a></dfn>,
				<dfn data-lt="constraints"><a href="https://www.w3.org/TR/shacl/#dfn-constraint">constraint</a></dfn>,
				<dfn data-lt="constraint components"><a href="https://www.w3.org/TR/shacl/#dfn-constraint-component">constraint component</a></dfn>,
				<dfn data-lt="data graphs"><a href="https://www.w3.org/TR/shacl/#dfn-data-graph">data graph</a></dfn>,
				<dfn data-lt="datatypes"><a href="https://www.w3.org/TR/shacl/#dfn-datatype">datatype</a></dfn>,
				<dfn data-lt="failures"><a href="https://www.w3.org/TR/shacl/#dfn-failure">failure</a></dfn>,
				<dfn data-lt="focus nodes"><a href="https://www.w3.org/TR/shacl/#dfn-focus-node">focus node</a></dfn>,
				<dfn data-lt="RDF graphs|graphs"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-graph">RDF graph</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-ill-formed">ill-formed</a></dfn>,
				<dfn data-lt="IRIs"><a href="https://www.w3.org/TR/shacl/#dfn-iri">IRI</a></dfn>,
				<dfn data-lt="literals"><a href="https://www.w3.org/TR/shacl/#dfn-literal">literal</a></dfn>,
				<dfn data-lt="local names"><a href="https://www.w3.org/TR/shacl/#dfn-local-name">local name</a></dfn>,
				<dfn data-lt="nodes|RDF node"><a href="https://www.w3.org/TR/shacl/#dfn-node">node</a></dfn>,
				<dfn data-lt="node shapes"><a href="https://www.w3.org/TR/shacl/#dfn-node-shape">node shape</a></dfn>,
				<dfn data-lt="objects"><a href="https://www.w3.org/TR/shacl/#dfn-object">object</a></dfn>,
				<dfn data-lt="parameters"><a href="https://www.w3.org/TR/shacl/#dfn-parameters">parameter</a></dfn>,
				<dfn data-lt="predicates"><a href="https://www.w3.org/TR/shacl/#dfn-predicate">predicate</a></dfn>,
				<dfn data-lt="property shapes"><a href="https://www.w3.org/TR/shacl/#dfn-property-shape">property shape</a></dfn>,
				<dfn data-lt="RDF terms|terms|term"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-term">RDF term</a></dfn>,
				<dfn data-lt="SHACL instances"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-instance">SHACL instance</a></dfn>,
				<dfn data-lt="shapes"><a href="https://www.w3.org/TR/shacl/#dfn-shape">shape</a></dfn>,
				<dfn data-lt="shapes graphs"><a href="https://www.w3.org/TR/shacl/#dfn-shapes-graph">shapes graph</a></dfn>,
				<dfn data-lt="subjects"><a href="https://www.w3.org/TR/shacl/#dfn-subject">subject</a></dfn>,
				<dfn data-lt="targets"><a href="https://www.w3.org/TR/shacl/#dfn-target">target</a></dfn>,
				<dfn data-lt="triples"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-triple">triple</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-validation">validation</a></dfn>,
				<dfn data-lt="validation reports"><a href="https://www.w3.org/TR/shacl/#dfn-validation-report">validation report</a></dfn>,
				<dfn data-lt="validation results"><a href="https://www.w3.org/TR/shacl/#dfn-validation-results">validation result</a></dfn>,
				<dfn data-lt="validators"><a href="https://www.w3.org/TR/shacl/#dfn-validators">validator</a></dfn>,
				<dfn data-lt="values"><a href="https://www.w3.org/TR/shacl/#dfn-value">value</a></dfn>,
				<dfn data-lt="value nodes"><a href="https://www.w3.org/TR/shacl/#dfn-value-nodes">value node</a></dfn>.
				Additional terms are defined in the SHACL Advanced Features document [[!shacl-af]]:
				<dfn data-lt="custom targets"><a href="https://www.w3.org/TR/shacl-af/#dfn-target">custom target</a></dfn>,
				<dfn data-lt="rule types"><a href="https://www.w3.org/TR/shacl-af/#dfn-rule-type">rule type</a></dfn>,
				<dfn data-lt="rules|SHACL rules"><a href="https://www.w3.org/TR/shacl-af/#dfn-shacl-rules">rule</a></dfn>,
				<dfn data-lt="functions|SHACL functions"><a href="https://www.w3.org/TR/shacl-af/#dfn-shacl-functions">SHACL function</a></dfn>.
			</p>
		</section>
			
		<section id="introduction">
			<h2>Introduction</h2>
			<p>
				The Shapes Constraint Language (SHACL) [[!shacl]] is a language for validating <a>RDF graphs</a> against a set of conditions.
				These conditions are provided as <a>shapes</a> and other constructs expressed in the form of an RDF graph.
				SHACL is represented in RDF and consists of a SHACL Core RDF vocabulary with terms such as <code>sh:minCount</code>
				to express the most frequently needed <a>constraint</a> kinds.
				However, in order to express more complex constraints, the SHACL Core vocabulary is often not sufficient.
				SHACL-SPARQL [[!shacl]] is one extension mechanism for SHACL to express constraints in SPARQL, allowing shape definitions
				to point at executable SPARQL [[sparql11-query]] queries to perform the validation checks.
				This document defines the <dfn>SHACL JavaScript Extensions (SHACL-JS)</dfn>, allowing users to express
				SHACL constraints and the advanced features of custom targets, functions and rules with the help of JavaScript. 
			</p>
			<p>
				SHACL-JS is based on a similar design to SHACL-SPARQL, but for JavaScript instead of SPARQL.
				The basic idea is that SHACL shapes can point at JavaScript functions in specified JavaScript files that
				can be resolved from the web.
				When shapes get evaluated, a SHACL-JS engine calls those functions with a predefined set of arguments
				and constructs validation results from the values and objects returned by these JavaScript function calls.
				The JavaScript code can access RDF triples from both the <a>shapes graph</a> and the <a>data graph</a> where needed,
				through the <a href="#js-api">JavaScript API</a> that is defined in this document, or a higher-level
				JavaScript API that uses the specified API under the hood.
			</p>
			<p>
				As a result of this design, SHACL shape definitions can be augmented with JavaScript and executed either
				within web browsers (assuming the SHACL engine operates on the client), or on servers that support
				JavaScript execution.
			</p>
		</section>

		<section id="conformance">
		</section>
		
		<section id="js-api">
			<h2>JavaScript API for RDF</h2>
			<p>
				This section defines an API that JavaScript-based SHACL functions can use to operate on
				<a href="#js-api-terms">RDF terms</a> and to query <a href="#js-api-triples">triples</a> in <a href="#js-api-graphs">graphs</a>.
				The JavaScript code behind SHACL-JS <a>constraints</a> and <a>constraint components</a>
				can directly access those functions or go through a higher-level layer of convenience functions that
				use these functions under the hood.
			</p>
			<p>
				Note that the API expects these JavaScript Objects to be immutable, i.e. neither
				the values of an <a href="#js-api-terms">RDF term</a> nor <a href="#js-api-triples">triples</a> nor
				<a href="#js-api-graphs">graphs</a> can be modified during SHACL <a>validation</a>.
			</p>
			<section id="js-api-terms">
				<h3>RDF Terms</h3>
				<p>
					All <a>RDF terms</a> (<a>IRIs</a>, <a>blank nodes</a> and <a>literals</a>) are represented using
					JavaScript Objects that have attributes as described in the following three subsections.
					The following table summarizes key functions to create and operate on RDF term Objects:
				</p>
				<table class="term-table">
					<tr>
						<th>Node Kind</th>
						<th>Factory Function</th>
						<th>Test Function</th>
						<th>Attributes</th>
					</tr>
					<tr>
						<td>IRIs</td>
						<td><code>TermFactory.namedNode(uri)</code></td>
						<td><code>.isURI()</code></td>
						<td><code>uri</code></td>
					</tr>
					<tr>
						<td>Blank Nodes</td>
						<td><code>TermFactory.blankNode(id)</code> or <code>TermFactory.blankNode()</code></td>
						<td><code>.isBlankNode()</code></td>
						<td><code>id</code></td>
					</tr>
					<tr>
						<td>Literals</td>
						<td><code>TermFactory.literal(lex, languageOrDatatype)</code></td>
						<td><code>.isLiteral()</code></td>
						<td><code>datatype</code>, <code>language</code>, <code>lex</code></td>
					</tr>
				</table>
				<p>
					Note that the attributes in the table above are only defined for Objects that have matching types.
					For example, the result of querying the <code>uri</code> of a <a>blank node</a> is undefined.
				</p>
				<p>
					Each of these Objects must have a function <code>.equals(other)</code>
					that takes another term Object as its only parameter and returns <code>true</code>
					exactly if the underlying <a>RDF terms</a> are equal, and <code>false</code> otherwise.
				</p>
				<section id="js-api-iri">
					<h4>IRIs / Named Nodes</h4>
					<p>
						An <a>IRI</a> is represented by a JavaScript <code>NamedNode</code> Object
						where <code>.isURI()</code> returns <code>true</code> while <code>.isBlankNode()</code>
						and <code>.isLiteral()</code> return <code>false</code>.
						The value of the read-only attribute <code>uri</code> is the <a>IRI</a> string.
					</p>
				</section>
				<section id="js-api-bnode">
					<h4>Blank Nodes</h4>
					<p>
						A <a>blank node</a> is represented by a JavaScript <code>BlankNode</code> Object
						where <code>.isBlankNode()</code> returns <code>true</code> while <code>.isURI()</code>
						and <code>.isLiteral()</code> return <code>false</code>.
						The value of the read-only attribute <code>id</code> is the blank node identifier as a string.
						That string is must be consistent for the same RDF node for the duration of a SHACL validation
						and processing of validation results.
					</p>
				</section>
				<section id="js-api-literals">
					<h4>Literals</h4>
					<p>
						A <a>literal</a> is represented by a JavaScript <code>Literal</code> Object
						where <code>.isLiteral()</code> returns <code>true</code> while <code>.isURI()</code> and <code>.isBlankNode()</code>
						return <code>false</code>.
						The value of the read-only attribute <code>language</code> is a lowercase BCP-47 [[!BCP47]]
						string (for example, <code>en</code>, <code>en-gb</code>), or an empty string if the literal has no language.
						The value of the read-only attribute <code>datatype</code> is a <a href="#js-api-iri">NamedNode</a> representing the datatype IRI of the literal.
						Note that this <code>datatype</code> is never undefined, and language-tagged strings have <code>rdf:langString</code> as their datatype.
						The value of the read-only attribute <code>lex</code> is the lexical form of the literal, e.g. <code>"042"</code> for the
						RDF node <code>"042"^^xsd:integer</code>.
					</p>
				</section>
				<section id="js-api-termfactory">
					<h4>The TermFactory</h4>
					<p>
						During the execution of JavaScript code, the SHACL engine MUST provide an Object
						accessible via the variable <code>TermFactory</code> that can be used to create
						JavaScript Objects for RDF terms.
						The <code>TermFactory</code> provides the following three functions:
					</p>
					<ul>
						<li>
							<code>namedNode(uri)</code> returns a  <a href="#js-api-iri">NamedNode</a> with the
							<a>IRI</a> provided as a string via <code>uri</code>.
						</li>
						<li>
							<code>blankNode(id)</code> returns a <a href="#js-api-bnode">BlankNode</a>
							with an optional identifier provided as a string via <code>id</code>.
							If the <code>id</code> is omitted then the system generates a unique identifier.
						</li>
						<li>
							<code>literal(lex, languageOrDatatype)</code> returns a <a href="#js-api-literals">Literal</a>
							with the lexical form provided as a string via <code>lex</code>.
							The second argument <code>languageOrDatatype</code> must be either a non-empty string,
							in which case the literal will have that value as its language tag,
							or a JavaScript <a href="#js-api-iri">NamedNode</a> Object representing a datatype other than
							<code>rdf:langString</code>.
						</li>
					</ul>
				</section>
			</section>
			<section id="js-api-triples">
				<h3>Triples</h3>
				<p>
					An RDF <a>triple</a> is represented by a JavaScript <code>Triple</code> Object with three 
					read-only attributes <code>subject</code>, <code>predicate</code> and <code>object</code>,
					each of which has exactly one RDF term as its value.
					Furthermore, triples must provide an <code>equals</code> function that takes an
					Object <code>other</code> as its only parameter and returns a boolean.
					<code>equals</code> returns <code>true</code> exactly if <code>other</code>
					has values for its attributes <code>subject</code>, <code>predicate</code> and <code>object</code>
					that return <code>true</code> when compared using <code>equals()</code> against the corresponding
					attribute values of the first triple, and <code>false</code> otherwise.
				</p>
			</section>
			<section id="js-api-graphs">
				<h3>Graphs</h3>
				<p>
					An RDF graph is represented by a JavaScript <code>Graph</code> Object that
					has a function <code>find</code> which takes three parameters of type Object,
					all of which are optional.
					The result of the <code>find</code> function is an <dfn data-lt="iterators">Iterator</dfn>
					object with two functions: 
				</p>
				<ul>
					<li>
						<code>next()</code> either returns a <code>Triple</code> or <code>null</code> if the iteration has been exhausted.
					</li>
					<li>
						<code>close()</code> terminates the <a>Iterator</a> and releases any resources allocated by it.
						Once <code>close()</code> has been called, further calls to <code>next()</code> cause an exception.
						The <code>close()</code> function MUST always be called unless the iterator has already been walked to completion.
					</li>
				</ul>
				<p>
					The following JavaScript snippet assumes that the current <a>data graph</a> is represented by
					the variable <code>$data</code> and gets the first label of a given resource
					where the label is an english literal.
				</p>
				<pre class="example-js">
function getEnglishLabel(resource) {
	var labelProperty = TermFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#label");
	var labels = $data.find(resource, labelProperty, null);
	for(;;) {
		var labelTriple = labels.next();
		if(!labelTriple) {
			return null;
		}
		var label = labelTriple.object;
		if(label.isLiteral() &amp;&amp; label.language.startsWith("en")) {
			labels.close();
			return label.value;
		}
	}
}</pre>
				<section id="dataGraph">
					<h4>Accessing the Data Graph via $data</h4>
					<p>
						During a <a>validation</a> process, the variable <code>$data</code> points at the
						JavaScript <a href="#js-api-graphs"><code>Graph</code></a> Object representing the SHACL <a>data graph</a>.
					</p>
				</section>
				<section id="shapesGraph">
					<h4>Accessing the Shapes Graph via $shapes</h4>
					<p>
						During a validation process, the variable <code>$shapes</code> points at the
						JavaScript <a href="#js-api-graphs">Graph</a> Object representing the SHACL <a>shapes graph</a>.
						This may be identical to the <a>data graph</a>.
					</p>
				</section>
				<section id="asynch" class="informative">
					<h4>Synchronous versus Asynchronous Queries</h4>
					<p>
						The iterators produced by the <code>find</code> function described in this section are expected to be
						operating synchronously, i.e. the triples are available immediately to the caller.
						Since many of the constraints that users want to express in SHACL can be quite complex,
						a synchronous API contract typically leads to more maintainable code than an asynchronous one (with callbacks or promises).
						If data needs to be loaded on demand from a remote server, then solutions such as pre-caching or
						the <code>await</code> keyword may be used as a work-around.
						More sophisticated handling of asynchronous query scenarios may be defined by future versions of SHACL-JS.
					</p>
				</section>
			</section>
			<section id="js-validate">
				<h3>Validating Nodes via JavaScript</h3>
				<p>
					SHACL-JS processors must provide a JavaScript function with the following signature:
				</p>
				<code>SHACL.nodeConformsToShape(node, shape)</code>
				<ol>
					<li><code>node</code>: The <a href="#js-api-terms">RDF term Object</a> of the <a>node</a> to validate</li>
					<li><code>shape</code>: The <a href="#js-api-terms">RDF term Object</a> of the <a>shape</a> to validate the <a>node</a> against</li>
				</ol>
				<p>
					The result of this function is <code>true</code> if and only if <code>node</code> <a>conforms</a> to the <code>shape</code>,
					and <code>false</code> otherwise.
				</p>
				<p>
					This function is needed because the implementation of some of the <a>constraint components</a>
					such as <code>sh:NotConstraintComponent</code> requires the ability to spawn off a new
					SHACL validation process.
					It may also be used as entry point into the validation engine by custom code.
				</p>
			</section>
		</section>
		
		<section id="js-rdf">
			<h2>Representing JavaScript in RDF</h2>
			<p>
				This section defines some general <a>RDF terms</a> used by SHACL-JS to represent JavaScript code and libraries
				as part of a declarative <a>shapes graph</a>.
			</p>
			<p>
				The SHACL-JS vocabulary includes the class <code>sh:JSExecutable</code>.
				SHACL instances of this class are called <dfn data-lt="JavaScript executable">JavaScript executables</dfn>
				and may have values for the properties <code>sh:jsFunctionName</code> and <code>sh:jsLibrary</code>.
			</p>
			<section id="jsFunctionName">
				<h3>sh:jsFunctionName</h3>
				<p class="syntax">
					<span data-syntax-rule="jsFunctionName-count">Every <a>JavaScript executable</a> must have exactly one <a>value</a> for the property <code>sh:jsFunctionName</code>.</span>
					<span data-syntax-rule="jsFunctionName-datatype">The values of <code>sh:jsFunctionName</code> are <a>literals</a> with <a>datatype</a> <code>xsd:string</code>.</span>
				</p>
				<p>
					The semantics of how arguments are passed into the provided function depend on the specific type of executable,
					as described in later sections.
				</p>
			</section>
			<section id="jsLibrary">
				<h3>sh:jsLibrary</h3>
				<p class="syntax">
					<span data-syntax-rule="jsLibrary-minCount">Every <a>JavaScript executable</a> must have at least one <a>value</a> for the property <code>sh:jsLibrary</code>.</span>
					<span data-syntax-rule="jsLibrary-nodeKind">The <a>values</a> of the property <code>sh:jsLibrary</code> are <a>IRIs</a> or <a>blank nodes</a>.</span>
					<span data-syntax-rule="jsLibrary-class">The <a>values</a> of the property <code>sh:jsLibrary</code> are well-formed SHACL instances of the class <code>sh:JSLibrary</code>.</span>
				</p>
			</section>
			<section id="JSLibrary">
				<h3>sh:JSLibrary</h3>
				<p>
					The class <code>sh:JSLibrary</code> can be used to declare <dfn data-lt="JavaScript library">JavaScript libraries</dfn>.
					A library can be understood as a pointer to zero or more JavaScript files that need to be executed before a <a>JavaScript executable</a> can be evaluated.
					Libraries may depend on each other by declaring further <code>sh:jsLibrary</code> triples.
				</p>
				<p class="syntax">
					<span data-syntax-rule="jsLibraryURL-datatype">The values of the property <code>sh:jsLibraryURL</code> are <a>literals</a> with <a>datatype</a> <code>xsd:anyURI</code>.</span>
				</p>
			</section>
		</section>
		
		<section id="js-exec">
			<h2>Executing JavaScript</h2>
			<p>
				This section defines general rules for the execution of JavaScript declared in RDF, by a SHACL engine.
			</p>

			<div class="def def-text">
				<div class="def-header">Execution of a JavaScript function</div>
				<div class="def-text-body" id="dfn-execution-of-a-javascript-function">
					Let <code>args</code> be a mapping of variable names to RDF nodes.
					The result of the <dfn data-lt="execution of function">execution of a JavaScript function</dfn> using <code>args</code>
					is the result of the invocation of the JavaScript function, matching each variable name in <code>args</code>
					to parameter values in the function's signature.
					A JavaScript parameter matches a variable name if its name is equal to the concatenation of <code>&quot;$&quot;</code>
					and the variable name.
				</div>
			</div>
			
			<p>
				For the above definition, consider an example function <code>myFunction($arg1, $arg2, $arg3) { ... }</code>
				and a variable mapping <code>{ "arg1" : ex:Instance1, "arg2" : 42 }</code>.
				The JavaScript function would be called with
				the JavaScript  <a href="#js-api-iri"><code>NamedNode</code></a> object representing <code>ex:Instance1</code> as value for <code>$arg1</code>,
				the JavaScript <a href="#js-api-literals"><code>Literal</code></a> object representing <code>42</code> as value for <code>$arg2</code>,
				and <code>undefined</code> as value for <code>$arg3</code>.
			</p>

			<div class="def def-text">
				<div class="def-header">Execution of a JavaScript executable</div>
				<div class="def-text-body" id="dfn-execution-of-a-javascript-executable">
					The <dfn data-lt="execution-of-executable">execution of a <a>JavaScript executable</a></dfn> consists of <em>executing</em>
					any <a>JavaScript libraries</a> that are <a>values</a> of <code>sh:jsLibrary</code> (including
					the libraries referenced by those libraries), followed
					by the <a href="#dfn-execution-of-a-javascript-function">execution of the JavaScript function</a> that has the same name as the
					<a>value</a> of <code>sh:jsFunctionName</code>.
					The result of the latter is the result of executing the executable.
				</div>
			</div>

			<div class="def def-text">
				<div class="def-header">Execution of a JavaScript library</div>
				<div class="def-text-body">
					Within the same JavaScript engine, the same <a>JavaScript library</a> MUST NOT be executed more than once.
					When a <a>JavaScript library</a> is executed, all its values for <code>sh:jsLibraryURL</code> must be resolved into JavaScript code.
					By default this resolution mechanism MUST be performing an HTTP GET request against the given script URL.
					A <a>failure</a> MUST be reported if the SHACL processor encounters a cyclic dependency between libraries.
				</div>
			</div>
			<p>
				In practice, SHACL implementations may redirect the resolution of URLs to local files or cached copies.
			</p>
		</section>
				
		<section id="js-constraints">
			<h2>JavaScript-based Constraints</h2>
			<p>
				SHACL-JS supports constraints that can be used to express restrictions based on JavaScript.
				In a nutshell, whenever a SHACL validation engine encounters a <a>shape</a> with a <code>sh:js</code> <a>constraint</a>,
				it will execute the provided JavaScript function and use the returned result to create <a>validation results</a>.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:JSConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary</th>
				</tr>
				<tr>
					<td><code>sh:js</code></td>
					<td>A <a>JavaScript-based constraint</a> declaring the JavaScript function to evaluate.</td>
				</tr>
			</table>
			<p>
				The <a>values</a> of <code>sh:js</code> at a <a>shape</a> are called <dfn data-lt="JavaScript-based constraint">JavaScript-based constraints</dfn>.
				Each JavaScript-based constraint is also a <a>JavaScript executable</a>.
				The syntax rules and validation process for JavaScript-based constraints are defined in the rest of this section.
			</p>
			
			<section id="js-constraints-example" class="informative">
				<h3>An Example JavaScript-based Constraint</h3>
				<p>
					The following example illustrates the syntax of a <a>JavaScript-based constraint</a>.
				</p>
				<pre class="example-data">
ex:ValidCountry a ex:Country ;
	ex:germanLabel "Spanien"@de .
  
<span class="focus-node-error">ex:InvalidCountry</span> a ex:Country ;
	ex:germanLabel "Spain"@en .</pre>
				<pre class="example-js">
function validateGermanLabel($this) {
	var results = [];
	var p = TermFactory.namedNode("http://example.org/ns#germanLabel");
	var s = $data.find($this, p, null);
	for(var t = s.next(); t; t = s.next()) {
		var object = t.object;
		if(!object.isLiteral() || !object.language.startsWith("de")) {
			results.push({
				value : object
			});
		}
	}
	return results;
}</pre>
				<pre class="example-shapes">
ex:LanguageExampleShape
	a sh:NodeShape ;
	sh:targetClass ex:Country ;
	sh:js [    # _:b1
		a sh:JSConstraint ;   # This triple is optional
		sh:message "Values are literals with German language tag." ;
		sh:jsLibrary [ sh:jsLibraryURL "http://example.org/js/germanLabel.js" ] ;
		sh:jsFunctionName "validateGermanLabel" ;
	] .</pre>
				<p>
					The <a>target</a> of the <a>shape</a> above includes all <a>SHACL instances</a> of <code>ex:Country</code>.
					For those nodes (represented by the variable <code>$this</code>),
					the JavaScript code walks through the <a>values</a> of the property <code>ex:germanLabel</code> at <code>$this</code>
					and verifies that they are <a>literals</a> with a German language tag.
					The <a>validation report</a> for the aforementioned <a>data graph</a> is shown below:
				</p>
				<pre class="example-results">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:resultSeverity sh:Violation ;
		sh:focusNode ex:InvalidCountry ;
		sh:resultMessage "Values are literals with German language tag." ;
		sh:resultPath ex:germanLabel ;
		sh:value "Spain"@en ;
		sh:sourceConstraint _:b1 ;
		sh:sourceConstraintComponent sh:JSConstraintComponent ;
		sh:sourceShape ex:LanguageExampleShape ;
	]
] .</pre>
			</section>
			
			<section id="js-constraints-validation">
				<h3>Validation with JavaScript-based Constraints</h3>
				<p>
					This section defines the validator of <code>sh:JSConstraintComponent</code>.
				</p>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						There are no validation results if the <a>JavaScript-based constraint</a> has <code>true</code>
						as a <a>value</a> for the property <code>sh:deactivated</code>.
						Otherwise, for each <a>focus node</a> <code>F</code> and each <a>value node</a> <code>V</code> for <code>F</code>,
						<a href="#dfn-execution-of-a-javascript-executable">execute</a> the constraint's JavaScript function
						using the argument mapping <code>{ "this" : F, "value" : V }</code>.
						<a href="#js-constraints-results">Construct validation results</a> for each result returned by these function calls.
						Report a <a>failure</a> if the execution of the JavaScript function results in an exception.
					</div>
				</div>
			</section>
			
			<section id="js-constraints-results">
				<h3>Mapping of JavaScript Results to Result Properties</h3>
				<p>
					The following rules define how to construct <a>validation results</a> from a given JavaScript function
					result <code>R</code> in the context of a given <a>constraint</a> <code>C</code> in a <a>shape</a> <code>S</code>,
					a <a>focus node</a> <code>F</code> and a <a>value node</a> <code>V</code>. 
				</p>
				<ol>
					<li>
						<b>If <code>R</code> is a JavaScript <code>String</code></b>:
						<a href="#result-create">Create</a> a <a>validation result</a> <code>?r</code>.
						Add a triple <code>?r sh:resultMessage ?s</code> where <code>?s</code> is an <code>xsd:string</code> literal
						with the JavaScript <code>String</code> as its lexical form.
						Add a <a>triple</a> <code>?r sh:value ?v</code> where <code>?v</code> is the current <a>value node</a> <code>V</code>.
					</li>
					<li>
						<b>If <code>R</code> is a JavaScript Array</b>:
						For each member of the Array <code>R</code> apply the rule for <a href="#result-object">JavaScript Objects</a>.
					</li>
					<li id="result-object">
						<b>If <code>R</code> is a JavaScript <code>Object</code> (not a <code>String</code>)</b>:
						<a href="#result-create">Create</a> a <a>validation result</a> <code>?r</code>.
						If <code>R.value</code> is an <a href="#js-api-terms">RDF term object</a> <code>?v</code>, add a <a>triple</a> <code>?r sh:value ?v</code>.
						If <code>R.message</code> is a JavaScript <code>String</code>, add a <a>triple</a> <code>?r sh:resultMessage ?s</code>
						where <code>?s</code> is an <code>xsd:string</code> <a>literal</a> with the given <code>String</code> as its lexical form.
						Otherwise, add <a>triples</a> <code>?r sh:resultMessage ?m</code> from the <a>shape</a> <code>S</code> following the rules defined by [[!shacl]].
						If the <a>shape</a> <code>S</code> is a <code>node shape</code> and <code>R.path</code> is an RDF
						<a href="#js-api-iri"><code>NamedNode</code></a> object <code>?path</code>, add a <a>triple</a> <code>?r sh:resultPath ?path</code>.
					</li>
					<li>
						<b>If <code>R</code> is the JavaScript <code>Boolean</code> <code>false</code></b>:
						<a href="#result-create">Create</a> a <a>validation result</a> <code>?r</code>.
						Add a <a>triple</a> <code>?r sh:value ?v</code> where <code>?v</code> is the current <a>value node</a> <code>V</code>.
						Add <a>triples</a> <code>?r sh:resultMessage ?m</code> from the <a>shape</a> <code>S</code> following the rules defined by [[!shacl]].
					</li>
				</ol>
				<p id="result-create">
					<b>To create a validation result</b> <code>?r</code>, create a <a>triple</a> <code>?r rdf:type sh:ValidationResult</code>
					using the provided <a>focus node</a> <code>F</code> as value for <code>sh:focusNode</code>,
					deriving <code>sh:resultSeverity</code> from the <code>sh:severity</code> of the <a>shape</a> <code>S</code> in the
					<a>shapes graph</a> (using <code>sh:Violation</code> as default),
					and setting the <code>sh:resultPath</code>, <code>sh:sourceConstraintComponent</code> and <code>sh:sourceShape</code>
					following the rules defined by [[!shacl]].
					If the result is produced by a <a>JavaScript-based constraint</a>, then set <code>sh:sourceConstraint</code>
					to the <a>value</a> of <code>sh:js</code> of the <a>constraint</a> <code>C</code> in the <a>shapes graph</a>.
				</p>
			</section>
		</section>
				
		<section id="js-components">
			<h2>JavaScript-based Constraint Components</h2>
			<p>
				SHACL is based on <a>constraint components</a>, which can be used to express <a>constraints</a> in a declarative, high-level vocabulary.
				For example, the constraint component <code>sh:MinCountConstraintComponent</code> defines a <a>parameter</a> <code>sh:minCount</code>.
				When a <a>shape</a> uses one of these constraint parameters, a SHACL engine finds a suitable <a>validator</a> that can produce validation results.
				SHACL-SPARQL [[!shacl]] defines how SPARQL queries can be used as validators.
				SHACL-JS defines a class <code>sh:JSValidator</code> which can be used to declare validators using JavaScript.
			</p>
			<section class="informative">
				<h3>An Example JavaScript-based Constraint Component</h3>
				<p>
					The following example demonstrates how JavaScript can be used to specify new <a>constraint components</a> using SHACL-JS.
					The example implements <a href="https://www.w3.org/TR/shacl/#MaxLengthConstraintComponent"><code>sh:maxLength</code></a> 
					using a JavaScript-based <a>validator</a> to validate that the string representation of each <a>value node</a>
					has at most a given number of characters.
					Note that this is only an example implementation and should not be considered normative.
				</p>
				<pre class="example-js">
function hasMaxLength($value, $maxLength) {
	if($value.isLiteral()) {
		return $value.lex.length &lt;= $maxLength.lex;
	}
	else if($value.isURI()) {
		return $value.uri.length &lt;= $maxLength.lex;
	}
	else { // Blank node
		return false;
	}
}</pre>
				<pre class="example-shapes" title="Constraint component based on JavaScript">
sh:MaxLengthConstraintComponent
	a sh:ConstraintComponent ;
	sh:parameter [
		sh:path sh:maxLength ;
		sh:datatype xsd:integer ;
	] ;
	sh:validator ex:hasMaxLength .

ex:hasMaxLength
	a sh:JSValidator ;
	sh:message "Value has more than {$maxLength} characters" ;
	rdfs:comment """
		Note that $value and $maxLength are RDF nodes expressed in JavaScript Objects.
		Their string value is accessed via the .lex and .uri attributes.
		The function returns true if no violation has been found.
		""" ;
	sh:jsLibrary [ sh:jsLibraryURL "http://example.org/ns/hasMaxLength.js"^^xsd:anyURI ] ;
	sh:jsFunctionName "hasMaxLength" .</pre>
			</section>
			
			<section>
				<h3>Syntax of JavaScript-based Constraint Components</h3>
				<p>
					The declaration of <dfn data-lt="JavaScript-based Constraint Component">JavaScript-based Constraint Components</dfn> in a <a>shapes graph</a>
					is very similar to <a href="https://www.w3.org/TR/shacl/#constraint-components-syntax">SPARQL-based Constraint Components</a>.
					In particular, components declare their <a>parameters</a> using <code>sh:parameter</code>.
					In fact, the same <a>constraint component</a> may serve as a declaration of both a SPARQL-based
					and a JavaScript-based constraint component, assuming that <a>validators</a> have been declared for both cases.
					Where SHACL-SPARQL uses the classes <code>sh:SPARQLSelectValidator</code> and <code>sh:SPARQLAskValidator</code>,
					SHACL-JS uses the class <code>sh:JSValidator</code>, which is a subclass of <code>sh:JSExecutable</code>.
					Each SHACL-JS validator is also a <a>JavaScript executable</a> and therefore has a value for <code>sh:jsFunctionName</code>.
				</p>
			</section>
			
			<section>
				<h3>Validation of JavaScript-based Constraint Components</h3>
				<p>
					This section defines the <a>validator</a> of <a>JavaScript-based constraint components</a>.
				</p>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>?E</code> be the <a>JavaScript executable</a> selected for the <a>constraint component</a>
						<code>?C</code> based on the rules outlined in
						<a href="https://www.w3.org/TR/shacl/#constraint-components-validators">section 6.2.3</a> of [[!shacl]].
						If the <a>shape</a> is a <a>property shape</a> and the <a>shapes graph</a> contains a <a>triple</a>
						<code>?C sh:propertyValidator ?E</code> then let <code>path</code> be the value of <code>sh:path</code>
						at the <a>shape</a> in the <a>shapes graph</a>, and <a href="#dfn-execution-of-a-javascript-executable">execute</a>
						<code>?E</code> for each <a>focus node</a> <code>F</code> using a mapping <code>{ "this" : F, "path" : path }</code>.
						(The validator's JavaScript function can access the <code>path</code> structure in the <a>shapes graph</a> <code>$shapes</code>,
						assuming the function declares <code>$path</code> as one of its parameters.)
						Otherwise, for each <a>focus node</a> <code>F</code> and each <a>value node</a> <code>V</code>,
						<a href="#dfn-execution-of-a-javascript-executable">execute</a> <code>?E</code>
						using a mapping <code>{ "this" : F, "value" : V }</code>.
						<a href="#js-constraints-results">Construct validation results</a> for each result returned by these function calls.
						Report a <a>failure</a> if the execution of the JavaScript function results in an exception.
					</div>
				</div>
			</section>

		</section>
				
		<section id="js-functions">
			<h2>JavaScript-based Functions</h2>
			<p>
				The SHACL Advanced Features includes a generic mechanism to declare new <a>SHACL functions</a>.
				In particular this is used to declare new SPARQL functions, using the class <code>sh:SPARQLFunction</code>.
				SHACL-JS includes a very similar mechanism, allowing users to declare new functions in an RDF vocabulary
				so that certain engines can use them.
				Functions declared using the SHACL-JS vocabulary can, among others, be used by function calls
				in SPARQL FILTER or BIND clauses and in <a>SHACL rules</a>. 
			</p>
						
			<section class="informative">
				<h3>An Example JavaScript-based Function</h3>
				<p>
					The following example demonstrates how JavaScript can be used to specify new SHACL function.
					The function can be used, for example in SPARQL using <code>BIND (ex:square(4) AS ?s)</code>.
				</p>
				<pre class="example-js">
function square($number) {
	return $number.lex * $number.lex;
}</pre>
				<pre class="example-shapes" title="Function based on JavaScript">
ex:square
	a sh:JSFunction ;
	sh:parameter [
		sh:path ex:number ;
		sh:datatype xsd:integer ;
	] ;
	sh:returnType xsd:integer ;
	sh:jsLibrary [ sh:jsLibraryURL "http://example.org/js/square.js"^^xsd:anyURI ] ;
	sh:jsFunctionName "square" .</pre>
			</section>
			
			<section>
				<h3>Syntax and Semantics of JavaScript-based Functions</h3>
				<p>
					The syntax of <dfn data-lt="JavaScript-based function">JavaScript-based functions</dfn> is very similar to SPARQL-based functions.
					Each <a>SHACL instance</a> of <code>sh:JSFunction</code> in a <a>shapes graph</a>,
					that is an <a>IRI</a>, declares one function.
					The <a>IRI</a> identifies the function, for example, in SPARQL queries.
					The function parameters are declared using <code>sh:parameter</code> in the same
					way as the <a>parameters</a> of <a>constraint components</a> are declared.
					The optional property <code>sh:returnType</code> can be used to specify the type of results
					produced by the function.
					Finally, <code>sh:JSFunction</code> is a subclass of <code>sh:JSExecutable</code>, and
					the syntax rules of <a>JavaScript executables</a> apply to functions, too.
					In particular, each JavaScript-based function has one <a>value</a> of <code>sh:jsFunctionName</code>.
					This is the name of the JavaScript function that is executed whenever the (SHACL) function is called.
				</p>
				<p>
					The JavaScript result <code>R</code> of the <a href="#dfn-execution-of-a-javascript-executable">execution of the function</a> is turned into
					an <a>RDF node</a> using the following rules:
				</p>
				<ol>
					<li>
						<b>If <code>R</code> is a <code>String</code>:</b>
						return an <code>xsd:string</code> <a>literal</a> with the string as its lexical form
					</li>
					<li>
						<b>If <code>R</code> is an <code>Object</code> representing an <a>RDF node</a>:</b>
						return <code>R</code>
					</li>
					<li>
						<b>If <code>R</code> is a <code>Number</code> and the function declares a <code>sh:returnType</code> <code>T</code>
						and the Number can be converted to a well-formed <a>literal</a> with datatype <code>T</code>:</b>
						return a <a>literal</a> with datatype <code>T</code> and the given value as lexical form
					</li>
					<li>
						<b>If <code>R</code> is a <code>Number</code> that can be converted to a well-formed <a>literal</a> with datatype <code>xsd:decimal</code>:</b>
						return an <code>xsd:decimal</code> <a>literal</a> with the given value as lexical form
					</li>
					<li>
						<b>If <code>R</code> is a Boolean:</b>
						return an <code>xsd:boolean</code> <a>literal</a> with the given value as lexical form
					</li>
					<li>
						<b>Otherwise:</b> return no result
					</li> 
				</ol>
				<p>
					During the execution of a JavaScript function, the variable <code>$data</code> can be used to access the
					current query graph, while the variable <code>$shapes</code> is undefined.
				</p>
			</section>
		</section>
		
		<section id="rules">
			<h2>JavaScript Rules</h2>
			<p>
				The SHACL Advanced Features document introduced the concept of SHACL-based <a>rules</a>
				which included an extension mechanism that can be used to define new <a>rule types</a>.
				This section defines a <a>rule type</a> called <dfn data-lt="JavaScript rule">JavaScript rules</dfn>.
			<p>
			<table class="term-table">
				<tr>
					<th>Rule Type IRI</th>
					<th>Key Property</th>
					<th>Other Properties</th>
				</tr>
				<tr>
					<td><code>sh:JSRule</code></td>
					<td><a href="#jsFunctionName"><code>sh:jsFunctionName</code></a></td>
					<td><a href="#jsLibrary"><code>sh:jsLibrary</code></a></td>
				</tr>
			</table>
			<section id="rules-example" class="informative">
				<h3>An Example JavaScript Rule</h3>
				<p>
					The following example illustrates the use of a <a>JavaScript rule</a> to compute the area of
					a rectangle, by multiplying width and height.
				</p>
				<pre class="example-js">
var NS = "http://datashapes.org/js/tests/rules/rectangle.test#";

function computeArea($this) {
	var width = getProperty($this, "width");
	var height = getProperty($this, "height");
	var area = TermFactory.literal(width.lex * height.lex, width.datatype);
	var areaProperty = TermFactory.namedNode(NS + "area");
	return [ [$this, areaProperty, area] ]; 
}

function getProperty($this, name) {
	var it = $data.find($this, TermFactory.namedNode(NS + name), null);
	var result = it.next().object;
	it.close();
	return result;
}</pre>
				<p>
					Note that this code is quite verbose because it uses only the very basic SHACL JavaScript API.
					In real-world examples, a higher level API with convenience methods is likely used.
				</p>
				<pre class="example-shapes" title="Rules example">
ex:RectangleShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:JSRule ;    # This triple is optional
		sh:jsFunctionName "computeArea" ;
		sh:jsLibrary [ sh:jsLibraryURL "http://example.org/js/rectangle.js"^^xsd:anyURI ] ;
    ] .</pre>
    			<p>
					For the following <a>data graph</a>, the <a>triples</a> below would be produced.
				</p>
				<pre class="example-data">
ex:ExampleRectangle
	a ex:Rectangle ;
	ex:width 7 ;
	ex:height 8 .</pre>
				<p>
					Inferred triples:
				</p>
				<pre class="example-inferences">	ex:ExampleRectangle ex:area 56 .</pre>
			</section>
			<section id="rules-execution">
				<h3>Execution Instructions for JavaScript Rules</h3>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Prior to execution, ensure that all JavaScript libraries for the <a>rule</a> (specified via <code>sh:jsLibrary</code>)
						have been executed.
						For each <a>focus node</a>, <a href="#dfn-execution-of-a-javascript-executable">execute</a> the JavaScript function specified as the <a>value</a> of
						<code>sh:jsFunctionName</code> at the <a>rule</a> in the <a>shapes graph</a>, using the <a>focus node</a>
						as the first (and only) argument into the function.
						If the result <code>R</code> of the function call is an Array then for each member <code>O</code>
						of this Array apply the instructions below.
					</div>
				</div>
				<ol>
					<li>
						<b>If <code>O</code> is an Array:</b> Infer a new <a>triple</a> with <a>subject</a> <code>O[0]</code>,
						<a>predicate</a> <code>O[1]</code> and <a>object</a> <code>O[2]</code>.
					</li>
					<li>
						<b>If <code>O</code> is another <code>Object</code>:</b>
						Infer a new <a>triple</a> with <a>subject</a> <code>O.subject</code>, <a>predicate</a> <code>O.predicate</code>
						and <a>object</a> <code>O.object</code>.
					</li>
				</ol>
				<p>
					In other words, each member of the Array returned by the JavaScript function must either
					be another Array with three members (for <a>subject</a>, <a>predicate</a> and <a>object</a>),
					of a JavaScript Object with three fields <code>subject</code>, <code>predicate</code> and <code>object</code>.
				</p>
			</section>
		</section>		
		
		<section id="targets">
			<h2>JavaScript-based Custom Targets</h2>
			<p>
				As one of the SHACL Advanced Features, <a>custom targets</a> define a mechanism to compute <a>target</a>
				nodes by more flexible means than the built-in target types.
				Similar to SPARQL-based targets, this section introduces <a>custom targets</a> based on JavaScript.
			</p>
			<section id="JSTarget">
				<h3>JavaScript-based Targets (sh:JSTarget)</h3>
				<p>
					<a>Custom targets</a> that are <a>SHACL instances</a> of <code>sh:JSTarget</code> are called
					<dfn data-lt="JavaScript-based target">JavaScript-based targets</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="JSTarget"><a>JavaScript-based targets</a> have the same syntax rules as
					<a>JavaScript executables</a> (e.g., requires a <code>sh:jsFunctionName</code>).
					The function must return a JavaScript Array where each member is an RDF term Object.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>T</code> be a <a>JavaScript-based target</a>.
						The <a>target</a> nodes of <code>T</code> are the <a>nodes</a> in the Array returned by its
						<a href="#dfn-execution-of-a-javascript-executable">execution</a> against the <a>data graph</a>.
					</div>
				</div>
			</section>
			<section id="JSTargetType">
				<h3>JavaScript-based Target Types (sh:JSTargetType)</h3>
				<p>
					Very similar to <a href="https://www.w3.org/TR/shacl-af/#SPARQLTargetType">SPARQL-based	target types</a>,
					there is a class <code>sh:JSTargetType</code> declared as <code>rdfs:subClassOf sh:TargetType</code>
					for <dfn data-lt="JavaScript-based target type">JavaScript-based target types</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="JSTargetType"><a>JavaScript-based target types</a> have the same syntax rules as
					<a>JavaScript executables</a> (e.g., requires a <code>sh:jsFunctionName</code>).
					The function must return a JavaScript Array where each member is an RDF term Object.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>T</code> be a <a>JavaScript-based target</a> of target type <code>Y</code>.
						The <a>target</a> nodes of <code>T</code> are the <a>nodes</a> in the Array returned by the
						<a href="#dfn-execution-of-a-javascript-executable">execution</a> of <code>Y</code>
						against the <a>data graph</a>.
						Similar to <a href="#js-components">JavaScript-based constraint components</a>,
						for the execution of the JavaScript function, all <a>parameter</a> values of <code>T</code>
						are mapped to the JavaScript arguments by the <a>local name</a> of the <a>parameter</a> property
						(for example, <code>ex:country</code> is passed into the function as values of <code>$country</code>).
					</div>
				</div>
			</section>
		</section>
		
		<div style="padding-top: 30px">
			<h1 id="appendix" style="font-size: 160%; font-weight: bold">Appendix</h1>
		</div>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of SHACL-JS Syntax Rules</h2>
			<p>
				This section enumerates all normative syntax rules of SHACL-JS.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a <a>shapes graph</a> are <a>ill-formed</a>.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</table>
		</section>
				
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				SHACL-JS shares certain security and privacy considerations with those <a href="https://www.w3.org/TR/shacl/#security">mentioned</a> in [[!shacl]].
				In addition, JavaScript opens a whole new range of topics that are outside of the scope of this document.
				The general advice is for users to only use trusted and controlled shape graphs.
			</p>
		</section>
		
	</body>
</html>
