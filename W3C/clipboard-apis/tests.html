<!DOCTYPE html>
<html><head>
    <title> Clipboard API and events </title>
    <meta charset="UTF-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
    <script class='remove'>
      var respecConfig = {
          // document info
          specStatus:           "ED",
          shortName:            "clipboard-apis",
          //copyrightStart:       "2010",

          // process version for this spec is the 2005 Process Document
          processVersion: "2015",

          edDraftURI:           "https://w3c.github.io/clipboard-apis/",
          // lcEnd:  "2010-08-06",
          // extraCSS:             ["../css/respec.css"],
          /*extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],*/
      NoIDLIn: true,
          // editors
          editors:  [
              { name: "Hallvord R. M. Steen", url: "mailto:hsteen@mozilla.com",
                company: "Mozilla", companyURL: "http://www.mozilla.com/",
                w3cid: "42065" },
          ],
          otherLinks:[
            {
                key:'Repository and Participation',
                data: [
                    {value:"Clipboard API spec on Github", href:"https://github.com/w3c/clipboard-apis/"},
                    {value:"Read past discussions", href:"http://lists.w3.org/Archives/Public/public-webapps/"},
                    {value:"Browse open bugs", href:"https://github.com/w3c/clipboard-apis/issues"},
                    {value:"File an Issue", href:"https://github.com/w3c/clipboard-apis/issues/new"}
                ]
            }
          ],
          // WG
          wg:           "Web Platform Working Group",
          wgURI:        "https://www.w3.org/WebPlatform/WG/",
          license:      "w3c-software-doc",
          wgPublicList: "public-webapps",
          /* add required bibliographic references */
          localBiblio: {
            'RFC2392': {
                    title: 'Content-ID and Message-ID Uniform Resource Locators. August 1998. Internet RFC 2392.',
                    href: 'http://www.ietf.org/rfc/rfc2392.txt',
                    authors: ['E. Levinson']
                     },
            'HTMLEA': {
                    title: 'HTML Editing APIs',
                    href: 'https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html',
                    authors: ['Aryeh Gregor. W3C Editing APIs CG.']
                     },
            'HTMLLS': {
                    title: 'HTML Living Standard',
                    href: 'https://html.spec.whatwg.org/multipage/',
                    authors: ['Ian Hickson. WHATWG.']
                     },
            'MICROSOFT-CLIP-OP': {
                title: 'About DHTML Data Transfer. Microsoft Developer Network.',
                href: 'http://msdn.microsoft.com/en-us/library/ms537658.aspx'}
        },
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83482/status",
        preProcess: [ function(){ // mark all SCRIPTs for removal
            for( var script, scripts=document.getElementsByTagName('script'),i=2;script=scripts[i];i++ )script.className='remove';
        }]
      };
    </script>
</head>
<!--
    The source of this spec contains a number of tests for extraction. Here are some requirements for the test framework:
        each SCRIPT in this file will be turned into one test case per listed event in Events: comment and per Targets: comment
        extra inline HTML code for test case can be given with Test HTML: comment (defaults to single input)
        defines clipboard_api_test() method that returns true for pass, false for failure and string for other unexpected statuses.
        framework must set up a listener for the relevant event(s) that calls the clipboard_api_test() method with the event object as argument, and check return value
        framework will then focus suitable element and trigger relevant event. For paste, data will be given in 'paste data:' comment.
        (If there is no "paste data:" instruction, the framework shall clear the clipboard before each test is run)
        for cut/copy, framework will select element contents before triggering command
        if test function returns undefined, the test is async and will call a result() method the framework must define with pass/fail
        An "External pass condition - clipboard data:" comment indicates that the pass/fail result of the test can not be checked from JavaScript, and the framework must check if the expected data is on the clipboard to know if the test passed or failed
        If the test code defines triggerTestManually() the tester or framework needs to do specific actions before the test runs.
        If the test code defines onTestSetupReady() it must be called after event listeners were defined to trigger the actual test

        Note on automation: if there is an external pass condition, the automation framework must check it and inject script that calls result() method with true or false respectively
-->

<body lang="en">
<section id='abstract'>
    <p>This document describes APIs for clipboard operations such as copy, cut and
    paste in web applications.</p>
</section>

<section id="sotd">
</section>

<section id="conformance"></section>

<section class="informative">
<h2 id="secintro">Introduction</h2>


<p>This specification defines the common clipboard operations of cutting,
copying and pasting, in such a way that they are exposed to Web Applications
and can be adapted to provide advanced functionalities. Its goal is to
provide for compatibility where possible with existing implementations.</p>
</section>

<section class="informative">
<h2 id="Cases">Use Cases</h2>

<p>There are many use cases for being able to change the default clipboard
operations (cut/copy/paste). We have collected
a few samples to demonstrate possible uses, although these may not all be
supported by this specification.</p>

<section><h3 id="Rich">Rich content editing</h3>

<p>When copying text which contains hyperlinks or other structure,
it is often useful to be able to reformat the content to preserve important
information.</p>
</section>

<section><h3>Graphics with built-in semantics</h3>
<p>In order to make web applications which allow the manipulation of rich
text, or of graphic content such as SVG, it is useful to provide a mechanism
that allows for copying more than just the rendered content.</p>
</section>

<section><h3 id="Mathematic">Mathematical information</h3>

<p>With content such as mathematics, simply copying rendered text and pasting
it into another application generally leads to most of the semantics being
lost. MathML often needs to be transformed to be copied as plain text, for example to make sure "to the power of" is shown with the caret  "^" sign in a formula plain-text input. The XML source
could also be placed in the clipboard with the appropriate transformation occurring at paste time.</p>
</section>
</section>
<section>
<h2>APIs from other specifications</h2>
<p>Algorithms in this document rely on several APIs defined in other web platform specifications and recommendations. Below is a list of all methods, properties and definitions this document relies on.</p>
<p>The following items are defined in the HTML Living Standard specification. [[!HTMLLS]]</p>
<ul>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#the-datatransferitemlist-interface">DataTransferItemList</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransfer-setdata">setData()</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransfer-getdata">getData()</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#drag-data-store-mode">drag data store mode</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#the-datatransfer-interface">DataTransfer</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#the-drag-data-item-kind">drag data item kind</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#the-drag-data-item-type-string">drag data item type string</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransfer-files">files</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransfer-types">types</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransfer-cleardata">clearData()</a></dfn></li>
<li><dfn><a href="https://html.spec.whatwg.org/multipage/interaction.html#dom-datatransferitemlist-clear">items.clear()</a></dfn></li>
</ul>
<p>The following items are defined in the HTML5 specification. [[!HTML5]]</p>
<ul>
<li><dfn><a href="https://www.w3.org/TR/html/sections.html#the-body-element">the body element</a></dfn></li>
<li>The <dfn><a href="https://www.w3.org/TR/html5/browsers.html#allowed-to-show-a-popup">allowed to show a popup</a></dfn> logic</li>
</ul>
<p>The following items are defined in the DOM specification [[!DOM]]</p>
<ul>
<li><dfn><a href="https://www.w3.org/TR/dom/#dom-event-type">type</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#dom-event-istrusted">isTrusted</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#dom-event-bubbles">bubbles</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#dom-event-cancelable">cancelable</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#interface-event">event interface</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#constructing-events">construct events</a></dfn></li>
<li><dfn><a href="https://www.w3.org/TR/dom/#eventinit">EventInit</a></dfn></li>
</ul>
</section>

<section>
<h3>Terminology</h3>
<p>The term <dfn>editable context</dfn> means any element that is either an <a data-cite="html">editing host</a>, a textarea element, or an input element with its type attribute set to any of <var>text</var>, <var>search</var>, <var>tel</var>, <var>url</var>, <var>email</var>, <var>password</var> or <var>number</var>.</p>
</section>

<section>

<h3>Clipboard actions and events</h3>
<p>This section defines clipboard actions and events and the processing model for event dispatch.</p>
<section>
    <h4>Actions</h4>
    <p>Each action has two flags called <em>script-triggered</em> and <em>script-may-access-clipboard</em>.</p>
    <p>The <dfn>script-triggered</dfn> flag is set if the action runs because of a script, for example a <code>document.execCommand()</code> call. Future scripting APIs that interact with the clipboard should also use these actions, and the <em>script-triggered</em> flag must be set accordingly.</p>
    <p>The <dfn>script-may-access-clipboard</dfn> flag is set as follows:</p>
    <dl class="switch">
      <dt>If action is <em>copy</em> or <em>cut</em> and the script thread is <a>allowed to modify the clipboard</a></dt>
      <dd>Set the action's <em>script-may-access-clipboard</em> flag</dd>
      <dt>If action is <em>paste</em> and the script thread is <a>allowed to read from clipboard</a></dt>
      <dd>set the action's <em>script-may-access-clipboard</em> flag.</dd>
    </dl>

<section>
<h4>The copy action</h4>
<div class="note">
<p>When the user initiates a copy action, the implementation <a href="#fire-a-clipboard-event">fires a clipboard event</a> named <em>copy</em>. If the event is not canceled, the selected data will be copied to the clipboard. </p>
<script>
/** ClipboardEvent - events fire on INPUT */
/* Events: copy cut */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e, test_obj, eventType){
    var passed = e.type === eventType;
    passed = passed && e.target.id==='input_text';
    return passed;
}
</script>
<script>
/** ClipboardEvent - events fire on TEXTAREA */
/* Events: copy cut */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">copied text</textarea></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e, test_obj, eventType){
    var passed = e.type === eventType;
    passed = passed && e.target.id==='input_text';
    return passed;
}
</script>
<script>
/** setData() method */
/* This test has no selection or cursor, but events should fire anyway (some UAs might require a BeforeCut "preflight" event?) */
/* Events: copy cut */
/* paste data: "pasted text" */
/* External pass condition - clipboard data: "modified text" */
function clipboard_api_test(e){
    var passed = false;
    e.clipboardData.setData('text/plain', 'modified text');
    e.preventDefault();
}
</script>
<script>
/** copy event when there is no selection and script uses setData()  */
/* here we have a cursor in an editable context but no selection */
/* Events: copy cut */
/* Test HTML: <form><input id="input_text" autofocus value="copied text"></form>*/
/* Targets: document */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "modified text" */
function clipboard_api_test(e){
  e.clipboardData.setData('text/plain', 'modified text');
    /* The default action is to do nothing (because there is no selection).
     *  We thus need to prevent the default 'NOOP' action to make the implementation update the clipboard */
  e.preventDefault();
}
</script>

<script>
/** cancelling default action, basic test  */
/* Events: copy cut */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document 'input_text' */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
    e.preventDefault();
}
</script>

<p>The current selection is not affected. The event bubbles and is cancelable.</p>
<script>
/** copy event does not modify selection  */
/* Events: copy */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e, test_obj){
    test_obj.step_timeout(function(){
    /* what is the "most standardised" way to test this? */
    var passed = document.activeElement == document.getElementById('input_text') ;
    passed = passed && document.activeElement.selectionStart == 0 && document.activeElement.selectionEnd == document.activeElement.value.length;
    result(passed);
  }, 10);
}
</script>

<p>A script which uses the event.clipboardData API to control what ends up on the clipboard, needs to cancel the event. Otherwise, the data the script intends to place on the clipboard will be ignored.</p>
<p>If there is no selection, the clipboard is not modified except if the script has added entries in the <a>DataTransferItemList</a>, for example by calling the <a>setData()</a> method, and canceled the event.</p>
</div>


<script>
/** default action of event when there is no selection is noop */
/* Events: copy cut */
/* Test HTML: <form><input id="input_text" onfocus="this.selectionEnd=this.selectionStart" autofocus value="copied text"></form>*/
/* Targets: document */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
  void(0);
}
</script>

<script>
/** default action of cut event when there is no selection - no text change */
/* Events: copy */
/* Test HTML: <form><input id="input_text" onfocus="this.selectionEnd=this.selectionStart" autofocus value="copied text"></form>*/
/* Targets: document */
/* paste data: "clipboard text" */
function clipboard_api_test(e, test_obj){
    var elm=e.target;
  test_obj.step_timeout(
        function(){
            result(elm.value===elm.defaultValue);
        },
        50
    );
}
</script>
<script>
/** getData() method in cut and copy events should return an empty string */
/* Events: cut copy */
function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.getData){
        if(e.clipboardData.getData('text/plain')==='')passed=true;
    }
    return passed;
}
</script>
<script>
/** getData() method when type is unsupported should return an empty string */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.getData){
        if(e.clipboardData.getData('text/foobarbogustype')==='')passed=true;
    }
    return passed;
}
</script>

<pre class="example javascript">
document.addEventListener('copy', function(e){
    e.clipboardData.setData('text/plain', 'Hello, world!');
    e.clipboardData.setData('text/html', '&lt;b&gt;Hello, world!&lt;/b&gt;');
    e.preventDefault(); // We want our data, not data from any selection, to be written to the clipboard
});
</pre>

<p>The copy action consists of the following steps:</p>
<ol>
<li>
    <dl class="switch">
        <dt>If the <em>script-triggered</em> flag is set</dt>
        <dd>
            <dl class="switch">
                <dt>If the <em>script-may-access-clipboard</em> flag is unset</dt>
                <dd>Return false from the copy action, terminate this algorithm</dd>
            </dl>
        </dd>
    </dl>
</li>
<li><a href="#fire-a-clipboard-event">Fire a clipboard event</a> named <em>copy</em></li>
<li>
    <dl class="switch">
        <dt>If the event was not canceled</dt>
        <dd>Copy the selected contents, if any, to the clipboard. Implementations <em>should</em> create alternate text/html and text/plain clipboard formats when content in a web page is selected.</dd>
        <dt>else, if the event was canceled</dt>
        <dd>Call the <a>writing contents to the clipboard</a> algorithm, passing on the <a>DataTransferItemList</a> list <em>items</em>, a <em>clear-was-called</em> flag and a <em>types-to-clear</em> list.</dd>
    </dl>
</li>
<li>Return true from the copy action</li>
</ol>

</section>

<section>

<h4>The cut action</h4>
<div class="note">
<p>When the user initiates a cut action, the implementation <a href="#fire-a-clipboard-event">fires a clipboard event</a> named <em>cut</em>. In an <a>editable context</a>, if the event is not canceled the action will place the selected data on the clipboard and remove the selection from the document.</p>
<p>The event bubbles and is cancelable.</p>
<!-- Tests are above, under copy. One additional test for preventing default action here: -->
<script>
/** cancelling default action of cut prevents removal of text from editable context  */
/* Events: cut */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e, test_obj){
    e.preventDefault();
    var theTarget=e.target;
    test_obj.step_timeout( function(){ var passed = theTarget.value === theTarget.defaultValue; result(passed);   }, 10 );
}
</script>
<p>The cut event fires before the selected data is removed.
<script>
/** cut fires before text is removed  */
/* Events: cut */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="cut text"></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e){
    return e.target.value === e.target.defaultValue;
}
</script>

 When the cut operation is completed, the selection is collapsed.</p>
<script>
/** cut collapses selection  */
/* Events: cut */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="cut text"></form>*/
/* Targets: 'input_text' */
function clipboard_api_test(e, test_obj){
  test_obj.step_timeout(function(){
    var elm=document.getElementById('input_text');
    var passed = elm.selectionStart === 0 && elm.selectionEnd === 0 && elm.value === '';
    result( passed );
  }, 20);
}
</script>

<p>In a non-<a>editable context</a>, or if there is no selection, the <em>cut action</em> does nothing. The implementation fires the event regardless.
<script>
/** no default action for cut in non-editable context */
/* Events: cut */
/* Targets: document  */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
    /* the point of the test is to make sure that the event fires but the clipboard data is not altered */
    /* hence we don't need to to anything here (if the event doesn't fire the test will hang without giving further instructions) */
}
</script>
In this case nothing, the clipboard is not modified except if the script has added entries in the <a>DataTransferItemList</a> and the event is canceled.</p>

<script>
/** setData() in cut event without preventDefault() has no effect when default action is noop */
/* Events: cut */
/* Targets: document  */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
    e.clipboardData.setData('text/plain', 'cut text');
  /* NO e.preventDefault() call here. This event's default action is to do nothing since there is no selection. The test verifies that nothing happens to clipboard content. */
}
</script>


<p>Any script which uses the event.clipboardData API to control what the cut event will write to the clipboard also needs to cancel the event. Otherwise, the data the script intends to place on the clipboard will be ignored.</p>
<script>
/** modifying data for cut event in non-editable context with selection */
/* Events: copy cut */
/* Targets: document  */
/* Test HTML: <script> function onTestSetupReady(){ if(document.createRange){ var range=document.createRange(); range.selectNodeContents(document.body); window.getSelection().addRange(range);}else if(document.selection){ var range=document.selection.createRange(); range.moveToElementText( document.body ); range.select(); }}<\/script>*/
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "cut text" */
function clipboard_api_test(e){
    e.clipboardData.setData('text/plain', 'cut text');
   e.preventDefault(); /* this event's default action is a NOOP since the selection can not be removed. */
}
</script>
<script>
/** setData() method without preventing events's default action */
/* Events: copy cut */
/* External pass condition - clipboard data: "unmodified text" */
/* Test HTML: <form><input autofocus onfocus="this.select()" value="unmodified text"></form>*/
function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.setData){
        e.clipboardData.setData('text/plain', 'copycutpaste modified text');
    }
    //e.preventDefault(); // The point of this test is that we do NOT call preventDefault() here.
}
</script>
</div>

<p>The cut action consists of the following steps:</p>
<ol>
<li>
    <dl class="switch">
        <dt>If the <em>script-triggered</em> flag is set</dt>
        <dd>
            <dl class="switch">
                <dt>If the <em>script-may-access-clipboard</em> flag is unset</dt>
                <dd>Return false from the cut action, terminate this algorithm</dd>
            </dl>
        </dd>
    </dl>
</li>
<li><a href="#fire-a-clipboard-event">Fire a clipboard event</a> named <em>cut</em></li>
<li>
    <dl class="switch">
        <dt>If the event was not canceled</dt>
        <dd>
            <dl class="switch">
                <dt>If there is a selection in an <a>editable context</a> where cutting is enabled</dt>
                <dd>
                    <ol>
                        <li>Copy the selected contents, if any, to the clipboard. Implementations <em>should</em> create alternate text/html and text/plain clipboard formats when content in a web page is selected.</li>
                        <li>Remove the contents of the selection from the document and collapse the selection.</li>
                        <li>Queue tasks to fire any events that should fire due to the modification, see <a href="#integration-with-other-scripts-and-events">interaction with other events</a> for details.</li>
                    </ol>
                </dd>
                <dt>Else, if there is no selection or the context is not editable</dt>
                <dd>Return false</dd>
<script type="text/javascript">
/** execCommand cut in non-editable context returns false */
/* Events: cut */
/* Test HTML: <p>This is filler text</p> */
/* Targets: document */
var eventFired = false
function clipboard_api_test(e){
  var eventFired = true;
}

function triggerTestManually(){
  var returnValue = document.execCommand('cut', false, null);
  /* The event should have fired, but the return value should be false */
  result(eventFired && !returnValue);
}

</script>
            </dl>
        </dd>
        <dt>Else, if the event was canceled</dt>
        <dd>Call the <a>writing contents to the clipboard</a> algorithm, passing on the <a>DataTransferItemList</a> list <em>items</em>, a <em>clear-was-called</em> flag and a <em>types-to-clear</em> list.</dd>
    </dl>
</li>
<li>Return true from the cut action</li>
</ol>



</section>
<section>


<h4>The paste action</h4>
<div class="note">
<p>When a user initiates a paste action, the implementation <a href="#fire-a-clipboard-event">fires a clipboard event</a> named <em>paste</em>. The event fires before any clipboard data is inserted.</p>
<p>The event bubbles and is cancelable.</p>
<script>
/** events fire on INPUT */
/* Events: paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="original text"></form>*/
/* Targets: document 'input_text' */
/* paste data: "pasted text" */
function clipboard_api_test(e, test_obj, eventType){
    var passed = e.type === eventType;
    passed = passed && e.target.id==='input_text';
    return passed;
}
</script>
<script>
/** events fire on TEXTAREA */
/* Events: paste */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">original text</textarea></form>*/
/* Targets: document 'input_text' */
/* paste data: "pasted text" */
function clipboard_api_test(e, test_obj, eventType){
    var passed = e.type === eventType;
    passed = passed && e.target.id==='input_text';
    return passed;
}
</script>

<script>
/** paste event fires before data is inserted */
/* Events: paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="original text"></form>*/
/* Targets: document 'input_text' */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    var passed = e.type == 'paste' && document.getElementById('input_text').value=='original text';
    return passed;
}
</script>


<p>If the cursor is in an editable element, the paste action will insert clipboard data in the most suitable format (if any) supported for the given context.</p>
<script>
/** preventing default action  */
/* Events: paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="original text"></form>*/
/* Targets: document 'input_text' */
/* paste data: "pasted text" */
function clipboard_api_test(e, test_obj){
    e.preventDefault();
    var theTarget=e.target;
    test_obj.step_timeout(function(){
      result(function(){assert_equals(theTarget.value, 'original text');});
    }, 10 );
}
</script>
<p> The paste action has no effect in a non-<a>editable context</a>, but the event fires regardless.</p>

<script>
/** paste event fires even in non-editable context */
/* Events: paste */
/* Targets: document */
/* paste data: "pasted text" */
/* Test HTML: <p>&nbsp;</p>*/
function clipboard_api_test(e){
    var passed = e.type === 'paste';
    return passed;
}
</script>
<p>When pasting, the <a>drag data store mode</a> flag is <em>read-only</em>, hence calling <a>setData()</a> from a <b>paste</b> event handler will not modify the data that is inserted, and not modify the data on the clipboard.</p>
<script>
/** setData() does not modify text that is about to be inserted in a paste event */
/* Events: paste */
/* paste data: "pasted text" */
/* Test HTML: <form><input autofocus></form> */
function clipboard_api_test(e, test_obj){
    test_obj.step_timeout(function(){
      var passed=false;
      passed=e.target.value==='pasted text';
      result(passed);
    }, 10);
    e.clipboardData.setData('text/plain', 'modified text');
}
</script>
<script>
/** setData() does not modify text about to be inserted in a paste event - w preventDefault() */
/* Events: paste */
/* paste data: "pasted text" */
/* Test HTML: <form><input autofocus></form> */
function clipboard_api_test(e, test_obj){
    test_obj.step_timeout(function(){
      result(function(){
        assert_equals(e.target.value, 'pasted text');
      });
    }, 10);
    e.clipboardData.setData('text/plain', 'modified text');
    e.preventDefault();
}
</script>
<script>
/** setData() doesn't modify text on the clipboard when called from a paste event */
/* Events: paste */
/* paste data: "pasted text" */
/* Test HTML: <form><input autofocus id="input_text"></form> */
/* External pass condition - clipboard data: "pasted text" */
/* Targets:  'input_text' */

function clipboard_api_test(e){
  e.clipboardData.setData('text/plain', 'modified text');
}
</script>
<script>
/** setData() doesn't modify text on the clipboard when called from a paste event - w preventDefault() */
/* Events: paste */
/* paste data: "pasted text" */
/* Test HTML: <form><input autofocus id="input_text"></form> */
/* External pass condition - clipboard data: "pasted text" */
/* Targets:  'input_text' */

function clipboard_api_test(e){
  e.clipboardData.setData('text/plain', 'modified text');
  e.preventDefault();
}
</script>
<script>
/** getData() method in paste event retrieving plain text */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    return e.clipboardData.getData('text/plain')==='pasted text';
}
</script>
<script>
/** getData() method when called outside event handler should return an empty string */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e, test_obj){
    var cbData=e.clipboardData;
    test_obj.step_timeout( function(){
        result(function(){
          assert_equals(cbData.getData('text/plain', ''));
        });
    }, 1 );
}
</script>
<script>
/** getData() method with wrong number of arguments */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
  result(function(){
    assert_throws(new TypeError, function(){
        e.clipboardData.getData();
    });
/*    assert_throws('TypeError', function(){
        e.clipboardData.getData('text/plain', 'wrong number of arguments');
    });*/
  });
}
</script>
<script>
/** getData() method supports legacy 'text' argument */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.getData){
        if(  e.clipboardData.getData('text')==='pasted text'
        && e.clipboardData.getData('tEXt')==='pasted text' )passed=true;
    }
    return passed;
}
</script>
<script>
/** getData() supports legacy 'url' argument */
/* Events: paste */
/* paste data: "{'text/uri-list':'http://www.example.com/', 'text/plain': 'example.com'}" */

function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.getData){
        if(  e.clipboardData.getData('url')==='http://www.example.com/'
        && e.clipboardData.getData('uRl')==='http://www.example.com/'
        && e.clipboardData.getData('text/plain') === 'example.com' )passed=true;
    }
    return passed;
}
</script>


<script>
/** getData() method's type argument not case sensitive */
/* Events: paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    var passed = false;
    if(e.clipboardData && e.clipboardData.getData){
        if( e.clipboardData.getData('text/PLAIN')==='pasted text' &&
            e.clipboardData.getData('TEXT/PLAIN')==='pasted text' &&
            e.clipboardData.getData('Text/Plain')==='pasted text' &&
            e.clipboardData.getData('TeXt/PlAin')==='pasted text'
        )passed=true;
    }
    return passed;
}
</script>
</div>
<pre class="example javascript">
document.addEventListener('paste', function(e){
    if(e.clipboardData.types.indexOf('text/html') > -1){
        processDataFromClipboard(e.clipboardData.getData('text/html'));
        e.preventDefault(); // We are already handling the data from the clipboard, we do not want it inserted into the document
    }
});
</pre>

<p>For the paste action, the <em>script-may-access-clipboard</em> flag depends on an implementation-specific permission mechanism for determining what sites or apps may read from the clipboard. When a paste action is triggered by a script, the implementation must not make clipboard contents available without the user's permission. If the permission has not already been granted, the permission prompt must include the hostname of the document associated with the script thread.
</p>
  <p>The paste action consists of the following steps:</p>
<ol>
<li>
    <dl class="switch">
        <dt>If the <em>script-triggered</em> flag is set</dt>
        <dd>
            <dl class="switch">
                <dt>If <em>script-may-access-clipboard</em> is unset</dt>
                <dd>Return false from the paste action, terminate this algorithm</dd>
<script>
/** paste action returns false in non-editable context */
/* Test HTML: <p>This document has no editable context</p> */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    assert_false(document.execCommand('paste', false, null));
}
</script>

            </dl>
        </dd>
    </dl>
</li>
<li><a href="#fire-a-clipboard-event">Fire a clipboard event</a> named <em>paste</em></li>
<li>
    <dl class="switch">
        <dt>If the event was not canceled</dt>
        <dd>
            <dl class="switch">
                <dt>If there is a selection or cursor in an <a>editable context</a> where pasting is enabled</dt>
                <dd><ol>
                        <li>Insert the most suitable content found on the clipboard, if any, into the context.</li>
                        <li>Queue tasks to fire any events that should fire due to the modification, see <a href="#integration-with-other-scripts-and-events">interaction with other events</a> for details.</li>
                    </ol>
                </dd>

                <dt>Else</dt>
                <dd>Return false</dd>
            </dl>
        </dd>
        <dt>Else, if the event was canceled</dt>
        <dd>Return false</dd>
</li>
<li>Return true from the action</li>

</section>
</section>

<section>
<h3>Processing model for event dispatch</h3>


<p>To <dfn id="fire-a-clipboard-event">fire a clipboard event of type <em>e</em></dfn>,</p>
<ol>
    <li>Let <var>clear-was-called</var> be <var>false</var></li>
    <li>Let <var>types-to-clear</var> be an empty list</li>
    <li>Let <var>clipboard-entry</var> be the sequence number of the current clipboard content, or null if the OS clipboard does not support sequence numbers</li>
    <li>Let <var>trusted</var> be <var>true</var> if the event is generated by the user agent, <var>false</var> otherwise</li>
<script>
/** event isTrusted - generated by UA */
/* Events: copy cut paste */
/* paste data: "pasted text" */
function clipboard_api_test(e){
    return e.isTrusted;
}
</script>
<script>
/** event isTrusted - generated by execCommand() */
/* Events: copy cut */
function clipboard_api_test(e){
    return e.isTrusted === false;
}
function triggerTestManually(eventType, test_obj){
  document.execCommand(eventType, false, null);
}
</script>
    <li>Set <var>target</var> as follows:
      <dl class="switch">
        <dt>If the context is editable:</dt>
        <dd>Let <var>target</var> be the element that contains the start of the selection in document order, or <a>the body element</a> if there is no selection or cursor.</dd>
        <dt>Else, if the context is not editable</dt>
        <dd>Let <var>target</var> be the focused node, or <a>the body element</a> if no node has focus.
    </li>
  </dl>
<script>
/** event target when selection spans several elements  */
/* Events: copy cut */
/* Test HTML: <p id="a" contentEditable="true">This<b id="b"> is </b>filler <b>text</b></p><script>if(document.createRange){var range=document.createRange();range.setStartBefore(document.getElementsByTagName('b')[0].firstChild);range.setEnd(document.getElementById('a').childNodes[3].firstChild,2);window.getSelection().addRange(range);}else if(document.selection){ var range=document.selection.createRange(); range.moveToElementText( document.getElementsByTagName('b')[0] ); range.moveEnd('character', 9); range.select(); } <\/script>*/
/* Targets: document 'a' 'b' */

function clipboard_api_test(e){
    var passed = e.target.id === 'b';
    return passed;
}
</script>
<script>
/** event target when selection spans several elements  */
/* Events: paste */
/* Test HTML: <p id="a" contentEditable="true">This<b id="b"> is </b>filler <b>text</b></p><script>if(document.createRange){var range=document.createRange();range.setStartBefore(document.getElementsByTagName('b')[0].firstChild);range.setEnd(document.getElementById('a').childNodes[3].firstChild,2);window.getSelection().addRange(range);}else if(document.selection){ var range=document.selection.createRange(); range.moveToElementText( document.getElementsByTagName('b')[0] ); range.moveEnd('character', 9); range.select(); } <\/script>*/
/* paste data: "pasted text" */
/* Targets: document 'a' 'b' */

function clipboard_api_test(e){
    var passed = e.target.id === 'b';
    return passed;
}
</script>
<script>
/** event target when selection spans several elements - reversed selection  */
/* Events: copy cut */
/* Test HTML: <p id="a" contentEditable="true">This<b id="b"> is </b>filler <b>text</b></p><script>if(document.createRange){var range=document.createRange();range.setStart(document.getElementsByTagName('b')[0].firstChild, 1);range.setEnd(document.getElementById('a').childNodes[3].firstChild,2);var sel=window.getSelection(); var reversedRange=range.cloneRange(); reversedRange.collapse(false); sel.removeAllRanges(); sel.addRange(reversedRange); sel.extend( range.startContainer, range.startOffset );}else if(document.selection){ document.body.appendChild(document.createTextNode('NOTE: this test case requires document.createRange() and window.getSelection() support'));} <\/script>*/
/* Targets: document 'a' 'b' */

function clipboard_api_test(e){
    var passed = e.target.id === 'b';
    return passed;
}
</script>
<script>
/** event target when selection spans several elements - reversed selection  */
/* Events: paste */
/* Test HTML: <p id="a" contentEditable="true">This<b id="b"> is </b>filler <b>text</b></p><script>if(document.createRange){var range=document.createRange();range.setStart(document.getElementsByTagName('b')[0].firstChild, 1);range.setEnd(document.getElementById('a').childNodes[3].firstChild,2);var sel=window.getSelection(); var reversedRange=range.cloneRange(); reversedRange.collapse(false); sel.removeAllRanges(); sel.addRange(reversedRange); sel.extend( range.startContainer, range.startOffset );}else if(document.selection){ document.body.appendChild(document.createTextNode('NOTE: this test case requires document.createRange() and window.getSelection() support'));} <\/script>*/
/* paste data: "pasted text" */
/* Targets: document 'a' 'b' */

function clipboard_api_test(e){
    var passed = e.target.id === 'b';
    return passed;
}
</script>
<script>
/** event target when focused element has no text node inside  */
/* Events: paste */
/* Test HTML: <form><input id="input_img" autofocus onfocus="this.select()" type="image" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAI0lEQVR4nGNkYNjCgARYGBgY/v/3hnAYGbcyMaACdD4jmn4A7CkEc/PaWSMAAAAASUVORK5CYII="></form><script>document.getElementById('input_img').focus()<\/script>*/
/* paste data: "pasted text" */
/* Targets: document 'input_img' */

function clipboard_api_test(e){
  if(document.activeElement.id!='input_img')return 'Not testable, input.focus() has not focused the input type=image';
    var passed = e.target.id==='input_img';
    return passed;
}
</script>
<script>
/** copy event target property - selection in input  */
/* Events: copy cut paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document */

function clipboard_api_test(e){
  var passed = e.target === document.getElementById('input_text');
  return passed;
}
</script>
<script>
/** event target property - selection in document text  */
/* Events: copy cut paste */
/* Test HTML: <div>This text should be selected</div><script>if(document.createRange){var range=document.createRange();range.selectNodeContents(document.getElementsByTagName('div')[0]);window.getSelection().addRange(range);}else if(document.selection){ var range=document.selection.createRange(); range.moveToElementText( document.getElementsByTagName('div')[0] ); range.select(); } <\/script>*/
/* Targets: document */

function clipboard_api_test(e){
  var passed = e.target === document.getElementsByTagName('div')[0];
  return passed;
}
</script>


<script>
/** event target when no specific element has focus  */
/* Events: copy cut paste */
/* Test HTML: <div>This is filler text</div>*/
/* Targets: document */

function clipboard_api_test(e){
    var passed = e.target===document.body;
    return passed;
}
</script>
</li>

<li>
    <dl class="switch">
        <dt>If <em>e</em> is <var>paste</var></dt>
        <dd>
            <p>Set the associated <a>DataTransfer</a> object's <a>drag data store mode</a> flag to <em>read-only</em></p>
            <dl class="switch">
                <dt>If <var>trusted</var> is <var>true</var>, or the implementation is configured to give script-generated events read access to the OS clipboard</dt>
                <dd>
                    <!-- tests: setData() does not modify text that is about to be inserted in a paste event ++ below  -->
                    <p>For each part on the OS clipboard, carry out these steps:</p>
                    <dl class="switch">
                        <dt>If the current clipboard part contains plain text:</dt>
                        <dd>
                            <ol>
                                <li>Ensure the text is in the encoding the scripting engine uses internally</li>
                                <li>Add one entry for the text to the <a>DataTransferItemList</a> with <a>drag data item kind</a> set to <em>string</em> and <a>drag data item type string</a> set to <em>text/plain</em></li>
<script>
/** clipboardData.items when clipboard has one single text/plain entry */
/* Events: paste */
/* paste data: "pasted text" */

function clipboard_api_test(e){
    var passed = e.clipboardData.items && e.clipboardData.items.length === 1;
    passed = passed && e.clipboardData.items[0].kind=='string' &&  e.clipboardData.items[0].type=='text/plain';
    return passed;
}
</script>
<script>
/** getting data from clipboardData.items when clipboard has one single text/plain entry */
/* Events: paste */
/* paste data: "pasted text" */

function clipboard_api_test(e){
    e.clipboardData.items[0].getAsString( function(s){
        result( s==='pasted text' );
    } );
}
</script>
<script>
/** setData and clipboardData.items  */
/* Events: copy cut */

function clipboard_api_test(e){
    e.clipboardData.setData('text/plain', 'modified text');
    var passed = e.clipboardData.items && e.clipboardData.items.length === 1;
    passed = passed && e.clipboardData.items[0].kind=='string' &&  e.clipboardData.items[0].type=='text/plain';
    return passed;
}
</script>
                            </ol>
                        </dd>
                        <!-- CF_HDROP -->
                        <dt>If the current clipboard part represents file references:</dt>
                        <dd>
                            <ol>
                                <li>Determine MIME type of referenced files</li>
                                <li>
                                    Add one entry per file reference to the <a>DataTransferItemList</a> with <a>drag data item kind</a> set to <em>file</em> and <a>drag data item type string</a> set to the corresponding MIME type,

<script>
/** pasting a file */
/* Events: paste */
/* Targets: document */
/* Clipboard data type: file reference: ./support/image.jpg */
/* paste data: "the file 'support/image.jpg'" */
/* Test HTML: <p>To complete this test, copy the './support/image.jpg' file from the OS file manager and paste into this page</p> <div contentEditable="true" id="paste_here">&nbsp;</div><script>document.getElementById('paste_here').focus()<\/script>*/

function clipboard_api_test(e){
    var passed = e.clipboardData.items && e.clipboardData.items.length === 1 ? true : false;
    passed = passed && e.clipboardData.items[0].kind=='file' && ( /image\/jpe?g/i.test(e.clipboardData.items[0].type) );
    return passed;
}
// TODO: figure out how to automate this test (i.e. find a better cross-platform clipboard library for JRuby..)
</script>

                                    or <code>application/octet-stream</code> if the file's type is unknown.</li>
<script>
/** pasting a file of unknown type */
/* Events: paste */
/* paste data: "the file 'support/test'" */
/* Targets: document */
/*     Clipboard data type: file reference: ./support/test */
/* Test HTML: <p>To complete this test, copy the "./support/test" file from the OS file manager and paste into this page</p>*/

function clipboard_api_test(e){
    var passed = e.clipboardData.items && e.clipboardData.items.length === 1;
    passed = passed && e.clipboardData.items[0].kind=='file' && ( /application\/octet-stream/.test(e.clipboardData.items[0].type) );
    return passed;
}
// TODO: figure out how to automate this test (i.e. find a better cross-platform clipboard library for JRuby..)
</script>
                            </ol>
                        </dd>
                        <dt>If the current clipboard part contains HTML- or XHTML-formatted text, according to the operating system's convention for describing such clipboard formats </dt>
                        <dd id="processing-model-for-html-data">
                            <p>If the implementation supports pasting HTML, the implementation <em>must</em> process the markup according to the following steps:</p>
                            <ol>
                                <li>Add one entry to the <a>DataTransferItemList</a> with <a>drag data item kind</a> set to <em>Plain Unicode string</em>, <a>drag data item type string</a> set to <em>text/html</em> or <em>application/xhtml+xml</em> accordingly. Let <var>mainPartIndex</var> be the index of this entry in the <a>DataTransferItemList</a>.</li>
                                <li>Extract the markup from the clipboard and use the relevant parser to construct a DOM tree</li>
                                <li>If the markup's source URL is known, resolve all relative URLs in HREF and SRC attributes using the source URL as base URL, and set the respective attributes to the resolved absolute URL</li>
                                <li>If the markup's origin is from a local application, check whether there are references to local files and/or other parts of the OS clipboard's contents. If such references are found, references to sub-parts <em>must</em> be replaced by content-id references using the cid: URL scheme [[!RFC2392]]. To do so, process each attribute referencing a local file or clipboard part according to the following steps:
                                <p class="issue">Are these steps necessary? Do we know about native (platform) clipboard implementations that support multiple parts with internal references?</p>
                                <p class="issue">This feature is at risk because it's unclear whether it is required, and because it's hard to test in a cross-platform way.</p>
                                    <ol>
                                        <li>Let <var>itemNumber</var> be the number of items on the <a>DataTransferItemList</a></li>
                                        <li><p>Choose the appropriate steps from this list:</p>
                                            <dl class="switch">
                                                <dt>If the <a>DataTransferItemList</a> of the current <a>DataTransfer</a> object already contains an entry for the referenced file or clipboard part</dt>
                                                <dd>set <var>itemNumber</var> to the index of the existing entry</dd>
                                                <dt>Otherwise</dt>
                                                <dd>
                                                    <ol>
                                                        <li>Add a new entry to the <a>DataTransferItemList</a> with <code>index</code> set to <var>itemNumber</var>, <a>drag data item kind</a> set to "file", and <a>drag data item type string</a> set to the MIME type of the file or clipboard part if known, or <code>application/octet-stream</code> if the file's type is unknown.</li>
                                                        <li>Let the new entry's internal <i>file name</i> be the file name part of the HTML attribute contents</li>
                                                        <li>Let the new entry's <i>last modified date</i> be the timestamp of the referenced file or 0 if the entry references a clipboard part</li>
                                                    </ol></dd>
                                            </dl>
                                        </li>
                                        <li>Update the DOM attribute that referenced the local file or clipboard part to contain the string 'cid:' followed by <var>itemNumber</var>.
                                        </li>
                                    </ol>
                                </li>
                                <li>Serialize the processed DOM and update the <a>DataTransferItemList</a> entry referenced by <var>mainPartIndex</var> with the resulting HTML code</li>
                            </ol>
                        </dd>
                        <dt>If the current clipboard part contains data in <a href="#mandatory-data-types">another supported binary or text-based format</a>:</dt>
                        <dd>
                            <ol>
                                <li>Determine the MIME type of the data
                                </li>
                                <li>Add one entry to the <a>DataTransferItemList</a> with <a>drag data item kind</a> set to <em>file</em>, <a>drag data item type string</a> set to the corresponding MIME type</li>
                            </ol>
                        </dd>

                    </dl>
                </dd>
            </dl>
        <p>Update the <a>files</a> property to match entries in the <a>DataTransferItemList</a>.</p>
        <p>Update the <a>types</a> property to match entries in the <a>DataTransferItemList</a>.</p>
        </dd>
        <dt>If <em>e</em> is <var>copy</var> or <var>cut</var></dt>
        <dd>
            <p>Set the associated <a>DataTransfer</a> object's <a>drag data store mode</a> flag to <em>read/write</em></p>
        </dd>
    </dl>
</li>
<li> Dispatch an event named <var>e</var> which bubbles and is cancelable and which uses the <a href="#clipboardevent">ClipboardEvent</a> interface, with <a>isTrusted</a> set to <var>trusted</var>, at <var>target</var>.
<script>
/** event.clipboardData exists and inherits from DataTransfer */
/* Events: copy cut paste */
/* Targets: document */

function clipboard_api_test(e){
    var passed = typeof e.clipboardData === 'object' && e.clipboardData instanceof DataTransfer;
    return passed;
}
</script>
 <script>
/** Clipboard event's clipboardData API */
/* Events: cut copy paste */
function clipboard_api_test(e){
    var passed = typeof e.clipboardData === 'object';
    passed = passed && typeof  e.clipboardData.clearData === 'function';
    passed = passed && typeof  e.clipboardData.setData === 'function';
    passed = passed && typeof  e.clipboardData.getData === 'function';
    passed = passed && typeof  e.clipboardData.types != 'undefined'; // TODO...
    return passed;
}
</script>

    <p>Implementation requirements for access to data during event dispatch are defined in [[!HTMLLS]]. Some additional clipboard event-specific processing rules are given below:</p>
    <p class="issue">Why here? Why not in the HTML spec?</p>
    <dl class="switch">
        <dt>If a script calls <a>clearData()</a> or <a>items.clear()</a> and the <a>DataTransfer</a> object's <a>drag data store mode</a> flag is <em>read/write</em></dt>
        <dd>set the <var>clear-was-called</var> flag to true. If an argument is given, add the argument to the <var>types-to-clear</var> list.</dd>
<script>
/** clearData() method without arguments */
/* Events: copy cut */
/* External pass condition - clipboard data: "" */
/* paste data: "clipboard text" */
function clipboard_api_test(e){
    var passed = false;
    e.clipboardData.clearData();
    e.preventDefault();
}
</script>
<script>
/** clearData() method with text/html argument */
/* Events: copy cut */
/* paste data: "{'text/html':'<p>This is <b>formatted HTML</b> for copy/paste tests.</p>', 'text/plain': 'This is formatted HTML for copy/paste tests.'}" */
/* External pass condition - clipboard data: "This is formatted HTML for copy/paste tests." */
function clipboard_api_test(e){
    e.clipboardData.clearData('text/html');
    e.preventDefault();
}
</script>

<script>
/** setData() followed by clearData() in same event handler */
/* Events: copy cut */
/* Targets: document */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "" */
function clipboard_api_test(e){
    e.clipboardData.setData( 'text/plain', 'modified text' );
    e.clipboardData.clearData( 'text/plain' );
    e.preventDefault();
}
</script>
        <dt>If a script calls <a>setData()</a> or modifies items and the <var>clear-was-called</var> flag is true</dt>
        <dd>
            <dl class="switch">
                <dt>If the <var>types-to-clear</var> list is empty</dt>
                <dd>set the <var>clear-was-called</var> flag to false</dd>
<script>
/** clearData() followed by setData() in same event handler */
/* Events: copy cut */
/* Targets: document */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "modified text" */
function clipboard_api_test(e){
    e.clipboardData.clearData( 'text/plain' );
    e.clipboardData.setData( 'text/plain', 'modified text' );
    e.preventDefault();
}
</script>
                <dt>else, if <a>setData()</a>'s <code>type</code> argument or the new item's <a>drag data item type string</a> is found in the <var>types-to-clear</var> list</dt>
                <dd>remove it from the list. If the list is now empty, set the <var>clear-was-called</var> flag to false</dd>
            </dl>
        </dd>
<script>
/** clipboard modification when script uses both clearData() and setData()  */
/* Events: copy cut */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">copied text</textarea></form>*/
/* Targets: document */
/* External pass condition - clipboard data: "modified text" */
function clipboard_api_test(e){
    e.clipboardData.clearData();
  e.clipboardData.setData('text/plain', 'modified text');
  e.preventDefault();
}
</script>

        <dt>If a script calls <a>getData()</a> or accesses items in the <a>DataTransferItemList</a> and <var>clipboard-entry</var> is set</dt>
        <dd>check that the clipboard data's sequence number matches <var>clipboard-entry</var>. If the clipboard no longer contains the same entry, set the <a>DataTransferItemList</a> object's <a>drag data store mode</a> to the <i>disabled mode</i></dd>
    </dl>
        <div class="warning" title="Long-running clipboard reading threads">A malicious script listening to a paste event may set up a never-ending loop in order to read what the user places on the clipboard in the future. On platforms where a clipboard sequence number is not available, other limitations should be implemented.</div>
<script>
/** reading clipboard data from looping script  */
/* Events: paste */
/* paste data: "pasted text" */
/* Targets: document */

function clipboard_api_test(e){
    var last=new Date(),now=new Date(), interval=50, seconds=10;
    var start=new Date();
    var text=e.clipboardData.getData( 'text/plain' ), readAgain='';
    document.body.appendChild( document.createElement('p') ).appendChild(document.createTextNode('Please copy "pasted text 2" to clipboard while the test runs.'));
    var logElm=document.body.appendChild( document.createElement('p') ).appendChild(document.createTextNode(''));
    while( now=new Date() ){
        if( now.getTime() - last.getTime() > interval ){
            readAgain=e.clipboardData.getData('text/plain');
            if( readAgain && readAgain !== text )return false;
            now=new Date();
            logElm.data='Test will run for '+parseInt( seconds - ((now.getTime() - start.getTime())/1000) )+' more seconds';
            if( (now.getTime() - start.getTime()) > seconds * 1000 )break;
        }
    }
    return true;
}

</script>
</li>
</ol>
</section>
</section>
<section>
<h2><dfn id="clipboardevent">Clipboard event</dfn> interfaces</h2>
<p>The ClipboardEvent interface extends the <a>Event interface</a>.</p>
<p>The interface can be used to <a>construct events</a>. An example is given below:</p>
<pre class="example javascript">
    var pasteEvent = new ClipboardEvent('paste');
    pasteEvent.clipboardData.items.add('My string', 'text/plain');
    document.dispatchEvent(pasteEvent);
</pre>
<p class="note">Synthetic events do not have default actions. In other words, while the script above will fire a paste event, the data will not actually be pasted into the document.</p>
<!-- TODO: <p class="issue">There should be a way a script can check if a clipboard format is registered and whether the implementation allows writing this format to the clipboard! event.clipboardData.isTypeSupported('mime/type')</em>?</p> -->

<script>
/** ClipboardEvent interface - synthetic events with new ClipboardEvent constructor  */
/* Events: paste */
/* paste data: "clipboard text" */
function clipboard_api_test(e){
    return e.clipboardData.getData('text/plain')=='synthetic event text';
}
function onTestSetupReady(){
    var evt = new ClipboardEvent('paste')
    evt.clipboardData.items.add('synthetic event text', 'text/plain');
    document.dispatchEvent(evt);
}
</script>
<script>
/** ClipboardEvent interface - synthetic events with non-standard MIME type  */
/* Events: paste */
/* paste data: "clipboard text" */
function clipboard_api_test(e){
    return e.clipboardData.getData('text/foobarbogustype')=='synthetic event text';
}

function onTestSetupReady(){
    var evt = new ClipboardEvent('paste');
    evt.clipboardData.items.add('synthetic event text', 'text/foobarbogustype');
    document.dispatchEvent(evt);
}
</script>
<div data-dfn-for="ClipboardEventInit">
<pre class="idl">
dictionary ClipboardEventInit : EventInit {
  DataTransfer? clipboardData = null;
};
</pre>

<dl>
    <dt><dfn>clipboardData</dfn></dt>
    <dd>A <a>DataTransfer</a> object to hold data and meta data related to the event</dd>
</dl>
</div>
<div data-dfn-for="ClipboardEvent">
<pre class="idl">
[Constructor(DOMString type, optional ClipboardEventInit eventInitDict)]
interface ClipboardEvent : Event {
  readonly attribute DataTransfer? clipboardData;
};
</pre>
<dl>
    <dt><dfn>clipboardData</dfn></dt>
    <dd>
     <p>The clipboardData attribute is an instance of the <a>DataTransfer</a> interface which lets a script read and manipulate values on the system clipboard during user-initiated copy, cut and paste operations. The associated drag data store is a live but filtered view of the system clipboard, exposing <a href="#mandatory-data-types">data types</a> the implementation knows the script can safely access. For synthetic events, the drag data store contains the data added by the script that created the event.</p>
     <p>The clipboardData object's <var>items</var> and <var>files</var> properties enable processing of multi-part or non-textual data from the clipboard.</p>
    </dd>
</dl>
</div>
</section>
<section>
    <h2><dfn>Writing contents to the clipboard</dfn></h2>
    <p>To update the clipboard contents, follow these steps, given a <a>DataTransferItemList</a> list <em>items</em>, a <em>clear-was-called</em> flag and a <em>types-to-clear</em> list:</p>
    <dl class="switch">
        <dt>If the <em>items</em> list is not empty</dt>
        <dd>
        <ol>
            <li>Clear the clipboard</li>
            <li>For each part in the list,
                <dl class="switch">
                    <dt>If data type is <i>text/plain</i></dt>
                    <dd>
                        <ol>
                            <li>Ensure encoding is correct per OS and locale conventions</li>
                            <li>Normalize line endings according to platform conventions</li>
                            <li>Place text on clipboard with the appropriate OS clipboard format description</li>
                        </ol>
                    </dd>
                    <dt>Otherwise, if data is of a type listed in the <a>mandatory data types</a> list</dt>
                    <dd>Place part on clipboard with the appropriate OS clipboard format description</dd>
                    <dt>Otherwise</dt>
                    <dd>This is left to the implementation..
                    <p class="issue">It's not good to leave things up to the implementation. What should happen here?</p>
                    <p class="note">Note: Due to limitations in the implementation of operating system clipboards, scripts should not assume that custom formats will be available to other applications on the system. For example, there is a limit to how many custom clipboard formats can be registered in Microsoft Windows. While it is possible to use any string for <a>setData()</a>'s type argument, sticking to <a href="#mandatory-data-types">well-known types</a> is strongly recommended.</p>
                    </dd>
                </dl>
            </li>
        </ol>
        </dd>
        <dt>Otherwise, the <em>items</em> list is empty. Follow these steps to determine whether to clear the clipboard:</dt>
        <dd>
            <dl class="switch">
                <dt>If the list of items is empty and the <var>clear-was-called</var> flag is <i>true</i></dt>
                <dd>
                    <dl class="switch">
                        <dt>If the <var>types-to-clear</var> list is empty
                        <dd>Clear the clipboard</dd>
                        <dt>Else</dt>
                        <dd>Remove types in the <var>types-to-clear</var> list from the clipboard in an operating system and implementation-specific way
                        <p class="issue">The "remove specific types from clipboard" feature is at risk. It doesn't seem all that important, and it's unclear if it can be implemented easily across relevant platforms.</p>
                        </dd>
                    </dl>
                </dd>
            </dl>
        </dd>
    </dl>

</section>

<section>
<h2>Integration with other scripts and events</h2>
<section><h3>Event handlers that are <dfn>allowed to modify the clipboard</dfn></h3>
  <p>Event handlers may write to the clipboard if any of the following is true:</p>
  <ul>
    <li>The action which triggers the event is invoked from the user-agent's own user interface, e.g. from a "Copy" menu entry or shortcut key.</li>
    <li>The action which triggers the event is invoked from a scripting thread which is <a>allowed to show a popup</a>.</li>

  </ul>
<p>The implementation <em>may</em> allow other trusted event types to modify the clipboard if the implementation authors believe that those event types are likely to express user intention. The implementation <em>may</em> also support configuration that trusts specific sites or apps to modify the clipboard regardless of the origin of the scripting thread.</p>
<p>Synthetic cut and copy events <em>must not</em> modify data on the system clipboard.</p>

<script>
/** ClipboardEvent interface - synthetic copy/cut events must not affect system clipboard */
/* Events: copy cut */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
  /* The result must be checked externally - i.e. what's on the clipboard.. */
}
function onTestSetupReady(eventType){
    var evt = new ClipboardEvent(eventType);
    evt.clipboardData.items.add('synthetic event text', 'text/plain');
    evt.preventDefault();
    if(eventType === 'cut'){
        document.body.contentEditable='true';
    }
    /* make a selection to check if selected text is copied by the synthetic event.. */
    var range = document.createRange();
    range.selectNodeContents(document.body);
    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);
    document.dispatchEvent(evt);
    window.getSelection().removeAllRanges();
    if(eventType === 'cut'){
        document.body.contentEditable = 'false';
    }
}
</script>
<script>
/** ClipboardEvent interface - execCommand() inside trusted event affects clipboard */
/* Events: copy cut */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "modified text" */
function clipboard_api_test(e){
    e.clipboardData.setData('text/plain', 'modified text');
    e.preventDefault();
}
function triggerTestManually(eventType){
    if(eventType === 'cut'){
        document.body.contentEditable = 'true';
    }
    /* make a selection to check if selected text is copied */
    var range = document.createRange();
    range.selectNodeContents(document.body);
    window.getSelection().addRange(range);
    document.execCommand(eventType, false, null);
    window.getSelection().removeAllRanges();
    if(eventType ==='cut'){
        document.body.contentEditable='false';
    }
}
</script>
<script>
/** ClipboardEvent interface - synthetic paste event does not insert payload data into TEXTAREA  */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <form><textarea autofocus></textarea></form>*/
/* Targets: document */
function clipboard_api_test(e){ }
function onTestSetupReady(type, test_obj){
    var evt = new ClipboardEvent(type);
    evt.clipboardData.items.add('synthetic event text', 'text/plain');
    document.getElementsByTagName('textarea')[0].dispatchEvent(evt);
    test_obj.step_timeout(function(){
        result(function(){
          assert_equals(document.getElementsByTagName('textarea')[0].value.indexOf( 'synthetic event text' ), -1);
        });
    }, 50 );
}
</script>
<script>
/** ClipboardEvent interface - synthetic paste event does not insert payload data into INPUT  */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <form><input autofocus></form>*/
/* Targets: document */
function clipboard_api_test(e){}
function onTestSetupReady(type, test_obj){
    var evt = new ClipboardEvent(type);
    evt.clipboardData.items.add('synthetic event text', 'text/plain');
    document.getElementsByTagName('input')[0].dispatchEvent(evt);
    test_obj.step_timeout( function(){
      result(function(){
        assert_equals(document.getElementsByTagName('input')[0].value.indexOf('synthetic event text'), -1);
        });
    }, 50 );
}
</script>
<script>
/** ClipboardEvent interface - synthetic paste event does not insert text/html payload data into INPUT  */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <form><input autofocus></form>*/
/* Targets: document */
function clipboard_api_test(e){ }
function onTestSetupReady(type){
    var evt = new ClipboardEvent(type);
    evt.clipboardData.items.add('<em>synthetic event text</em>', 'text/html');
    document.getElementsByTagName('input')[0].dispatchEvent(evt);
    test_obj.step_timeout(function(){
      result(function(){
        assert_equals(document.getElementsByTagName('input')[0].value.indexOf( 'synthetic event text' ), -1);
      });
    }, 50);
}
</script>

<script>
/** ClipboardEvent interface - synthetic paste event does not insert plain text data into contentEditable element  */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <div id="editable" contentEditable><p>Editable element</p></div><script>document.getElementById('editable').focus();<\/script>*/
/* Targets: document */
function clipboard_api_test(e){}
function onTestSetupReady(type, test_obj){
    var evt = new ClipboardEvent(type);
    evt.clipboardData.items.add('synthetic event text', 'text/plain');
    document.getElementById('editable').dispatchEvent(evt);
    test_obj.step_timeout( function(){
      result(function(){
        assert_equals(document.getElementById('editable').textContent.indexOf( 'synthetic event text' ), -1);
      });
    }, 50 );
}
</script>
<script>
/** ClipboardEvent interface - synthetic paste event does not insert HTML data into contentEditable element  */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <div id="editable" contentEditable><p>Editable element</p></div><script>document.getElementById('editable').focus();<\/script>*/
/* Targets: document */
function clipboard_api_test(e){}
function onTestSetupReady(type, test_obj){
    var evt = new ClipboardEvent(type);
    evt.clipboardData.items.add('<em>synthetic event text</em>', 'text/html');
    document.getElementById('editable').dispatchEvent(evt);
    test_obj.step_timeout( function(){
      result(function(){
        assert_equals(document.getElementById('editable').getElementsByTagName('em').length, 0);
      });
    }, 50 );
}
</script>
</section>
<section><h3>Event handlers that are <dfn>allowed to read from clipboard</dfn></h3>
  <p>Event handlers may read data from the system clipboard if either of the following is true</p>
  <ul>
    <li>The action that triggers the event is invoked from the user-agent's own user interface, e.g. a "Paste" menu entry or shortcut key.</li>
    <li>The script that triggers the action is running on a site which through an implementation-dependant mechanism is given permission to read data from the clipboard.</li>
    <li>The action that triggers the event is triggered in an app with permissions to read the clipboard.</li>
  </ul>
<p>Synthetic paste events <em>must not</em> give a script access to data on the real system clipboard.</p>

</section>
<section><h3>Integration with rich text editing APIs</h3>
<p class="not-fully-tested">If an implementation supports ways to execute clipboard commands through scripting, for example by calling the <code>document.execCommand()</code> method with the commands "cut", "copy" and "paste", the implementation <em>must</em> trigger the corresponding action, which again will dispatch the associated clipboard event.</p>
<p>These are the steps to follow when triggering copy, cut or paste actions through a scripting API:</p>
<ol>
    <li>Execute the corresponding action synchronously.</li>
    <li>Use the action's return value as the return value for the API call.</li>
<script>
/** integration with execCommand - returns false when not allowed to write to clipboard */
/* Events: cut copy */

function clipboard_api_test(e){
    assert_unreached('document.execCommand() triggered from non-user-initiated script thread, events should not fire');
}
function onTestSetupReady(eventType){
    result(function(){
      assert_false(document.execCommand(eventType, false, null));
    });
}
</script>

</ol>
<p class="note">Copy and cut commands triggered through a scripting API will only affect the contents of the real clipboard if the event is dispatched from an event that is trusted and triggered by the user, or if the implementation is configured to allow this. Paste commands triggered through a scripting API will only fire paste events and give access to clipboard contents if the implementation is configured to allow this. How implementations can be configured to allow read or write access to the clipboard is outside the scope of this specification.</p>

<script>
/** integration with execCommand, events are syncronous */
/* Events: copy cut */
/* Test HTML: <iframe id="iframe"></iframe>*/
/* Targets: 'iframe.contentWindow' */
/* This assertation is based on Gecko's implementation. */
var eventFired = false;
function clipboard_api_test(e){
    /* the event is syncronous, must not run after the execCommand call is finished */
    assert_false(window.afterExecCommand);
    eventFired = true;
}
function onTestSetupReady( eventType ){
  document.getElementsByTagName('p')[0].firstChild.data='FAILED'; // if event doesn't fire, this test failed..
    var ifr=document.getElementById('iframe'), doc;
    (doc=ifr.contentDocument).designMode='on';
    doc.body.innerHTML='<p>Frame contents</p>';
    ifr.contentWindow.focus();
    var rng=doc.createRange();
    rng.selectNodeContents(doc.getElementsByTagName('p')[0]);
    var sel=ifr.contentWindow.getSelection();
    sel.removeAllRanges();
    sel.addRange(rng);
}
function triggerTestManually(eventType){
    var ifr=document.getElementById('iframe');
    window.afterExecCommand=false;
    /* This triggers the event listener, which asserts false */
    var execSucceeded = ifr.contentDocument.execCommand(eventType, false, null);
    window.afterExecCommand=true;
    result(function(){
      assert_true(eventFired, eventType + ' event should fire');
      assert_true(execSucceeded, 'document.execCommand() should succeed and return true');
    });
}
</script>
<script>
/** integration with execCommand, can prevent default action */
/* Events: copy cut */
/* paste data: "clipboard text" */
/* Test HTML: <iframe id="ifr"></iframe>*/
/* Targets: 'ifr.contentWindow' */
/* External pass condition - clipboard data: "clipboard text" */

function clipboard_api_test(e){
    e.preventDefault();
}

function triggerTestManually(eventType){
  document.getElementsByTagName('p')[0].firstChild.data='FAILED'; // if event doesn't fire, this test failed..
  var ifr=document.getElementById('ifr');
  var doc=ifr.contentDocument;
  doc.designMode='on';
  doc.body.innerHTML='<p>Frame contents</p>';
  ifr.contentWindow.focus();
  var range=doc.createRange();
  range.selectNodeContents(doc.getElementsByTagName('p')[0]);
  doc.defaultView.getSelection().removeAllRanges();
  doc.defaultView.getSelection().addRange(range);
  var returnValue = doc.execCommand(eventType, false, null);
  /* Main pass condition here is clipboard contents - but we can add a couple of assertations here */
  assert_false(returnValue, 'execCommand() returns false when event default action is prevented');
  /* This assertation is especially relevant for 'cut' */
  assert_equals(doc.getElementsByTagName('p')[0].firstChild.textContent, 'Frame contents');
}
</script>

<script>
/** integration with execCommand, can prevent default action */
/* Events: paste */
/* paste data: "clipboard text" */
/* Test HTML: <iframe id="ifr"></iframe><p>Note: this test is only relevant if scripted paste is allowed</p>*/
/* Targets: 'ifr.contentWindow' */
function clipboard_api_test(e){
    window.eventFired=true;
    e.preventDefault();
}
function triggerTestManually(eventType, test_obj){
    var ifr=document.getElementById('ifr');
    ifr.contentDocument.designMode='on';
    ifr.contentWindow.focus();
    ifr.contentDocument.execCommand(eventType, false, null);
    test_obj.step_timeout(function(){
        var passed= window.eventFired === true && ifr.contentDocument.body.innerHTML.indexOf('clipboard text')==-1;
        result(passed);
    }, 10);
}
</script>
</section>
<section>
<h3 id="otherevents">Interaction with other events</h3>
<p>If the clipboard operation is triggered by keyboard input, the implementation <em>must</em> fire the corresponding event as the default action of the <b>keydown</b> event that initiates the clipboard operation. For example, if the user presses <kbd>Ctrl-C</kbd> to copy, dispatching a copy event <em>must</em> be the default action of the C key's keydown event. The event is asynchronous but <em>must</em> be dispatched before <b>keyup</b> events for the relevant keys.</p>

<script>
/** clipboard events relative to key events  */
/* Events: copy cut paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form><p>Note: please trigger event from keyboard (ctrl+x/c/v) for this test</p>*/
/* Targets: 'input_text' */

var eventsFired=[];
function logEvent(e){eventsFired.push(e.type);};
document.addEventListener('DOMContentLoaded', function(){
  document.getElementById('input_text').addEventListener( 'keydown', logEvent, false );
  document.getElementById('input_text').addEventListener( 'keyup', logEvent, false );
  document.getElementById('input_text').addEventListener( 'keypress', logEvent, false );
},false);

function clipboard_api_test(e, test_obj, eventType){
  logEvent(e);
  test_obj.step_timeout(function(){
    result(function(){
      assert_array_equals(eventsFired, ['keydown','keydown', eventType, 'keyup','keyup'], 'The right events fired in the expected order')
    });
  }, 500);
}
</script>

<script>
/** clipboard events relative to key events - preventDefault prevents clipboard events  */
/* Events: copy cut paste */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form><p>Note: please trigger event from keyboard (ctrl+x/c/v) for this test</p>*/
/* Targets: 'input_text' */

var eventsFired=[], timeout;
function logEvent(e){
    eventsFired.push(e.type);
    if(e.type==='keydown')e.preventDefault(); // no clipboard events should fire if preventDefault() is called here
};
document.addEventListener('DOMContentLoaded', function(){
  document.getElementById('input_text').addEventListener( 'keydown', logEvent, false );
  document.getElementById('input_text').addEventListener( 'keyup', logEvent, false );
  document.getElementById('input_text').addEventListener( 'keypress', logEvent, false );
  document.getElementById('input_text').addEventListener( 'cut', logEvent, false );
  document.getElementById('input_text').addEventListener( 'copy', logEvent, false );
  document.getElementById('input_text').addEventListener( 'paste', logEvent, false );
},false);
document.onkeyup = function(){
    if(timeout)clearTimeout(timeout);
    setTimeout(
      function(){
        result(function(){
          assert_array_equals(eventsFired, ['keydown','keydown','keyup','keyup']);
        });
      }
    , 500);
}
function clipboard_api_test(e, test_obj){
  if(timeout)clearTimeout(timeout);
  result(function(){
      assert_unreached();
  });
}
</script>


<p>The cut and paste actions <em>may</em> cause the implementation to dispatch other supported events, such as textInput, input, change, validation events, DOMCharacterDataModified and DOMNodeRemoved / DOMNodeInserted. Any such events are queued up to fire after processing of the cut/paste event is finished.</p>
<script>
/** clipboard events relative to other input events  */
/* Events: cut */
/* Test HTML: <form action=""><input id="input_text" autofocus onfocus="this.select()" value="copied text" required></form>*/
/* Targets: 'input_text' */

var eventsFired=[];
function logEvent(e){eventsFired.push(e.type);};
document.addEventListener('DOMContentLoaded', function(){
  document.getElementById('input_text').addEventListener( 'change', logEvent, false );
  document.getElementById('input_text').addEventListener( 'input', logEvent, false );
  document.getElementById('input_text').addEventListener( 'invalid', logEvent, false );
  document.getElementById('input_text').addEventListener( 'textInput', logEvent, false );
},false);

function clipboard_api_test(e, test_obj){
  logEvent(e);
  test_obj.step_timeout(function(){
    e.target.blur(); // causes change event
    e.target.form.checkValidity(); // causes invalid event
  }, 10);
  test_obj.step_timeout(function(){
    var expected = ['cut','cut handler done','input','change','invalid']; // Issue: should textInput fire? Chrome doesn't but I don't know if it's on purpose
    result(function(){
      assert_array_equals(eventsFired, expected);
    });
  }, 500);
  logEvent( {type: e.type+' handler done'} );
}
</script>

<script>
/** clipboard events relative to other input events  */
/* Events:  paste */
/* Test HTML: <form action=""><input id="input_text" autofocus onfocus="this.select()" value="copied text" required></form>*/
/* paste data: "clipboard text" */
/* Targets: 'input_text' */

var eventsFired=[];
function logEvent(e){eventsFired.push(e.type);};
document.addEventListener('DOMContentLoaded', function(){
  document.getElementById('input_text').addEventListener( 'change', logEvent, false );
  document.getElementById('input_text').addEventListener( 'input', logEvent, false );
  document.getElementById('input_text').addEventListener( 'invalid', logEvent, false );
  document.getElementById('input_text').addEventListener( 'textInput', logEvent, false );
},false);

function clipboard_api_test(e, test_obj){
  logEvent(e);
  test_obj.step_timeout(function(){
    e.target.blur(); // causes change event
    e.target.form.checkValidity(); // causes invalid event
  }, 10);
  test_obj.step_timeout(function(){
    // would be nice to use assert_array_equals, but at the moment we allow two
    // different pass conditions..
    var evString = eventsFired.join(',')
    var passed =  evString ==='paste,paste handler done,textInput,input,change' || evString ==='paste,paste handler done,input,change' ;
    result( passed, 'Got: '+evString );
  }, 500);
  logEvent( {type: e.type+' handler done'} );
}
</script>

<p>The implementation <em>must not</em> dispatch other input-related events like textInput, input, change, and validation events in response to the copy operation. </p>
<script>
/** copy operation does not dispatch other events  */
/* Events: copy */
/* Test HTML: <form><input id="input_text" autofocus onfocus="this.select()" value="copied text"></form>*/
/* Targets: document 'input_text' */
function clipboard_api_test(e, test_obj){
  var otherEventsFired=[];
  var events=[ 'input', 'textInput', 'change' ];
  for( var i=0,ev; ev=events[i];i++ )e.currentTarget.addEventListener(ev, function(e){ otherEventsFired.push(e.type); }, false);
    test_obj.step_timeout(function(){
      result(function(){
        assert_equals(otherEventsFired.length, 0);
      });
    }, 50);
  e.target.blur(); // might provoke a change event, but should not
}
</script></section>

<section>
<h3 id="selection-mod">Event listeners that modify selection or focus</h3>
<p>If the event listener modifies the selection or focus, the clipboard action <em>must</em> be completed on the modified selection.</p>
<script>
/** event listener that modifies focus */
/* Events: copy cut */
/* Test HTML: <input id="input_text" onfocus="this.select()" autofocus value="input 1"><input id="second" onfocus="this.select()" value="input 2">*/
/* Targets: 'input_text' */
/* External pass condition - clipboard data: "input 2" */

function clipboard_api_test(e){
    document.getElementById('second').focus();
}

</script>
<script>
/** event listener that modifies focus */
/* Events: paste */
/* Test HTML: <input id="input_text" onfocus="this.select()" autofocus value="input 1"><input id="second" onfocus="this.select()" value="input 2">*/
/* Targets: 'input_text' */
/* paste data: "clipboard text" */

function clipboard_api_test(e, test_obj){
  document.getElementById('second').focus();
  test_obj.step_timeout(function(){
    result(function(){
      assert_equals(document.getElementById('second').value, 'clipboard text');
    });
  }, 20);
}
</script>
<script>
/** event listener that modifies selection */
/* Events: copy */
/* Test HTML: <div>This is demo text</div>*/
/* Targets: document */
/* External pass condition - clipboard data: "This is demo text" */

function clipboard_api_test(e){
  var range=document.createRange();
  range.selectNodeContents(document.getElementsByTagName('div')[0]);
  window.getSelection().removeAllRanges();
  window.getSelection().addRange(range);
}

</script>
</section>
</section>

<section>
<h3 id="pasting-html">Pasting HTML and multi-part data</h3>
<section class="informative">
<h4>Security risks</h4>
<p>There are certain security risks associated with pasting formatted or multi-part data.</p>
<ul>
  <li>The user might paste hidden data without realising is there. This may happen if, for example, the markup includes &lt;input type="hidden"&gt; tags or HTML comments. Such hidden data might contain sensitive information.</li>
  <li>The user might paste malicious JavaScript into a trusted page.</li>
  <li>The implementation might grant scripts access to local files the user did not intend to expose.</li>
</ul>
<p>To determine what policies to use, the factors we consider are </p>
<ul>
  <li>The origin of the data being pasted</li>
  <li>The origin of data sub-parts such as referenced images</li>
  <li>The origin of the running script</li>
</ul>
<p>This is an overview of the scenarios and the possible security policies:</p>
<table class="simple">
  <tr><th>Origin of data</th><th>Origin of script</th><th>Rules</th></tr>
  <tr><td rowspan="2">Originates from online source</td><td>Same as data</td><td>Do not sanitize HTML. Do not access any local files.</td></tr>
  <tr><td>Different origin</td><td>Optionally sanitize content. Do not access any local files.</td></tr>
  <tr><td>Originates from local application</td><td>Any</td><td>Do not sanitize HTML. Grant access to local files</td></tr>
</table>
<p>Some implementations mitigate the risks associated with pasting rich text by stripping potentially malicious content such as SCRIPT elements and javascript: links by default when pasting rich text, but allow a paste event handler to retrieve and process  the original, un-sanitized data.</p>
</section>
<section>
<h4>General security policies</h4>
<p>The implementation <em>must not</em> download referenced online resources, or expose their contents in the <a>files</a> list or <a>DataTransferItemList</a>.</p>
<p>If the data on the clipboard is not from a local application, the implementation <em>must not</em> give access to any referenced local files. For example, if the data contains &lt;img src="file://localhost/example.jpg"&gt; but the data's origin is an online resource, the implementation must not add an entry for example.jpg to the clipboardData.items list.</p>
</section>
</section>


<section>
<h2 id="security">Other security and privacy considerations</h2>
<p>Enabling authors to change what is copied by a user, or to make an automated copy of something that was never selected and allowing unrestricted calls to paste information can raise various security and privacy concerns.</p>

<p>An example scenario of a problem is where a user selects a link and copies it, but a different link is copied to the clipboard. The effect of this can range from an unexpected result on pasting to an attempted "phishing" attack.</p>

<section>
<h3 id="privacy">Privacy concerns</h3>
<p>Untrusted scripts should not get uncontrolled access to a user's clipboard data. This specification assumes that granting access to the current clipboard data when a user explicitly initiates a paste operation from the user agent's trusted chrome is acceptable. However, implementors must proceed carefully, and as a minimum implement the precautions below:</p>
<ul>
<li>Objects implementing the <a>DataTransfer</a> interface to return clipboard data <em>must not</em> be available outside the ClipboardEvent event handler.</li>
<li>If a script stores a reference to an object implementing the <a>DataTransfer</a> interface to use from outside the ClipboardEvent event handler, all methods <em>must</em> be no-ops when called outside the expected context.
<script>
/** setData() called outside event handler method */
/* Events: copy cut paste */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e, test_obj){
    var cbData=e.clipboardData;
    test_obj.step_timeout( function(){
        cbData.setData('text/plain', 'Test failed');
    }, 1 );
    e.preventDefault();
}
</script>
<script>
/** items.add() called outside event handler method */
/* Events: copy cut paste */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e, test_obj){
    var cbData=e.clipboardData;
    test_obj.step_timeout( function(){
        cbData.items.add( 'Test failed', 'text/plain');
    }, 1 );
    e.preventDefault();
}
</script>
<script>
/** clearData() called outside event handler method */
/* Events: copy cut paste */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e, test_obj){
    var cbData=e.clipboardData;
    test_obj.step_timeout(function(){
        cbData.clearData();
    }, 1);
    e.preventDefault();
}
</script>
</li>
<li>Implementations <em>must not</em> let scripts create synthetic clipboard events to get access to real clipboard data except if configured to do so.</li>
<li>Implementations <em>should not</em> let scripts call document.execCommand('paste') unless the user has explicitly allowed it.</li>
</ul>
<p>Implementations may choose to further limit the functionality provided by the <a>DataTransfer</a> interface. For example, an implementation may allow the user to disable this API, or configure which web sites should be granted access to it.</p>
</section>

<section><h3 id="nuisances">Nuisance considerations</h3>
<p>Scripts may use the <a>DataTransfer</a> API to annoy and confuse users by altering the data on the system clipboard from copy and cut events. This specification does not attempt to prevent such nuisances, though implementations may add additional restrictions.</p>
<p>Implementations must handle scripts that try to place excessive amounts of data on the clipboard gracefully.</p>
</section>
</section>
<section>
<h2><dfn id="mandatory-data-types">Mandatory data types</dfn></h2>
<p>The implementation must recognise the native OS clipboard format description for the following data types, to be able to populate the <a>DataTransferItemList</a> with the correct description for paste events, and set the correct data format on the OS clipboard in response to copy and cut events.</p>
<h3>Reading from the clipboard</h3>
<p>These data types must be exposed by <em>paste</em> events if a corresponding native type exists on the clipboard:</p>
<ul>
<li>text/plain</li>
<li>text/uri-list</li>
<li>text/csv</li>
<li>text/css</li>
<li>text/html</li>
<li>application/xhtml+xml</li>
<li>image/png</li>
<li>image/jpg, image/jpeg</li>
<li>image/gif</li>
<li>image/svg+xml</li>
<li>application/xml, text/xml</li>
<li>application/javascript</li>
<li>application/json</li>
<li>application/octet-stream</li>
</ul>

<h3>Writing to the clipboard</h3>
<p>These data types must be placed on the clipboard with a corresponding native type description if added to a <a>DataTransfer</a> object during <em>copy</em> and <em>cut</em> events.</p>

<ul>
<li>text/plain</li>
<li>text/uri-list</li>
<li>text/csv</li>
<li>text/html</li>
<li>image/svg+xml</li>
<li>application/xml, text/xml</li>
<li>application/json</li>
</ul>

<p class="warning">Data types untrusted scripts are allowed to write to the clipboard is limited as a security precaution. Untrusted scripts can attempt to exploit security vulnerabilities in local software by placing data known to trigger those vulnerabilities on the clipboard.</p>


<!-- TODO:
<p class="issue">What about audio and video types? BMP?
RTF? RTF was requested due to embedded images possibility (but this spec allows access to local images referenced in HTML fragments by design..).
</p>

<pre class="issue">
Some standard Windows formats we don't handle

DataFormats.CF_RTFTEXT

DataFormats.CF_WAVE
DataFormats.CF_RIFF

DataFormats.CF_BITMAP
DataFormats.CF_DIB
DataFormats.CF_DIF
DataFormats.CF_METAFILEPICT
DataFormats.CF_PALETTE
DataFormats.CF_TIFF

</pre>
-->
</section>

<section>
<h2 id="Acknowledg">Acknowledgements</h2>

<p>This section is informative</p>

<p>The editors would like to acknowledge their intellectual debt to the
documentation of Data Transfer functionalities from Microsoft [[MICROSOFT-CLIP-OP]] and earlier drafts of the [[HTML5]] specification.  We are also grateful for the draft "safe copy and paste" from Paul Libbrecht (this draft is no longer available on the Web).</p>

<p>We would like to acknowledge the contributions made by the following:</p>

<p>Shawn Carnell, Daniel Dardailler, Al Gilman, Lachlan Hunt, Aaron
Leventhal, Jim Ley, Paul Libbrecht, "Martijn", Dave Poehlman, Chris Mills, "ROBO Design",
Janina Sajka, Rich Schwerdtfeger, Jonas Sicking, Maciej Stachowiak, Mihai
Sucan, Tom Wlodkowski, Anne van Kesteren, Tarquin Wilton-Jones, Dmitry Titov,
Robert O'Callahan, Ryosuke Niwa, Ian Hickson, Ojan Vafai, Daniel Cheng, Adam Barth, ms2ger, Glenn Maynard, James Graham, James Greene, Boris Zbarsky, Philip Jägenstedt.</p>
</section>

<!--  Here follow some more quirky tests that don't directly correspond to any of the requirements in the spec itself.. -->

<script>
/** ClipboardEvent and non-ASCII data I - Japanese */
/* Events: copy cut */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">copied text</textarea></form>*/
/* Targets: 'input_text' */
/* External pass condition - clipboard data: "テスト" */

function clipboard_api_test(e){
    e.clipboardData.setData( 'text/plain', 'テスト' );
    e.preventDefault();
}
</script>
<script>
/** ClipboardEvent and non-ASCII data I - Japanese */
/* Events: paste */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">copied text</textarea></form>*/
/* Targets: 'input_text' */
/* paste data: "テスト" */

function clipboard_api_test(e){
    var passed = e.clipboardData.getData( 'text/plain') === 'テスト' ;
    return passed;
}
</script>

<script>
/** ClipboardEvent and non-ASCII data II - random Unicode symbols */
/* Events: copy cut */
/* Test HTML: <form><textarea id="input_text" autofocus onfocus="this.select()">copied text</textarea></form>*/
/* Targets: 'input_text' */
/* External pass condition - clipboard data: "☺✌☑☝" */

function clipboard_api_test(e){
    e.clipboardData.setData( 'text/plain', '☺✌☑☝' );
    e.preventDefault();
}
</script>

<script>
/** events fire inside SVG content  */
/* Events: copy cut paste */
/* Test HTML: <svg xmlns="http://www.w3.org/2000/svg"><text focusable="true" id="svg_text" x="0" y="15" fill="black">SVG text</text></svg><script>document.getElementsByTagName('svg')[0].setFocus(document.getElementById('svg_text'));<\/script>*/
/* Targets: document 'svg_text' */
function clipboard_api_test(e){
    var passed = e.target.id==='svg_text';
    return passed;
}
</script>
<script>
/** events fire inside editable SVG content  */
/* Events: copy cut paste */
/* Test HTML: <svg xmlns="http://www.w3.org/2000/svg"><text focusable="true" editable="simple" id="svg_text" x="0" y="15" fill="black">SVG text</text></svg><script>document.getElementsByTagName('svg')[0].setFocus(document.getElementById('svg_text'));<\/script>*/
/* Targets: document 'svg_text' */
function clipboard_api_test(e){
    var passed = e.target.id==='svg_text';
    return passed;
}
</script>
<script>
/** events fire inside SVG content in contentEditable */
/* Events: copy cut paste */
/* Test HTML: <div contentEditable><svg xmlns="http://www.w3.org/2000/svg"><text focusable="true" id="svg_text" x="0" y="15" fill="black">SVG text</text></svg></div><script>document.getElementsByTagName('svg')[0].setFocus(document.getElementById('svg_text')); <\/script>*/
/* Targets: document 'svg_text' */
function clipboard_api_test(e){
    var passed = e.target.id==='svg_text';
    return passed;
}
</script>

<script>
/** types property - 'text/plain' in .types entries when there is plain text on the clipboard */
/* Events: paste */
/* paste data: "clipboard text" */
function clipboard_api_test(e){
    var hasTextPlain=false;
    if(e.clipboardData.types){
        for(var i=0; i<e.clipboardData.types.length;i++){
            if(e.clipboardData.types[i]==='text/plain')hasTextPlain=true;
        }
    }
    return hasTextPlain;
}
</script>


<script>
/** setData() method does not throw when implementation does not know the type */
/* Events: copy cut */
/* External pass condition - clipboard data: "unmodified text" */
/* Test HTML: <form><input autofocus onfocus="this.select()" value="unmodified text"></form>*/
/* paste data: "unmodified text" */
//TODO: this test asserts a NOOP.
// how this SHOULD work is, however, underspecified..
function clipboard_api_test(e){
    e.clipboardData.setData('text/foobarbogustype', 'copycutpaste modified text');
    e.preventDefault();
    // pass condition is external, check clipboard contents
}
</script>

<script>
/** setData() method with text/html (experimental) */
/* Events: copy cut */
/* External pass condition - clipboard data: "{'text/html': '<p>copycut <b>modified</b> text</p>', 'text/plain':'copycut modified text'}" */
/* IE's CF_HTML can not be emulated from JS with the existing clipboard API. The format includes quite some meta data:
Version:1.0
StartHTML:000000224
EndHTML:000007594
StartFragment:000006999
EndFragment:000007548
StartSelection:000006999
EndSelection:000007530
SourceURL: ...
and a document containing all parents of the selection, plus the full HEAD section. Plus magic <!--StartFragment--> and EndFragment comments.

If the script tries to place text/html data on the clipboard, a conforming implementation that supports writing HTML to clipboard must supply all the relevant meta data in a platform-specific way.
Note: IE throws for this test. Presumably it would use just "html", not "text/html" for the format argument if it supported this.
*/
function clipboard_api_test(e){
    var passed = false;
    e.clipboardData.setData('text/html', '<p>copycut <b>modified</b> text</p>');
    e.clipboardData.setData('text/plain', 'copycut modified text');
    e.preventDefault();
}
</script>
<script>
/** clearData() method is noop in paste event */
/* Events: paste */
/* paste data: "clipboard text" */
/* External pass condition - clipboard data: "clipboard text" */
function clipboard_api_test(e){
    e.clipboardData.clearData();
    e.preventDefault();
}
</script>
<script>
/** clearData() method without preventing events's default action */
/* Events: copy cut */
/* External pass condition - clipboard data: "unmodified text" */
/* Test HTML: <form><input autofocus onfocus="this.select()" value="unmodified text"></form>*/
function clipboard_api_test(e){
    var passed = false;
    e.clipboardData.clearData();
    //e.preventDefault(); // The point of this test is that we do NOT call preventDefault() here.
}
</script>

</body>
</html>
