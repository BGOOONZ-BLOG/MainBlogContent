<!DOCTYPE html>
<html>
  <head>
    <title>RangeFinder API</title>
    <meta charset='utf-8'>

    <link rel="canonical" href="http://www.w3.org/TR/rangefinder-api/">
    <!--
    <script src="https://notes.webplatform.org/annotator.js" async defer></script>
    -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        shortName:  "rangefinder-api",
        specStatus: "ED",
        edDraftURI: "https://specs.webplatform.org/rangefinder/w3c/master/",
        editors: [
              {   
                name:       "Doug Schepers",
                url:        "http://schepers.cc/",
                w3cid:      "38635",
                company:    "W3C",
                companyURL: "http://w3.org/" 
              }
        ],
        wg:           "Web Annotation Working Group",
        wgURI:        "http://www.w3.org/annotation/",
        wgPublicList: "public-annotation",
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73180/status",
        tocIntroductory: true
      };
    </script>
    <style type="text/css">
      .example {
        margin-left: 2em;
        font-style: italic;
      }

      .highlight {
        background-color: yellow; 
      }

      dt {
        padding-top: 0.5em;
      }

        dd > p {
          margin-top: 0;
          padding-top: 0;
        }
    </style>
  </head>
  <body>
    <section id='abstract' class="informative">
      <p>
        This specification describes an API for finding ranges of text or DOM nodes in a document or part of a document, using a variety of selection critiera.
      </p>

      <p class="note">
        This specification is a strawman, intended to collect feedback. It is not stable, and radical ideas for improvement are welcome. Feedback on searching and ranking algorithms are especially needed.
      </p>
    </section>

    <section id='sotd'>
      <p>
        The API described in this document is still experimental.
      </p>

      <p class="note">
        Feedback on this specification can be made via annotations. All annotations are archived on the <a rel="reply-to" href="mailto:public-annotation@w3.org">public-annotation@w3.org</a> mailing list (<a href="http://lists.w3.org/Archives/Public/public-annotation/">archives</a>), and on the searchable <a href="https://notes.webplatform.org/stream">WebPlatform Notes stream</a>; see more details on <a href="https://notes.webplatform.org/">Notes.WebPlatform.org</a>. <b>Note:</b> To create annotations, you must have a <a href="https://accounts.webplatform.org/">WebPlatform.org account</a>; do not use your W3C credentials.
      </p>
    </section>
    
    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Finding a text selection is a basic operation of a Web browser, but the functionality is not exposed to Web developers. There are many different use cases for a custom mechanism for finding and navigating to a particular range of text in a Web document, such as [[!HTML5]] or [[!SVG]]. A developer may wish to design a webapp in which only the text in the active editing subtreee, and not the controls or other application text, is returned as a result of a search, overriding the native find-text functionality. A user may wish to highlight a particular passage, and link to it, even if that selection doesn't have a <code>id</code> attribute to serve as a fragment identifier. A designer may wish to find and style a range of text without changing the markup. A developer may wish to provide a particular text-matching algorithm for searching their specific type of content, to return more meaningful results (such as fuzzy matching or term substitution). A CMS developer may wish to allow advanced review and commenting on text selections for a collaborative document. All of these use cases share the a fundamental requirement for a API to find text.  
      </p>
      <p>
        There are many challenges to finding text in a modern Web document. 

        The content may have changed; the change could be a document restructuring, the addition of content before the target selection, or even a change to the target string itself. In dynamic documents, such as real-time collaborative editing webapps, the content may change during the same session as the selection; in linking or annotation scenarios, the state is lost between sessions, so other search and anchoring strategies must be used.

        Highly repetitive content, such as poetry or lyrics, may duplicate the same passage several times, making it difficult to indicate a specific instance of that passage.

        Large documents may have many possible matches, such that search-ahead mechanism may be computationally expensive. 

        In dynamic lazy-loaded (or “infinite-scroll”) content, the text being searched for may not have been loaded into the DOM yet.
      </p>
      <p>
        There are also quirks in some native browser find-text mechanisms that could be improved through this API. For example, most current browsers do not let the user search for text across element boundaries (such as a string broken across different paragraphs or list items), which may be unintuitive and inconvenient to the end-user. Not all browsers allow the user to specify case-sensitive or whole-word search parameters, and not all browsers indicate the number of returned results. Browsers do not typically match language patterns that may be found in non-Latin character sets, including collapsed Unicode character sequences, optional diacritical marks, or similar features, such as matching <code>o</code> to <code>ó</code>, <code>ö</code>, <code>ø</code>, and <code>oe</code>.
      </p>
      <p>
        Sometimes, a selection of a document may contain more than text, or no text at all. Such selections include a picture and its caption, the picture alone, a specific area of a picture, a point on a rendered map, or a range of time within timed media such as audio or video. Some of these examples can be fully expressed as a DOM range; others need supplementary characteristics, which may be application-specific, in order to be addressable.
      </p>
      <p>
        The RangeFinder API is intended to be flexible and performant. To ensure interoperability, this specification describes a default find-text algorithm, but this can be overriden by the developer. For flexibility in searches, this specification defines several parameterized selector methods, which can be applied in different ordered sequences to best match particular kinds of content, via method chaining, which will allow the developer to provide refined matching algorithms to customize the results.

        For performance reasons, the RangeFinder API can be evoked iteratively, to find the next match in the document, rather than attempting to search the entire document for all matches.
      </p>
      <p>
        The result of a RangeFinder search is an object that contains the found range, any additional addressing characteristics, and a confidence interval to indicate how closely the search result matches the various selection criteria. By running a search multiple times and comparing the confidence interval for each result, a script can determine the best match for that set of search criteria. A script can also add or subtract selectors based on the results and confidence interval to refine a search.
      </p>
      <p class="issue">
        Should the return object also contain the CSS and/or XPath selector that is the closest match for the selection? Can you get that easily from another Web Platform feature?
      </p>
      <p class="note">
        This specification defines what is returned, but not the specific algorithms used to find that result, or the speed or optimizations taken. Such optimizations are implementation-specific.
      </p>

      <p class="note">
        For character counts in ranges, what exactly would be counted as a character? Unicode code points? Graphemes?
      </p>


    </section>


    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The following concepts and interfaces are defined in [[!HTML5]]:
      </p>
      <ul>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#queue-a-task">queue a
          task</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#fire-a-simple-event">fire
          a simple event</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#event-handlers">event
          handler</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#event-handler-event-type">event
          handler event type</a></dfn>
        </li>
        <li>
          <code><dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#window'>Window</a></dfn></code>
        </li>
        <li>
          <code><dfn><a href=
          'http://www.w3.org/TR/html5/dom.html#document'>Document</a></dfn></code>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/browsers.html#browsing-context">browsing
          context</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/browsers.html#top-level-browsing-context">
          top-level browsing context</a></dfn>
        </li>
        <li>browsing context's <dfn><a href=
        'http://www.w3.org/TR/html5/browsers.html#active-document'>active
        document</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#navigate'>navigated</a></dfn>
          browsing context
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#active-sandboxing-flag-set'>
          active sandboxing flag set</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/webappapis.html#responsible-document'>responsible
          document</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#list-of-the-descendant-browsing-contexts'>
          list of the descendant browsing contexts</a></dfn>
        </li>
      </ul>
      <p>
        <a href=
        'http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'>
        <dfn>Promise</dfn> objects</a> are defined in [[!ECMASCRIPT]].
      </p>
      <p>
        The following concepts and interfaces are defined in [[!DOM4]]:
      </p>
      <ul>
        <li>
          <dfn><a href="http://www.w3.org/TR/dom/#concept-range">Range object</a></dfn>
        </li>
        <li>
          <dfn><a href="http://www.w3.org/TR/dom/#dom-node-textcontent">textContent attribute</a></dfn>
        </li>
      </ul>
    </section>


    <section id="conformance">
      <p>
        The following conformance classes are defined by this specification: 
      </p>
      <dl>
        <dt><dfn id="dfn-conforming-implementation">conforming implementation</dfn></dt>
        <dd>
          <p>
            A <dfn id="dfn-user-agent">user agent</dfn> is considered to be a <a class="dfnref" href="#dfn-conforming-implementation">conforming implementation</a> if it satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that apply to implementations. 
          </p>
        </dd>
      </dl>
      <p>
        User agents that use ECMAScript to implement the APIs defined in this
        specification must implement them in a manner consistent with the ECMAScript
        Bindings defined in the Web IDL specification [[!WEBIDL]] as this
        specification uses that specification and terminology.
      </p>
    </section>

    <section id="terms">
      <h2>
        Terminology
      </h2>
      <dl>
        <dt>
          <dfn id="search_tree">search tree</dfn>
        </dt>
        <dd>
          The <a>search tree</a> is the subset of the document that the <a>RangeFinder</a> object is scoped to search in.
        </dd>

        <dt>
          <dfn id="search_content">search content</dfn>
        </dt>
        <dd>
          The <a>search content</a> is the normalized element text content from the <a>search tree</a>.
        </dd>

        <dt>
          <dfn id="edit_distance">edit distance</dfn>
        </dt>
        <dd>
          <p>
            The edit distance tolerance is the number of operations between the supplied target text attribute string and the candidate text content of the document. The edit distance is measured as the number of operations, of the set <i>delete</i>, <i>insert</i>, <i>replace</i>, and <i>transpose</i>, required to transform one string into another. 
          </p>

          <p class="issue">
            Decide which algorithm to use to calculate this value: Levenshtein; Damerau–Levenshtein; Hamming; Jaro–Winkler (unlikely); or some other edit distance algorithm.
          </p>

          <p class="issue">
            Should this edit distance apply to the values of the <code>prefix</code> and <code>suffix</code> attributes as well?
          </p>

          <p class="issue">
            Expose edit-distance calculator as low-level API?
          </p>

          <p class="issue">
            What about "close key" calculations (keyboard-specific)
          </p>            
        </dd>
      </dl>
    </section>

    <section id="rangefinderapi">
      <h2 id="api">
        The RangeFinder API
      </h2>
      <p>
        The RangeFinder API enables a client-side script to incrementally search the DOM of the current document for matching strings, elements, or other DOM structures, based on criteria set with dedicated methods.
      </p>
<!-- 
      <section>
        <h2>The RangeFinderResult object</h2>
      </section>

      <section>
        <h2>The RangeFinderArgs object</h2>

      </section>
 -->
      <section>
        <h2 id="RangeFinder">
          The RangeFinder Interface
        </h2>
        <p>
          This interface represents an object which allows for the discovery of arbitrary selections of a document based on criteria set out in its attributes. The constructor takes an optional property object to set the selecotr attributes. The results of the RangeFinder object's search are obtained through iterative execution of the <code>search()</code> method.
        </p>

        <p class="note">
          Currently, this API uses attributes to set selectors. I considered using chaining setter methods, which would allow for multiple parameters for each selector, and specific confidence ratings for each selector. However, that approach wouldn't let you initialize the object with a property object, nor allow easy object introspection. Feedback welcome.
        </p>

        <dl title='[Constructor(optional RangeFinderArgs args)] interface RangeFinder : EventTarget' class='idl' data-merge="RangeFinderState RangeFinderResult RangeFinderArgs UnicodeEquivalenceType">
          <dt>
            attribute DOMString text
          </dt>
          <dd>
            <p>
              A text string to be searched for. <b>Note:</b> This string is equivalent to the <code>textContent</code> of a DOM node.
            </p>

            <p>The default value of the <a>text</a> attribute MUST be the empty string.</p>
          </dd>

          <dt>
            attribute unsigned short textDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>text</a> attribute string. 
            </p>

            <p>The default value of the <a>textDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>text</a> attribute is the empty string, the <a>textDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute DOMString prefix
          </dt>
          <dd>
            <p>
              A text string of arbitrary length (often 32 characters) that precedes the target string.
            </p>

            <p>The default value of the <a>prefix</a> attribute MUST be the empty string.</p>

            <p class="issue">
              Include link to study that shows optimal distance for character prefixes?
            </p>
          </dd>

          <dt>
            attribute unsigned short prefixDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>prefix</a> attribute string. 
            </p>

            <p>The default value of the <a>prefixDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>prefix</a> attribute is the empty string, the <a>prefixDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute DOMString suffix
          </dt>
          <dd>
            <p>
              A text string of arbitrary length (often 32 characters) that follows the target string.
            </p>

            <p>The default value of the <a>suffix</a> attribute MUST be the empty string.</p>

            <p class="issue">
              Include link to study that shows optimal distance for character suffixes?
            </p>
          </dd>

          <dt>
            attribute unsigned short suffixDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>suffix</a> attribute string. 
            </p>

            <p>The default value of the <a>suffixDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>suffix</a> attribute is the empty string, the <a>suffixDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute Range scopeRange
          </dt>
          <dd>
            <p>
              The DOM range which delineates the bounds of the search operation. The default range MUST be a range comprising the document's body element.
            </p>

            <p class="issue">
              Should this be an element?
            </p>
          </dd>

          <dt>
            attribute Range startRange
          </dt>
          <dd>
            <p>
              A range object, as the starting point for the selection search.
            </p>
          </dd>

          <dt>
            attribute boolean caseFolding
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST ignore the case of the characters when doing match comparison. The default value MUST be true.
            </p>
          </dd>

          <dt>
            attribute UnicodeEquivalenceType unicodeFolding
          </dt>
          <dd>
            <p> 
              A enumerated value representing whether a search MUST match exact characters, or use a particular Unicode character equivalence. The default value MUST be <code>none</code>.
            </p>
            <p> 
              Canonical Equivalence is described in [[!UTS10]]. If the value of this attribute is true, the User Agent MUST follow the algorthim defined in section <a href="http://unicode.org/reports/tr10/#Searching">8 Searching and Matching</a>, with collations and contractions formed per section <a href="http://unicode.org/reports/tr10/#Collation_Folding">8.1 Collation Folding</a>, and secondary strength asymmetric search per section <a href="http://unicode.org/reports/tr10/#Asymmetric_Search">8.2 Asymmetric Search</a>.
            </p>

            <p class="issue">
              We should require that the UA support the Character Model for the World Wide Web: String Matching and Searching [[!charmod-norm]] spec (and urge the I18n WG to complete that spec).
            </p>

            <p class="issue">
              This still needs a lot of work!
            </p>

            <p class="issue">
              Should we allow the author to supply their own tailoring mapping?
            </p>

            <p class="issue">
              This needs to be balanced with other kinds of fuzzy matches, such as case-folding and edit distance.
            </p>

            <p class="issue">
              Define how these matches affect the rank or confidence of the return result.
            </p>
          </dd>

          <dt>
            attribute boolean wholeWord
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST require that the search string be surrounded by non-word characters. The default value MUST be false.
            </p>
          </dd>

          <dt>
            attribute boolean wrap
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST begin again at the beginning (or end, depending on search direction) of the search tree. The default value MUST be false.
            </p>
          </dd>
          <dt>
            Promise≺RangeFinderResult≻ search(optional boolean forward)
          </dt>
          <dd>
            <p>
              Executes the search, based on the current selection criteria attributes, from the current search index position within the document serialization. The return result MUST be a <code>Promise</code> of a <a>RangeFinderResult</a> object with properties defined as follows:
            </p>
            <ul>
              <li>
                If a match is found for the current selection criteria, the value of the <a>range</a> property MUST be a <code>Range</code> object that contains the target string or DOM structure, and the value of the <a>confidence</a> property MUST be a postive value as described <i>in the upcoming section on magical ways to determine a confidence value on the results, probably something to do with the edit distance and how many criteria failed or something</i>.
              </li>
              
              <li>
                If no match is found for the current selection criteria, the value of the <code>range</code> property MUST be <code>null</code>., and the value of the <code>confidence</code> property MUST be <code>0</code>.
              </li>
            </ul>

            <p class="issue">
              TODO: Add algorithm that describes the search operation, the setting of the search index position, evaluation of each search criterion, and so on. Maybe that's in a later section of the spec?
            </p>

            <dl class="parameters">
              <dt>
                optional boolean forward
              </dt>
              <dd>
                <p>
                  This parameter indicates whether the search should proceed in forward (positive) direction from the last index, or in a reverse (negative) direction. The default value MUST be true.
                </p>
                <p>
                  If the value is <code>true</code>, the search MUST continue in a positive direction along the character or DOM serialization, from the start of the document toward the end, beginning at the index of the last search.
                </p>
                <p>
                  If the value is <code>false</code>, the search MUST continue in a negative direction along the character or DOM serialization, from the end of the document toward the start, beginning at the index of the last search.
                </p>
              </dd>
            </dl>  

            <dl class="exceptions">
              <dt>
                DOMException error
              </dt>
              <dd>
                The error that occurred while searching.
              </dd>
            </dl>
          </dd>
        </dl>


        <dl title="enum UnicodeEquivalenceType" class="idl">
          <dt>
            none
          </dt>
          <dd>
            The search MUST NOT use any Unicode equivalence of characters.
          </dd>
          <dt>
            canonical
          </dt>
          <dd>
            The search MUST use canonical (NFC/NFD) Unicode equivalence of characters.
          </dd>
          <dt>
            compatibility
          </dt>
          <dd>
            The search MUST use compatibility (NFKC/NFKD) Unicode equivalence of characters.
          </dd>
        </dl>


        <dl title='dictionary RangeFinderArgs' class='idl'>
          <dt>
            DOMString text
          </dt> <dd></dd>
          <dt>
            unsigned short textDistance
          </dt> <dd></dd>
          <dt>
            DOMString prefix
          </dt> <dd></dd>
          <dt>
            unsigned short prefixDistance
          </dt> <dd></dd>
          <dt>
            DOMString suffix
          </dt> <dd></dd>
          <dt>
            unsigned short suffixDistance
          </dt> <dd></dd>
          <dt>
            Range scope
          </dt> <dd></dd>
          <dt>
            Range startRange
          </dt> <dd></dd>
          <dt>
            boolean caseFolding
          </dt> <dd></dd>
          <dt>
            UnicodeEquivalenceType unicodeFolding
          </dt> <dd></dd>
          <dt>
            boolean wholeWord
          </dt> <dd></dd>
          <dt>
            boolean wrap
          </dt>
        </dl>

        <dl title='dictionary RangeFinderResult' class='idl'>
          <dt>
            Range? range
          </dt>
          <dd>
            <p>
              A <a href="http://www.w3.org/TR/dom/#range">DOM Range object</a>, as defined in [[!DOM4]]. If no match is found, the value MUST be <code>null</code>.
            </p>
          </dd>

          <dt>
            dictionary RangeFinderArgs
          </dt>
          <dd>
            <p>
              A dictionary object which contains all the parameters used in the search.
            </p>

            <p>
              <a>RangeFinderArgs</a> MUST include entries for all available parameters, and MUST include default values for any parameter not explicitly set in the RangeFinder object.
            </p>
          </dd>
        </dl>

 <!-- 
        <section>
          <h3 id="lifetime-RangeFinder" class="informative">
            Note goes here
          </h3>
          <p>
            Say anything useful.
          </p>
        </section>
 -->
      </section>
    </section>



    <section>
      <h2 id="api">
        The EditDistance Interface
      </h2>
      <p>The EditDistance API defines a method to calculate the minimum <a>edit distance</a> between any two strings. This method uses the Levenshtein Distance algorithm, with the following operations:</p>
      <ul>
        <li>Adding one character to the target string.</li>
        <li>Deleting one character from the target string.</li>
        <li>Replacing one character of the target string with another character.</li>
      </ul>
      <p>The EditDistance Interface is a lower-level API that acts as a helper API to the <a>RangeFinder</a> API. It may also be used as a standalone method.</p>

      <p>Given two strings <var>s<sub>1</sub></var> and <var>s<sub>2</sub></var>, the edit distance between <var>s<sub>1</sub></var> and <var>s<sub>2</sub></var> is the minimum number of addition, deletion, and replacement operations required to convert string <var>s<sub>1</sub></var> to <var>s<sub>2</sub></var>.</p>

      <section>
        <h2>
          The EditDistance Method
        </h2>
        <dl title='interface EditDistance' class='idl'>
          <dt>unsigned short findEditDistance (in DOMString targetString, in DOMString comparisonString)</dt>
          <dd>
            <p>The findEditDistance method calculates the <a>edit distance</a> between the targetString and the comparisonString.</p>

            <dl class='parameters'>
              <dt>DOMString comparisonString</dt>
              <dd>
                Specifies the comparison string, which the target string is compared to. The default value MUST be the empty string.
              </dd>
              <dt>DOMString targetString</dt>
              <dd>
                Specifies the target string, which is compared to the comparison string. The default value MUST be the empty string.
              </dd>
            </dl>
          </dd>
        </dl>
      </section>
    </section>


    <section id="issues">
      <h2>
        Open Issues
      </h2>

      <p>
        These are open issues that don't yet have a location in the document.
      </p>

      <p class="issue">
        Explain how to tell when a search is complete, e.g. when all the matches have been found.
      </p>

      <p class="issue">
        How to deal with search matches that are dynamically inserted before the current search index position? LEave it up to the webapp?
      </p>

      <p class="issue">
        Should this find "meta" content, such as text in a <code>script</code>, <code>style</code>, <code>body</code>, or <code>CDATA</code> block?
      </p>

      <p class="issue">
        Should this find "hidden" content, such as text that is <code>display:none</code> or  <code>visibility:none</code>?
      </p>

      <p class="issue">
        What are the minimum criteria for performing a search? You might usefully look for what's between the prefix and suffix, or what is at a certain range. Should we allow that, or require that the <code>text</code> attribute not be the empty string?
      </p>

      <p class="issue">
        Should we include an option to ignore punctuation? Apparently use of punctuation is widely variable and often changed, so this improves search efficiency.
      </p>

    </section>

    <section>
      <h2>
        Concepts
      </h2>
      <p>
        Algorithms defined in this specification assume that for each
        <a>document</a> there is a <dfn>pending promise</dfn>, which is
        initially set to <code>null</code>, which is a <a>Promise</a> object
        whose associated operation is to search the document.
      </p>
    </section>

    <section>
      <h3>Performing a search operation</h3>
      <p>A conforming <a>user agent</a> MUST perform a search operation in a manner that produces results consistent with this following algorithm. A conforming <a>user agent</a> MAY optimize the search algorithm in any way that produces these consistent results.</p>

      <div class='note'>
        <h4>Algorithm summary</h4>
        <p>
          The <code>RangeFinder</code> <code>search()</code> method initiates an incremental text search of that portion 
          of the document set as the <code>scope</code> parameter of the <code>RangeFinder</code> object, starting at its <code>startRange</code> parameter. 
        </p>
        <p>
          The search process starts by finding the scope of the search; given the <code>scope</code> range, it first finds the parent start and end elements, and all elements between them; these element comprise the <a>search tree</a>. It then extracts the text content of all these elements, and truncates everything outside the start and end character positions, using the algorithm defined for the <code>textContent</code> attribute in [[!DOM4]]; this is referred to as the <a>search content</a>.  
        </p>
        <p>
          In the <a>search content</a>, <code>target text</code>, and  <code>prefix and suffix text</code>, all multiple consecutive whitespace characters, including newline characters, are collapsed into single space characters. If the <code>caseFolding</code> attribute is set to true, all characters are converted into their lowercase equivalents (if any). If the <code>unicodeFolding</code> attribute is set to true, all characters are converted into their decomposed equivalents (if any), per the [[!charmod-norm]] spec. <i>If the <code>ignorePunctuation</code> attribute is set to true, all punctuation characters are removed.</i> (How should <code>wholeWord</code> be modeled?)
        </p>
        <p>
          Once the <a>search content</a>, <code>target text</code>, and  <code>prefix and suffix text</code> are normalized according to the required parameters, the search operation is begun. The starting point of the search is the character position of the <code>startRange</code> attribute; if this character position lies outside the scoped range, then the starting point of the search is the 0 position of the <a>search content</a> string.
        </p>
        <p>
          The <code>target text</code> is then incrementally compared with the <a>search content</a>, within the tolerance of the specified <a href="#edit_distance">edit distance</a>. Each such operation is performed at the current index character, starting with the first character and proceeding to each subsequent character. If there is a match, the prefix and suffix strings are also tested against the surrounding text and within their respective specified <a href="#edit_distance">edit distance</a> tolerances. If this also matches, then the process stops and the return results are prepared. If no appropriate match is found, the index character is incremented by a single character until a match is found, or until the end of the <a>search content</a> is reached if the <code>wrap</code> attribute is set to false. If the <code>wrap</code> attribute is set to true, and the start position was not the 0 position of the <a>search content</a> string, the search only concludes when the start position has been reached.
        </p>
        <p>
          The return results are prepared by first reconciling the matched string with its equivalent DOM range in the document. This range object is created, and bundled in an object with the original search parameters. This return object is in the form of a Promise, so the results can be analyzed and subsquent search operations can be performed by incrementing the start range position based on the matched range (if any). By performing this search multiple times, an application can incrementally find all matching ranges in the document.
        </p>
      </div>


      <p>The steps to <dfn>perform a search operation</dfn> to a 
        <a>document</a> using <a>RangeFinder</a> are as follows:</p>
      <ol>
        <li>If the <a>user agent</a> does not support searching the <a>document</a> using <a>RangeFinder</a>,
          return a <a>Promise</a> rejected with a
          <code>DOMException</code> whose name is
          <code>NotSupportedError</code> and abort these steps.
        </li>
        <li>The following sub-steps MAY be run asynchronously for performance
        reasons, for example, if the <a>user agent</a> has <a title=
        'browsing context'>browsing contexts</a> living in different
        processes:
          <ol>
            <li>Let <var>browsing contexts</var> be the <a>list of the
            descendant browsing contexts</a> of the <a>top-level browsing
            context</a>'s <a>document</a>.
            </li>
            <li>If one of the <var>browsing contexts</var>'s
            <a>document</a>'s <a>pending promise</a> is not
            <code>null</code>:
              <ol>
                <li>Let <var>doc</var> be the <a>document</a> which has a not
                <code>null</code> <a>pending promise</a>.
                </li>
                <li>Reject <var>doc</var>'s <a>pending promise</a> with
                <code>DOMException</code> whose name is
                <code>AbortError</code>.
                </li>
                <li>Set <var>doc</var>'s <a>pending promise</a> to
                <code>null</code> .
                </li>
              </ol>
            </li>
          </ol>
        </li>

      <li class="issue">
        Finish the algorithm.
      </li>

<!--         
        <li>If the <a>document</a>'s <a>active sandboxing flag set</a> has
        the <a>sandboxed orientation lock browsing context flag</a> set, or
        <a>user agent</a> doesn't meet the <a>security conditions</a> to
        perform an orientation change, return a <a>Promise</a> rejected with
        a <code>DOMException</code> whose name is <code>SecurityError</code>
        and abort these steps.
        </li>
        <li>Let <var>orientations</var> be an empty list.
        </li>
        <li>Depending on <var>orientation</var> value, do the following:
          <dl>
            <dt>
              <code><dfn id=
              'idl-def-OrientationLockType.portrait-primary'>portrait-primary</dfn></code>
              or <code><dfn id=
              'idl-def-OrientationLockType.portrait-secondary'>portrait-secondary</dfn></code>
              or <code><dfn id=
              'idl-def-OrientationLockType.landscape-primary'>landscape-primary</dfn></code>
              or <code><dfn id=
              'idl-def-OrientationLockType.landscape-secondary'>landscape-secondary</dfn></code>
            </dt>
            <dd>
              Append <var>orientation</var> to <var>orientations</var>.
            </dd>
            <dt>
              <code><dfn id=
              'idl-def-OrientationLockType.landscape'>landscape</dfn></code>
            </dt>
            <dd>
              Depending on platform convention, append
              <code>landscape-primary</code>, or
              <code>landscape-secondary</code>, or both to
              <var>orientations</var>.
            </dd>
            <dt>
              <code><dfn id=
              'idl-def-OrientationLockType.portrait'>portrait</dfn></code>
            </dt>
            <dd>
              Depending on platform convention, append
              <code>portrait-primary</code>, or
              <code>portrait-secondary</code>, or both to
              <var>orientations</var>.
            </dd>
            <dt>
              <code><dfn id=
              'idl-def-OrientationLockType.natural'>natural</dfn></code>
            </dt>
            <dd>
              Append <code>portrait-primary</code> or
              <code>landscape-primary</code> to <var>orientations</var> such
              as the associated screen orientation angle is 0.
            </dd>
            <dt>
              <code><dfn id=
              'idl-def-OrientationLockType.any'>any</dfn></code>
            </dt>
            <dd>
              Append <code>portrait-primary</code>,
              <code>portrait-secondary</code>, <code>landscape-primary</code>
              and <code>landscape-secondary</code> to
              <var>orientations</var>.
            </dd>
          </dl>
        </li>
        <li>Set <var>pending-promise</var> to be a newly-created
        <a>Promise</a>.
        </li>
        <li>Return <var>pending-promise</var> and continue asynchronously.
        </li>
        <li>
          <a>Lock the orientation</a> of the <a>document</a> to
          <var>orientations</var>.
        </li>
        <li>If locking the orientation did not result in a change of
        orientation, <a>queue a task</a> to resolve
        <var>pending-promise</var> with <code>undefined</code> and set <var>
          pending-promise</var> to <code>null</code>.
        </li>
      </ol>
      <div class='note'>
        If locking the orientation results in an orientation change, the
        promise will be resolved when the orientation will change as
        described in the <a href=
        '#handling-screen-orientation-changes'>Handling screen orientation
        changes</a> section.
      </div>
      <p>
        When the <a>user agent</a> has to <dfn>lock the orientation</dfn> of
        a <a>document</a> to <var>orientations</var>, it MUST run the
        following steps:
      </p>
      <ol>
        <li>Set the <a>document</a>'s <a>orientation lock</a> to
        <var>orientations</var>.
        </li>
        <li>If the <a>active orientation lock</a> is not the
        <a>document</a>'s <a>orientation lock</a>, abort these steps.
        </li>
        <li>If the <a>active orientation lock</a> value is equal to
        <var>orientations</var> value, abort these steps.
        </li>
        <li>If <var>orientations</var> contains only one value, run the
        following sub-steps:
          <ol>
            <li>Let <var>orientation</var> be the value contained in
            <var>orientations</var>.
            </li>
            <li>Change how the viewport is drawn so that the
            <a>document</a>'s <a>current orientation type</a> will be equal
            to <var>orientation</var>.
            </li>
            <li>After the change has happened, prevent the <a>document</a>'s
            <a>top-level browsing context</a>'s screen orientation from
            changing until those steps are run again.
            </li>
            <li>Abort these steps.
            </li>
          </ol>
        </li>
        <li>If the <a>document</a>'s <a>current orientation type</a> is not
        part of <var>orientations</var>, change how the viewport is drawn
        such as the <a>document</a>'s <a>current orientation type</a> will be
        equal to one of <var>orientations</var>' values.
        </li>
        <li>Otherwise, depending on platform conventions, change how the
        viewport is drawn in order to make it match another screen
        orientation type. However, it has to be part of
        <var>orientations</var>.
        </li>
        <li>Allow the user to change the screen orientation to any value part
        of <var>orientations</var> and only those values until those steps
        are run again. The method to define the current screen orientation
        has to match the platform conventions.
        </li> 
        -->
      </ol>


      <p class="issue">
        Define the EditDistance algorithm.
      </p>

    </section>

    <section id="examples" class="informative">
      <h2>Examples</h2>
        <p class="warning">
          This examples section is out of date, and uses syntax from an earlier draft of this spec. The general ideas are similar, but the syntax may be very different.
        </p>
      <p>
        Poetry, lyrics, and some prose often include significant repetition. A simple find-text operation would return only the first instance of a repetition, while the selection in question might be for the second or third instance.
      </p>


      <section id="example-1" class="informative">
        <h3>Example 1</h3>
        <p>
          In the following poem, there are four instances of the phrase “<i>Rage, rage</i>”; the desired selection is the third instance. Assuming an HTML page consisting only of the poem, there are several ways to use the RangeFinder API to achieve this, a few of which are demonstrated below. Any or all of these techniques can be applied to ensure robust anchoring.
        </p>

        <article id="poem-1" class="example">
          <header>
            <b>Do Not Go Gentle Into That Good Night</b>
            <p>by Dylan Thomas</p>
          </header>
          <p>
            Do not go gentle into that good night,<br>
            Old age should burn and rave at close of day;<br>
            Rage, rage against the dying of the light.<br>
          </p>

          <p>
            Though wise men at their end know dark is right,<br>
            Because their words had forked no lightning they<br>
            Do not go gentle into that good night.
          </p>

          <p>
            Good men, the last wave by, crying how bright<br>
            Their frail deeds might have danced in a green bay,<br>
            Rage, rage against the dying of the light.
          </p>

          <p>
            Wild men who caught and sang the sun in flight,<br>
            And learn, too late, they grieved it on its way,<br>
            Do not go gentle into that good night.
          </p>

          <p>
            Grave men, near death, who see with blinding sight<br>
            Blind eyes could blaze like meteors and be gay,<br>
            <span class="highlight">Rage, rage</span> against the dying of the light.
          </p>

          <p>
            And you, my father, there on the sad height,<br>
            Curse, bless, me now with your fierce tears, I pray.<br>
            Do not go gentle into that good night.<br>
            Rage, rage against the dying of the light.    
          </p>
        </article>

        <h4 id="ex1-m1">Method 1: Iterative search</h4>
        <pre class="example"><code>
var rf = new RangeFinder({ text: "Rage, rage" });
var result = rf.search()  // result is 1st instance of string
    .then( rf.search() )  // result is 2nd instance of string
    .then( rf.search() ); // result is 3rd instance of string, the target instance
        </code></pre>

        <h4 id="ex1-m2">Method 2: Context search with prefix</h4>
        <pre class="example"><code>
var rf = new RangeFinder({ text: "Rage, rage" });
    rf.prefix = "blaze like meteors and be gay, "; // the 32 characters preceding the selection
var result = rf.search(); // result is 1st instance of string after prefix
        </code></pre>

        <h4 id="ex1-m3">Method 3: Character count</h4>
        <pre class="example"><code>
var rf = new RangeFinder();
    rf.characterStart = 696; // the character count of the normalized textContent preceding the selection
    rf.characterLength = 11; // the character count of the selection
var result = rf.search(); // result is the 11 characters starting at the position 696
        </code></pre>



        <h4 id="ex1-m4">Method 4: Edit distance and query selector</h4>

        @@ YOU ARE HERE! @@
        <pre class="example"><code>
        var range = document.createRange();
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
var rf = new RangeFinder();
    rf.text = "Range, range"; // the selection, misspelled
    rf.editDistance = 2; // the Levenshtein distance tolerance between "Rage, rage" and "Range, range"
    rf.querySelector = "p:nth-of-type(5)"; // the 5th paragraph (the one containing the selection)
var result = rf.search(); // result is 1st instance of string starting at query selector, 
                          //   with a confidence reflecting the expected edit distance
        </code></pre>

        <h4 id="ex1-m5">Method 5: Edit distance and query selector</h4>
        <pre class="example"><code>
var rf = new RangeFinder();
    rf.text = "Range, range"; // the selection, misspelled
    rf.editDistance = 2; // the Levenshtein distance tolerance between "Rage, rage" and "Range, range"
    rf.querySelector = "p:nth-of-type(5)"; // the 5th paragraph (the one containing the selection)
var result = rf.search(); // result is 1st instance of string starting at query selector, 
                          //   with a confidence reflecting the expected edit distance
        </code></pre>

        <h4 id="ex1-m6">Method 6: Element scope</h4>
        <p class="note">
          The main difference here between the <code>querySelector</code> attribute (used in <a href="#ex1-m4">Method 4</a>)
          and the <code>element</code> attribute is that <code>querySelector</code> sets the starting point for the search, 
          while <code>element</code> limits the scope. In other words, running <code>search()</code> again on the previous example
          will find the next instance in the next paragraph, while in this example, it will only find the single instance in the target paragraph.
        </p>
        <pre class="example"><code>
var rf = new RangeFinder();
    rf.text = "Rage, rage"; // the selection
    rf.element = document.querySelector("p:nth-of-type(5)"); // limit scope to the 5th paragraph
                                                             //   (the one containing the selection)
var result = rf.search(); // result is 1st instance of string within query selector, 
                          //   with a confidence reflecting the expected edit distance
        </code></pre>


      </section>
    </section>
   
    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>
        Special thanks to Cameron McCormack (Mozilla), Kristof Csillag (Hypothes.is), Randall Leeds (Hypothes.is), Dan Whaley (Hypothes.is), Mitar Milutinovic (UC-Berkeley), Jake Hartnell (UC-Berkeley, EPUB.js), Nick Stenning (Hypothes.is), Benjamin Young (Hypothes.is), Mike de Boer (Mozilla), Travis Leithead (Microsoft), Ryosuke Niwa (Apple), Josh Soref (Blackberry), Rob Sanderson (Stanford), Paolo Ciccarese (Mass General Hospital / Harvard), Takeshi Kanai (Sony), Ivan Herman (W3C), Robin Berjon (W3C), Mike™ Smith (W3C), Mounir Lamouri (Google) and Marcos Cáceres (Mozilla) for writing a spec I could plunder mechanics, Peter Brantley (for putting on the Books in Browsers conference), and the entire Web Annotation Working Group and Open Annotations Community Group for discussion and insight. If I've forgotten anyone, please remind me; I'm truly grateful for all the discussions I've had on this topic.
      </p>
    </section>
    
    <section id='tof'></section>

  </body>
</html>
