<!-- $Id: contm-new.xml,v 1.517 2014-04-16 10:54:12 dcarlis Exp $ -->
<div1 id="contm" role="chapter4">
<head>Content Markup</head>

<!--
Principal Authors
Stephen Buswell: overall design; organization and original text of documentation.
Stan Devitt: design revision for MathML2.
Stephen Watt: new material relating to numbers.
Michael Kohlhase, David Carlisle, Robert Miner: major revision for MathML3
-->
<div2 id="contm_intro">
<head>Introduction</head>
<div3>
<head>The Intent of Content Markup</head>

<p>The intent of Content Markup is to provide an explicit encoding of
the <emph>underlying mathematical meaning</emph> of an expression,
rather than any particular rendering for the expression.  Mathematics
is distinguished both by its use of rigorous formal logic to define
and analyze mathematical concepts, and by the use of a (relatively)
formal notational system to represent and communicate those concepts.
However, mathematics and its presentation should not be viewed as one
and the same thing. Mathematical notation, though more rigorous than
natural language, is nonetheless at times ambiguous,
context-dependent, and varies from community to community.  In some
cases, heuristics may adequately infer mathematical semantics from
mathematical notation. But in many others cases, it is preferable to
work directly with the underlying, formal, mathematical objects.
Content Markup provides a rigorous, extensible semantic framework and
a markup language for this purpose.
</p>

<p>The difficulties in inferring semantics from a presentation stem
from the fact that there are many to one mappings from presentation to
semantics and vice versa. For example the mathematical construct
<quote><var>H</var> multiplied by <var>e</var></quote> is often
encoded using an explicit operator as in
<var>H</var>&#160;&#215;&#160;<var>e</var>. In different
presentational contexts, the multiplication operator might be
invisible <quote><var>H</var>&#160;<var>e</var></quote>, or rendered
as the spoken word <quote>times</quote>. Generally, many different
presentations are possible depending on the context and style
preferences of the author or reader. Thus, given
<quote><var>H</var>&#160;<var>e</var></quote> out of context it may be
impossible to decide if this is the name of a chemical or a
mathematical product of two variables <var>H</var> and
<var>e</var>. Mathematical presentation also varies across cultures
and geographical regions. For example, many notations for long
division are in use in different parts of the world today. Notations
may lose currency, for example the use of musical sharp and flat
symbols to denote maxima and minima <bibref ref="Chaundy1954"/>. A
notation in use in 1644 for the multiplication mentioned above was
<graphic role="inline" source="image/f4001.gif"
alt="\blacksquare"/><var>H</var><var>e</var> <bibref
ref="Cajori1928"/>.</p>

<p>By encoding the underlying mathematical structure explicitly,
without regard to how it is presented aurally or visually, it is
possible to interchange information more precisely between systems
that semantically process mathematical objects. In the trivial example
above, such a system could substitute values for the variables
<var>H</var> and <var>e</var> and evaluate the result. Important
application areas include computer algebra systems, automatic
reasoning system, industrial and scientific applications,
multi-lingual translation systems, mathematical search, and
interactive textbooks.</p>

<p>The organization of this chapter is as follows.  In <specref
ref="contm_core"/>, a core collection of elements comprising Strict
Content Markup are described.  Strict Content Markup is sufficient to
encode general expression trees in a semantically rigorous way.  It is
in one-to-one correspondence with OpenMath element set. OpenMath is a
standard for representing formal mathematical objects and semantics
through the use of extensible Content Dictionaries.  Strict Content
Markup defines a mechanism for associating precise mathematical
semantics with expression trees by referencing OpenMath Content
Dictionaries. The next two sections introduce markup that is more
convenient than Strict markup for some purposes, somewhat less formal
and verbose.  In <specref ref="contm_structure_extended"/>, markup is
introduced for representing a small number of mathematical idioms,
such as limits on integrals, sums and product.  These constructs may
all be rewritten as Strict Content Markup expressions, and rules for
doing so are given.  In <specref ref="contm_opel"/>, elements are
introduced for many common function, operators and constants. This
section contains many examples, including equivalent Strict Content
expressions.  In <specref ref="contm_deprecated"/>, elements from
MathML 1 and 2 whose use is now discouraged are listed.
Finally, <specref ref="contm_p2s"/> summarizes the algorithm for
translating arbitrary Content Markup into Strict Content Markup.  It
collects together in sequence all the rewrite rules introduced
throughout the rest of the chapter.</p> </div3>

<div3 id="contm_rendering">
  <head>The Structure and Scope of Content MathML Expressions</head>

  <p>Content MathML represents mathematical objects as <emph>expression trees</emph>.  The
  notion of constructing a general expression tree is e.g. that of applying an operator to
  sub-objects. For example, the sum <quote><var>x</var>+<var>y</var></quote> can be
  thought of as an application of the addition operator to two arguments <var>x</var> and
  <var>y</var>. And the expression <quote>cos(&#960;)</quote> as the application of the
  cosine function to the number &#960;.</p>

  <p>As a general rule, the terminal nodes in the tree represent basic mathematical
  objects such as numbers, variables, arithmetic operations and so on. The internal nodes
  in the tree represent function application or other mathematical constructions that
  build up a compound objects. Function application provides the most important example;
  an internal node might represent the application of a function to several arguments,
  which are themselves represented by the nodes underneath the internal node.</p>

  <p>The semantics of general mathematical expressions is not a matter of consensus. It
  would be an enormous job to systematically codify most of mathematics &#8211; a task
  that can never be complete. Instead, MathML makes explicit a relatively small number of
  commonplace mathematical constructs, chosen carefully to be sufficient in a large number
  of applications. In addition, it provides a mechanism for referring
  to mathematical concepts outside of the base collection, allowing
  them to be represented, as well.</p>

  <p>The base set of content elements is chosen to be adequate for simple coding of most
  of the formulas used from kindergarten to the end of high school in the United States,
  and probably beyond through the first two years of college, that is up to A-Level or
  Baccalaureate level in Europe.</p>

  <p>While the primary role of the MathML content element set is to directly encode the
  mathematical structure of expressions independent of the notation used to present the
  objects, rendering issues cannot be ignored. There are different approaches for
  rendering Content MathML formulae, ranging from native implementations of the
  MathML elements to declarative notation definitions, to XSLT style
  sheets. Because rendering requirements for Content MathML vary
  widely, MathML 3 does not provide a normative specification for
  rendering.  Instead, typical renderings are suggested by way of examples.</p>
</div3>

<div3 id="contm_strict">
  <head>Strict Content MathML</head>

  <p>In MathML 3, a subset, or profile, of Content MathML is defined: <emph>Strict Content
  MathML</emph>.  This uses a minimal, but sufficient, set of elements to represent the meaning of a
  mathematical expression in a uniform structure, while the full Content MathML grammar is
  backward compatible with MathML 2.0, and generally tries to strike a more pragmatic
  balance between verbosity and formality.</p>

  <p>Content MathML provides a large number of predefined functions
  encoded as empty elements (e.g. <el>sin</el>, <el>log</el>, etc.)
  and a variety of constructs for forming compound objects
  (e.g. <el>set</el>, <el>interval</el>, etc.).  By contrast, Strict
  Content MathML uses a single element (<el>csymbol</el>) with an
  attribute pointing to an external definition in extensible content
  dictionaries to represent all functions, and uses only
  <el>apply</el> and <el>bind</el> for building up compound
  objects. The token elements such as <el>ci</el> and <el>cn</el> are
  also considered part of Strict Content MathML, but with a more
  restricted set of attributes and with content restricted to
  text.</p>

  <p>Strict Content MathML is designed to be compatible with OpenMath (in
  fact it is an XML encoding of OpenMath Objects in the sense of <bibref ref="OpenMath2004"/>).  
  OpenMath is a standard for representing formal mathematical
  objects and semantics through the use of extensible Content Dictionaries.  The table below
  gives an element-by-element correspondence between the OpenMath XML encoding of OpenMath
  objects and Strict Content MathML.
  <table border="1" id="contm_om_correspondence">
    <thead>
      <tr><td>Strict Content MathML</td><td>OpenMath</td></tr>
    </thead>
    <tbody>
      <tr>
        <td><intref ref="contm_cn"><el>cn</el></intref></td>
        <td><el namespace="openmath">OMI</el>, <el namespace="openmath">OMF</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_csymbol"><el>csymbol</el></intref></td>
        <td><el namespace="openmath">OMS</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_ci"><el>ci</el></intref></td>
        <td><el namespace="openmath">OMV</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_cs"><el>cs</el></intref></td>
        <td><el namespace="openmath">OMSTR</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_apply"><el>apply</el></intref></td>
        <td><el namespace="openmath">OMA</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_binding"><el>bind</el></intref></td>
        <td><el namespace="openmath">OMBIND</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_binding"><el>bvar</el></intref></td>
        <td><el namespace="openmath">OMBVAR</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_sharing"><el>share</el></intref></td>
        <td><el namespace="openmath">OMR</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_semantics"><el>semantics</el></intref></td>
        <td><el namespace="openmath">OMATTR</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_semantics"><el>annotation</el></intref>,
        <intref ref="contm_semantics"><el>annotation-xml</el></intref></td>
        <td><el namespace="openmath">OMATP</el>, <el namespace="openmath">OMFOREIGN</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_cerror"><el>cerror</el></intref></td>
        <td><el namespace="openmath">OME</el></td>
      </tr>
      <tr>
        <td><intref ref="contm_cbytes"><el>cbytes</el></intref></td>
        <td><el namespace="openmath">OMB</el></td>
      </tr>
    </tbody>
  </table>
  </p>

  <p>In MathML 3, formal semantics Content MathML expressions are
  given by specifying equivalent Strict Content MathML expressions.
  Since Strict Content MathML expressions all have carefully-defined
  semantics given in terms of OpenMath Content Dictionaries, all
  Content MathML expressions inherit well-defined semantics in this
  way. To make the correspondence exact, an algorithm is
  given in terms of transformation rules that are applied to
  rewrite non-Strict MathML constructs into a strict equivalents. The
  individual rules are introduced in context throughout the chapter.
  In <specref ref="contm_p2s"/>, the algorithm as a whole is
  described.</p>

  <p>As most transformation rules relate to
  classes of MathML elements that have similar argument structure,
  they are introduced in <specref ref="contm_opclasses"/> where these
  classes are defined. Some special case rules for specific elements
  are given in Section <specref ref="contm_opel"/>. Transformations in
  <specref ref="contm_core"/> concern non-Strict usages of the core
  Content MathML elements, those in <specref
  ref="contm_structure_extended"/> concern the rewriting of some
  additional structures not directly supported in Strict Content MathML.</p>

  <p>The full algorithm described in<specref ref="contm_p2s"/> is
  complete in the sense that it gives every Content MathML expression a specific
  meaning in terms of a Strict Content MathML expression.  This means
  it has to give specific strict interpretations to some expressions
  whose meaning was insufficiently specified in MathML2. The intention
  of this algorithm is to be faithful to mathematical intuitions.
  However edge cases may remain where the normative interpretation of
  the algorithm may break earlier intuitions.</p>

  <p>A conformant MathML processor need
  not implement this transformation. The existence of these
  transformation rules does not imply that a system must treat
  equivalent expressions identically. In particular systems may give
  different presentation renderings for expressions that the
  transformation rules imply are mathematically equivalent.</p>

</div3>

<div3 id="contm_cds">
  <head>Content Dictionaries</head>

      <p>Due to the nature of mathematics, any method for formalizing
      the meaning of the mathematical expressions must be
      extensible. The key to extensibility is the ability to define
      new functions and other symbols to expand the terrain of
      mathematical discourse. To do this, two things are required: a
      mechanism for representing symbols not already defined by
      Content MathML, and a means of associating a specific
      mathematical meaning with them in an unambiguous way.  In MathML
      3, the <el>csymbol</el> element provides the means to represent
      new symbols, while <emph>Content Dictionaries</emph> are the way
      in which mathematical semantics are described.  The association
      is accomplished via attributes of the <el>csymbol</el> element
      that point at a definition in a CD. The syntax and usage of
      these attributes are described in detail in <specref
      ref="contm_csymbol"/>.</p>

      <p>Content Dictionaries are structured documents for the
      definition of mathematical concepts; see the OpenMath standard,
      <bibref ref="OpenMath2004"/>.
      To maximize modularity and reuse, a
      Content Dictionary typically contains a relatively small
      collection of definitions for closely related concepts.  The
      OpenMath Society maintains a large set of public Content Dictionaries
     including the MathML CD group that including contains definitions 
  for all pre-defined symbols in MathML.
 There is a process for contributing privately
      developed CDs to the OpenMath Society repository to facilitate
      discovery and reuse.  MathML 3 does not require CDs be publicly
      available, though in most situations the goals of semantic
      markup will be best served by referencing public CDs available
      to all user agents.</p>

      <p>In the text below, descriptions of semantics for predefined
      MathML symbols refer to the Content Dictionaries developed by
      the OpenMath Society in conjunction with the W3C Math Working
      Group.  It is important to note, however, that this information
      is informative, and not normative. In general, the precise
      mathematical semantics of predefined symbols are not not fully
      specified by the MathML 3 Recommendation, and the only normative
      statements about symbol semantics are those present in the text
      of this chapter.  The semantic definitions provided by the
      OpenMath Content CDs are intended to be sufficient for
      most applications, and are generally compatible with the
      semantics specified for analogous constructs in the MathML 2.0
      Recommendation.  However, in contexts where highly precise
      semantics are required (e.g. communication between computer
      algebra systems, within formal systems such as theorem provers,
      etc.) it is the responsibility of the relevant community of
      practice to verify, extend or replace definitions provided by
      OpenMath CDs as appropriate.</p>
</div3>

<div3 id="contm_concepts">
<head>Content MathML Concepts</head>

<p>The basic building blocks of Content MathML expressions are
numbers, identifiers and symbols.  These building blocks are combined
using function applications and binding operators.  It is important to
have a basic understanding of these key mathematical concepts, and how
they are reflected in the design of Content MathML.  For the
convenience of the reader, these concepts are reviewed here.</p>

<p>In the expression <quote><var>x</var>+<var>y</var></quote>,
<var>x</var> is a mathematical variable, meaning an identifier that
represents a quantity with no fixed value.  It may have other
properties, such as being an integer, but its value is not a fixed
property.  By contrast, the plus sign is an identifier that represents a
fixed and externally defined object, namely the addition function.
Such an identifier is termed a <emph>symbol</emph>, to distinguish it
from a variable.  Common elementary functions and operators all have
fixed, external definitions, and are hence symbols.  Content MathML
uses the <el>ci</el> element to represent variables, and the
<el>csymbol</el> to represent symbols.</p>

<p>The most fundamental way in which symbols and variables are
combined is function application.  Content MathML makes a crucial
semantic distinction between a function itself (a symbol such as the
sine function, or a variable such as <var>f</var>) and the result of
applying the function to arguments.  The <intref
ref="contm_apply"><el>apply</el></intref> element groups the function
with its arguments syntactically, and represents the expression
resulting from applying that function to its arguments.</p>

<p>Mathematically, variables are divided into <emph>bound</emph> and
<emph>free</emph> variables.  Bound variables are variables that are
assigned a special role by a binding operator within a certain scope.
For example, the index variable within a summation is a bound
variable. They can be characterized as variables with the property
that they can be renamed consistently throughout the binding scope
without changing the underlying meaning of the expression.  Variables
that are not bound are termed free variables.
Because the logical distinction between bound and free variables is
important for well-defined semantics, Content MathML differentiates
between the application of a function to a free variable,
e.g. <var>f</var>(<var>x</var>) and the operation of binding a
variable within a scope.  The <intref
ref="contm_bind"><el>bind</el></intref> element is used the delineate
the binding scope, and group the binding operator with its bound
variables, which are indicated by the <el>bvar</el> element.</p>

<p>In Strict Content markup, the <el>bind</el> element is the only way
of performing variable binding.  In non-Strict usage, however, markup
is provided that more closely resembles well-known idiomatic
notations, such as the <quote>limit</quote> notations for sums and
integrals.  These constructs often implicitly bind variables, such as
the variable of integration, or the index variable in a sum.  MathML
terms the elements used to represent the auxiliary data such as limits
required by these constructions <emph>qualifier</emph> elements.</p>

<p>Expressions involving qualifiers follow one of a small number of
idiomatic patterns, each of which applies to class of similar binding
operators.  For example, sums and products are in the same class
because they use index variables following the same pattern.  The
Content MathML operator classes are described in detail in <specref
ref="contm_opclasses"/>.
</p>

<p>Each Content MathML element is described in a section below that
begins with a table summarizing the key information about the element.
For elements that have different Strict and non-Strict
usage, these syntax tables are divided to clearly separate the two cases. The element's content
model is given in the <kw>Content</kw> row, linked to the MathML
Schema in <specref ref="parsing"/>.  The <kw>Attributes</kw>, and
<kw>Attribute Values</kw> rows similarly link to the schema. Where
applicable, the <kw>Class</kw> row specifies the operator class, which
indicate how many arguments the operator represented by this element
takes, and also in many cases determines the mapping to Strict Content
MathML, as described in <specref ref="contm_opclasses"/>.  Finally,
the <kw>Qualifiers</kw> row clarifies whether the operator takes
qualifiers and if so, which. <phrase>Note <kw>Class</kw>
and <kw>Qualifiers</kw> specify how many siblings may follow
the operator element in an <el>apply</el>, or the children of the
element for container elements;</phrase> see <specref
ref="contm_apply"/> and <specref ref="contm_qualifiers"/> for
details).</p>

</div3>


</div2>

<div2 id="contm_core">
  <head>Content MathML Elements Encoding Expression Structure</head>

  <p>In this section we will present the elements for encoding the structure of content
  MathML expressions. These elements are the only ones used for the Strict Content MathML
  encoding. Concretely, we have 
  <ulist>
    <item>
      <p>basic expressions, i.e.  <intref ref="contm_cn">Numbers</intref>, <intref ref="contm_cs">string literals</intref>, <intref ref="contm_cbytes">encoded
      bytes</intref>, <intref ref="contm_csymbol">Symbols</intref>, and <intref ref="contm_ci">Identifiers</intref>.</p>
    </item>
    <item>
      <p>derived expressions, i.e.
      <intref ref="contm_apply">function applications</intref> and
      <intref ref="contm_binding">binding expressions</intref>, and </p>
    </item>
    <item>
      <p><intref ref="contm_semantics">semantic annotations</intref></p>
    </item>
    <item>
      <p><intref ref="contm_cerror">error markup</intref></p>
    </item>
  </ulist>
  Full Content MathML allows further elements presented in
  <specref ref="contm_structure_extended"/> and <specref ref="contm_opel"/>, and allows a richer
  content model presented in this section. Differences in Strict and non-Strict
  usage of are highlighted in the sections discussing each of the Strict element below.</p>

  <div3 id="contm_cn">
    <head>Numbers <el role="defn starttag">cn</el></head>

 <table id="contm_cn_syntax" role="syntax">
   <thead>
     <tr>
       <th/>
       <th colspan="2">Schema Fragment (Strict)</th>
       <th colspan="2">Schema Fragment (Full)</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <th>Class</th>
       <td colspan="2"><intref ref="contm_cn">Cn</intref></td>
       <td colspan="2"><intref ref="contm_cn">Cn</intref></td>
     </tr>
     <tr>
       <th>Attributes</th>
       <td colspan="2"><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">type</kw></td>
       <td colspan="2"><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>, <kw role="parsing_ref">type</kw>?, <kw role="parsing_ref">base</kw>?</td>
     </tr>
     <tr>
       <th><att>type</att> Attribute Values</th>
       <td>
         <attval>integer</attval> |
         <attval>real</attval> |
         <attval>double</attval> |
         <attval>hexdouble</attval>
       </td>
       <td>&#160;&#160;&#160;</td>
       <td>
         <attval>integer</attval> |
         <attval>real</attval> |
         <attval>double</attval> |
         <attval>hexdouble</attval> |
         <attval>e-notation</attval> |
         <attval>rational</attval> |
         <attval>complex-cartesian</attval> |
         <attval>complex-polar</attval> |
         <attval>constant</attval> | text
       </td>
       <td>default is real</td>
     </tr>
     <tr>
       <th><att>base</att> Attribute Values</th>
       <td colspan="2"/>
       <td>
         <kw role="parsing_ref">integer</kw>
       </td>
       <td>default is 10</td>
     </tr>
     <tr>
       <th>Content</th>
       <td colspan="2">text</td>
       <td colspan="2">(text | <kw role="parsing_ref">mglyph</kw> | <kw role="parsing_ref">sep</kw> | <kw role="parsing_ref">PresentationExpression</kw>)*</td>
     </tr>
   </tbody>
 </table>

  <p>The <el>cn</el> element is the Content MathML element used to
  represent numbers.  Strict Content MathML supports integers, real numbers,
  and double precision floating point numbers.  In these types of numbers,
  the content of <el>cn</el> is text. Additionally, <el>cn</el>
  supports rational numbers and complex numbers in which the different
  parts are separated by use of the <el>sep</el> element.  Constructs
  using <el>sep</el> may be rewritten in Strict Content MathML as
  constructs using <el>apply</el> as described below. </p>

<p> The <att>type</att> attribute specifies which kind of number is
represented in the <el>cn</el> element.  The default value is
<attval>real</attval>.  Each type implies that the content be of
a certain form, as detailed below.</p>

<div4 id="contm_rendering_numbers">
  <head>Rendering <el role="starttag">cn</el><phrase>,<el role="defn emptytag">sep</el></phrase>-Represented Numbers </head>
  <p>The default rendering of the text content of  <el>cn</el> is the same as that of the Presentation element <el>mn</el>, with suggested variants in the
case of attributes or <el>sep</el> being used, as listed below.</p>
</div4>

  <div4 id="contm_cn_strict"><head>Strict uses of <el role="starttag">cn</el></head>

<p>In Strict Content MathML, the <att>type</att> attribute is mandatory, and may only take the values
<attval>integer</attval>, <attval>real</attval>, <attval>hexdouble</attval> or
<attval>double</attval>:</p>

  <glist>
    <gitem>
      <label>integer</label>
      <def>
        <p>An integer is represented by an optional sign followed by a string of
        one or more decimal <quote>digits</quote>.</p>
      </def>
    </gitem>
    <gitem>
      <label>real</label>
      <def>
        <p>A real number is presented in radix notation. Radix notation consists of an
        optional sign (<quote>+</quote> or <quote>-</quote>) followed by a string of
        digits possibly separated into an integer and a fractional part by a
        decimal point. Some examples are 0.3, 1, and -31.56.</p>
      </def>
    </gitem>

    <gitem>
      <label>double</label>
      <def>
        <p>This type is used to mark up those double-precision
        floating point numbers that can be represented in the IEEE 754
        standard format <bibref ref="IEEE754"/>.  This includes a subset of the (mathematical) real
        numbers, negative zero, positive and negative real infinity
        and a set of "not a number" values.  The lexical rules for
        interpreting the text content of a <el>cn</el> as an IEEE
        double are specified by <loc href="http://www.w3.org/TR/xmlschema-2/#double">Section
        3.1.2.5</loc> of XML Schema Part 2: Datatypes Second Edition
        <bibref ref="XMLSchemaDatatypes"/>.  For example, -1E4, 1267.43233E12, 12.78e-2,
        12 , -0, 0 and INF are all valid doubles in this format.</p>
      </def>
    </gitem>
    <gitem>
      <label>hexdouble</label>
      <def>
        <p>This type is used to directly represent the 64 bits of an
        IEEE 754 double-precision floating point number as a 16 digit
        hexadecimal number.  Thus the number represents mantissa, exponent, and sign
        from lowest to highest bits using a least significant byte ordering.
        This   consists of a string of 16 digits 0-9, A-F.
        The following example 
        represents a NaN value. Note that certain IEEE doubles, such as the
        NaN in the example, cannot be represented in the lexical format for
        the <attval>double</attval> type.</p>
<div id="contm_cn_hexdouble_ex" role="mathml-example">
<eg role="mathml"><![CDATA[
<cn type="hexdouble">7F800000</cn>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mn>0x7F800000</mn>]]></eg>
<graphic source="image/contm_cn_hexdouble_ex.gif" alt="{\mn{0x7F800000}}"/>
</div>
       </def>
    </gitem>
  </glist>
</div4>

<div4 id="contm_cn_extended"><head>Non-Strict uses of <el role="starttag">cn</el></head>


<p>The <att>base</att> attribute is used to specify how the content is
to be parsed.  The attribute value is a base 10 positive integer
giving the value of base in which the text content of the <el>cn</el>
is to be interpreted.  The <att>base</att> attribute should only be
used on elements with type <attval>integer</attval> or
<attval>real</attval>.  Its use on <el>cn</el> elements of other type
is deprecated.  The default value for <att>base</att> is
<attval>10</attval>.</p>

  <p>Additional values for the <att>type</att> attribute element for supporting
  e-notations for real numbers, rational numbers, complex numbers and selected important
  constants. As with the <attval>integer</attval>, <attval>real</attval>,
  <attval>double</attval> and <attval>hexdouble</attval> types, each of these types
  implies that the content be of a certain form. If the <att>type</att> attribute is
  omitted, it defaults to <attval>real</attval>.</p>

  <glist>
    <gitem>
      <label>integer</label>
      <def>
        <p>Integers can be represented with respect to a base different from
        10: If <att>base</att> is present, it specifies (in base 10) the base for the digit encoding.
        Thus <att>base</att>='16' specifies a hexadecimal
        encoding.  When <att>base</att> &gt; 10, Latin letters (A-Z, a-z) are used in
        alphabetical order as digits. The case of letters used as digits is not
        significant.  The following example encodes the base 10 number 32736.</p>
<div id="cn_base_ex" role="mathml-example">
<eg role="mathml"><![CDATA[<cn base="16">7FE0</cn>]]></eg>
<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<msub><mn>7FE0</mn><mn>16</mn></msub>]]></eg>

<graphic source="image/cn_base_ex.gif" alt="{\mn{7FE0}\sb{16}}"/>
        </div>
        <p>
        When <att>base</att> &gt; 36, some integers cannot be represented using
        numbers and letters alone. For example, while 
<eg role="mathml"><![CDATA[<cn base="1000">10F</cn>]]></eg>
        arguably represents the number written in base 10 as 1,000,015, the number
        written in base 10 as 1,000,037 cannot be represented using letters and
        numbers alone when <att>base</att> is 1000.  Consequently, support
        for additional characters (if any) that may be used for digits when <att>base</att> &gt; 36 is application specific.
        </p>
      </def>
    </gitem>
    <gitem>
      <label>real</label>
      <def>
        <p>Real numbers can be represented with respect to a base
        different than 10. If a <att>base</att> attribute is present, then the digits are
        interpreted as being digits computed relative to that base (in the same way as
        described for type <attval>integer</attval>).</p>
      </def>
    </gitem>
    <gitem>
       <label>e-notation</label>
       <def>
         <p>A real number may be presented in scientific notation using this type.  Such
         numbers have two parts (a significand and an exponent)
         separated by a <el role="emptytag">sep</el> element. The
         first part is a real number, while the
         second part is an integer exponent indicating a power of the base.</p>
         <p> For example, <code>&lt;cn type="e-notation"&gt;12.3&lt;sep/&gt;5&lt;/cn&gt;</code>
         represents 12.3 times 10<sup>5</sup>. The default presentation of this example is
         12.3e5. Note that this type is primarily useful for backwards compatibility with
         MathML 2, and in most cases, it is preferable to use the <attval>double</attval>
         type, if the number to be represented is in the range of IEEE doubles:</p>
         
       </def>
    </gitem>
    <gitem>
      <label>rational</label>
      <def>
         <p>A rational number is given as two integers to be used as the numerator and
         denominator of a quotient. The numerator and denominator are
         separated by <el role="emptytag">sep</el>.</p>
<div id="cn_rational_ex" role="mathml-example">
<eg role="mathml"><![CDATA[<cn type="rational">22<sep/>7</cn>]]></eg>
<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow><mn>22</mn><mo>/</mo><mn>7</mn></mrow>]]></eg>
<graphic source="image/cn_rational_ex.gif" alt="{{22}/{7}}"/>
</div>
      </def>
    </gitem>
    <gitem>
      <label>complex-cartesian</label>
      <def>
        <p>A complex cartesian number is given as two numbers specifying the real and
        imaginary parts.  The real and imaginary parts are separated
        by the <el role="emptytag">sep</el> element, and each part has
        the format of a real number as described above.</p>
<div id="cn_cc_ex" role="mathml-example">
<eg role="mathml"><![CDATA[
<cn type="complex-cartesian"> 12.3 <sep/> 5 </cn>
]]></eg>
<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow>
 <mn>12.3</mn><mo>+</mo><mn>5</mn><mo>&#x2062;</mo><mi>i</mi>
</mrow>]]></eg>
<graphic source="image/cn_cc_ex.gif" alt="{{\mn{12.3}}+{5}\unicode{8290}i}"/>
</div>
      </def>
    </gitem>
    <gitem>
      <label>complex-polar</label>
      <def>
        <p>A complex polar number is given as two numbers specifying
        the magnitude and angle. The magnitude and angle are separated
        by the <el role="emptytag">sep</el> element, and each part has
        the format of a real number as described above.</p>
<div id="cn_cp_ex" role="mathml-example">
<eg role="mathml"><![CDATA[
<cn type="complex-polar"> 2 <sep/> 3.1415 </cn>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mn>2</mn>
 <mo>&#x2062;</mo>
 <msup>
  <mi>e</mi>
  <mrow><mi>i</mi><mo>&#x2062;</mo><mn>3.1415</mn></mrow>
 </msup>
</mrow>]]></eg>
<graphic source="image/cn_cp_ex.gif" alt="{ {2} \unicode{8290} {\msup{e}{{i\unicode{8290}{\mn{3.1415}}}}} }"/>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>Polar</mi>
 <mo>&#x2061;</mo>
 <mfenced><mn>2</mn><mn>3.1415</mn></mfenced>
</mrow>]]></eg>
<graphic source="image/cn_cp_ex-2.gif" alt="{ \mathop{\minormal{Polar}} {\left({2},{\mn{3.1415}}\right)} }"/>
</div>
      </def>
    </gitem>
    <gitem>
       <label>constant</label>
       <def>
          <p>If the value <att>type</att> is <attval>constant</attval>,
          then the content should be a Unicode representation of a
          well-known constant.  Some important constants and their
          common Unicode representations are listed below.</p>

          <p>This <el>cn</el> type is primarily for backward
          compatibility with MathML 1.0.  MathML 2.0 introduced many
          empty elements, such as <el role="emptytag">pi</el> to
          represent constants, and using these representations or 
	  a Strict csymbol representation is preferred.</p>

       </def>
    </gitem>
  </glist>


<p>In addition to the additional values of the type attribute, the
content of <el>cn</el> element can contain (in addition to the
<el>sep</el> element allowed in Strict Content MathML) <el>mglyph</el>
elements to refer to characters not currently available in Unicode, or
a general presentation construct (see <specref ref="presm_summary"/>),
which is used for rendering (see <specref ref="contm_rendering"/>).</p>


        <p><emph>Mapping to Strict Content MathML</emph></p>




       <p>If a <att>base</att> attribute is present, it specifies the base used for the digit
       encoding of both integers.  The use of <att>base</att> with
       <attval>rational</attval> numbers is deprecated.</p>

       <div id="contm-strict-cn-sep" role="strict-mathml-example">    
           <head>Rewrite: cn sep</head>
         <p>If there are <el>sep</el> children of the <el>cn</el>,
         then intervening text may be rewritten as <el>cn</el>
         elements.  If the <el>cn</el> element containing <el>sep</el>
         also has a <att>base</att> attribute, this is copied to each
         of the <el>cn</el> arguments of the resulting symbol, as
         shown below.</p>

<eg meta="@-b #-d #-n @-rational" role="mathml"><![CDATA[
<cn type="rational" base="b">n<sep/>d</cn>]]></eg>
<p> is rewritten to</p>
<eg meta="@-b #-d #-n @-nums1 #-rational" role="mathml"><![CDATA[
<apply><csymbol cd="nums1">rational</csymbol>
  <cn type="integer" base="b">n</cn>
  <cn type="integer" base="b">d</cn>
</apply>]]></eg>
<p>The symbol used in the result depends on the <att>type</att> attribute according to the following table:</p>
          <table id="contm_table-cntype" border="1">
            <thead>
              <tr>
                <td>type attribute</td>
                <td>OpenMath Symbol</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>e-notation</td><td><symbolref cd="bigfloat1" name="bigfloat"/></td>
              </tr>
              <tr>
                <td>rational</td><td><symbolref cd="nums1" name="rational"/></td>
              </tr>
              <tr>
                <td>complex-cartesian</td><td><symbolref cd="complex1" name="complex_cartesian"/></td>
              </tr>
              <tr>
                <td>complex-polar</td><td><symbolref cd="complex1" name="complex_polar"/></td>
              </tr>
            </tbody>
          </table>
          <p>Note: In the case of <symbolref cd="bigfloat1" name="bigfloat"/> the symbol
takes three arguments, <code>&lt;cn type="integer">10&lt;/cn></code> should be inserted as the second argument, denoting the base of the exponent used.</p>
<p>If the <att>type</att> attribute has a different value,
or if there is more than one <el role="emptytag">sep</el> element,
then the intervening expressions are converted as above,
but a system-dependent choice of symbol for the head of the application must be used.</p>

<p>If a base attribute has been used then the resulting expression is not Strict Content MathML, and each of the arguments needs to be recursively processed.</p>
         </div>



         <div id="contm_cn-base" role="strict-mathml-example">
           <head>Rewrite: cn based_integer</head>
           <p>A <el>cn</el> element with a base attribute other than 10 is rewritten as follows. (A base attribute with value 10 is simply removed) .</p> 
         <eg meta="#-FF60 @-integer @-16" role="mathml"><![CDATA[
<cn type="integer" base="16">FF60</cn>]]></eg>

         <eg  meta="#-FF60 #-based_integer #-16" role="strict-mathml"><![CDATA[
<apply><csymbol cd="nums1">based_integer</csymbol>
  <cn type="integer">16</cn>
  <cs>FF60</cs>
</apply>]]></eg>

<p>If the original element specified type <attval>integer</attval>
or if there is no type attribute, but the content of the
element just consists of the characters [a-zA-Z0-9] and white space
then the symbol used as the head in the resulting application should
be <symbolref cd="nums1" name="based_integer"/> as shown. Otherwise it
should be should be <symbolref cd="nums1" name="based_float"/>.</p>
 
         </div>

          <div id="contm_cn_strict_const" role="strict-mathml-example">
           <head>Rewrite: cn constant</head>
            <p>In Strict Content MathML, constants should be represented using
            <el>csymbol</el> elements.  A number of important constants are defined in the
            <cdref cd="nums1"/> content dictionary. An expression of the form 
<eg meta="#-c" role="mathml"><![CDATA[<cn type="constant">c</cn>]]></eg>
has the Strict Content MathML equivalent
<eg meta="#-c2" role="strict-mathml"><![CDATA[<csymbol cd="nums1">c2</csymbol>]]></eg>
          where <code meta="#-c2">c2</code>  corresponds to <code meta="#-c">c</code> as specified in the following table.</p>
          <table id="contm_table-pragnum" border="1">
            <thead>
              <tr>
                <td>Content</td>
                <td>Description</td>
                <td>OpenMath Symbol</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>U+03C0 (<code>&amp;pi;</code>)</td>
                <td>The usual <var>&#960;</var> of trigonometry: approximately 3.141592653...</td>
                <td><symbolref cd="nums1" name="pi"/></td>
              </tr>
              <tr>
                <td>U+2147 (<code>&amp;ExponentialE;</code> or <code>&amp;ee;</code>)</td>
                <td>The base for natural logarithms: approximately 2.718281828...</td>
                <td><symbolref cd="nums1" name="e"/></td>
              </tr>
              <tr>
                <td>U+2148 (<code>&amp;ImaginaryI;</code> or <code>&amp;ii;</code>)</td>
                <td>Square root of -1</td>
                <td><symbolref cd="nums1" name="i"/></td>
              </tr>
              <tr>
                <td>U+03B3 (<code>&amp;gamma;</code>)</td>
                <td>Euler's constant: approximately 0.5772156649...</td>
                <td><symbolref cd="nums1" name="gamma"/></td>
              </tr>
              <tr>
                <td>U+221E (<code>&amp;infin;</code> or <code>&amp;infty;</code>)</td>
                <td>Infinity. Proper interpretation varies with context</td>
                <td><symbolref cd="nums1" name="infinity"/></td>
              </tr>
            </tbody>
          </table>
        </div>

<div role="strict-mathml-example" id="contm_cn_pres">
           <head>Rewrite: cn presentation mathml</head>
<p>If the <el>cn</el> contains Presentation MathML markup, then it may
be rewritten to Strict MathML using variants of the rules above where
the arguments of the constructor are <el>ci</el> elements annotated
with the supplied Presentation MathML.</p> 
<p>A <el>cn</el> expression with non-text content of the form 
    <eg meta="mi @-rational" role="mathml"><![CDATA[
<cn type="rational"><mi>P</mi><sep/><mi>Q</mi></cn>]]></eg> 
is transformed to Strict Content MathML by rewriting it to 
    <eg meta="#-p @-nums1 #-q mi #-rational" role="strict-mathml"><![CDATA[
<apply><csymbol cd="nums1">rational</csymbol>
 <semantics>
  <ci>p</ci>
  <annotation-xml encoding="MathML-Presentation">
   <mi>P</mi>
  </annotation-xml>
 </semantics>
 <semantics>
  <ci>q</ci>
  <annotation-xml encoding="MathML-Presentation">
   <mi>Q</mi>
  </annotation-xml>
 </semantics>
</apply>]]></eg>
    Where the identifier names, p and q, (which have to be a text string) should be
    determined from the presentation MathML content, in a system defined way, perhaps as
    in the above example by taking the character data of the element ignoring any element
    markup.  Systems doing such rewriting should ensure that constructs using the same
    Presentation MathML content are rewritten to <el>semantics</el> elements using the
    same <el>ci</el>, and that conversely constructs that use different MathML should be
    rewritten to different identifier names (even if the Presentation MathML has  the same character data).
    </p>

<p>A related special case arises when a <el>cn</el> element
  contains character data not permitted in Strict Content MathML
  usage, e.g. non-digit, alphabetic characters.  Conceptually, this is
  analogous to a <el>cn</el> element containing a presentation
  markup <el>mtext</el> element, and could be rewritten accordingly.
  However, since the resulting annotation would contain no additional
  rendering information, such instances should be rewritten directly
  as <el>ci</el> elements, rather than as a <el>semantics</el>
  construct.</p>

</div>

</div4>


</div3>

    <div3 id="contm_ci">
        <head>Content Identifiers <el role="defn starttag">ci</el></head>

<table role="syntax">
  <thead>
    <tr>
      <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
    </tr>
  </thead>
  <tbody>
    <tr><th>Class</th>
    <td><intref ref="contm_ci">Ci</intref></td>
    <td><intref ref="contm_ci">Ci</intref></td>
    </tr> 
   <tr>
      <th>Attributes</th>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">type</kw>?</td>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>, <kw role="parsing_ref">type</kw>?</td>
    </tr>
     <tr>
       <th><att>type</att> Attribute Values</th>
       <td>
         <attval>integer</attval>|
         <attval>rational</attval>| 
         <attval>real</attval>|
         <attval>complex</attval>| 
         <attval>complex-polar</attval>|
         <attval>complex-cartesian</attval>|
         <attval>constant</attval>|
         <attval>function</attval>| 
         <attval>vector</attval>|
         <attval>list</attval>|
         <attval>set</attval>|
         <attval>matrix</attval> 
       </td>
       <td> string</td>
     </tr>
    <tr>
      <th>Qualifiers</th>
      <td/>
      <td>
        <kw role="parsing_ref">BvarQ</kw>, 
        <kw role="parsing_ref">DomainQ</kw>, 
        <kw role="parsing_ref">degree</kw>, 
        <kw role="parsing_ref">momentabout</kw>, 
        <kw role="parsing_ref">logbase</kw>
      </td>
    </tr>
    <tr>
    <th>Content</th>
    <td>text</td>
    <td>text | <kw role="parsing_ref">mglyph</kw> | <kw role="parsing_ref">PresentationExpression</kw></td>
    </tr>
  </tbody>
</table>

<p>Content MathML uses the <el>ci</el> element (mnemonic for <quote>content
identifier</quote>) to construct a variable. Content identifiers
represent <quote>mathematical variables</quote> which have 
properties, but no fixed value. For example, <var>x</var> and <var>y</var> are variables 
in the expression <quote><var>x</var>+<var>y</var></quote>, and the variable
<var>x</var> would be represented as 

<eg role="strict-mathml"><![CDATA[<ci>x</ci>]]></eg>

In MathML, variables are distinguished from symbols, which have fixed, external
definitions, and are represented by the <intref ref="contm_csymbol">csymbol</intref> element.</p>

<p>After white space normalization the content of a <el>ci</el> element is interpreted as a
name that identifies it. Two variables are considered equal, if and only if their names
are identical and in the same scope (see <specref ref="contm_binding"/> for a
discussion).</p>



<div4 id="contm_ci_strict"><head>Strict uses of <el role="starttag">ci</el></head>


<p>The <el>ci</el> element uses the <att>type</att> attribute to specify the basic type of 
object that it represents. In Strict Content  MathML, the set of permissible values is
<attval>integer</attval>, <attval>rational</attval>, <attval>real</attval>,
<attval>complex</attval>, <attval>complex-polar</attval>,
<attval>complex-cartesian</attval>, <attval>constant</attval>, <attval>function</attval>,
<el>vector</el>, <el>list</el>, <el>set</el>, and <el>matrix</el>. These values correspond
to the symbols 
<symbolref cd="mathmltypes" name="integer_type"/>, 
<symbolref cd="mathmltypes" name="rational_type"/>, 
<symbolref cd="mathmltypes" name="real_type"/>,
<symbolref cd="mathmltypes" name="complex_polar_type"/>,
<symbolref cd="mathmltypes" name="complex_cartesian_type"/>, 
<symbolref cd="mathmltypes" name="constant_type"/>, 
<symbolref cd="mathmltypes" name="fn_type"/>,
<symbolref cd="mathmltypes" name="vector_type"/>,
<symbolref cd="mathmltypes" name="list_type"/>, 
<symbolref cd="mathmltypes" name="set_type"/>, and 
<symbolref cd="mathmltypes" name="matrix_type"/> in the 
<cdref cd="mathmltypes"/> Content Dictionary: In this sense the following two expressions are considered equivalent: 
</p>

<div role="strict-mathml-example" id="contm_ci_mathmltypes">
<eg role="mathml"><![CDATA[<ci type="integer">n</ci>]]></eg>
<eg role="strict-mathml"><![CDATA[
<semantics>
  <ci>n</ci>
  <annotation-xml cd="mathmltypes" name="type" encoding="MathML-Content">
    <csymbol cd="mathmltypes">integer_type</csymbol>
  </annotation-xml>
</semantics>]]></eg>
<p>Note that <attval>complex</attval> should be considered
an alias for <attval>complex-cartesian</attval> and rewritten to the
same <symbolref cd="mathmltypes" name="complex_cartesian_type"/>
symbol. It is perhaps a more natural type name for use with
<el>ci</el> as the distinction <phrase>between</phrase> cartesian and polar form really
<phrase>only</phrase> affects the interpretation of <phrase>literals</phrase> encoded with <el>cn</el>.</p>
</div>
</div4>

<div4 id="contm_ci_extended"><head>Non-Strict uses of <el role="starttag">ci</el></head>

<p>The <el>ci</el> element allows any string value for the <att>type</att>
attribute, in particular any of the names of the MathML container elements or their type
values.</p>

<p>For a more advanced treatment of types, the <att>type</att> attribute is
inappropriate.  Advanced types require significant structure of their own (for example,
<var>vector(complex)</var>) and are probably best constructed as mathematical objects and
then associated with a MathML expression through use of the <el>semantics</el>
element. See <bibref ref="MathMLTypes"/> for more examples.</p>


<p><emph>Mapping to Strict Content MathML</emph></p>

<div role="strict-mathml-example" id="contm_ci_strict_ex">
           <head>Rewrite: ci type annotation</head>
<p>In Strict Content, type attributes are represented via 
semantic attribution. An expression of the form 
<eg meta="@-T #-n" role="mathml"><![CDATA[<ci type="T">n</ci>]]></eg>
is rewritten to 
<eg meta="#-T #-n" role="strict-mathml"><![CDATA[
<semantics>
  <ci>n</ci>
  <annotation-xml cd="mathmltypes" name="type" encoding="MathML-Content">
    <ci>T</ci>
  </annotation-xml>
</semantics>]]></eg></p>
</div>

<p>The <el>ci</el> element can contain
<el>mglyph</el> elements to refer to characters not currently available in Unicode, or a
general presentation construct (see <specref ref="presm_summary"/>), which is used for
rendering (see <specref ref="contm_rendering"/>).</p>


<div role="strict-mathml-example" id="contm_ci_pres">
           <head>Rewrite: ci presentation mathml</head>
<p>A <el>ci</el> expression with non-text content of the form 
    <eg meta="mi" role="mathml"><![CDATA[<ci><mi>P</mi></ci>]]></eg> 
is transformed to Strict Content MathML by rewriting it to 
    <eg meta="#-p mi" role="strict-mathml"><![CDATA[
<semantics>
  <ci>p</ci>
  <annotation-xml encoding="MathML-Presentation">
    <mi>P</mi>
  </annotation-xml>
</semantics>]]></eg>
    Where the identifier name, p, (which has to be a text string) should be
    determined from the presentation MathML content, in a system defined way, perhaps as
    in the above example by taking the character data of the element ignoring any element
    markup.  Systems doing such rewriting should ensure that constructs using the same
    Presentation MathML content are rewritten to <el>semantics</el> elements using the
    same <el>ci</el>, and that conversely constructs that use different MathML should be
    rewritten to different identifier names (even if the Presentation MathML has  the same character data).
    </p>
</div>

<div role="strict-mathml-example" id="contm_ci_c2">
<p> The following example encodes an atomic 
symbol that displays visually as <var>C</var><sup>2</sup> and that, 
    for purposes of content, is treated as a single symbol</p>
    <eg role="mathml"><![CDATA[
<ci>
  <msup><mi>C</mi><mn>2</mn></msup>
</ci>]]></eg>

<p>The Strict Content MathML equivalent is</p> 
    <eg role="strict-mathml"><![CDATA[
<semantics>
  <ci>C2</ci>
  <annotation-xml encoding="MathML-Presentation">
    <msup><mi>C</mi><mn>2</mn></msup>
  </annotation-xml>
</semantics>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
 <msup><mi>C</mi><mn>2</mn></msup>]]></eg>


<graphic source="image/contm_ci_c2.gif" alt="{\msup{C}{{2}}}"/>
</div>

  </div4>

  <div4 id="contm_rendering_ci">
    <head>Rendering Content Identifiers</head>
        <p>If the content of a <el>ci</el> element consists of Presentation MathML, that
        presentation is used. If no such tagging is supplied then the text
        content is rendered as if it were the content of an <el>mi</el> element. If an
        application supports bidirectional text rendering, then the rendering follows the
        Unicode bidirectional rendering.</p>
        
        <p>The <att>type</att> attribute can be interpreted to
        provide rendering information. For example in
<eg role="mathml"><![CDATA[<ci type="vector">V</ci>]]></eg>
a renderer could display a bold V for the vector.</p>
      </div4>
    </div3>

      <div3 id="contm_csymbol">
        <head>Content Symbols <el role="defn starttag">csymbol</el></head>
<table role="syntax">
  <thead>
    <tr>
      <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Class</th>
      <td><intref ref="contm_csymbol">Csymbol</intref></td>
      <td><intref ref="contm_csymbol">Csymbol</intref></td>
    </tr>
    <tr>
      <th>Attributes</th>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">cd</kw></td>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>, <kw role="parsing_ref">type</kw>?, <kw role="parsing_ref">cd</kw>?</td>
    </tr>
    <tr>
      <th>Content</th>
      <td><kw role="parsing_ref">SymbolName</kw></td>
      <td>text | <kw role="parsing_ref">mglyph</kw> | <kw role="parsing_ref">PresentationExpression</kw></td>
    </tr>
    <tr>
    <th>Qualifiers</th>
    <td/>
    <td><kw role="parsing_ref">BvarQ</kw>, <kw role="parsing_ref">DomainQ</kw>, <kw role="parsing_ref">degree</kw>, <kw role="parsing_ref">momentabout</kw>, <kw role="parsing_ref">logbase</kw></td>
    </tr>
  </tbody>
</table>

<p>A <el>csymbol</el> is used to refer to a specific,
mathematically-defined concept with an external definition. In the
expression <quote><var>x</var>+<var>y</var></quote>, the plus sign is
a symbol since it has a specific, external definition, namely the addition function.
MathML 3 calls such an identifier  a
<emph>symbol</emph>. Elementary functions and common mathematical
operators are all examples of symbols. Note that the term
<quote>symbol</quote> is used here in an abstract sense and has no
connection with any particular presentation of the construct on screen
or paper.</p>

<div4 id="contm_csymbol_strict"><head>Strict uses of  <el role="starttag">csymbol</el></head>

<p>The <el>csymbol</el> identifies the specific mathematical concept
it represents by referencing its definition via attributes.
Conceptually, a reference to an external definition is merely a URI,
i.e. a label uniquely identifying the definition.  However, to be
useful for communication between user agents, external definitions
must be shared.</p>  

<p>For this reason, several longstanding efforts have
been organized to develop systematic, public repositories of
mathematical definitions.  Most notable of these, the OpenMath Society
repository of Content Dictionaries (CDs) is extensive, open and
active. In MathML 3, OpenMath CDs are the preferred source of external
definitions. In particular, the definitions of pre-defined MathML 3
operators and functions are given in terms of OpenMath CDs.</p>

<p>MathML 3 provides two mechanisms for referencing external definitions or content
dictionaries.  The first, using the <att>cd</att> attribute, follows conventions
established by OpenMath specifically for referencing CDs. This is the
form required in Strict Content MathML.  The second, using the
<att>definitionURL</att> attribute, is backward compatible with MathML 2, and can be used
to reference CDs or any other source of definitions that can be
identified by a URI.  It is described in the following section</p>

<p>When referencing OpenMath CDs, the preferred method is to use the <att>cd</att>
attribute as follows. Abstractly, OpenMath symbol definitions are identified by a triple
of values: a <emph>symbol name</emph>, a <emph>CD name</emph>, and a <emph>CD base</emph>,
which is a URI that disambiguates CDs of the same name.  To associate such a triple with a
<el>csymbol</el>, the content of the <el>csymbol</el> specifies the symbol name, and the
name of the Content Dictionary is given using the <att>cd</att> attribute. The CD base is
determined either from the document embedding the <el>math</el> element which contains the
<el>csymbol</el> by a mechanism given by the embedding document format, or by system
defaults, or by the <att>cdgroup</att> attribute , which is optionally specified on the
enclosing <el>math</el> element; see <specref ref="interf_toplevel_atts"/>. In the absence
of specific information <code>http://www.openmath.org/cd</code> is assumed as the CD base
for all <el>csymbol</el> elements <el>annotation</el>, and <el>annotation-xml</el>.  This
is the CD base for the collection of standard CDs maintained by the OpenMath Society.</p>

<p>The <att>cdgroup</att> specifies a URL to an OpenMath CD Group file.  For a detailed
description of the format of a CD Group file, see Section 4.4.2 (CDGroups) 
 in <bibref ref="OpenMath2004"/>.  Conceptually, a CD group file is a list of
pairs consisting of a CD name, and a corresponding CD base. When a <el>csymbol</el>
references a CD name using the <att>cd</att> attribute, the name is looked up in the CD
Group file, and the associated CD base value is used for that <el>csymbol</el>. When a CD
Group file is specified, but a referenced CD name does not appear in the group file, or
there is an error in retrieving the group file, the referencing <el>csymbol</el> is not
defined.  However, the handling of the resulting error is not defined, and is the
responsibility of the user agent.</p>

<p>While references to external definitions are URIs, it is strongly recommended that CD
files be retrievable at the location obtained by interpreting the URI as a URL.  In
particular, other properties of the symbol being defined may be available by inspecting
the Content Dictionary specified. These include not only the symbol definition, but also
examples and other formal properties.  Note, however, that there are multiple encodings
for OpenMath Content Dictionaries, and it is up to the user agent to correctly determine
the encoding when retrieving a CD.</p>
</div4>

<div4 id="contm_csymbol_extended"><head>Non-Strict uses of <el role="starttag">csymbol</el></head>

<p>In addition to the forms described above, the <el>csymbol</el> and element can contain
<el>mglyph</el> elements to refer to characters not currently available in Unicode, or a
general presentation construct (see <specref ref="presm_summary"/>), which is used for
rendering (see <specref ref="contm_rendering"/>). In this case, when
writing to Strict Content MathML, the csymbol should be treated as a
<el>ci</el> element, and rewritten using <specref ref="contm_ci_pres"/>.</p>

<p>External definitions (in OpenMath CDs or elsewhere) may also be specified directly for
a <el>csymbol</el> using the <att>definitionURL</att> attribute.  When used to reference
OpenMath symbol definitions, the abstract triple of (symbol name, CD name, CD base) is
mapped to a fully-qualified URI as follows:

<eg><code>URI = </code><var>cdbase</var><code> + '/' + </code><var>cd-name</var><code> + '#' + </code><var>symbol-name</var></eg>

For example,

<eg><![CDATA[(plus, arith1, http://www.openmath.org/cd)]]></eg>

is mapped to

<eg><code>http://www.openmath.org/cd/arith1#plus</code></eg>

The resulting URI is specified as the value of the <att>definitionURL</att> attribute.</p>

<p>This form of reference is useful for backwards compatibility with MathML2 and to
facilitate the use of Content MathML within URI-based frameworks (such as RDF <bibref ref="rdf"/> in the Semantic Web or OMDoc <bibref ref="OMDoc1.2"/>).  Another benefit is
that the symbol name in the CD does not need to correspond to the content of the
<el>csymbol</el> element.  However, in general, this method results in much longer MathML
instances.  Also, in situations where CDs are under development, the use of a CD Group
file allows the locations of CDs to change without a change to the markup.  A third
drawback to <att>definitionURL</att> is that unlike the <att>cd</att> attribute, it is not
limited to referencing symbol definitions in OpenMath content dictionaries.  Hence, it is
not in general possible for a user agent to automatically determine the proper
interpretation for <att>definitionURL</att> values without further information about the
context and community of practice in which the MathML instance occurs.</p>

<p>Both the <att>cd</att> and <att>definitionURL</att> mechanisms of external reference
may be used within a single MathML instance.  However, when both a <att>cd</att> and a
<att>definitionURL</att> attribute are specified on a single <el>csymbol</el>, the
<att>cd</att> attribute takes precedence.</p>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>In non-Strict usage <el>csymbol</el> allows the use of
  a <att>type</att> attribute.</p>  

<div  role="strict-mathml-example" id="contm_csymbol_strict_ex">
           <head>Rewrite: csymbol type annotation</head>
<p>In Strict Content, type attributes are represented via 
semantic attribution. An expression of the form 
<eg meta="@-T #-n" role="mathml"><![CDATA[<csymbol type="T">symbolname</csymbol>]]></eg>
is rewritten to 
<eg meta="#-T #-n" role="strict-mathml"><![CDATA[
<semantics>
  <csymbol>symbolname</csymbol>
  <annotation-xml cd="mathmltypes" name="type" encoding="MathML-Content">
    <ci>T</ci>
  </annotation-xml>
</semantics>]]></eg></p>
</div>

      </div4>

      <div4 id="contm_rendering_csymbol">
        <head>Rendering Symbols</head>
        <p>If the content of a <el>csymbol</el> element is tagged using presentation tags,
        that presentation is used. If no such tagging is supplied then the text
        content is rendered as if it were the content of an <el>mi</el> element. In
        particular if an application supports bidirectional text rendering, then the
        rendering follows the Unicode bidirectional rendering.</p>
      </div4>
    </div3>

    <div3 id="contm_cs">
        <head>String Literals <el role="defn starttag">cs</el></head>

<table role="syntax">
  <thead>
    <tr>
      <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
    </tr>
  </thead>
  <tbody>
    <tr><th>Class</th>
    <td><intref ref="contm_cs">Cs</intref></td>
    <td><intref ref="contm_cs">Cs</intref></td>
    </tr> 
   <tr>
      <th>Attributes</th>
      <td><kw role="parsing_ref">CommonAtt</kw></td>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
    </tr>
    <tr>
    <th>Content</th>
    <td>text</td>
    <td>text</td>
    </tr>
  </tbody>
</table>

<p>The <el>cs</el> element encodes <quote>string literals</quote>
which may be used in Content MathML expressions.</p>

<p>The content of cs is text; no
Presentation MathML constructs are allowed even when used in
non-strict markup. Specifically, <el>cs</el> may not contain
<el>mglyph</el> elements, and the content does not undergo white space
normalization.</p>  

<div id="contm_cs_ex" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<set>
  <cs>A</cs><cs>B</cs><cs>  </cs>
</set>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo>
 <ms>A</ms>
 <mo>,</mo>
 <ms>B</ms>
 <mo>,</mo>
 <ms>&#xa0;&#xa0;</ms>
 <mo>}</mo>
</mrow>]]></eg>

<graphic source="image/cs-ex.gif" alt="{\left.\middle\{\mbox{\textquotedbl A\textquotedbl},\mbox{\textquotedbl B\textquotedbl },\mbox{\textquotedbl\ \ \textquotedbl }\middle\}\right.}"/>
</div>
    </div3>

    <div3 id="contm_apply">
      <head>Function Application <el role="defn starttag">apply</el></head>

 <table role="syntax">
   <thead>
     <tr>
       <th/>
       <th>Schema Fragment (Strict)</th>
       <th>Schema Fragment (Full)</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <th>Class</th>
       <td><intref ref="contm_apply">Apply</intref></td>
       <td><intref ref="contm_apply">Apply</intref></td>
     </tr>
     <tr>
       <th>Attributes</th>
       <td><kw role="parsing_ref">CommonAtt</kw></td>
       <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
     </tr>
     <tr>
       <th>Content</th>
       <td><kw role="parsing_ref">ContExp</kw>+</td>
       <td><kw role="parsing_ref">ContExp</kw>+
                       | 
                       (<kw role="parsing_ref">ContExp</kw>, 
                       <kw role="parsing_ref">BvarQ</kw>, 
                       <kw role="parsing_ref">Qualifier</kw>?, 
                       <kw role="parsing_ref">ContExp</kw>*)</td>
     </tr>
   </tbody>
 </table>

      <p>The most fundamental way of building a compound object in
      mathematics is by applying a function or an operator to some
      arguments.</p>

      <div4 id="contm_applications_strict">
        <head>Strict Content MathML</head>
        <p>In MathML, the <el>apply</el> element is used to build an expression tree that
        represents the application a function or operator to its arguments. The
        resulting tree corresponds to a complete mathematical expression. Roughly
        speaking, this means a piece of mathematics that could be surrounded by
        parentheses or <quote>logical brackets</quote> without changing its meaning.</p>

        <p>For example, (<var>x</var> + <var>y</var>) might be encoded as
        
        <eg role="mathml"><![CDATA[<apply><csymbol cd="arith1">plus</csymbol><ci>x</ci><ci>y</ci></apply>]]></eg>

        The opening and closing tags of <el>apply</el> specify exactly the scope of any
        operator or function. The most typical way of using <el>apply</el> is simple and
        recursive. Symbolically, the content model can be described as:

        <eg role="mathml-extension"><![CDATA[<apply>]]> <emph>op</emph> [ <emph>a</emph> <emph>b</emph> ...] <![CDATA[</apply>]]></eg>

        where the <emph>operands</emph> <emph>a</emph>, <emph>b</emph>, ... are MathML
        expression trees themselves, and <emph>op</emph> is a MathML expression tree that
        represents an operator or function. Note that <el>apply</el> constructs can be
        nested to arbitrary depth.</p>

        <p>An <el>apply</el> may in principle have any number of operands. For example,
        (<var>x</var> + <var>y</var> + <var>z</var>) can be encoded as

      <eg role="mathml"><![CDATA[
<apply><csymbol cd="arith1">plus</csymbol>
  <ci>x</ci>
  <ci>y</ci>
  <ci>z</ci>
</apply>]]></eg>
Note that MathML also allows applications without operands, e.g. to represent functions like <code>random()</code>, or  <code>current-date()</code>.</p>

<p>Mathematical expressions involving a mixture of operations result in nested
      occurrences of <el>apply</el>. For example, <var>a</var> <var>x</var> + <var>b</var>
      would be encoded as

      <eg role="mathml"><![CDATA[
<apply><csymbol cd="arith1">plus</csymbol>
  <apply><csymbol cd="arith1">times</csymbol>
    <ci>a</ci>
    <ci>x</ci>
  </apply>
  <ci>b</ci>
</apply>]]></eg>
      </p>

      <p>There is no need to introduce parentheses or to resort to
      operator precedence in order to parse expressions correctly. The
      <el>apply</el> tags provide the proper grouping for the re-use
      of the expressions within other constructs. Any expression
      enclosed by an <el>apply</el> element is well-defined, coherent
      object whose interpretation does not depend on the surrounding
      context.  This is in sharp contrast to presentation markup,
      where the same expression may have very different meanings in
      different contexts.  For example, an expression with a visual
      rendering such as (<var>F</var>+<var>G</var>)(<var>x</var>)
      might be a product, as in

      <eg role="mathml"><![CDATA[
<apply><csymbol cd="arith1">times</csymbol>
  <apply><csymbol cd="arith1">plus</csymbol>
    <ci>F</ci>
    <ci>G</ci>
  </apply>
  <ci>x</ci>
</apply>]]></eg>

      or it might indicate the application of the function <var>F</var> + <var>G</var> to
      the argument <var>x</var>. This is indicated by constructing the sum

      <eg role="mathml"><![CDATA[<apply><csymbol cd="arith1">plus</csymbol><ci>F</ci><ci>G</ci></apply>]]></eg>

      and applying it to the argument <var>x</var> as in

      <eg role="mathml"><![CDATA[
<apply>
  <apply><csymbol cd="arith1">plus</csymbol>
    <ci>F</ci>
    <ci>G</ci>
  </apply>
  <ci>x</ci>
</apply>]]></eg>

      In both cases, the interpretation of the outer <el>apply</el> is
      explicit and unambiguous, and does not change regardless of
      where the expression is used.</p>

      <p>The preceding example also illustrates that in an
      <el>apply</el> construct, both the function and the arguments
      may be simple identifiers or more complicated expressions.</p>

      <p>The <el>apply</el> element is conceptually necessary in order to distinguish
      between a function or operator, and an instance of its use. The expression
      constructed by applying a function to 0 or more arguments is always an element from
      the codomain of the function. Proper usage depends on the operator that is being
      applied. For example, the <el>plus</el> operator may have zero or more arguments,
      while the <el>minus</el> operator requires one or two arguments in order to be properly
      formed.</p>
      </div4>

<!--
    <div4 id="contm_domainofapplication">
      <head>Applications with Domain of Application</head>

      <p>The <el>domainofapplication</el> element may be used in an <el>apply</el> element
      without <el>bvar</el> children to mark up the domain over which a given function is
      being applied. In contrast to its 
     <intref ref="contm_domainofapplication_qualifier">use
     as a qualifier</intref> in the <el>bind</el> element,
     the usage in the <el>apply</el> element only marks the argument position.</p>

      <div id="contm_strict-domainofapplication-nobvar" role="strict-mathml-example">
        <p> For instance, the integral of a function <var>f</var> over an arbitrary domain
        <var>C</var> can be represented as

<eg role="mathml"><![CDATA[
<apply><int/>
  <domainofapplication><ci>C</ci></domainofapplication>
  <ci>f</ci>
</apply>]]></eg>

This expression is considered equivalent to the Strict Content MathML:

<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="calculus1">defint</csymbol><ci>C</ci><ci>f</ci></apply>]]></eg>
</p>
</div>
</div4>

-->

<div4 id="contm_rendering_applications">
  <head>Rendering Applications</head>
    <p>Strict Content MathML applications are rendered as mathematical
    function applications.  If 
<code meta="mi"><![CDATA[<mi>F</mi>]]></code> denotes the rendering of 
<code meta="ci"><![CDATA[<ci>f</ci>]]></code> and 
<code meta="mi"><![CDATA[<mi>Ai</mi>]]></code>
 the rendering of
<code meta="ci"><![CDATA[<ci>ai</ci>]]></code>, the the sample
    rendering of a simple application is as follows:
</p>
<div id="contm_render_apply" role="mathml-example">
 <p>Content MathML</p>
<eg meta="ci" role="mathml"><![CDATA[
<apply><ci>f</ci>
  <ci>a1</ci>
  <ci>a2</ci>
  <ci>...</ci>
  <ci>an</ci>
</apply>]]></eg>
  <p>Sample Presentation</p>
    <eg meta="mi" role="mathml"><![CDATA[
<mrow>
 <mi>F</mi>
 <mo>&#x2061;</mo>
 <mrow>
  <mo fence="true">(</mo>
  <mi>A1</mi>
  <mo separator="true">,</mo>
  <mi>...</mi>
  <mo separator="true">,</mo>
  <mi>A2</mi>
  <mo separator="true">,</mo>
  <mi>An</mi>
  <mo fence="true">)</mo>
 </mrow>
</mrow>]]></eg>
</div>

<p>Non-Strict MathML applications may also be used with qualifiers. In the absence of
any more specific rendering rules for well-known operators, rendering
should follow the sample presentation below, motivated by the typical
presentation for <el>sum</el>. Let  
<code meta="mi"><![CDATA[<mi>Op</mi>]]></code> denote the rendering of 
<code meta="ci"><![CDATA[<ci>op</ci>]]></code>, 
<code meta="mi"><![CDATA[<mi>X</mi>]]></code>
 the rendering of
<code meta="ci"><![CDATA[<ci>x</ci>]]></code>, and so on.  Then:
</p>

<div id="contm_render_apply_limit" role="mathml-example">
<p>Content MathML</p>
<eg meta="ci" role="mathml"><![CDATA[
<apply><ci>op</ci>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>d</ci></domainofapplication>
  <ci>expression-in-x</ci>
</apply>]]></eg>
  <p>Sample Presentation</p>
    <eg meta="mi" role="mathml"><![CDATA[
<mrow>
 <munder>
  <mi>Op</mi>
  <mrow><mi>X</mi><mo>&#x2208;</mo><!--ELEMENT OF--><mi>D</mi></mrow>
 </munder>
 <mo>&#x2061;</mo><!--FUNCTION APPLICATION-->
 <mrow>
  <mo fence="true">(</mo>
  <mi>Expression-in-X</mi>
  <mo fence="true">)</mo>
 </mrow>
</mrow>]]></eg>
</div>

</div4>

   </div3>

   <div3 id="contm_binding">
     <head>Bindings and Bound Variables <el role="defn starttag">bind</el>
      and <el role="defn starttag">bvar</el></head>

     <p>Many complex mathematical expressions are constructed with the use of bound
     variables, and bound variables are an important concept of logic and formal
     languages. Variables become <emph>bound</emph> in the scope of an expression through
     the use of a quantifier.  Informally, they can be thought of as the "dummy variables"
     in expressions such as integrals, sums, products, and the logical quantifiers "for
     all" and "there exists".  A bound variable is characterized by the property that
     systematically renaming the variable (to a name not already appearing in the
     expression) does not change the meaning of the expression.  </p>

     <div4 id="contm_bind">
       <head>Bindings</head>

 <table role="syntax">
   <thead>
     <tr>
       <th/>
       <th>Schema Fragment (Strict)</th>
       <th>Schema Fragment (Full)</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <th>Class</th>
       <td><intref ref="contm_bind">Bind</intref></td>
       <td><intref ref="contm_bind">Bind</intref></td>
     </tr>
     <tr>
       <th>Attributes</th>
       <td><kw role="parsing_ref">CommonAtt</kw></td>
       <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
     </tr>
     <tr>
       <th>Content</th>
       <td>
         <kw role="parsing_ref">ContExp</kw>,
         <kw role="parsing_ref">BvarQ</kw>*,
         <kw role="parsing_ref">ContExp</kw>
       </td>
       <td>
          <kw role="parsing_ref">ContExp</kw>, 
          <kw role="parsing_ref">BvarQ</kw>*, 
          <kw role="parsing_ref">Qualifier</kw>*, 
          <kw role="parsing_ref">ContExp</kw>+
       </td>
     </tr>
   </tbody>
 </table>

 <p>Binding expressions are represented as MathML expression trees using the <el>bind</el>
 element. Its first child is a MathML expression that represents a binding operator, for
 example integral operator. This is followed by a non-empty list of <el>bvar</el>
 elements denoting the bound variables, and then the final child which is a general
 Content MathML expression, known as the <emph>body</emph> of the binding.</p>
     </div4>

     <div4 id="contm_bvar">
       <head>Bound Variables</head>

<table role="syntax">
  <thead>
    <tr>
      <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Class</th>
      <td><intref ref="contm_bvar">BVar</intref></td>
      <td><intref ref="contm_bvar">BVar</intref></td>
    </tr>
    <tr>
      <th>Attributes</th>
      <td><kw role="parsing_ref">CommonAtt</kw></td>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
    </tr>
    <tr>
      <th>Content</th>
      <td><kw role="parsing_ref">ci</kw> | <kw role="parsing_ref">semantics-ci</kw></td>
      <td>
        (<kw role="parsing_ref">ci</kw> | <kw role="parsing_ref">semantics-ci</kw>), <kw role="parsing_ref">degree</kw>? | 
        <kw role="parsing_ref">degree</kw>?, (<kw role="parsing_ref">ci</kw> | <kw role="parsing_ref">semantics-ci</kw>
      </td>
    </tr>
  </tbody>
</table>

       <p>The <el>bvar</el> element is used to denote the bound variable of a binding
       expression, e.g. in sums, products, and quantifiers or user defined functions.</p>

       <p>The content of a <el>bvar</el> element is an <emph>annotated variable</emph>,
       i.e. either a content identifier represented by a <el>ci</el> element or a
       <el>semantics</el> element whose first child is an annotated variable. The
       <emph>name</emph> of an annotated variable of the second kind is the name of its first
       child. The <emph>name</emph> of a bound variable is that of the annotated variable
       in the <el>bvar</el> element.</p>

       <p>Bound variables are identified by comparing their names. Such
       identification can be made explicit by placing an <att>id</att> on the <el>ci</el>
       element in the <el>bvar</el> element and referring to it using the <att>xref</att>
       attribute on all other instances.  An example of this approach is

<eg role="mathml"><![CDATA[
<bind><csymbol cd="quant1">forall</csymbol>
  <bvar><ci id="var-x">x</ci></bvar>
  <apply><csymbol cd="relation1">lt</csymbol>
    <ci xref="var-x">x</ci>
    <cn>1</cn>
  </apply>
</bind>]]></eg>

       This <att>id</att> based approach is especially helpful when constructions
       involving bound variables are nested.</p>

       <p>It is sometimes necessary to associate additional
       information with a bound variable.  The information might be
       something like a detailed mathematical type, an alternative
       presentation or encoding or a domain of application.  Such
       associations are accomplished in the standard way by replacing
       a <el>ci</el> element (even inside the <el>bvar</el> element)
       by a <el>semantics</el> element containing both the <el>ci</el>
       and the additional information.  Recognition of an instance of
       the bound variable is still based on the actual <el>ci</el>
       elements and not the <el>semantics</el> elements or anything
       else they may contain.  The <att>id</att> based-approach
       outlined above may still be used.</p>

<p>The following example encodes forall <var>x</var>. <var>x</var>+<var>y</var>=<var>y</var>+<var>x</var>.</p>
<eg role="mathml"><![CDATA[
<bind><csymbol cd="quant1">forall</csymbol>
  <bvar><ci>x</ci></bvar>
  <apply><csymbol cd="relation1">eq</csymbol>
    <apply><csymbol cd="arith1">plus</csymbol><ci>x</ci><ci>y</ci></apply>
    <apply><csymbol cd="arith1">plus</csymbol><ci>y</ci><ci>x</ci></apply>
  </apply>
</bind>]]></eg>

<p>In non-Strict Content markup, the <el>bvar</el> element is used in
a number of idiomatic constructs.  These are described in <specref
ref="contm_qualifiers"/> and <specref ref="contm_opel"/>.</p>
    </div4>

     <div4 id="contm_alpharenmaing">
       <head>Renaming Bound Variables</head>

       <p>It is a defining property of bound variables that they can be renamed
       consistently in the scope of their parent <el>bind</el> element.
This operation, sometimes known as <emph>&#945;-conversion</emph>,
preserves the semantics of the expression.</p>
<p>A bound variable <var>x</var> may be renamed to say
<var>y</var> so long as <var>y</var> does not occur free in the body of the binding, or in any annotations of
the bound variable, <var>x</var> to be renamed, or later bound variables.</p>
<p>If a bound variable <var>x</var> is renamed, all free occurrences of
<var>x</var> in annotations in its <el>bvar</el> element,
any following <el>bvar</el> children of the <el>bind</el>
and in the expression in the body of the <el>bind</el> should be renamed.</p>

<p> In the example in the previous section, note how renaming
<var>x</var> to <var>z</var> produces the equivalent expression forall
<var>z</var>. <var>z</var>+<var>y</var>=<var>y</var>+<var>z</var>,
whereas <var>x</var> may not be renamed to <var>y</var>, as
<var>y</var> is free in the body of the binding and would be
<emph>captured</emph>, producing the expression forall
<var>y</var>. <var>y</var>+<var>y</var>=<var>y</var>+<var>y</var>
which is not equivalent to the original expression.</p>

     </div4>
     <div4 id="contm_rendering_binders">
       <head>Rendering Binding Constructions</head>
       <p>If 
<code meta="ci"><![CDATA[<ci>b</ci>]]></code> and
<code meta="ci"><![CDATA[<ci>s</ci>]]></code> are Content MathML expressions
 that render as the Presentation MathML expressions
<code meta="mi"><![CDATA[<mi>B</mi>]]></code> and
<code meta="mi"><![CDATA[<mi>S</mi>]]></code>
then the sample rendering of a binding element is as follows:</p>
<div id="contm_bvar_render" role="mathml-example">
<p>Content MathML</p>
<eg meta="ci" role="mathml"><![CDATA[
<bind><ci>b</ci>
  <bvar><ci>x1</ci></bvar>
  <bvar><ci>...</ci></bvar>
  <bvar><ci>xn</ci></bvar>
  <ci>s</ci>
</bind>]]></eg>
  
   <p>Sample Presentation</p>
    <eg meta="mi" role="mathml"><![CDATA[
<mrow>
 <mi>B</mi>
 <mrow>
  <mi>x1</mi>
  <mo separator="true">,</mo>
  <mi>...</mi>
  <mo separator="true">,</mo>
  <mi>xn</mi>
 </mrow>
 <mo separator="true">.</mo>
 <mi>S</mi>
</mrow>]]></eg>
</div>
</div4>
   </div3>

<div3 id="contm_sharing">
  <head>Structure Sharing <el role="defn starttag">share</el></head>

  <p>To conserve space in the XML encoding, MathML expression trees can make use of
  structure sharing.</p>
  <div4 id="contm_share">
    <head>The <el>share</el> element</head>
  <table role="syntax">
   <thead>
     <tr>
       <th/>
       <th>Schema Fragment</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <th>Class</th>
       <td><intref ref="contm_share">Share</intref></td>
     </tr>
     <tr>
       <th>Attributes</th>
       <td>
         <kw role="parsing_ref">CommonAtt</kw>,
         <kw role="parsing_ref">src</kw>
       </td>
     </tr>
     <tr>
       <th><att>src</att> Attribute Values</th>
       <td><var>URI</var></td>
     </tr>
     <tr>
       <th>Content</th>
       <td>Empty</td>
     </tr>
   </tbody>
 </table>

    <p>The <el>share</el> element has an <att diff="chg">src</att> attribute used to
    to reference a MathML expression tree. The value of the
    <att diff="chg">src</att> attribute is a URI specifying the <att>id</att>
    attribute of the root node of the expression tree.  When building a  
    MathML expression tree, the <el>share</el> element is equivalent to a copy of the MathML
    expression tree referenced by the <att diff="chg">src</att> attribute. Note that this copy is
    <emph>structurally equal</emph>, but not identical to the element referenced. The
    values of the <el>share</el> will often be relative URI references, in which case they
    are resolved using the base URI of the document containing the <el>share</el> element.
</p>

<issue role="closed" id="share_presentation" tracker="12">
  <head><el>share</el> in Presentation MathML as well?</head>
  <p>In order to get parallel markup working, we might want to introduce a sharing element
  for Presentation MathML as well. That would also potentially give us size benefits.</p>
  <resolution><p>The WG decided on the Boston F2F that we do not want sharing in presentation (too complicated with all the inherited elements</p></resolution>
</issue>

<p>For instance, the mathematical object <var>f(f(f(a,a),f(a,a)),f(f(a,a),f(a,a)))</var> can
be encoded as either one of the following representations (and some intermediate versions as well).

<table id="contm_share_table">
<tbody>
<tr>
<td>
<eg role="mathml"><![CDATA[
<apply><ci>f</ci>
  <apply><ci>f</ci>
    <apply><ci>f</ci>
      <ci>a</ci>
      <ci>a</ci>
    </apply>
    <apply><ci>f</ci>
      <ci>a</ci>
      <ci>a</ci>
    </apply>
  </apply>
  <apply><ci>f</ci>
    <apply><ci>f</ci>
      <ci>a</ci>
      <ci>a</ci>
    </apply>
    <apply><ci>f</ci>
      <ci>a</ci>
      <ci>a</ci>
    </apply>
  </apply>
</apply>]]></eg>
</td>
<td>
<eg role="mathml" diff="chg"><![CDATA[
<apply><ci>f</ci>
  <apply id="t1"><ci>f</ci>
    <apply id="t11"><ci>f</ci>
      <ci>a</ci>
      <ci>a</ci>
    </apply>
    <share src="#t11"/>



  </apply>
  <share src="#t1"/>









</apply>]]></eg>
</td>
</tr>
</tbody>
</table>
</p>
  </div4>

<div4 id="contm_acyclicity">
  <head>An Acyclicity Constraint</head>
<p>Say that an element <emph>dominates</emph> all its children and all
elements they dominate. Say also that a
<el>share</el> element dominates its target, i.e. the element that carries the
<att>id</att> attribute pointed to by the <att diff="chg">src</att> attribute. For instance in the
representation on the right above, the <el>apply</el> element with <code>id="t1"</code> and also the
second <el>share</el> (with <code diff="chg">src="t11"</code>) both dominate the
<el>apply</el> element with <code>id="t11"</code>.</p> 

<p>The occurrences of the <el>share</el> element must obey the following global
<emph>acyclicity constraint</emph>: An element may not dominate itself. For example, the
following representation violates this constraint:

<eg role="error" diff="chg"><![CDATA[
<apply id="badid1"><csymbol cd="arith1">divide</csymbol>
  <cn>1</cn>
  <apply><csymbol cd="arith1">plus</csymbol>
    <cn>1</cn>
    <share src="#badid1"/>
  </apply>
</apply>]]></eg>
</p>

<p>Here, the <el>apply</el> element with <code>id="badid1"</code> dominates its third child,
which dominates the <el>share</el> element, which dominates its target: the element with
<code>id="badid1"</code>. So by transitivity, this element dominates itself. By the
acyclicity constraint, the example is not a valid MathML expression tree. It
might be argued that such an expression could be given the interpretation of the continued fraction
<graphic role="inline" source="image/contfrac1.gif" alt="  \frac{1}{1 + \frac{1}{1 + \frac{1}{1 + \ldots}}}"/>.
However, the procedure of building an expression tree by replacing
<el>share</el> element does not terminate for such an
expression, and hence such expressions are not allowed by Content MathML.</p>

<p>Note that the acyclicity constraints is not restricted to such simple cases, as the following
example shows:

<eg role="error" diff="chg"><![CDATA[
<apply id="bar">                        <apply id="baz">
  <csymbol cd="arith1">plus</csymbol>     <csymbol cd="arith1">plus</csymbol>
  <cn>1</cn>                              <cn>1</cn>
  <share src="#baz"/>                    <share src="#bar"/>
</apply>                                </apply>]]></eg>

Here, the <el>apply</el> with <code>id="bar"</code> dominates its third child, the
<el>share</el> with <code diff="chg">src="#baz"</code>.  That element dominates its target <el>apply</el>
(with <code>id="baz"</code>), which in turn dominates its third child, the <el>share</el>
with <code diff="chg">src="#bar"</code>. Finally, the <el>share</el> with
<code diff="chg">src="#bar"</code> dominates its target, the original 
<el>apply</el> element with <code>id="bar"</code>. So this pair of representations
ultimately violates the acyclicity constraint.</p>
</div4>

<div4 id="contm_share_binding">
  <head>Structure Sharing and Binding</head>
<p>Note that the <el>share</el> element is a <emph>syntactic</emph> referencing mechanism:
a <el>share</el> element stands for the exact element it points to. In particular,
referencing does not interact with binding in a semantically intuitive way, since it
allows a phenomenon called <emph>variable capture</emph> to
occur. Consider an example:

<eg role="mathml" diff="chg"><![CDATA[
<bind id="outer"><csymbol cd="fns1">lambda</csymbol>
  <bvar><ci>x</ci></bvar>
  <apply><ci>f</ci>
    <bind id="inner"><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <share id="copy" src="#orig"/>
    </bind>
    <apply id="orig"><ci>g</ci><ci>x</ci></apply>
  </apply>
</bind>]]></eg>

This represents a term
<graphic role="inline" source="image/lamshare1.gif" alt="\lambda{x}.f(\lambda{x}.g(x),g(x))"/>
which has two sub-terms of the form
<graphic role="inline" source="image/lamshare2.gif" alt="g(x)"/>,
one with <code>id="orig"</code>
(the one explicitly represented) and one with <code>id="copy"</code>,
represented by the <el>share</el> element.
In the original, explicitly-represented term,
the variable <var>x</var> is bound by the 
<emph>outer</emph> <el>bind</el> element.
However, in the copy, the variable <var>x</var> is
bound by the <emph>inner</emph> <el>bind</el> element.
One says that the inner <el>bind</el>
has captured the variable <var>x</var>.</p>

<p>Using references that capture variables in this way can easily lead to representation
 errors, and is not recommended.  For instance, using
 &#945;-conversion to rename the inner occurrence of <var>x</var>
 into, say, <var>y</var> leads to the semantically equivalent expression
<graphic role="inline" source="image/lamshare3.gif" alt="\lambda{x}.f(\lambda{y}.g(y),g(x))"/>.  
However, in this form, it is no longer possible to share the expression
<graphic role="inline" source="image/lamshare2.gif" alt="g(x)"/>.
Replacing <var>x</var> with <var>y</var> in the inner
<el>bvar</el> without replacing the <el>share</el> element results in a change
in semantics.</p>
</div4>

  <div4 id="contm_rendering_share">
    <head>Rendering Expressions with Structure Sharing</head>
    <p>There are several acceptable renderings for the <el>share</el> element.  These include rendering the element
    as a hypertext link to the referenced element and using the rendering of the element referenced by the
    <att diff="chg">src</att> attribute.</p>
  </div4>
</div3>

  <div3 id="contm_semantics">
    <head>Attribution via <el>semantics</el></head>

    <p>Content elements can be annotated with additional information via the
    <el>semantics</el> element. MathML uses the
    <el>semantics</el> element to wrap the annotated element and the
    <el>annotation-xml</el> and <el>annotation</el> elements used for representing the
    annotations themselves. The use of the <el>semantics</el>, <el>annotation</el> and
    <el>annotation-xml</el> is described in detail <specref
    ref="mixing" />.</p>

    <p>The <el>semantics</el> element is be considered part of both
    presentation MathML and Content MathML. MathML considers a <el>semantics</el> element
    (strict) Content MathML, if and only if its first child is (strict) Content MathML.</p>

</div3>

<div3 id="contm_cerror">
  <head>Error Markup <el role="defn starttag">cerror</el></head>

  <table role="syntax">
   <thead>
     <tr>
       <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
     </tr>
   </thead>
   <tbody>
     <tr>
       <th>Class</th>
       <td><intref ref="contm_cerror">Error</intref></td>
       <td><intref ref="contm_cerror">Error</intref></td>
     </tr>
     <tr>
       <th>Attributes</th>
       <td><kw role="parsing_ref">CommonAtt</kw></td>
       <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
     </tr>
     <tr>
       <th>Content</th>
       <td>
         <kw role="parsing_ref">csymbol</kw>, <kw role="parsing_ref">ContExp</kw>*
       </td>
       <td>
         <kw role="parsing_ref">csymbol</kw>, <kw role="parsing_ref">ContExp</kw>*
       </td>
     </tr>
   </tbody>
 </table>

  <p>A content error expression is made up of a <el>csymbol</el>
  followed by a sequence of zero or more MathML expressions. The
  initial expression must be a <el>csymbol</el> indicating the kind of
  error. Subsequent children, if present, indicate the context in
  which the error occurred.</p>

  <p>The <el>cerror</el> element has no direct mathematical meaning.
  Errors occur as the result of some action performed on an expression
  tree and are thus of real interest only when some sort of
  communication is taking place. Errors may occur inside other objects
  and also inside other errors.</p>

  <p>As an example, to encode a division by zero error, one might
  employ a hypothetical <code>aritherror</code> Content Dictionary
  containing a <code>DivisionByZero</code> symbol, as in the following
  expression:

<eg role="mathml"><![CDATA[
<cerror>
  <csymbol cd="aritherror">DivisionByZero</csymbol>
  <apply><csymbol cd="arith1">divide</csymbol><ci>x</ci><cn>0</cn></apply>
</cerror>]]></eg>

Note that error markup generally should enclose only the smallest
erroneous sub-expression.  Thus a <el>cerror</el> will often be a sub-expression of
a bigger one, e.g.

<eg role="mathml"><![CDATA[
<apply><csymbol cd="relation1">eq</csymbol>
  <cerror>
    <csymbol cd="aritherror">DivisionByZero</csymbol>
    <apply><csymbol cd="arith1">divide</csymbol><ci>x</ci><cn>0</cn></apply>
  </cerror>
  <cn>0</cn>
</apply>]]></eg></p>

<p>The default presentation of a <el>cerror</el> element is an
<el>merror</el> expression whose first child is a presentation of the
error symbol, and whose subsequent children are the default
presentations of the remaining children of the <el>cerror</el>. In
particular, if one of the remaining children of the <el>cerror</el> is
a presentation MathML expression, it is used literally in the
corresponding <el>merror</el>.</p>

<div id="contm_cerror_ex" role="mathml-example">
<eg role="mathml"><![CDATA[
<cerror>
  <csymbol cd="aritherror">DivisionByZero</csymbol>
  <apply><csymbol cd="arith1">divide</csymbol><ci>x</ci><cn>0</cn></apply>
</cerror>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<merror>
  <mtext>DivisionByZero:&#160;</mtext>
  <mfrac><mi>x</mi><mn>0</mn></mfrac>
</merror>]]></eg>

<graphic source="image/cerror-ex.gif" alt="\hbox{DivisionByZero: } \frac{x}{0}"/>
</div>

<p>Note that when the context where an error occurs is so nonsensical
that its default presentation would not be useful, an application may
provide an alternative representation of the error context.  For
example:

<eg role="mathml"><![CDATA[
<cerror>
  <csymbol cd="error">Illegal bound variable</csymbol>
  <cs> &lt;bvar&gt;&lt;plus/&gt;&lt;/bvar&gt; </cs>
</cerror>]]></eg>
</p>
</div3>


    <div3 id="contm_cbytes">
        <head>Encoded Bytes <el role="defn starttag">cbytes</el></head>

<table role="syntax">
  <thead>
    <tr>
      <th/>
      <th>Schema Fragment (Strict)</th>
      <th>Schema Fragment (Full)</th>
    </tr>
  </thead>
  <tbody>
    <tr><th>Class</th>
    <td><intref ref="contm_cbytes">Cbytes</intref></td>
    <td><intref ref="contm_cbytes">Cbytes</intref></td>
    </tr> 
   <tr>
      <th>Attributes</th>
      <td><kw role="parsing_ref">CommonAtt</kw></td>
      <td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td>
    </tr>
    <tr>
    <th>Content</th>
    <td><kw role="parsing_ref">base64</kw></td>
    <td><kw role="parsing_ref">base64</kw></td>
    </tr>
  </tbody>
</table>

<p>The content of <el>cbytes</el> represents a stream of bytes as a
sequence of characters in Base64 encoding, that is it matches the
base64Binary data type defined in <bibref ref="XMLSchemaDatatypes"/>. All white space is ignored.</p>

<p>The <el>cbytes</el> element is mainly used for OpenMath
compatibility, but may be used, as in OpenMath, to encapsulate output
from a system that may be hard to encode in MathML, such as binary
data relating to the internal state of a system, or image data.</p>

<p>The rendering of <el>cbytes</el> is not expected to represent the
content and the proposed rendering is that of an empty
<el>mrow</el>. Typically <el>cbytes</el> is used in an
<el>annotation-xml</el> or is itself annotated with Presentation
MathML, so this default rendering should rarely be used.</p>
    </div3>

</div2>

<div2 id="contm_structure_extended">
  <head>Content MathML for Specific Structures</head>

  <p>The elements of Strict Content MathML described in
  <intref ref="contm_core">the previous section</intref> are sufficient to
  encode logical assertions and expression structure, and they do so
  in a way that closely models the standard constructions of
  mathematical logic that underlie the foundations of mathematics. As a
  consequence, Strict markup can be used to represent all of
  mathematics, and is ideal for providing consistent mathematical
  semantics for all Content MathML expressions.
  </p>

  <p>At the same time, many notational idioms of mathematics are not
  straightforward to represent directly with Strict Content markup.
  For example, standard notations for sums, integrals, sets, piecewise
  functions and many other common constructions require non-obvious
  technical devices, such as the introduction of lambda functions, to
  rigorously encode them using Strict markup. Consequently, in order
  to make Content MathML easier to use, a range of additional elements
  have been provided for encoding such idiomatic constructs more
  directly. This section discusses the general approach for encoding
  such idiomatic constructs, and their Strict Content equivalents.
  Specific constructions are discussed in detail in <specref
  ref="contm_opel"/>.</p>

  <p>Most idiomatic constructions which Content markup addresses fall
  into about a dozen classes.  Some of these classes, such as <intref
  ref="contm_container"><emph>container elements</emph></intref>, have
  their own syntax. Similarly, a small number of non-Strict
  constructions involve a single element with an exceptional syntax,
  for example <el>partialdiff</el>. These exceptional elements are
  discussed on a case-by-case basis in <specref
  ref="contm_opel"/>. However, the majority of constructs consist of
  classes of operator elements which all share a particular usage of
  <intref ref="contm_qualifiers"><emph>qualifiers</emph></intref>.
  These classes of operators are described in <specref
  ref="contm_opclasses"/>.</p>
  
  <p>In all cases, non-Strict expressions may be rewritten using only
  Strict markup.  In most cases, the transformation is completely
  algorithmic, and may be automated. Rewrite rules for classes of
  non-Strict constructions are introduced and discussed later in this
  section, and rewrite rules for exceptional constructs involving a
  single operator are given in <specref ref="contm_opel"/>. The
  complete algorithm for rewriting arbitrary Content MathML as Strict
  Content markup is summarized at the end of the Chapter in <specref
  ref="contm_p2s"/>.
</p>

  <div3 id="contm_container">
    <head>Container Markup</head>

    <p>Many mathematical structures are constructed from subparts or
    parameters. The motivating example is a set. Informally, one
    thinks of a set as a certain kind of mathematical object that
    contains a collection of elements. Thus, it is intuitively natural
    for the markup for a set to contain, in the XML sense, the markup
    for its constituent elements. The markup may define the set
    elements explicitly by enumerating them, or implicitly by rule,
    using qualifier elements. However, in either case, the markup for
    the elements is contained in the markup for the set, and
    consequently this style of representation is termed
    <emph>container markup</emph> in MathML. By contrast, Strict
    markup represents an instance of a set as the result of applying a
    function or <emph>constructor symbol</emph> to arguments.  In this
    style of markup, the markup for the set construction is a sibling
    of the markup for the set elements in an enclosing <el>apply</el>
    element.</p>

    <p>While the two approaches are formally equivalent, container
    markup is generally more intuitive for non-expert authors to use, while
    Strict markup is preferable is contexts where semantic rigor is
    paramount.  In addition, MathML 2 relied on container markup, and
    thus container markup is necessary in cases where backward
    compatibility is required.</p>

    <p>MathML provides container markup for the following mathematical
    constructs: sets, lists, intervals, vectors, matrices (two
    elements), piecewise functions (three elements) and lambda
    functions.  There are corresponding constructor symbols in Strict
    markup for each of these, with the exception of lambda functions,
    which correspond to binding symbols in Strict markup. Note that in
    MathML 2, the term "container markup" was also taken to include
    token elements, and the deprecated <el>declare</el>, <el>fn</el>
    and <el>reln</el> elements, but MathML 3 limits usage of the term
    to the above constructs.</p>

    <p>The rewrite rules for obtaining equivalent Strict Content
    markup from container markup depend on the <intref
    ref="contm_opclasses">operator class</intref> of the particular
    operator involved.  For details about a specific container
    element, obtain its operator class (and any applicable special
    case information) by consulting the syntax table and discussion
    for that element in <specref ref="contm_opel"/>. Then apply the
    rewrite rules for that specific operator class as described in
    <specref ref="contm_opclasses"/>.</p>

    <div4 id="contm_container_constructor">
    <head>Container Markup for Constructor Symbols</head>

    <p>The arguments to container elements corresponding to
    constructors may either be explicitly given as a sequence of child
    elements, or they may be specified by a rule using qualifiers. The
    only exceptions are the <el>piecewise</el>, <el>piece</el>, and
    <el>otherwise</el> elements used for representing functions with
    <intref ref="contm_piecewise">piecewise</intref> definitions.  The
    arguments of these elements must always be specified
    explicitly.</p>

<div id="contm_strict-set" role="strict-mathml-example">
    <p>Here is an example of container markup with explicitly specified arguments:

    <eg role="mathml"><![CDATA[<set><ci>a</ci><ci>b</ci><ci>c</ci></set>]]></eg>

    This is equivalent to the following Strict Content MathML expression:

    <eg role="strict-mathml"><![CDATA[<apply><csymbol cd="set1">set</csymbol><ci>a</ci><ci>b</ci><ci>c</ci></apply>]]></eg>
    </p>
</div>

<div id="contm_strict-set-bvar" role="strict-mathml-example">

    <p>Another example of container markup, where the list of arguments is
    given indirectly as an expression with a bound variable. The container markup
    for the set of even integers is:

    <eg role="mathml"><![CDATA[
<set>
  <bvar><ci>x</ci></bvar> 
  <domainofapplication><integers/></domainofapplication>
  <apply><times/><cn>2</cn><ci>x</ci></apply>
</set>]]></eg>

This may be written as follows in Strict Content MathML:

    <eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="set1">map</csymbol>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <apply><csymbol cd="arith1">times</csymbol>
      <cn>2</cn>
      <ci>x</ci>
    </apply>
  </bind>
  <csymbol cd="setname1">Z</csymbol>
</apply>]]></eg>
</p>
</div>

    <issue role="closed" id="dom_for_containers">
      <head>MathML DOM for Container Elements</head>
      <p>Do we want to prescribe one of the representations for the DOM? That would make
      the processing much simpler.</p>
      <resolution><p>We have decided to keep the MathML DOM directly in equivalent to the
      XML DOM of this, then this becomes a non-issue</p></resolution>
    </issue>

</div4>



  <div4 id="contm_lambda_container">
    <head>Container Markup for Binding Constructors</head>

<!-- clashes with syntax table in lambda section
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_intsumproduct">lambda</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>,<kw role="parsing_ref">ContExp</kw></td></tr>
<tr><th>OM Symbol</th>
     <td>
       <symbolref cd="fns1" name="lambda"/>, 
     </td>
</tr>
</tbody>
</table>
-->
    <p>The <el>lambda</el> element is a container element
    corresponding to the <symbolref cd="fns1" name="lambda"/> symbol
    in the <cdref cd="fns1"/> Content Dictionary.  However, unlike the
    container elements of the preceding section, which purely
    construct mathematical objects from arguments, the <el>lambda</el>
    element performs variable binding as well.  Therefore, the child
    elements of <el>lambda</el> have distinguished roles.  In
    particular, a <el>lambda</el> element must have at least one
    <el>bvar</el> child, optionally followed by <intref
    ref="contm_qualifiers">qualifier elements</intref>, followed by a
    Content MathML element. This basic difference between the
    <el>lambda</el> container and the other constructor container
    elements is also reflected in the OpenMath symbols to which they
    correspond.  The constructor symbols have an OpenMath role of
    "application", while the lambda symbol has a role of "bind".</p>

<div id="contm_strict-lambda" role="strict-mathml-example">

<p>This example shows the use of <el>lambda</el> container element and the equivalent use of <el>bind</el> in Strict Content MathML</p>
    <eg role="mathml"><![CDATA[<lambda><bvar><ci>x</ci></bvar><ci>x</ci></lambda>]]></eg>

   <eg role="strict-mathml"><![CDATA[
<bind><csymbol cd="fns1">lambda</csymbol>
 <bvar><ci>x</ci></bvar><ci>x</ci>
</bind>]]></eg>

</div>
  </div4>

</div3>


  <div3 id="contm_bind_apply">
    <head>Bindings with <el role="starttag">apply</el></head>
    
    <p>MathML allows the use of the <el>apply</el> element to perform
    variable binding in non-Strict constructions instead of
    the <el>bind</el> element.  This usage conserves backwards
    compatibility with MathML 2.  It also simplifies the encoding of
    several constructs involving bound variables with qualifiers as
    described <intref ref="contm_qualifiers">below</intref>.</p>

    <p>Use of the <el>apply</el> element to bind variables is allowed
    in two situations.  First, when the operator to be applied is
    itself a binding operator, the <el>apply</el> element merely
    substitutes for the <el>bind</el> element.  The logical quantifiers
    <el role="emptytag">forall</el>, <el role="emptytag">exists</el> and the
    container element <el>lambda</el> are the primary examples of this
    type.</p>

    <p>The second situation arises when the operator being applied
    allows the use of bound variables with qualifiers.  The most
    common examples are sums and integrals.  In most of these cases,
    the variable binding is to some extent implicit in the notation,
    and the equivalent Strict representation requires the introduction
    of auxiliary constructs such as lambda expressions for formal
    correctness.</p>

    <p>Because expressions using bound variables with qualifiers are
    idiomatic in nature, and do not always involve true variable
    binding, one cannot expect systematic renaming (alpha-conversion)
    of variables "bound" with <el>apply</el> to preserve meaning in
    all cases.  An example for this is the <el>diff</el> element where
    the <el>bvar</el> term is technically not bound at all.</p>

<div id="contm_strict-apply-bvar" role="strict-mathml-example">

    <p>The following example illustrates the use of <el>apply</el>
    with a binding operator.  In these cases, the corresponding Strict
    equivalent merely replaces the <el>apply</el> element with a
    <el>bind</el> element:

    <eg role="mathml"><![CDATA[
<apply><forall/>
  <bvar><ci>x</ci></bvar>
  <apply><geq/><ci>x</ci><ci>x</ci></apply>
</apply>]]></eg>
    The equivalent Strict expression is:
    <eg role="strict-mathml"><![CDATA[
<bind><csymbol cd="logic1">forall</csymbol>
  <bvar><ci>x</ci></bvar>
  <apply><csymbol cd="relation1">geq</csymbol><ci>x</ci><ci>x</ci></apply>
</bind>]]></eg>
</p>
</div>

<div id="contm_strict-apply-bvar-2" role="strict-mathml-example">

    <p>In this example, the sum operator is not itself a binding
    operator, but bound variables with qualifiers are implicit in the
    standard notation, which is reflected in the non-Strict markup.
    In the equivalent Strict representation, it is necessary to
    convert the summand into a lambda expression, and recast the
    qualifiers as an argument expression:

    <eg role="mathml"><![CDATA[
<apply><sum/>
  <bvar><ci>i</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><cn>100</cn></uplimit>
  <apply><power/><ci>x</ci><ci>i</ci></apply>
</apply>]]></eg>
    The equivalent Strict expression is: 
    <eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">sum</csymbol>
  <apply><csymbol cd="interval1">integer_interval</csymbol>
    <cn>0</cn>
    <cn>100</cn>
  </apply>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>i</ci></bvar>
    <apply><csymbol cd="arith1">power</csymbol>
      <ci>x</ci>
      <ci>i</ci>
    </apply>
  </bind>
</apply>]]></eg>
    </p>
</div>
   </div3>

   <div3 id="contm_qualifiers">
     <head>Qualifiers</head>

    <p>Many common mathematical constructs involve an operator
    together with some additional data.  The additional data is either
    implicit in conventional notation, such as a bound variable, or
    thought of as part of the operator, as is the case with the limits
    of a definite integral.  MathML 3 uses <emph>qualifier</emph>
    elements to represent the additional data in such cases.</p>

    <p>Qualifier elements are always used in conjunction with operator or container
    elements.  Their meaning is idiomatic, and depends on the context in which they are
    used.  When used with an operator, qualifiers always follow the operator and precede
    any arguments that are present. In all cases, if more than one qualifier is present,
    they appear in the order <el>bvar</el>, <el>lowlimit</el>, <el>uplimit</el>,
    <el>interval</el>, <el>condition</el>, <el>domainofapplication</el>, <el>degree</el>,
    <el>momentabout</el>, <el>logbase</el>.</p>

    <p>The precise function of qualifier elements depends on the
    operator or container that they modify.  The majority of use cases
    fall into one of several categories, discussed below, and usage
    notes for specific operators and qualifiers are given in <specref
    ref="contm_opel"/>.</p>

    <div4 id="contm_domainofapplication_qualifier">
      <head>Uses of 
      <el role="defn starttag">domainofapplication</el>,
      <el role="starttag">interval</el>,
      <el role="defn starttag">condition</el>,
      <el role="defn starttag">lowlimit</el> and
      <el role="defn starttag">uplimit</el></head> 

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">qualifier</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw></td></tr>
</tbody>
</table>
<p>(For the syntax of <el>interval</el> see <specref ref="contm_interval"/>.)</p>

<p>The primary use of <el>domainofapplication</el>, <el>interval</el>,
<el>uplimit</el>, <el>lowlimit</el> and <el>condition</el> is to
restrict the values of a bound variable.  The most general qualifier
is <el>domainofapplication</el>. It is used to specify a set (perhaps
with additional structure, such as an ordering or metric) over which
an operation is to take place. The <el>interval</el> qualifier, and
the pair <el>lowlimit</el> and <el>uplimit</el> also restrict a bound
variable to a set in the special case where the set is an
interval. The <el>condition</el> qualifier, like
<el>domainofapplication</el>, is general, and can be used to restrict
bound variables to arbitrary sets.  However, unlike the other
qualifiers, it restricts the bound variable by specifying a
Boolean-valued function of the bound variable.  Thus,
<el>condition</el> qualifiers always contain instances of the bound
variable, and thus require a preceding <el>bvar</el>, while the other
qualifiers do not.  The other qualifiers may even be used when no
variables are being bound, e.g. to indicate the restriction of a
function to a subdomain.</p>

<p>In most cases, any of the qualifiers capable of representing the
domain of interest can be used interchangeably. The most general
qualifier is <el>domainofapplication</el>, and therefore has a
privileged role. It is the preferred form, unless there are
particular idiomatic reasons to use one of the other qualifiers,
e.g. limits for an integral.  In MathML 3, the other forms are treated
as shorthand notations for <el>domainofapplication</el> because they
may all be rewritten as equivalent <el>domainofapplication</el>
constructions.  The rewrite rules to do this are given below. The other
qualifier elements are provided because they correspond to common
notations and map more easily to familiar presentations.  Therefore,
in the situations where they naturally arise, they may be more
convenient and direct than <el>domainofapplication</el>.</p>

<p>To illustrate these ideas, consider the following examples showing alternative
representations of a definite integral.  Let <var>C</var> denote the interval from 0 to 1,
and <var>f</var>(<var>x</var>) = <var>x</var><sup>2</sup>. Then
<el>domainofapplication</el> could be used express the integral of a
function <var>f</var> over
<var>C</var> in this way:

<eg role="mathml"><![CDATA[
<apply><int/>
  <domainofapplication>
    <ci type="set">C</ci>
  </domainofapplication>
  <ci type="function">f</ci>
</apply>]]></eg></p>

<p>Note that no explicit bound variable is identified in this
encoding, and the integrand is a function. Alternatively, the
<el>interval</el> qualifier could be used with an explicit bound variable:

<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <interval><cn>0</cn><cn>1</cn></interval>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
</apply>]]></eg></p>

<p>The pair <el>lowlimit</el> and <el>uplimit</el> can also be used.
This is perhaps the most "standard" representation of this integral:

<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><cn>1</cn></uplimit>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
</apply>]]></eg></p>

<p>Finally, here is the same integral, represented using
a <el>condition</el> on the bound variable:

<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><and/>
      <apply><leq/><cn>0</cn><ci>x</ci></apply>
      <apply><leq/><ci>x</ci><cn>1</cn></apply>
    </apply>
  </condition>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
</apply>]]></eg>

Note the use of the explicit bound variable within the
<el>condition</el> term. Note also that when a bound
variable is used, the integrand is an expression in the bound
variable, not a function.</p>

<p>The general technique of using a <el>condition</el> element
together with <el>domainofapplication</el> is quite powerful.  For
example, to extend the previous example to a multivariate domain, one
may use an extra bound variable and a domain of application
corresponding to a cartesian product:

<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <domainofapplication>
    <set>
      <bvar><ci>t</ci></bvar>
      <bvar><ci>u</ci></bvar>
      <condition>
        <apply><and/>
          <apply><leq/><cn>0</cn><ci>t</ci></apply>
          <apply><leq/><ci>t</ci><cn>1</cn></apply>
          <apply><leq/><cn>0</cn><ci>u</ci></apply>
          <apply><leq/><ci>u</ci><cn>1</cn></apply>
        </apply>
      </condition>
      <list><ci>t</ci><ci>u</ci></list>
    </set>
  </domainofapplication>
  <apply><times/>
    <apply><power/><ci>x</ci><cn>2</cn></apply>
    <apply><power/><ci>y</ci><cn>3</cn></apply>
  </apply>
</apply>]]></eg></p>

<p>Note that the order of the inner and outer bound variables is significant.</p>

<p><emph>Mappings to Strict Content MathML</emph></p>

<p>When rewriting expressions to Strict Content MathML, qualifier
elements are removed via a series of rules described in this section.
The general algorithm for rewriting a MathML expression involving
qualifiers proceeds in two steps.  First, constructs using the
<el>interval</el>, <el>condition</el>, <el>uplimit</el> and
<el>lowlimit</el> qualifiers are converted to constructs using only
<el>domainofapplication</el>. Second, <el>domainofapplication</el>
expressions are then rewritten as Strict Content markup.
</p>

<div id="contm_limits-strict" role="strict-mathml-example">
           <head>Rewrite: interval qualifier</head>

<eg meta="ci"  role="mathml"><![CDATA[
<apply><ci>H</ci>
  <bvar><ci>x</ci></bvar>
  <lowlimit><ci>a</ci></lowlimit>
  <uplimit><ci>b</ci></uplimit>
  <ci>C</ci>
</apply>]]></eg>
<eg meta="ci #-interval" role="strict-mathml"><![CDATA[
<apply><ci>H</ci>
  <bvar><ci>x</ci></bvar>
  <domainofapplication>
    <apply><csymbol cd="interval1">interval</csymbol>
      <ci>a</ci>
      <ci>b</ci>
    </apply>
  </domainofapplication>
  <ci>C</ci>
</apply>]]></eg>

<p>The symbol used in this translation depends on the head of the
application, denoted by <code meta="ci"><![CDATA[<ci>H</ci>]]></code>
here. By default <symbolref cd="interval1" name="interval"/> should be
used, unless the semantics of the head term can be determined and
indicate a more specific interval symbols.  In particular, several
predefined Content MathML element should be used with more specific
interval symbols.  If the head is <el>int</el> then <symbolref
cd="interval1" name="oriented_interval"/> is used.  When the head term
is <el>sum</el> or <el>product</el>, <symbolref cd="interval1"
name="integer_interval"/> should be used.</p>

<p>The above technique for replacing <el>lowlimit</el> and <el>uplimit</el> qualifiers
with a <el>domainofapplication</el> element is also used for replacing the
<el>interval</el> qualifier. </p>
</div>

<p>The <el>condition</el> qualifier restricts a bound variable by specifying a
Boolean-valued expression on a larger domain, specifying whether a given value is in the
restricted domain. The <el>condition</el> element contains a single child that represents
the truth condition. Compound conditions are formed by applying Boolean operators such as
<el>and</el> in the condition.</p>

<div id="contm_condition-strict" role="strict-mathml-example">
           <head>Rewrite: condition</head>
<p>To rewrite an expression using the <el>condition</el>
qualifier as one using <el>domainofapplication</el>,

<eg meta="ci" role="mathml-fragment"><![CDATA[
<bvar><ci>x1</ci></bvar>
<bvar><ci>xn</ci></bvar>
<condition><ci>P</ci></condition>]]></eg>

is rewritten to

<eg meta="ci" role="mathml-fragment"><![CDATA[
<bvar><ci>x1</ci></bvar>
<bvar><ci>xn</ci></bvar>
<domainofapplication>
  <apply><csymbol cd="set1">suchthat</csymbol>
    <ci>R</ci>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x1</ci></bvar>
      <bvar><ci>xn</ci></bvar>
      <ci>P</ci>
    </bind>
  </apply>
</domainofapplication>]]></eg>
If the <el>apply</el> has a <el>domainofapplication</el> (perhaps originally expressed as
<el>interval</el> or an <el>uplimit</el>/<el>lowlimit</el> pair) then that is used for
<code meta="ci"><![CDATA[<ci>R</ci>]]></code>. Otherwise <code meta="ci"><![CDATA[<ci>R</ci>]]></code> is a set determined by the <att>type</att> attribute
of the bound variable as specified in <specref ref="contm_ci_extended"/>, if that is
present. If the type is unspecified, the translation introduces an unspecified domain via
content identifier <code>&lt;ci&gt;R&lt;/ci&gt;</code>.</p>
</div>

    
<p>By applying the rules above, expression using the
<el>interval</el>, <el>condition</el>, <el>uplimit</el> and
<el>lowlimit</el> can be rewritten using only
<el>domainofapplication</el>. Once a <el>domainofapplication</el> has
been obtained, the final mapping to Strict markup is accomplished
using the following rules:</p>

<div id="contm_strict-doa" role="strict-mathml-example">
           <head>Rewrite: restriction</head>

<p>An application of a function that is qualified by the
<el>domainofapplication</el> qualifier (expressed by an <el>apply</el> element without
bound variables) is converted to an application of a function term constructed with the
<symbolref cd="fns1" name="restriction"/> symbol.</p>

<eg meta="ci" role="mathml"><![CDATA[
<apply><ci>F</ci>
  <domainofapplication>
    <ci>C</ci>
  </domainofapplication>
  <ci>a1</ci>
  <ci>an</ci>
</apply>]]></eg>
<p>may be written as:</p>
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="fns1">restriction</csymbol>
    <ci>F</ci>
    <ci>C</ci>
  </apply>
  <ci>a1</ci>
  <ci>an</ci>
</apply>]]></eg>
</div>

<p>In general, an application involving bound variables and (possibly)
<el>domainofapplication</el> is rewritten using the following rule,
which makes the domain the first positional argument of the application,
and uses the lambda symbol to encode the variable bindings.
Certain classes of operator have alternative rules, as described below.</p>
<div id="contm_dombind-strict" role="strict-mathml-example">
           <head>Rewrite: apply bvar domainofapplication</head>
  <p>A content MathML expression with bound variables and 
  <el>domainofapplication</el>
<eg meta="ci" role="mathml-fragment"><![CDATA[
<apply><ci>H</ci>
  <bvar><ci>v1</ci></bvar>
  ...
  <bvar><ci>vn</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
    <ci>A1</ci>
    ...
    <ci>Am</ci>
</apply>]]></eg>
is rewritten to 
<eg meta="ci" role="mathml-fragment"><![CDATA[
<apply><ci>H</ci>
  <ci>D</ci>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>v1</ci></bvar>
    ...
    <bvar><ci>vn</ci></bvar>
    <ci>A1</ci>
  </bind>
  ...
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>v1</ci></bvar>
    ...
    <bvar><ci>vn</ci></bvar>
    <ci>Am</ci>
  </bind>
</apply>]]></eg>
If there is no <el>domainofapplication</el> qualifier the <code meta="ci"><![CDATA[<ci>D</ci>]]></code> child is
omitted.</p>
</div>

    </div4>


   <div4 id="contm_degree">
     <head>Uses of <el role="defn starttag">degree</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">qualifier</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw></td></tr>
</tbody>
</table>

    <p>The <el>degree</el> element is a qualifier used to specify the
    <quote>degree</quote> or <quote>order</quote> of an operation.  MathML uses the
    <el>degree</el> element in this way in three contexts: to specify the degree of a
    root, a moment, and in various derivatives. Rather than introduce special elements for
    each of these families, MathML provides a single general construct, the
    <el>degree</el> element in all three cases.</p>

    <p>Note that the <el>degree</el> qualifier is not used to restrict a bound variable in
    the same sense of the qualifiers discussed above.  Indeed, with roots and moments, no
    bound variable is involved at all, either explicitly or implicitly. In the case of
    differentiation, the <el>degree</el> element is used in conjunction with a
    <el>bvar</el>, but even in these cases, the variable may not be genuinely bound.</p>

    <p>For the usage of <el>degree</el> with the <intref ref="contm_root"><el>root</el></intref> and <intref ref="contm_moment"><el>moment</el></intref> operators, see the discussion of those
    operators below. The usage of <el>degree</el> in differentiation is more complex.  In
    general, the <el>degree</el> element indicates the order of the derivative with
    respect to that variable. The degree element is allowed as the second child of a
    <el>bvar</el> element identifying a variable with respect to which the derivative is
    being taken. Here is an example of a second derivative using the <el>degree</el>
    qualifier:</p>

<eg role="mathml"><![CDATA[
<apply><diff/>
  <bvar>
    <ci>x</ci>
    <degree><cn>2</cn></degree>
  </bvar>
  <apply><power/><ci>x</ci><cn>4</cn></apply>
</apply>]]></eg>
<p>For details see <specref ref="contm_diff"/> and <specref ref="contm_partialdiff"/>.</p>
   </div4>

   <div4 id="contm_otherqualifiers">
     <head>Uses of <el role="starttag">momentabout</el> and <el role="starttag">logbase</el></head>

     <p>The qualifiers <el>momentabout</el> and <el>logbase</el> are
     specialized elements specifically for use with the <intref ref="contm_moment"><el>moment</el></intref>
     and <intref ref="contm_log"><el>log</el></intref> operators
     respectively.  See the descriptions of those operators below for their usage.</p>
   </div4>
   </div3>

    <div3 id="contm_opclasses">
    <head>Operator Classes</head>

<p>The Content MathML elements described in detail in the next section
may be broadly separated into <emph>classes</emph>. The class of each
element is shown in the syntax table that introduces the element in
<specref ref="contm_opel"/>. The class gives an indication of the
general intended mathematical usage of the element, and also
determines its usage as determined by the schema.  The class also
determines the applicable rewrite rules for mapping to Strict Content
MathML.  This section presents the rewrite rules for each of the
operator classes.</p>

<p>The rules in this section cover the use cases applicable to
specific operator classes.  Special-case rewrite rules for individual
elements are discussed in the sections below.  However, the most
common usage pattern is generic, and is used by operators from almost all
operator classes. It consists of applying an operator to an explicit list
of arguments using an <el>apply</el> element.  In these cases,
rewriting to Strict Content MathML is simply a matter of replacing the
empty element with an appropriate <el>csymbol</el>, as listed in the
syntax tables in <specref ref="contm_opel"/>.  This is summarized in
the following rule.</p>

    <div id="contm_strict-opel" role="strict-mathml-example">
<head>Rewrite: element</head>
<p>  For example,</p>
<eg meta="plus" role="mathml"><![CDATA[<plus/>]]></eg> 
<p>is equivalent to the Strict form 
<eg meta="@-arith1 #-plus" role="strict-mathml"><![CDATA[<csymbol cd="arith1">plus</csymbol>]]></eg></p>
    </div>

<p>In MathML 2, the <att>definitionURL</att> attribute could be
used to redefine or modify the meaning of an operator element. When the <att>definitionURL</att> 
attribute is present, the value for the <att>cd</att> attribute on the <el>csymbol</el> should be 
determined by the <att>definitionURL</att> value if possible. The correspondence between <att>cd</att> and <att>definitionURL</att> values is described <specref ref="contm_csymbol_extended"/>.</p>


<div4 id="contm_nary">
  <head>N-ary Operators (classes nary-arith, nary-functional, nary-logical,
  nary-linalg, nary-set, nary-constructor)</head>

<p>Many MathML operators may be used with an arbitrary number of
arguments. <phrase>The corresponding OpenMath symbols for elements in these classes
also take an arbitrary number of arguments.</phrase>
In all such cases, either the arguments my be given
explicitly as children of the <el>apply</el> or <el>bind</el> element, or
the list may be specified implicitly via the use of qualifier
elements.</p>

<div5 id="contm_nary_schema"><head>Schema Patterns</head>
<p>The elements representing these n-ary operators are
specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">nary-arith.class</kw>, <kw role="parsing_ref">nary-functional.class</kw>, <kw role="parsing_ref">nary-logical.class</kw>,
  <kw role="parsing_ref">nary-linalg.class</kw>, <kw role="parsing_ref">nary-set.class</kw>, <kw role="parsing_ref">nary-constructor.class</kw>.</p>
</div5>
<div5 id="contm_nary_rewrite"><head>Rewriting to Strict Content MathML</head>
<p>If the argument list is given explicitly, the <intref
ref="contm_strict-opel">Rewrite: element</intref> rule applies.</p>

<p>Any use of qualifier elements is expressed in Strict Content
MathML, via explicitly applying the function to a list of arguments
using the <symbolref cd="fns2" name="apply_to_list"/> symbol as shown
in the following rule. The rule only considers the
<el>domainofapplication</el> qualifier as other qualifiers may be
rewritten to <el>domainofapplication</el> as described earlier.</p>

<div id="contm_p2s.lifted" role="strict-mathml-example">
           <head>Rewrite: n-ary domainofapplication</head>
<p>An expression of the following form,
where <code meta="union"><![CDATA[<union/>]]></code> represents any
 element of the relevant class and 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
is an arbitrary expression involving the bound variable(s)
<eg meta="ci union" role="mathml"><![CDATA[
<apply><union/>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x</ci>
</apply>]]></eg>
is rewritten to 
<eg meta="ci #-union @-set1" role="strict-mathml"><![CDATA[
<apply><csymbol cd="fns2">apply_to_list</csymbol>
  <csymbol cd="set1">union</csymbol>
  <apply><csymbol cd="list1">map</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <ci>expression-in-x</ci>
    </bind>
    <ci>D</ci>
  </apply>
</apply>]]></eg></p>
</div>
<p>The above rule applies to all symbols in the listed classes.
In the  case of <kw>nary-set.class</kw> the choice of Content
Dictionary to use depends on the <att>type</att> attribute on the
<phrase>arguments</phrase>, defaulting to <cdref cd="set1"/>, but <cdref cd="multiset1"/>
should be used if <att>type</att>=<attval>multiset</attval>.</p>

<p>Note that the members of the <kw>nary-constructor.class</kw>, such
as <el>vector</el>, use <emph>constructor</emph> syntax where the arguments and
qualifiers are given as children of the element rather than as
children of a containing <el>apply</el>.  In this case, the above rules apply 
with the analogous syntactic modifications.</p>
</div5>
</div4>
<div4 id="contm_nary_setlist">
  <head>N-ary Constructors for set and list (class nary-setlist-constructor)</head>
  <p>The use of <el>set</el> and <el>list</el> follows the same format
  as other n-ary constructors, however when rewriting to Strict
  Content MathML a variant of the above rule is used. This is because the <symbolref cd="set1" name="map"/>
  symbol implicitly constructs the required set or list, and <symbolref cd="fns2" name="apply_to_list"/> is
  not needed in this case.</p>

<div5 id="contm_narysetlist_schema"><head>Schema Patterns</head>
<p>The elements representing these n-ary operators are
specified in the schema pattern <kw role="parsing_ref">nary-setlist-constructor.class</kw>.</p>
</div5>
<div5 id="contm_narysetlist_rewrite"><head>Rewriting to Strict Content MathML</head>

<p>If the argument list is given explicitly, the <intref
ref="contm_strict-opel">Rewrite: element</intref> rule applies.</p>

<p>When qualifiers are used to specify the list of arguments, the following rule is used.</p>

<div id="contm_rewrite_setliste" role="strict-mathml-example">
           <head>Rewrite: n-ary setlist domainofapplication</head>
<p>An expression of the following form,
where <code meta="set"><![CDATA[<set/>]]></code> is either of the elements <el>set</el> or <el>list</el> and 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
is an arbitrary expression involving the bound variable(s)
<eg meta="ci set" role="mathml"><![CDATA[
<set>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x</ci>
</set>]]></eg>
is rewritten to 
<eg meta="ci @-set1 " role="strict-mathml"><![CDATA[
<apply><csymbol cd="set1">map</csymbol>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <ci>expression-in-x</ci>
  </bind>
  <ci>D</ci>
</apply>]]></eg></p>

<p>Note that
  when <code meta="ci"><![CDATA[<ci>D</ci>]]></code> is already a set
  or list of the appropriate type for the container element, and the lambda function created
  from <code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is
  the identity, the entire container element should be rewritten
  directly as <code meta="ci"><![CDATA[<ci>D</ci>]]></code>.</p> 

</div>
<p>In the  case of <el>set</el>, the choice of Content
Dictionary and symbol depends on the value of <phrase>the <att>type</att> attribute of the arguments. By default the   <symbolref
cd="set1" name="set"/> symbol is used, but if one of the arguments has 
<att>type</att> attribute with value <attval>multiset</attval>, the <symbolref
cd="multiset1" name="multiset"/> symbol is used.
If there is a <att>type</att> attribute with value other than <attval>set</attval> or <attval>multiset</attval>
the <symbolref cd="set1" name="set"/> symbol should be used, and the arguments should be annotated with their type
by rewriting the <att>type</att> attribute using the rule
<intref ref="contm_strict-attributes">Rewrite: attributes</intref></phrase>.</p>

</div5>
</div4>
<div4 id="contm_nary_reln">
 <head>N-ary Relations (classes nary-reln, nary-set-reln)</head>
<p>MathML allows transitive relations to be used with multiple
arguments, to give a natural expression to <quote>chains</quote> of
relations such as <var>a</var> &lt; <var>b</var> &lt; <var>c</var> &lt;
<var>d</var>. However unlike the case of the arithmetic operators, the
underlying symbols used in the Strict Content MathML are classed as
binary, so it is not possible to use  
<symbolref cd="fns2" name="apply_to_list"/> as in the previous
section, but instead a similar function  
<symbolref cd="fns2" name="predicate_on_list"/> is used, the
semantics of which is essentially to take the conjunction of applying
the predicate to elements of the domain two at a time.</p>

<div5 id="contm_nary_reln_schema"><head>Schema Patterns</head>
<p>The elements representing these n-ary operators are
specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">nary-reln.class</kw>, <kw role="parsing_ref">nary-set-reln.class</kw>.</p>
</div5>
<div5 id="contm_nary_reln_rewrite"><head>Rewriting to Strict Content MathML</head>
<div id="contm_rewrite_reln" role="strict-mathml-example">
           <head>Rewrite: n-ary relations</head>
<p>An expression of the form 
<eg meta="ci lt" role="mathml"><![CDATA[
<apply><lt/>
  <ci>a</ci><ci>b</ci><ci>c</ci><ci>d</ci>
</apply>]]></eg>

rewrites to Strict Content MathML

<eg meta="ci #-lt @-reln1" role="mathml"><![CDATA[
<apply><csymbol cd="fns2">predicate_on_list</csymbol>
 <csymbol cd="reln1">lt</csymbol>
 <apply><csymbol cd="list1">list</csymbol>
  <ci>a</ci><ci>b</ci><ci>c</ci><ci>d</ci>
 </apply>
</apply>]]>
</eg></p>
</div>

<div id="contm_rewrite_reln_bvar" role="strict-mathml-example">
           <head>Rewrite: n-ary relations bvar</head>
<p>An expression of the form 
<eg meta="ci lt" role="mathml"><![CDATA[
<apply><lt/>
 <bvar><ci>x</ci></bvar>
 <domainofapplication><ci>R</ci></domainofapplication>
 <ci>expression-in-x</ci>
</apply>]]></eg>

where
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
is an arbitrary expression involving the bound variable, rewrites to the Strict Content MathML

<eg meta="ci #-lt @-reln1" role="mathml"><![CDATA[
<apply><csymbol cd="fns2">predicate_on_list</csymbol>
 <csymbol cd="reln1">lt</csymbol>
 <apply><csymbol cd="list1">map</csymbol>
   <ci>R</ci>
   <bind><csymbol cd="fns1">lambda</csymbol>
     <bvar><ci>x</ci></bvar>
     <ci>expression-in-x</ci>
   </bind>
  </apply>
</apply>]]></eg></p>
</div>


<p>The above rules apply to all symbols in classes <kw>nary-reln.class</kw>
and <kw>nary-set-reln.class</kw>. In the latter case the choice of Content
Dictionary to use depends on the <att>type</att> attribute on the
symbol, defaulting to <cdref cd="set1"/>, but <cdref cd="multiset1"/>
should be used if <att>type</att>=<attval>multiset</attval>.</p>
</div5>
</div4>

<div4 id="contm_nary_unary">
  <head>N-ary/Unary Operators (classes nary-minmax, nary-stats)</head>
<p>The MathML elements, <el>max</el>, <el>min</el> and some statistical
elements such as <el>mean</el> may be used  as a n-ary function as in
the above classes, however a special interpretation is given in the
case that a single argument is supplied. If a single argument is
supplied the function is applied to the elements represented by the
argument.</p>
<p>The underlying symbol used in Strict Content MathML for these
elements is <emph>Unary</emph> and so if the MathML is used with
0 or more than 1 arguments, the function is applied to the set
constructed from the explicitly supplied arguments according to the
following rule.</p>

<div5 id="contm_nary_unary_schema"><head>Schema Patterns</head>
<p>The elements representing these n-ary operators are
specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">nary-minmax.class</kw>, <kw role="parsing_ref">nary-stats.class</kw>.</p>
</div5>
<div5 id="contm_nary_unary_rewrite"><head>Rewriting to Strict Content MathML</head>
<div id="contm_p2s.max" role="strict-mathml-example">
           <head>Rewrite: n-ary unary set</head>
<p>When an element,
<code meta="max"><![CDATA[<max/>]]></code>, of class nary-stats or nary-minmax
 is applied to an explicit
list of  0 or 2 or more arguments,
<code meta="ci"><![CDATA[<ci>a1</ci><ci>a2</ci><ci>an</ci>]]></code> </p>
<eg meta="ci max" role="mathml"><![CDATA[
<apply><max/><ci>a1</ci><ci>a2</ci><ci>an</ci></apply>]]></eg>
<p>It is is translated to the unary application of the symbol
<code meta="@-minmax1 @-max"><![CDATA[<csymbol cd="minmax1" name="max"/>]]></code>
as specified in the syntax table for the element to the set of
arguments, constructed using the
<code><![CDATA[<csymbol cd="set1" name="set"/>]]></code>
symbol.</p>
<eg meta="ci  @-minmax1 #-max" role="strict-mathml"><![CDATA[
<apply><csymbol cd="minmax1">max</csymbol>
  <apply><csymbol cd="set1">set</csymbol>
    <ci>a1</ci><ci>a2</ci><ci>an</ci>
  </apply>
</apply>]]></eg>
</div>
<p>Like all MathML n-ary operators, The list of arguments may be
specified implicitly using qualifier elements. This is expressed in
Strict Content MathML using the following rule, which is similar to
the rule <specref ref="contm_p2s.lifted"/> but differs in that the
symbol can be directly applied to the constructed set of arguments and
it is not necessary to use <symbolref cd="fns2"
name="apply_to_list"/>.</p>

<div id="contm_unary_nary_doma" role="strict-mathml-example">
           <head>Rewrite: n-ary unary domainofapplication</head>
<p>An expression of the following form,
where <code meta="max"><![CDATA[<max/>]]></code> represents any
 element of the relevant class and 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
is an arbitrary expression involving the bound variable(s)
<eg meta="ci max" role="mathml"><![CDATA[
<apply><max/>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x</ci>
</apply>]]></eg>
is rewritten to 
<eg meta="ci #-max @-minmax1" role="strict-mathml"><![CDATA[
<apply><csymbol cd="minmax1">max</csymbol>
  <apply><csymbol cd="set1">map</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <ci>expression-in-x</ci>
    </bind>
    <ci>D</ci>
  </apply>
</apply>]]></eg></p>

<p>Note that
  when <code meta="ci"><![CDATA[<ci>D</ci>]]></code> is already a set
  and the lambda function created from <code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is
  the identity, the <el>domainofapplication</el> term should should be
  rewritten directly
  as <code meta="ci"><![CDATA[<ci>D</ci>]]></code>.</p> 

</div>
<p>If the element is applied to a single argument the
<symbolref cd="set1" name="set"/> symbol is not used and the symbol is
applied directly to the argument.</p>
<div id="contm_nary_unary_single" role="strict-mathml-example">
           <head>Rewrite: n-ary unary single</head>
<p>When an element,
<code meta="max"><![CDATA[<max/>]]></code>, of class nary-stats or nary-minmax
 is applied to a single argument,</p>
<eg meta="ci max" role="mathml"><![CDATA[
<apply><max/><ci>a</ci></apply>]]></eg>
<p>It is is translated to the unary application of the symbol
in the syntax table for the element.</p>
<eg meta="ci  @-minmax1 #-max" role="strict-mathml"><![CDATA[
<apply><csymbol cd="minmax1">max</csymbol> <ci>a</ci> </apply>]]></eg>
</div>
<p>Note: Earlier versions of MathML were not explicit about the correct
interpretation of elements in this class, and left it undefined as to
whether an expression such as max(X) was a trivial application of max
to a singleton, or whether it should be interpreted as meaning the
maximum of values of the set X. Applications finding that the rule 
<specref ref="contm_nary_unary_single"/> can not be applied as the
supplied argument is a scalar may wish to use the rule
<specref ref="contm_p2s.max"/> as an error recovery.
As a further complication, in the case of the statistical functions
the Content Dictionary to use in this case depends on the desired
interpretation of the argument as a set of explicit data or a random
variable representing a distribution. </p>

</div5>
</div4>
<div4 id="contm_binary">
  <head>Binary Operators (classes binary-arith, binary-logical, binary-reln, binary-linalg, binary-set)</head>
<p>Binary operators take two arguments and simply map to OpenMath
symbols via <intref ref="contm_strict-opel">Rewrite: element</intref>
without the need of any special rewrite rules. The binary 
constructor <el>interval</el> is similar but uses constructor syntax
in which the arguments are children of the element, and the symbol
used depends on the type element as described in <specref
ref="contm_interval"/> </p> 

<div5 id="contm_binary_schema"><head>Schema Patterns</head>
<p>The elements representing these binary operators are
specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">binary-arith.class</kw>,
<kw role="parsing_ref">binary-logical.class</kw>,
<kw role="parsing_ref">binary-reln.class</kw>,
<kw role="parsing_ref">binary-linalg.class</kw>,
<kw role="parsing_ref">binary-set.class</kw>.</p>
</div5>
</div4>

<div4 id="contm_unary">
  <head>Unary Operators (classes unary-arith, unary-linalg, unary-functional, unary-set, unary-elementary, unary-veccalc)</head>
<p>Unary operators take a single argument and map to OpenMath symbols
via <intref ref="contm_strict-opel">Rewrite: element</intref> without the need of any special rewrite rules.</p> 
<div5 id="contm_unary_schema"><head>Schema Patterns</head>
<p>The elements representing these unary operators are
specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">unary-arith.class</kw>,
<kw role="parsing_ref">unary-functional.class</kw>,
<kw role="parsing_ref">unary-set.class</kw>,
<kw role="parsing_ref">unary-elementary.class</kw>,
<kw role="parsing_ref">unary-veccalc.class</kw>.</p>
</div5>
</div4>


<div4 id="contm_constant">
  <head>Constants (classes constant-arith, constant-set)</head>
<p>Constant symbols relate to mathematical constants such as e and true and
also to names of sets such as the Real Numbers, and Integers.
In Strict Content MathML, they rewrite simply to the corresponding
symbol listed in the syntax tables for these elements in <specref ref="contm_constantsandsymbols"/>.
</p>
<div5 id="contm_constant_schema"><head>Schema Patterns</head>
<p>The elements representing these constants are
specified in the schema patterns 
<kw role="parsing_ref">constant-arith.class</kw> and  <kw role="parsing_ref">constant-set.class</kw>.</p>
</div5>

</div4>

<div4 id="contm_quantifier">
  <head>Quantifiers (class quantifier)</head>
<p>The Quantifier class is used for the forall and exists quantifiers
of predicate calculus.</p>

<div5 id="contm_quantifier_schema"><head>Schema Patterns</head>
<p>The elements representing quantifiers are
specified in the schema pattern <kw role="parsing_ref">quantifier.class</kw>.</p>
</div5>

<div5 id="contm_quantifier_rewrite"><head>Rewriting to Strict Content MathML</head>
<p>If used with <el>bind</el> and no qualifiers,
then the interpretation in Strict Content MathML is simple. In general
if used with <el>apply</el> or qualifiers, the interpretation in
Strict Content MathML is via the following rule.</p>
<div id="contm_rewrite_quantifier" role="strict-mathml-example">
           <head>Rewrite: quantifier</head>

<p> An expression of following form where
<code meta="exists"><![CDATA[<exists/>]]></code> denotes an element of
class <kw>quantifier</kw> and 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
is an arbitrary expression involving the bound variable(s)
<eg meta="ci exists" role="mathml"><![CDATA[
<apply><exists/>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x</ci>
</apply>]]></eg>
is rewritten to an expression 
<eg meta="ci #-and #-exists @-logic1  @-quant1" role="strict-mathml"><![CDATA[
<bind><csymbol cd="quant1">exists</csymbol>
  <bvar><ci>x</ci></bvar>
  <apply><csymbol cd="logic1">and</csymbol>
    <apply><csymbol cd="set1">in</csymbol><ci>x</ci><ci>D</ci></apply>
  <ci>expression-in-x</ci>
  </apply>
</bind>
]]></eg>
where the symbols
<code meta="#-exists @-quant1"><![CDATA[<csymbol cd="quant1">exists</csymbol>]]></code>
and
<code meta="#-and @-logic1"><![CDATA[<csymbol cd="logic1">and</csymbol>]]></code>
are as specified in the syntax table of the element.
(The additional symbol being  
<symbolref cd="logic1" name="and"/> in the case of <el>exists</el> and 
<symbolref cd="logic1" name="implies"/> in the case of <el>forall</el>.) <phrase>When no 
<el>domainofapplication</el> is present, no logical conjunction is necessary, and the translation 
is direct.</phrase>
</p>
</div>
</div5>
</div4>

<div4 id="contm_otherclass">
  <head>Other Operators (classes lambda, interval, int, diff partialdiff, sum, product, limit)</head>
<p>Special purpose classes, described in the sections for the
appropriate elements</p>
<div5 id="contm_otherclass_schema"><head>Schema Patterns</head>
<p>The elements are specified in the following schema patterns in <specref ref="parsing"/>:
<kw role="parsing_ref">lambda.class</kw>,
<kw role="parsing_ref">interval.class</kw>,
<kw role="parsing_ref">int.class</kw>,
<kw role="parsing_ref">partialdiff.class</kw>,
<kw role="parsing_ref">sum.class</kw>,
<kw role="parsing_ref">product.class</kw>,
<kw role="parsing_ref">limit.class</kw>.</p>
</div5>
</div4>

    </div3>
<div3>
<head>Non-strict Attributes</head>

<p>A number of content MathML elements such as <el>cn</el> and
<el>interval</el> allow attributes to specialize the semantics of the
objects they represent.  For these cases, special rewrite rules are
given on a case-by-case basis in <specref ref="contm_opel"/>. However,
content MathML elements also accept <intref
ref="fund_globatt">attributes shared all MathML elements</intref>, and
depending on the context, may also contain attributes from other XML
namespaces.  Such attributes must be rewritten in alternative form in
Strict Content Markup.</p>

    <div id="contm_strict-attributes" role="strict-mathml-example">
      <head>Rewrite: attributes</head>
      <p> For instance,  
<eg meta="@-http://example.com @-foo @-bla other:att xmlns:other #-x" role="mathml"><![CDATA[
<ci class="foo" xmlns:other="http://example.com" other:att="bla">x</ci>]]></eg>
is rewritten to 
<eg meta="#-http://example.com #-bla #-foo #-other #-att #-other #-x" role="strict-mathml"><![CDATA[
<semantics>
  <ci>x</ci>
  <annotation cd="mathmlattr"
     name="class" encoding="text/plain">foo</annotation>
  <annotation-xml cd="mathmlattr" name="foreign" encoding="MathML-Content">
    <apply><csymbol cd="mathmlattr">foreign_attribute</csymbol>
      <cs>http://example.com</cs>
      <cs>other</cs>
      <cs>att</cs>
      <cs>bla</cs>
    </apply>
  </annotation-xml>
</semantics>]]></eg>

For MathML attributes not allowed in Strict Content MathML the content
dictionary <cdref cd="mathmlattr"/> is referenced, which provides
symbols for all attributes allowed on content MathML
elements.</p>
</div>
</div3>
</div2>

  <div2 id="contm_opel">
    <head>Content MathML for Specific Operators and Constants</head>

    <p>This section presents elements representing a core set of
    mathematical operators, functions and constants.  Most are empty
    elements, covering the subject matter of standard mathematics
    curricula up to the level of calculus.  The remaining elements are
    <intref ref="contm_container">container</intref> elements for
    sets, intervals, vectors and so on.  For brevity, all elements
    defined in this section are sometimes called <emph>operator
    elements</emph>.</p>

    <p>Each subsection below discusses a specific operator element,
    beginning with a syntax table, giving the elements <intref
    ref="contm_opclasses">operator class</intref>.  Special case rules
    for rewriting as Strict Markup are introduced as needed.
    However, in most cases, the generic rewrite rules for the
    appropriate operator class is sufficient.  In particular, unless
    otherwise indicated, elements are to be rewritten using the
    default <intref ref="contm_strict-opel">Rewrite: element</intref>
    rule.  Note, however, that all elements in this section must be rewritten in
    some fashion, since they are not allowed in Strict Content markup.</p>

    <p>In MathML 2, the <att>definitionURL</att> attribute could be
    used to redefine or modify the meaning of an operator
    element. This use of the <att>definitionURL</att> attribute is <intref
    ref="interf_deprec">deprecated</intref> in MathML 3. Instead a
    <el>csymbol</el> element should be used.  In general, the value of
    <att>cd</att> attribute on the <el>csymbol</el> will correspond to
    the <att>definitionURL</att> value.</p>

    <issue role="closed" id="ops_attribs" tracker="11">
      <head>Operator elements with Attributes</head>
      <p>In MathML 2, the meaning of various operator elements could be specialized via
      various attributes, usually the <att>type</att> attribute. Strict Content MathML
      does not have this possibility</p>
     <resolution><p>We pass these attributes
      as extra arguments in the <el>apply</el> (or <el>bind</el> elements), or add new
      symbols for the non-default case to the respective content dictionaries.</p></resolution>
    </issue>

<div3 id="contm_basicfun"><head>Functions and Inverses</head>
<div4 id="contm_interval"><head>Interval <el role="defn starttag">interval</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">interval</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>,<kw role="parsing_ref">closure</kw>?</td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>,<kw role="parsing_ref">ContExp</kw></td></tr>
<tr><th>OM Symbols</th>
     <td>
       <symbolref cd="interval1" name="interval_cc"/>, 
       <symbolref cd="interval1" name="interval_oc"/>, 
       <symbolref cd="interval1" name="interval_co"/>, 
       <symbolref cd="interval1" name="interval_oo"/>
     </td>
</tr>
</tbody>
</table>

<p>The <el>interval</el> element is a container element used to represent simple mathematical intervals of the
real number line.  It takes an optional attribute <att>closure</att>, with a default value
of <attval>closed</attval>.</p>

<div id="interval1.interval.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<interval closure="open"><ci>x</ci><cn>1</cn></interval>]]></eg>
<eg role="mathml"><![CDATA[
<interval closure="closed"><cn>0</cn><cn>1</cn></interval>]]></eg>
<eg role="mathml"><![CDATA[
<interval closure="open-closed"><cn>0</cn><cn>1</cn></interval>]]></eg>
<eg role="mathml"><![CDATA[
<interval closure="closed-open"><cn>0</cn><cn>1</cn></interval>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mfenced><mi>x</mi><mn>1</mn></mfenced>]]></eg>
<graphic source="image/interval1-interval_oo-ex1.gif" alt="{\left(x,{1}\right)}"/>
<eg role="mathml"><![CDATA[
<mfenced open="[" close="]"><mn>0</mn><mn>1</mn></mfenced>]]></eg>
<graphic source="image/interval1-interval_cc-ex1.gif" alt="{\left[{0},{1}\right]}"/>
<eg role="mathml"><![CDATA[
<mfenced open="(" close="]"><mn>0</mn><mn>1</mn></mfenced>]]></eg>
<graphic source="image/interval1-interval_oc-ex1.gif" alt="{\left({0},{1}\right]}"/>
<eg role="mathml"><![CDATA[
<mfenced open="[" close=")"><mn>0</mn><mn>1</mn></mfenced>]]></eg>
<graphic source="image/interval1-interval_co-ex1.gif" alt="{\left[{0},{1}\right)}"/>
</div>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>In Strict markup, the <el>interval</el> element corresponds to one
of four symbols from the <cdref cd="interval1"/> content
dictionary. If <att>closure</att> has the value <attval>open</attval> then
<el>interval</el> corresponds to the
<symbolref cd="interval1" name="interval_oo"/>.
With the value <attval>closed</attval>
<el>interval</el> corresponds to the symbol
<symbolref cd="interval1" name="interval_cc"/>,
with value <attval>open-closed</attval> to
<symbolref cd="interval1" name="interval_oc"/>, and with
<attval>closed-open</attval> to
<symbolref cd="interval1" name="interval_co"/>.</p>
</div4>

<div4 id="contm_inverse">
<head>Inverse <el role="defn starttag">inverse</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="inverse"/></td></tr>
</tbody>
</table>

<p>The <el>inverse</el> element is applied to a function in order to
construct a generic expression for the functional inverse of that
function. The <el>inverse</el> element may either be applied to
arguments, or it may appear alone, in which case it represents an
abstract inversion operator acting on other functions.</p>
<div id="fns1.inverse.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><inverse/>
  <ci> f </ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msup><mi>f</mi><mrow><mo>(</mo><mn>-1</mn><mo>)</mo></mrow></msup>]]></eg>
<graphic source="image/fns1-inverse-ex1.gif" alt="{\msup{f}{{\left.\middle({\mn{-1}}\middle)\right.}}}"/>
</div>

<div id="fns1.inverse.ex2" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply>
  <apply><inverse/><ci type="matrix">A</ci></apply>
  <ci>a</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mi>A</mi><mrow><mo>(</mo><mn>-1</mn><mo>)</mo></mrow></msup>
 <mo>&#x2061;</mo>
 <mfenced><mi>a</mi></mfenced>
</mrow>]]></eg>
<graphic source="image/fns1-inverse-ex2.gif" alt="{\msup{A}{{\left.\middle({\mn{-1}}\middle)\right.}}\unicode{8289}{\left(a\right)}}"/>
</div>
</div4>

<div4 id="contm_lambda"><head>Lambda <el role="defn starttag">lambda</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">lambda</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">BvarQ</kw>, <kw role="parsing_ref">DomainQ</kw>, <kw role="parsing_ref">ContExp</kw></td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="lambda"/></td></tr>
</tbody>
</table>

<p>The <el>lambda</el> element is used to construct a user-defined
function from an expression, bound variables, and qualifiers. In a
lambda construct with <var>n</var> (possibly 0) bound variables, the
first <var>n</var> children are <el>bvar</el> elements that identify
the variables that are used as placeholders in the last child for
actual parameter values. The bound variables can be restricted by an
optional <el>domainofapplication</el> qualifier or one of its
<intref ref="contm_domainofapplication_qualifier">shorthand
notations</intref>. The meaning of the <el>lambda</el> construct is an
<var>n</var>-ary function that returns the expression in the last
child where the bound variables are replaced with the respective
arguments.</p>

<p>The <el>domainofapplication</el> child restricts the possible
values of the arguments of the constructed function. For instance, the
following <el>lambda</el> construct represents a function on
the integers.

<eg role="mathml"><![CDATA[
<lambda>
  <bvar><ci> x </ci></bvar>
  <domainofapplication><integers/></domainofapplication>
  <apply><sin/><ci> x </ci></apply>
</lambda>]]></eg>

If a <el>lambda</el> construct does not contain bound variables, then
the <el>lambda</el> construct is superfluous and may be removed,
unless it also contains a <el>domainofapplication</el> construct.  
In that case, if the last child of the <el>lambda</el> construct is
itself a function, then the <el>domainofapplication</el> restricts
its existing functional arguments, as in this example, which is
a variant representation for the function above.  

<eg role="mathml"><![CDATA[
<lambda>
  <domainofapplication><integers/></domainofapplication> 
  <sin/>
</lambda>]]></eg>  

Otherwise, if the last child of the <el>lambda</el> construct is not a
function, say a number, then the <el>lambda</el> construct will not be
a function, but the same number, and any <el>domainofapplication</el>
is ignored.</p>


<div id="fns1.lambda.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<lambda>
  <bvar><ci>x</ci></bvar>
  <apply><sin/>
    <apply><plus/><ci>x</ci><cn>1</cn></apply>
  </apply>
</lambda>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>&#x3bb;</mi>
 <mi>x</mi>
 <mo>.</mo>
 <mfenced>
  <mrow>
   <mi>sin</mi>
   <mo>&#x2061;</mo>
   <mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
  </mrow>
 </mfenced>
</mrow>]]></eg>


<graphic source="image/fns1-lambda-ex2.gif" alt="{\unicode{955}x.{\left({\mathop{{\minormal{sin}}}{\left.\middle(x+{1}\middle)\right.}}\right)}}"/>

<eg role="mathml"><![CDATA[
<mrow>
 <mi>x</mi>
 <mo>&#x21a6;</mo>
  <mrow>
   <mi>sin</mi>
   <mo>&#x2061;</mo>
   <mrow><mo>(</mo><mi>x</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
  </mrow>
</mrow>]]></eg>

<graphic source="image/fns1-lambda-ex2-2.gif" alt="{x\unicode{8614}{\mathop{{\minormal{sin}}}{\left.\middle(x+{1}\middle)\right.}}}"/>

</div>

<p><emph>Mapping to Strict Markup</emph></p>

<div id="contm_rewrite_lambda" role="strict-mathml-example">
           <head>Rewrite: lambda</head>
<p>If the <el>lambda</el> element does not contain qualifiers, the
lambda expression is directly translated into a <el>bind</el>
expression.</p>
<eg meta="ci" role="mathml"><![CDATA[
<lambda>
  <bvar><ci>x1</ci></bvar><bvar><ci>xn</ci></bvar>
  <ci>expression-in-x1-xn</ci>
</lambda>]]></eg>
<p>rewrites to the Strict Content MathML</p>
<eg meta="ci" role="mathml"><![CDATA[
<bind><csymbol cd="fns1">lambda</csymbol>
  <bvar><ci>x1</ci></bvar><bvar><ci>xn</ci></bvar>
  <ci>expression-in-x1-xn</ci>
</bind>]]></eg>
</div>

<div id="contm_rewrite_lambda_domofa" role="strict-mathml-example">
           <head>Rewrite: lambda domainofapplication</head>
<p>If the <el>lambda</el> element does contain qualifiers, the
qualifier may be rewritten to <el>domainofapplication</el>
and then the lambda expression is translated to a
function term constructed with <symbolref cd="fns1" name="lambda"/>
and restricted to the specified domain using 
<symbolref cd="fns1" name="restriction"/>.</p>

<eg meta="ci" role="mathml"><![CDATA[
<lambda>
  <bvar><ci>x1</ci></bvar><bvar><ci>xn</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x1-xn</ci>
</lambda>]]></eg>
<p>rewrites to the Strict Content MathML</p>
<eg meta="ci" role="mathml"><![CDATA[
<apply><csymbol cd="fns1">restriction</csymbol>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x1</ci></bvar><bvar><ci>xn</ci></bvar>
    <ci>expression-in-x1-xn</ci>
  </bind>
  <ci>D</ci>
</apply>]]></eg>
</div>

</div4>

<div4 id="contm_compose"><head>Function composition <el role="defn emptytag">compose</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="left_compose"/></td></tr>
</tbody>
</table>

<p>The <el>compose</el> element represents the function
composition operator. Note that MathML makes no assumption about the domain
and codomain of the constituent functions in a composition; the domain of the
resulting composition may be empty.</p>

<p>The <el>compose</el> element is a commutative n-ary operator.  Consequently, it may be
lifted to the induced operator defined on a collection of arguments indexed by a (possibly
infinite) set by using qualifier elements as described in <specref ref="contm_nary"/>.
</p>

<div id="fns1.compose.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><compose/><ci>f</ci><ci>g</ci><ci>h</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>f</mi><mo>&#x2218;</mo><mi>g</mi><mo>&#x2218;</mo><mi>h</mi>
</mrow>]]></eg>
<graphic source="image/fns1-compose-ex1.gif" alt="{f\unicode{8728}g\unicode{8728}h}"/>
</div>

<div id="fns1.compose.ex2" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply>
    <apply><compose/><ci>f</ci><ci>g</ci></apply>
    <ci>x</ci>
  </apply>
  <apply><ci>f</ci><apply><ci>g</ci><ci>x</ci></apply></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow>
  <mrow><mo>(</mo><mi>f</mi><mo>&#x2218;</mo><mi>g</mi><mo>)</mo></mrow>
  <mo>&#x2061;</mo>
  <mfenced><mi>x</mi></mfenced>
 </mrow>
 <mo>=</mo>
 <mrow>
  <mi>f</mi>
  <mo>&#x2061;</mo>
  <mfenced>
   <mrow>
    <mi>g</mi>
    <mo>&#x2061;</mo>
    <mfenced><mi>x</mi></mfenced>
  </mrow>
 </mfenced>
 </mrow>
</mrow>]]></eg>

<graphic source="image/fns1-compose-ex2.gif" alt="{{{\left.\middle(f\unicode{8728}g\middle)\right.}\unicode{8289}{\left(x\right)}}={\mathop{f}{\left({\mathop{g}{\left(x\right)}}\right)}}}"/>
</div>
</div4>

<div4 id="contm_ident"><head>Identity function <el role="defn emptytag">ident</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="identity"/></td></tr>
</tbody>
</table>

  <p>The <el>ident</el> element represents the
  identity function. Note that MathML makes no assumption about the
  domain and codomain of the represented identity function, which
  depends on the context in which it is used.</p>

  <div id="fns1.ident.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><compose/>
    <ci type="function">f</ci>
    <apply><inverse/>
      <ci type="function">f</ci>
    </apply>
  </apply>
  <ident/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow>
  <mi>f</mi>
  <mo>&#x2218;</mo>
  <msup><mi>f</mi><mrow><mo>(</mo><mn>-1</mn><mo>)</mo></mrow></msup>
 </mrow>
 <mo>=</mo>
 <mi>id</mi>
</mrow>]]></eg>

<graphic source="image/fns1-ident-ex1.gif" alt="{{f\unicode{8728}\msup{f}{{\left.\middle({\mn{-1}}\middle)\right.}}}={\minormal{id}}}"/>
</div>
</div4>

<div4 id="contm_domain"><head>Domain <el role="defn emptytag">domain</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="domain"/></td></tr>
</tbody>
</table>

  <p>The <el>domain</el> element represents the domain of the
  function to which it is applied.  The domain is the set of values
  over which the function is defined.</p>

  <div id="fns1.domain.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><domain/><ci>f</ci></apply>
  <reals/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>domain</mi><mo>&#x2061;</mo><mfenced><mi>f</mi></mfenced></mrow>
 <mo>=</mo>
 <mi mathvariant="double-struck">R</mi>
</mrow>]]></eg>

<graphic source="image/fns1-domain-ex1.gif" alt="{{\mathop{{\minormal{domain}}}{\left(f\right)}}={\midoublestruck{R}}}"/>
</div>
</div4>

<div4 id="contm_codomain"><head>codomain <el role="defn emptytag">codomain</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="range"/></td></tr>
</tbody>
</table>

  <p>The <el>codomain</el> represents the codomain, or range, of the function
  to which is is applied.  Note that the codomain is not necessarily
  equal to the image of the function, it is merely required to contain
  the image.</p>

  <div id="fns1.range.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><codomain/><ci>f</ci></apply>
  <rationals/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>codomain</mi><mo>&#x2061;</mo><mfenced><mi>f</mi></mfenced></mrow>
 <mo>=</mo>
 <mi mathvariant="double-struck">Q</mi>
</mrow>]]></eg>

<graphic source="image/fns1-range-ex1.gif" alt="{{\mathop{{\minormal{codomain}}}{\left(f\right)}}={\midoublestruck{Q}}}"/>
</div>
</div4>

<div4 id="contm_image"><head>Image <el role="defn emptytag">image</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="fns1" name="image"/></td></tr>
</tbody>
</table>

  <p>The <el>image</el> element represent the image of
  the function to which it is applied. The image of a function is the
  set of values taken by the function. Every point in the image is
  generated by the function applied to some point of the domain.</p>

  <div id="fns1.image.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><image/><sin/></apply>
  <interval><cn>-1</cn><cn> 1</cn></interval>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>image</mi><mo>&#x2061;</mo><mfenced><mi>sin</mi></mfenced></mrow>
 <mo>=</mo>
 <mfenced open="[" close="]"><mn>-1</mn><mn>1</mn></mfenced>
</mrow>]]></eg>

<graphic source="image/fns1-image-ex1.gif" alt="{{\mathop{{\minormal{image}}}{\left({\minormal{sin}}\right)}}={\left[{\mn{-1}},{1}\right]}}"/>
</div>
</div4>

<div4 id="contm_piecewise">
<head>Piecewise declaration <el role="defn starttag">piecewise</el>, <el role="defn starttag">piece</el>, <el role="defn starttag">otherwise</el></head>

<table>
<tbody>
<tr>
<td>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_container_constructor">Constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">piece</kw>* 
<kw role="parsing_ref">otherwise</kw>?</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="piece1" name="piecewise"/></td></tr>
</tbody>
</table>

<emph>Syntax Table for <el>piecewise</el></emph>
</td>
<td>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_container_constructor">Constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw> <kw role="parsing_ref">ContExp</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="piece1" name="piece"/></td></tr>
</tbody>
</table>

<emph>Syntax Table for <el>piece</el></emph>
</td>
<td>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_container_constructor">Constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="piece1" name="otherwise"/></td></tr>
</tbody>
</table>

<emph>Syntax Table for <el>otherwise</el></emph>
</td>
</tr></tbody></table>

<p>The <el>piecewise</el>, <el>piece</el>, and <el>otherwise</el> elements are used to
represent <quote>piecewise</quote> function definitions of the form <quote>
<var>H</var>(<var>x</var>) = 0 if <var>x</var> less than 0, <var>H</var>(<var>x</var>) = 1
otherwise</quote>.</p>

<p>The declaration is constructed using the <el>piecewise</el> element.  This contains
zero or more <el>piece</el> elements, and optionally one <el>otherwise</el> element. Each
<el>piece</el> element contains exactly two children. The first child defines the value
taken by the <el>piecewise</el> expression when the condition specified in the associated
second child of the <el>piece</el> is true.  The degenerate case of no <el>piece</el>
elements and no <el>otherwise</el> element is treated as undefined for all values of the
domain.</p>

<p>The <el>otherwise</el> element allows the specification of a value to be taken by the
<el>piecewise</el> function when none of the conditions (second child elements of the
<el>piece</el> elements) is true, i.e. a default value.</p>

 <p>It should be noted that no <quote>order of execution</quote> is implied by the
 ordering of the <el>piece</el> child elements within <el>piecewise</el>. It is the
 responsibility of the author to ensure that the subsets of the function domain defined by
 the second children of the <el>piece</el> elements are disjoint, or that, where they
 overlap, the values of the corresponding first children of the <el>piece</el> elements
 coincide. If this is not the case, the meaning of the expression is
 undefined.</p>

<p>Here is an example:</p>

<div id="piece1.piecewise.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<piecewise>
  <piece>
    <apply><minus/><ci>x</ci></apply>
    <apply><lt/><ci>x</ci><cn>0</cn></apply>
  </piece>
  <piece>
    <cn>0</cn>
    <apply><eq/><ci>x</ci><cn>0</cn></apply>
  </piece>
  <piece>
    <ci>x</ci>
    <apply><gt/><ci>x</ci><cn>0</cn></apply>
  </piece>
</piecewise>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo>
 <mtable>
  <mtr>
   <mtd><mrow><mo>&#x2212;</mo><mi>x</mi></mrow></mtd>
   <mtd columnalign="left"><mtext>&#xa0; if &#xa0;</mtext></mtd>
   <mtd><mrow><mi>x</mi><mo>&lt;</mo><mn>0</mn></mrow></mtd>
  </mtr>
  <mtr>
   <mtd><mn>0</mn></mtd>
   <mtd columnalign="left"><mtext>&#xa0; if &#xa0;</mtext></mtd>
   <mtd><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow></mtd>
  </mtr>
  <mtr>
   <mtd><mi>x</mi></mtd>
   <mtd columnalign="left"><mtext>&#xa0; if &#xa0;</mtext></mtd>
   <mtd><mrow><mi>x</mi><mo>&gt;</mo><mn>0</mn></mrow></mtd>
  </mtr>
 </mtable>
</mrow>]]></eg>

<graphic source="image/piece1-piecewise-ex1.gif"
alt="{\left.\middle\{{\begin{matrix}{\unicode{8722}x}\endcell{\mathrm{\unicode{160}~if~\unicode{160}}}\endcell{x\lt{0}}\\{0}\endcell{\mathrm{\unicode{160}~if~\unicode{160}}}\endcell{x={0}}\\x\endcell{\mathrm{\unicode{160}~if~\unicode{160}}}\endcell{x\gt{0}}\end{matrix}}\right.}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

 <p>In Strict Content MathML, the container elements
 <el>piecewise</el>, <el>piece</el> and <el>otherwise</el> are mapped
 to applications of the constructor symbols of the same names in the
 <cdref cd="piece1"/> CD.  Apart from the fact that these three
 elements (respectively symbols) are used together, the mapping to
 Strict markup is straightforward:</p>

<div id="contm_piecewise-example" role="strict-mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<piecewise>
  <piece>
    <cn>0</cn>
    <apply><lt/><ci>x</ci><cn>0</cn></apply>
  </piece>
  <piece>
    <cn>1</cn>
    <apply><gt/><ci>x</ci><cn>1</cn></apply>
  </piece>
  <otherwise>
    <ci>x</ci>
  </otherwise>
</piecewise>]]></eg>

<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="piece1">piecewise</csymbol>
  <apply><csymbol cd="piece1">piece</csymbol>
    <cn>0</cn>
    <apply><csymbol cd="relation1">lt</csymbol><ci>x</ci><cn>0</cn></apply>  
  </apply>   
  <apply><csymbol cd="piece1">piece</csymbol>
    <cn>1</cn>
    <apply><csymbol cd="relation1">gt</csymbol><ci>x</ci><cn>1</cn></apply>  
  </apply>   
  <apply><csymbol cd="piece1">otherwise</csymbol>
    <ci>x</ci>
  </apply>   
</apply>]]></eg>
</div>

</div4>
</div3>

<div3><head>Arithmetic, Algebra and Logic</head>

<div4 id="contm_quotient">
<head>Quotient <el role="defn emptytag">quotient</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="integer1" name="quotient"/></td></tr>
</tbody>
</table>

  <p>The <el>quotient</el> element represents the integer division
  operator. When the operator is applied to integer arguments
  <var>a</var> and <var>b</var>, the result is the <quote>quotient of
  <var>a</var> divided by <var>b</var></quote>. That is, the quotient
  of integers <var>a</var> and <var>b</var>, is the integer
  <var>q</var> such that <var>a</var> = <var>b</var> * <var>q</var> +
  <var>r</var>, with |<var>r</var>| less than |<var>b</var>| and
  <var>a</var> * <var>r</var> positive. In common usage, <var>q</var>
  is called the quotient and <var>r</var> is the remainder. </p>

  <div id="integer1.quotient.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><quotient/><ci>a</ci><ci>b</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>&#x230a;</mo><mi>a</mi><mo>/</mo><mi>b</mi><mo>&#x230b;</mo></mrow>]]></eg>

<graphic source="image/integer1-quotient-ex1.gif" alt="{\unicode{8970}a/b\unicode{8971}}"/>
</div>
</div4>

<div4 id="contm_factorial"><head>Factorial <el role="defn emptytag">factorial</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="integer1" name="factorial"/></td></tr>
</tbody>
</table>
  <p>This element represents the unary factorial operator on non-negative integers.</p>
  <p>The factorial of an integer <var>n</var> is given by <var>n</var>! = <var>n</var>*(<var>n</var>-1)* ... * 1</p>
  <div id="integer1.factorial.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><factorial/><ci>n</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>n</mi><mo>!</mo></mrow>]]></eg>

<graphic source="image/integer1-factorial-ex1.gif" alt="{n!}"/>
</div>
</div4>

<div4 id="contm_divide"><head>Division <el role="defn emptytag">divide</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="divide"/></td></tr>
</tbody>
</table>

  <p>The <el>divide</el> element represents the division operator in a
  number field.</p>

  <div id="arith1.divide.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><divide/>
  <ci>a</ci>
  <ci>b</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>/</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/arith1-divide-ex1.gif" alt="{a/b}"/>
</div>
</div4>

<div4 id="contm_max">
<head>Maximum <el role="defn emptytag">max</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-minmax</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>  
<tr><th>OM Symbols</th><td><symbolref cd="minmax1" name="max"/></td></tr>
</tbody>
</table>

  <p>The <el>max</el> element denotes the maximum function, which
  returns the largest of the arguments to which it is applied.  Its
  arguments may be explicitly specified in the enclosing
  <el>apply</el> element, or specified using qualifier elements
  as described in <specref ref="contm_nary_unary"/>.  Note that when applied to
  infinite sets of arguments, no maximal argument may exist.</p>

<div id="minmax1.max.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><max/><cn>2</cn><cn>3</cn><cn>5</cn></apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>max</mi>
 <mrow>
  <mo>{</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo>}</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/minmax1-max-ex1.gif" alt="{{\minormal{max}}{\left.\middle\{{2},{3},{5}\middle\}\right.}}"/>
</div>


<div id="minmax1.big_max.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><max/>
  <bvar><ci>y</ci></bvar>
  <condition>
    <apply><in/>
      <ci>y</ci>
      <interval><cn>0</cn><cn>1</cn></interval>
    </apply>
  </condition>
  <apply><power/><ci>y</ci><cn>3</cn></apply>
</apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>max</mi>
 <mrow>
  <mo>{</mo><mi>y</mi><mo>|</mo>
  <mrow>
   <msup><mi>y</mi><mn>3</mn></msup>
   <mo>&#x2208;</mo>
   <mfenced open="[" close="]"><mn>0</mn><mn>1</mn></mfenced>
  </mrow>
  <mo>}</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/minmax1-big_max-ex1.gif" alt="{{\minormal{max}}{\left.\middle\{y^3\middle|{y\unicode{8712}{\left[{0},{1}\right]}}\middle\}\right.}}"/>
</div>
</div4>

<div4 id="contm_min">
<head>Minimum <el role="defn emptytag">min</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-minmax</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="minmax1" name="min"/></td></tr>
</tbody>
</table>

  <p>The <el>min</el> element denotes the minimum function, which returns the smallest of
  the arguments to which it is applied.  Its arguments may be explicitly specified in the
  enclosing <el>apply</el> element, or specified using qualifier
  elements as described in <specref ref="contm_nary_unary"/>.  Note that when applied to infinite sets of arguments, no
  minimal argument may exist.</p>

<div id="minmax1.min.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><min/><ci>a</ci><ci>b</ci></apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>min</mi>
 <mrow><mo>{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>}</mo></mrow>
</mrow>]]></eg>

<graphic source="image/minmax1-min-ex1.gif" alt="{{\minormal{min}}{\left.\middle\{a,b\middle\}\right.}}"/>
</div>


<div id="minmax1.big_min.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><min/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><notin/><ci>x</ci><ci type="set">B</ci></apply>
  </condition>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
</apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>min</mi>
 <mrow><mo>{</mo><msup><mi>x</mi><mn>2</mn></msup><mo>|</mo>
  <mrow><mi>x</mi><mo>&#x2209;</mo><mi>B</mi></mrow>
  <mo>}</mo>
</mrow>
</mrow>]]></eg>

<graphic source="image/minmax1-big_min-ex2.gif" alt="{{\minormal{min}}{\left.\middle\{x^2\middle|{x\unicode{8713}B}\middle\}\right.}}"/>
</div>

</div4>

<div4 id="contm_minus"><head>Subtraction <el role="defn emptytag">minus</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref>, <intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="unary_minus"/>, <symbolref cd="arith1" name="minus"/></td></tr>
</tbody>
</table>

<p>The <el>minus</el> element can be used as a <emph>unary arithmetic operator</emph>
(e.g. to represent - <var>x</var>), or as a <emph>binary arithmetic operator</emph>
(e.g. to represent <var>x</var>- <var>y</var>).</p>

<p>If it is used with one argument, <el>minus</el> corresponds to the <symbolref cd="arith1" name="unary_minus"/> symbol.</p>

<div id="arith1.unary_minus.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><minus/><cn>3</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>&#x2212;</mo><mn>3</mn></mrow>]]></eg>

<graphic source="image/arith1-unary_minus-ex1.gif" alt="{\unicode{8722}{3}}"/>
</div>

<p>If it is used with two arguments, <el>minus</el> corresponds to the
<symbolref cd="arith1" name="minus"/> symbol</p>
<div id="arith1.minus.ex1" role="mathml-example">
<p>Content MathML</p> 

<eg role="mathml"><![CDATA[
<apply><minus/><ci>x</ci><ci>y</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>x</mi><mo>&#x2212;</mo><mi>y</mi></mrow>]]></eg>

<graphic source="image/arith1-minus-ex1.gif" alt="{x\unicode{8722}y}"/>
</div>

<p>In both cases, the translation to Strict Content markup is direct,
as described in <specref ref="contm_strict-opel"/>. It is merely a
matter of choosing the symbol that reflects the actual usage.</p>

</div4>

<div4 id="contm_plus"><head>Addition <el role="defn emptytag">plus</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="plus"/></td></tr>
</tbody>
</table>

<p>The <el>plus</el> element represents the addition operator.  Its
arguments are normally specified explicitly in the enclosing
<el>apply</el> element.  As an n-ary commutative operator, it can
be used with qualifiers to specify arguments, however,
this is discouraged, and the <el>sum</el> operator should be
used to represent such expressions instead.</p>

<div id="arith1.plus.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><plus/><ci>x</ci><ci>y</ci><ci>z</ci></apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>z</mi></mrow>]]></eg>

<graphic source="image/arith1-plus-ex1.gif" alt="{x+y+z}"/>
</div>

</div4>

<div4 id="contm_power"><head>Exponentiation <el role="defn emptytag">power</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="power"/></td></tr>
</tbody>
</table>

<p>The <el>power</el> element represents the exponentiation
operator. The first argument is raised to the power of the second
argument.</p>

<div id="arith1.power.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><power/><ci>x</ci><cn>3</cn></apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msup><mi>x</mi><mn>3</mn></msup>]]></eg>

<graphic source="image/arith1-power-ex1.gif" alt="\msup{x}{{3}}"/>
</div>
</div4>

<div4 id="contm_rem"><head>Remainder <el role="defn emptytag">rem</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="integer1" name="remainder"/></td></tr>
</tbody>
</table>

<p>The <el>rem</el> element represents the modulus operator, which
returns the remainder that results from dividing the first argument by
the second.  That is, when applied to integer arguments <var>a</var>
and <var>b</var>, it returns the unique integer <var>r</var> such that
<var>a</var> = <var>b</var> * <var>q</var> + <var>r</var>, with
|<var>r</var>| less than |<var>b</var>| and <var>a</var> *
<var>r</var> positive.</p>

<div id="arith1.remainder.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><rem/><ci> a </ci><ci> b </ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>mod</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/arith1-remainder-ex1.gif" alt="{a\mathbin{\mathrm{mod}}b}"/>
</div>
</div4>

<div4 id="contm_times"><head>Multiplication <el role="defn emptytag">times</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="times"/></td></tr>
</tbody>
</table>

<p>The <el>times</el> element represents the n-ary multiplication operator.  Its
arguments are normally specified explicitly in the enclosing
<el>apply</el> element.  As an n-ary commutative operator, it can 
be used with qualifiers to specify arguments by rule, however,
this is discouraged, and the <el>product</el> operator should be
used to represent such expressions instead.</p>

<div id="arith1.times.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><times/><ci>a</ci><ci>b</ci></apply>]]></eg>

<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>&#x2062;</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/arith1-times-ex1.gif" alt="{a\unicode{8290}b}"/>
</div>

</div4>

<div4 id="contm_root"><head>Root <el role="defn emptytag">root</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref>, <intref ref="contm_binary">binary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">degree</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="root"/></td></tr>
</tbody>
</table>

<p>The <el>root</el> element is used to extract roots. The kind of root to be taken is
specified by a <quote>degree</quote> element, which should be given as the second child of
the <code>apply</code> element enclosing the <code>root</code> element. Thus, square roots
correspond to the case where <code>degree</code> contains the value 2, cube roots
correspond to 3, and so on. If no <code>degree</code> is present, a default value of 2 is
used.</p>

<div id="arith1.root.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><root/>
  <degree><ci type="integer">n</ci></degree>
  <ci>a</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[<mroot><mi>a</mi><mi>n</mi></mroot>]]></eg>

<graphic source="image/arith1-root-ex1.gif" alt="\sqrt[{n}]{a}"/>
</div>

<p><emph>Mapping to Strict Content Markup</emph></p>

<p>In Strict Content markup, the <symbolref cd="arith1" name="root"/>
symbol is always used with two arguments, with the second indicating
the degree of the root being extracted.</p>

<div id="arith1.root.ex2" role="strict-mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[<apply><root/><ci>x</ci></apply>]]></eg>

<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">root</csymbol>
  <ci>x</ci>
  <cn type="integer">2</cn>
</apply>]]></eg>
</div>

<div id="arith1.root.ex3" role="strict-mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><root/>
  <degree><ci type="integer">n</ci></degree>
  <ci>a</ci>
</apply>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">root</csymbol>
  <ci>a</ci>
  <cn type="integer">n</cn>
</apply>]]></eg>
</div>
</div4>

<div4 id="contm_gcd">
<head>Greatest common divisor <el role="defn emptytag">gcd</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="gcd"/></td></tr>
</tbody>
</table>

<p>The <el>gcd</el> element represents the n-ary operator which returns
the greatest common divisor of its arguments. Its
arguments may be explicitly specified in the enclosing
<el>apply</el> element, or specified by rule as described in
<specref ref="contm_nary"/>.</p>

  <div id="arith1.gcd.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><gcd/><ci>a</ci><ci>b</ci><ci>c</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>gcd</mi>
 <mo>&#x2061;</mo>
 <mfenced><mi>a</mi><mi>b</mi><mi>c</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/arith1-gcd-ex1.gif" alt="{\mathop{{\minormal{gcd}}}{\left(a,b,c\right)}}"/>
</div>
  <p>This default rendering is English-language locale specific: other locales may have
  different default renderings.</p>

<p>When the <el>gcd</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="arith1" name="gcd"/> symbol, as described in <specref ref="contm_strict-opel"/>.  However, when
qualifiers are used, the equivalent Strict markup is computed via
<specref ref ="contm_p2s.lifted"/>.</p>
</div4>

<div4 id="contm_and"><head>And <el role="defn emptytag">and</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="and"/></td></tr>
</tbody>
</table>

  <p>The <el>and</el> element represents the logical <quote>and</quote> function which is
  an n-ary function taking Boolean arguments and returning a Boolean value. It is true if
  all arguments are true, and false otherwise. Its arguments may be explicitly specified
  in the enclosing <el>apply</el> element, or specified by rule as described in <specref ref="contm_nary"/>.</p>

  <div id="logic1.and.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><and/><ci>a</ci><ci>b</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>&#x2227;</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/logic1-and-ex1.gif" alt="{a\unicode{8743}b}"/>
</div>

<div id="contm_and_bvar_ex" role="strict-mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><and/>
  <bvar><ci>i</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><ci>n</ci></uplimit>
  <apply><gt/><apply><selector/><ci>a</ci><ci>i</ci></apply><cn>0</cn></apply>
</apply>]]></eg>

<p>Strict Content MathML</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="fns2">apply_to_list</csymbol>
  <csymbol cd="logic1">and</csymbol>
  <apply><csymbol cd="list1">map</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>i</ci></bvar>
      <apply><csymbol cd="relation1">gt</csymbol>
        <apply><csymbol cd="linalg1">vector_selector</csymbol>
          <ci>i</ci>
          <ci>a</ci>
        </apply>
        <cn>0</cn>
      </apply>
    </bind>
    <apply><csymbol cd="interval1">integer_interval</csymbol>
      <cn type="integer">0</cn>
      <ci>n</ci>
    </apply>
  </apply>
</apply>]]></eg>

<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow>
 <munderover>
  <mo>&#x22C0;</mo>
  <mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow>
  <mi>n</mi>
 </munderover>
 <mrow>
  <mo>(</mo>
  <msub><mi>a</mi><mi>i</mi></msub>
  <mo>&gt;</mo>
  <mn>0</mn>
  <mo>)</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/contm_and_bvar_ex.gif" alt="{\munderover\bigwedge{i=0}{n}{\left(a\sb{i} \gt 0 \right)}}"/>
</div>

</div4>

<div4 id="contm_or"><head>Or <el role="defn emptytag">or</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="or"/></td></tr>
</tbody>
</table>

<p>The <el>or</el> element represents the logical <quote>or</quote> function. It is
true if any of the arguments are true, and false otherwise.</p>

  <div id="logic1.or.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><or/><ci>a</ci><ci>b</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>&#x2228;</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/logic1-or-ex1.gif" alt="{a\unicode{8744}b}"/>
</div>
</div4>

<div4 id="contm_xor"><head>Exclusive Or <el role="defn emptytag">xor</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="xor"/></td></tr>
</tbody>
</table>

<p>The <el>xor</el> element represents the logical <quote>xor</quote>
function. It is true if there are an odd number of true arguments or
false otherwise.</p>

  <div id="logic1.xor.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><xor/><ci>a</ci><ci>b</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>xor</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/logic1-xor-ex1.gif" alt="{a\mathbin{\mathrm{xor}}b}"/>
</div>

</div4>

<div4 id="contm_not"><head>Not <el role="defn emptytag">not</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="not"/></td></tr>
</tbody>
</table>

  <p>The <phrase><el>not</el></phrase> element represents the logical not function
  which takes one Boolean argument, and returns the opposite Boolean
  value.</p>  
  <div id="logic1.not.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><not/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>&#xac;</mo><mi>a</mi></mrow>]]></eg>

<graphic source="image/logic1-not-ex1.gif" alt="{\unicode{172}a}"/>
</div>
</div4>

<div4 id="contm_implies"><head>Implies <el role="defn emptytag">implies</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="implies"/></td></tr>
</tbody>
</table>

  <p>The <el>implies</el> element represents the logical implication
  function which takes two Boolean expressions as arguments. It
  evaluates to false if the first argument is true and the second
  argument is false, otherwise it evaluates to true.</p> 
  <div id="logic1.implies.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><implies/><ci>A</ci><ci>B</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x21d2;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/logic1-implies-ex1.gif" alt="{A\unicode{8658}B}"/>
</div>
</div4>

<div4 id="contm_forall"><head>Universal quantifier <el role="defn emptytag">forall</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_quantifier">quantifier</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="quant1" name="forall"/>,
<symbolref cd="logic1" name="implies"/></td></tr>
</tbody>
</table>
  <p>The <el>forall</el> element represents the universal ("for all")
  quantifier which takes one or more bound variables, and an
  argument which specifies the assertion being quantified.
  In addition, <el>condition</el> or other qualifiers may be used as
  described in <specref ref="contm_quantifier"/> to limit the domain
  of the bound variables.</p>

  <div id="quant1.forall.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<bind><forall/>
  <bvar><ci>x</ci></bvar>
  <apply><eq/>
    <apply><minus/><ci>x</ci><ci>x</ci></apply>
    <cn>0</cn>
  </apply>
</bind>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2200;</mo>
 <mi>x</mi>
 <mo>.</mo>
 <mfenced>
  <mrow>
   <mrow><mi>x</mi><mo>&#x2212;</mo><mi>x</mi></mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/quant1-forall-ex1.gif" alt="{\unicode{8704}x.{\left({{x\unicode{8722}x}={0}}\right)}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

  <div id="quant1.forall.ex2" role="strict-mathml-example">
  <p>When the <el>forall</el> element is used with a <el>condition</el> qualifier the
  strict equivalent is constructed with the help of logical implication by the rule
  <specref ref="contm_rewrite_quantifier"/>.  Thus

<eg role="mathml"><![CDATA[
<bind><forall/>
  <bvar><ci>p</ci></bvar>
  <bvar><ci>q</ci></bvar>
  <condition>
    <apply><and/>
      <apply><in/><ci>p</ci><rationals/></apply>
      <apply><in/><ci>q</ci><rationals/></apply>
      <apply><lt/><ci>p</ci><ci>q</ci></apply>
    </apply>
  </condition>
  <apply><lt/>
    <ci>p</ci>
    <apply><power/><ci>q</ci><cn>2</cn></apply>
  </apply>
</bind>]]></eg>
translates to 
<eg role="strict-mathml"><![CDATA[
<bind><csymbol cd="quant1">forall</csymbol>
  <bvar><ci>p</ci></bvar>
  <bvar><ci>q</ci></bvar>
  <apply><csymbol cd="logic1">implies</csymbol>
    <apply><csymbol cd="logic1">and</csymbol>
      <apply><csymbol cd="set1">in</csymbol>
        <ci>p</ci>
        <csymbol cd="setname1">Q</csymbol>
        </apply>
      <apply><csymbol cd="set1">in</csymbol>
        <ci>q</ci>
        <csymbol cd="setname1">Q</csymbol>
      </apply>
      <apply><csymbol cd="relation1">lt</csymbol><ci>p</ci><ci>q</ci></apply>
    </apply>
    <apply><csymbol cd="relation1">lt</csymbol>
      <ci>p</ci>
      <apply><csymbol cd="arith1">power</csymbol>
        <ci>q</ci>
        <cn>2</cn>
      </apply>
    </apply>
  </apply>
</bind>]]></eg>
  </p>


<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2200;</mo>
 <mrow>
  <mrow><mi>p</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">Q</mi></mrow>
  <mo>&#x2227;</mo>
  <mrow><mi>q</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">Q</mi></mrow>
  <mo>&#x2227;</mo>
  <mrow><mo>(</mo><mi>p</mi><mo>&lt;</mo><mi>q</mi><mo>)</mo></mrow>
 </mrow>
 <mo>.</mo>
 <mfenced>
  <mrow><mi>p</mi><mo>&lt;</mo><msup><mi>q</mi><mn>2</mn></msup></mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/quant1-forall-ex2.gif"
 alt="{\unicode{8704}{{p\unicode{8712}{\midoublestruck{Q}}}\unicode{8743}{q\unicode{8712}{\midoublestruck{Q}}}\unicode{8743}{\left.\middle(p\lt q\middle)\right.}}.{\left({p\lt\msup{q}{{2}}}\right)}}"/>

<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2200;</mo>
 <mrow><mi>p</mi><mo>,</mo><mi>q</mi></mrow>
 <mo>.</mo>
 <mfenced>
  <mrow>
   <mrow>
    <mo>(</mo>
    <mrow>
     <mi>p</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">Q</mi>
    </mrow>
    <mo>&#x2227;</mo>
    <mrow>
     <mi>q</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">Q</mi>
    </mrow>
    <mo>&#x2227;</mo>
    <mrow><mo>(</mo><mi>p</mi><mo>&lt;</mo><mi>q</mi><mo>)</mo></mrow>
    <mo>)</mo>
   </mrow>
   <mo>&#x21d2;</mo>
   <mrow>
    <mo>(</mo>
    <mi>p</mi>
    <mo>&lt;</mo>
    <msup><mi>q</mi><mn>2</mn></msup>
    <mo>)</mo>
   </mrow>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/quant1-forall-ex2-2.gif"
alt="{ \unicode{8704} {p,q} . {\left({ {\left. \middle( {p\unicode{8712}{\midoublestruck{Q}}} \unicode{8743} {q\unicode{8712}{\midoublestruck{Q}}} \unicode{8743} {\left.\middle(p\lt q\middle)\right.} \middle) \right.} \unicode{8658} {\left. \middle( p \lt \msup{q}{{2}} \middle) \right.} }\right)} }"/>
  </div>
</div4>

<div4 id="contm_exists"><head>Existential quantifier <el role="defn emptytag">exists</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_quantifier">quantifier</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="quant1" name="exists"/>,
<symbolref cd="logic1" name="and"/></td></tr>
</tbody>
</table>

  <p>The <el>exists</el> element represents the existential ("there exists")
  quantifier which takes one or more bound variables, and an
  argument which specifies the assertion being quantified. In
  addition, <el>condition</el> or other qualifiers may be used as 
  described in <specref ref="contm_quantifier"/> to limit the domain
  of the bound variables.</p>
  <div id="quant1.exists.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<bind><exists/>
  <bvar><ci>x</ci></bvar>
  <apply><eq/>
    <apply><ci>f</ci><ci>x</ci></apply>
    <cn>0</cn>
  </apply>
</bind>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2203;</mo>
 <mi>x</mi>
 <mo>.</mo>
 <mfenced>
  <mrow>
   <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/quant1-exists-ex1.gif" alt="{\unicode{8707}x.{\left({{\mathop{f}{\left(x\right)}}={0}}\right)}}"/>
</div>

  <div id="quant1.exists.ex2" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><exists/>
  <bvar><ci>x</ci></bvar>
  <domainofapplication>
    <integers/>
  </domainofapplication>
   <apply><eq/>
    <apply><ci>f</ci><ci>x</ci></apply>
    <cn>0</cn>
  </apply>
</apply>]]></eg>
<p>Strict MathML equivalent:</p>
<eg role="strict-mathml"><![CDATA[
<bind><csymbol cd="quant1">exists</csymbol>
  <bvar><ci>x</ci></bvar>
  <apply><csymbol cd="logic1">and</csymbol>
    <apply><csymbol cd="set1">in</csymbol>
      <ci>x</ci>
      <csymbol cd="setname1">Z</csymbol>
    </apply>
    <apply><csymbol cd="relation1">eq</csymbol>
      <apply><ci>f</ci><ci>x</ci></apply>
      <cn>0</cn>
    </apply>
  </apply>
</bind>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2203;</mo>
 <mi>x</mi>
 <mo>.</mo>
 <mfenced separators="">
  <mrow><mi>x</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">Z</mi></mrow>
  <mo>&#x2227;</mo>
  <mrow>
   <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
   <mo>=</mo>
   <mn>0</mn>
  </mrow>
 </mfenced>
</mrow>]]></eg>


<graphic source="image/quant1-exists-ex2.gif" alt="{\unicode{8707}x.{\left({x\unicode{8712}{\midoublestruck{Z}}}\unicode{8743}{{\mathop{f}{\left(x\right)}}={0}}\right)}}"/>

</div>
</div4>

<div4 id="contm_abs"><head>Absolute Value <el role="defn emptytag">abs</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="abs"/></td></tr>
</tbody>
</table>
  <p>The <el>abs</el> element represents the absolute value
  function. The argument should be numerically valued. When the
  argument is a complex number, the absolute value is often referred
  to as the modulus.</p>
  <div id="arith1.abs.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><abs/><ci>x</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>|</mo><mi>x</mi><mo>|</mo></mrow>]]></eg>

<graphic source="image/arith1-abs-ex1.gif" alt="{\left.\middle|x\middle|\right.}"/>
</div>
</div4>

<div4 id="contm_conjugate"><head>Complex conjugate <el role="defn emptytag">conjugate</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="complex1" name="conjugate"/></td></tr>
</tbody>
</table>
  <p>
      The <el>conjugate</el> element represents the function defined
      over the complex numbers with returns the complex conjugate of
      its argument.
    </p>
  <div id="complex1.conjugate.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><conjugate/>
  <apply><plus/>
    <ci>x</ci>
    <apply><times/><cn>&#x2148;</cn><ci>y</ci></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mover>
 <mrow>
  <mi>x</mi>
  <mo>+</mo>
  <mrow><mn>&#x2148;</mn><mo>&#x2062;</mo><mi>y</mi></mrow>
 </mrow>
 <mo>&#xaf;</mo>
</mover>]]></eg>

<graphic source="image/complex1-conjugate-ex1.gif" alt="{\overline{{x+{{\mn{\unicode{8520}}}\unicode{8290}y}}}}"/>
</div>
</div4>

<div4 id="contm_arg"><head>Argument <el role="defn emptytag">arg</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="complex1" name="argument"/></td></tr>
</tbody>
</table>
  <p>
      The <el>arg</el> element represents the unary function which
      returns the angular argument of a complex number, namely the
      angle which a straight line drawn from the number to zero makes
      with the real line (measured anti-clockwise). 
    </p>
  <div id="complex1.argument.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><arg/>
  <apply><plus/>
    <ci> x </ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>arg</mi>
 <mo>&#x2061;</mo>
 <mfenced>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mrow><mi>i</mi><mo>&#x2062;</mo><mi>y</mi></mrow>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/complex1-argument-ex1.gif" alt="{\mathop{{\minormal{arg}}}{\left({x+{i\unicode{8290}y}}\right)}}"/>
</div>
</div4>

<div4 id="contm_real"><head>Real part <el role="defn emptytag">real</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="complex1" name="real"/></td></tr>
</tbody>
</table>
  <p>
      The <el>real</el> element represents the unary operator used to
      construct an expression representing the "real" part of a
      complex number, that is, the <var>x</var> component in <var>x</var> + i<var>y</var>.
    </p>
  <div id="complex1.real.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><real/>
  <apply><plus/>
    <ci>x</ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x211b;</mo>
 <mo>&#x2061;</mo>
 <mfenced>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mrow><mi>i</mi><mo>&#x2062;</mo><mi>y</mi></mrow>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/complex1-real-ex1.gif" alt="{\unicode{8475}\unicode{8289}{\left({x+{i\unicode{8290}y}}\right)}}"/>
</div>
</div4>

<div4 id="contm_imaginary"><head>Imaginary part <el role="defn emptytag">imaginary</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="complex1" name="imaginary"/></td></tr>
</tbody>
</table>
  <p>
      The <el>imaginary</el> element represents the unary operator used to
      construct an expression representing the "imaginary" part of a
      complex number, that is, the <var>y</var> component in <var>x</var> + i<var>y</var>.
    </p>
  <div id="complex1.imaginary.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><imaginary/>
  <apply><plus/>
    <ci>x</ci>
    <apply><times/><imaginaryi/><ci>y</ci></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2111;</mo>
 <mo>&#x2061;</mo>
 <mfenced>
  <mrow>
   <mi>x</mi>
   <mo>+</mo>
   <mrow><mi>i</mi><mo>&#x2062;</mo><mi>y</mi></mrow>
  </mrow>
 </mfenced>
</mrow>]]></eg>

<graphic source="image/complex1-imaginary-ex1.gif" alt="{\unicode{8465}\unicode{8289}{\left({x+{i\unicode{8290}y}}\right)}}"/>
</div>
</div4>

<div4 id="contm_lcm"><head>Lowest common multiple <el role="defn emptytag">lcm</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="lcm"/></td></tr>
</tbody>
</table>

  <p>The <el>lcm</el> element represents the n-ary operator used to
  construct an expression which represents the least common multiple
  of its arguments. If no argument is provided, the lcm is 1. If one
  argument is provided, the lcm is that argument. The least common
  multiple of <var>x</var> and 1 is <var>x</var>.</p> 

  <div id="arith1.lcm.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><lcm/><ci>a</ci><ci>b</ci><ci>c</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>lcm</mi>
 <mo>&#x2061;</mo>
 <mfenced><mi>a</mi><mi>b</mi><mi>c</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/arith1-lcm-ex1.gif" alt="{\mathop{{\minormal{lcm}}}{\left(a,b,c\right)}}"/>
</div>
  <p>This default rendering is English-language locale specific: other locales may have
  different default renderings.</p>
</div4>

<div4 id="contm_floor"><head>Floor <el role="defn emptytag">floor</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="rounding1" name="floor"/></td></tr>
</tbody>
</table>

 <p>The <el>floor</el> element represents the operation that rounds
 down (towards negative infinity) to the nearest integer. This
 function takes one real number as an argument and returns an
 integer.</p>
  <div id="rounding1.floor.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><floor/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>&#x230a;</mo><mi>a</mi><mo>&#x230b;</mo></mrow>]]></eg>

<graphic source="image/rounding1-floor-ex1.gif" alt="{\unicode{8970}a\unicode{8971}}"/>
</div>
</div4>

<div4 id="contm_ceiling"><head>Ceiling <el role="defn emptytag">ceiling</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="rounding1" name="ceiling"/></td></tr>
</tbody>
</table>
  <p>The <el>ceiling</el> element represents the operation that rounds
  up (towards positive infinity) to the nearest integer. This function
  takes one real number as an argument and returns an integer.</p>

  <div id="rounding1.ceiling.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><ceiling/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mo>&#x2308;</mo><mi>a</mi><mo>&#x2309;</mo></mrow>]]></eg>

<graphic source="image/rounding1-ceiling-ex1.gif" alt="{\unicode{8968}a\unicode{8969}}"/>
</div>
</div4>
</div3>

<div3><head>Relations</head>

<div4 id="contm_eq"><head>Equals <el role="defn emptytag">eq</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="eq"/></td></tr>
</tbody>
</table>

<p>The <el>eq</el> elements represents the equality relation. While equality is a binary relation,
<phrase><el>eq</el></phrase> may be used with more than two arguments, denoting a chain
of equalities, as described in <specref ref="contm_nary_reln"/>.</p>

<div id="relation1.eq.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <cn type="rational">2<sep/>4</cn>
  <cn type="rational">1<sep/>2</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mn>2</mn><mo>/</mo><mn>4</mn></mrow>
 <mo>=</mo>
 <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow>
</mrow>]]></eg>

<graphic source="image/relation1-eq-ex1.gif" alt="{{{2}/{4}}={{1}/{2}}}"/>
</div>

</div4>

<div4 id="contm_neq"><head>Not Equals <el role="defn emptytag">neq</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="neq"/></td></tr>
</tbody>
</table>

  <p>The <el>neq</el> element represents the binary inequality
  relation, i.e. the relation "not equal to" which returns true unless
  the two arguments are equal.</p> 

  <div id="relation1.neq.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><neq/><cn>3</cn><cn>4</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mn>3</mn><mo>&#x2260;</mo><mn>4</mn></mrow>]]></eg>

<graphic source="image/relation1-neq-ex1.gif" alt="{{3}\unicode{8800}{4}}"/>
</div>
</div4>

<div4 id="contm_gt"><head>Greater than <el role="defn emptytag">gt</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="gt"/></td></tr>
</tbody>
</table>

  <p>The <el>gt</el> element represents the "greater than" function
  which returns true if the first argument is greater than the second, and
  returns false otherwise. While this is a binary relation,
  <el>gt</el> may be used with more than two arguments, denoting a chain
  of inequalities, as described in <specref
  ref="contm_nary_reln"/>.</p> 

  <div id="relation1.gt.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><gt/><cn>3</cn><cn>2</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mn>3</mn><mo>&gt;</mo><mn>2</mn></mrow>]]></eg>

<graphic source="image/relation1-gt-ex1.gif" alt="{{3}\gt{2}}"/>
</div>

</div4>


<div4 id="contm_lt"><head>Less Than <el role="defn emptytag">lt</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="lt"/></td></tr>
</tbody>
</table>

  <p>The <el>lt</el> element represents the "less than" function
  which returns true if the first argument is less than the second, and
  returns false otherwise. While this is a binary relation,
  <el>lt</el> may be used with more than two arguments, denoting a chain
  of inequalities, as described in <specref
  ref="contm_nary_reln"/>.</p> 

  <div id="relation1.lt.ex1" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><lt/><cn>2</cn><cn>3</cn><cn>4</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mn>2</mn><mo>&lt;</mo><mn>3</mn><mo>&lt;</mo><mn>4</mn></mrow>]]></eg>

<graphic source="image/relation1-lt-ex1.gif" alt="{{2}\lt{3}\lt{4}}"/>
</div>
</div4>

<div4 id="contm_geq"><head>Greater Than or Equal <el role="defn emptytag">geq</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="geq"/></td></tr>
</tbody>
</table>
  <p>The <el>geq</el> element represents the "greater than or equal to" function
  which returns true if the first argument is greater than or equal to
  the second, and returns false otherwise. While this is a binary relation,
  <el>geq</el> may be used with more than two arguments, denoting a chain
  of inequalities, as described in <specref
  ref="contm_nary_reln"/>.</p> 

  <div id="relation1.geq.ex1" role="strict-mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><geq/><cn>4</cn><cn>3</cn><cn>3</cn></apply>]]></eg>
<p>Strict Content MathML</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="fns2">predicate_on_list</csymbol>
 <csymbol cd="reln1">geq</csymbol>
 <apply><csymbol cd="list1">list</csymbol>
  <cn>4</cn><cn>3</cn><cn>3</cn>
 </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mn>4</mn><mo>&#x2265;</mo>
 <mn>3</mn><mo>&#x2265;</mo>
 <mn>3</mn>
</mrow>]]></eg>

<graphic source="image/relation1-geq-ex1.gif" alt="{{4}\unicode{8805}{3}\unicode{8805}{3}}"/>
</div>
</div4>

<div4 id="contm_leq"><head>Less Than or Equal <el role="defn emptytag">leq</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="leq"/></td></tr>
</tbody>
</table>
  <p>The <el>leq</el> element represents the "less than or equal to" function
  which returns true if the first argument is less than or equal to
  the second, and returns false otherwise. While this is a binary relation,
  <el>leq</el> may be used with more than two arguments, denoting a chain
  of inequalities, as described in <specref
  ref="contm_nary_reln"/>.</p> 

  <div id="relation1.leq.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><leq/><cn>3</cn><cn>3</cn><cn>4</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mn>3</mn><mo>&#x2264;</mo>
 <mn>3</mn><mo>&#x2264;</mo>
 <mn>4</mn>
</mrow>]]></eg>

<graphic source="image/relation1-leq-ex1.gif" alt="{{3}\unicode{8804}{3}\unicode{8804}{4}}"/>
</div>
</div4>

<div4 id="contm_equivalent"><head>Equivalent <el role="defn emptytag">equivalent</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-logical</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="equivalent"/></td></tr>
</tbody>
</table>

  <p>The <el>equivalent</el> element represents the relation that
  asserts two Boolean expressions are logically equivalent,
  that is have the same Boolean value for any inputs.</p> 

  <div id="logic1.equivalent1.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><equivalent/>
  <ci>a</ci>
  <apply><not/><apply><not/><ci>a</ci></apply></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>a</mi>
 <mo>&#x2261;</mo>
 <mrow><mo>&#xac;</mo><mrow><mo>&#xac;</mo><mi>a</mi></mrow></mrow>
</mrow>]]></eg>

<graphic source="image/logic1-equivalent1-ex1.gif" alt="{a\unicode{8801}{\unicode{172}{\unicode{172}a}}}"/>
</div>
</div4>


<div4 id="contm_approx"><head>Approximately <el role="defn emptytag">approx</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="relation1" name="approx"/></td></tr>
</tbody>
</table>


  <p>The <el>approx</el> element represent the relation that asserts
  the approximate equality of its arguments.</p> 

  <div id="relation1.approx.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><approx/>
  <pi/>
  <cn type="rational">22<sep/>7</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>&#x3c0;</mi>
 <mo>&#x2243;</mo>
 <mrow><mn>22</mn><mo>/</mo><mn>7</mn></mrow>
</mrow>]]></eg>

<graphic source="image/relation1-approx-ex1.gif" alt="{\unicode{960}\unicode{8771}{{22}/{7}}}"/>
</div>
</div4>

<div4 id="contm_factorof"><head>Factor Of <el role="defn emptytag">factorof</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="integer1" name="factorof"/></td></tr>
</tbody>
</table>

  <p>The <el>factorof</el> element is used to indicate the
  mathematical relationship that the first argument "is a factor of"
  the second. This relationship is true if and only 
  if <var>b</var> mod <var>a</var> = 0.</p> 
  <div id="integer1.factorof.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><factorof/><ci>a</ci><ci>b</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>|</mo><mi>b</mi></mrow>]]></eg>

<graphic source="image/integer1-factorof-ex1.gif" alt="{\left.a\middle|b\right.}"/>
</div>
</div4>
</div3>



<div3>
<head>Calculus and Vector Calculus</head>

<div4 id="contm_int"><head>Integral <el role="defn emptytag">int</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">int</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="calculus1" name="int"/> <symbolref cd="calculus1" name="defint"/></td></tr>
</tbody>
</table>

<p>The <el>int</el> element is the operator element for a definite or indefinite integral
over a function or a definite over an expression with a bound variable.</p>

<div id="calculus1.int.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><int/><sin/></apply>
  <cos/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mrow><mi>&#x222b;</mi><mi>sin</mi></mrow><mo>=</mo><mi>cos</mi></mrow>]]></eg>

<graphic source="image/calculus1-int-ex1.gif" alt="{{\unicode{8747}{\minormal{sin}}}={\minormal{cos}}}"/>
</div>


<div id="calculus1.defint.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><int/>
  <interval><ci>a</ci><ci>b</ci></interval>
  <cos/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msubsup><mi>&#x222b;</mi><mi>a</mi><mi>b</mi></msubsup><mi>cos</mi>
</mrow>]]></eg>

<graphic source="image/calculus1-defint-ex1.gif" alt="{\mosubsup\int{a}{b}{\minormal{cos}}}"/>

</div>

<p>The <el>int</el> element can also be used with bound variables serving as the
integration variables.</p>

<div id="calculus1.defint.ex2" role="mathml-example">
<p>Content MathML</p>
<p> Here, definite integrals are indicated by providing qualifier elements specifying a
domain of integration (here a <el>lowlimit</el>/<el>uplimit</el> pair). This is perhaps
the most "standard" representation of this integral:</p>

<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><cn>1</cn></uplimit>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
</apply>]]></eg>

<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow>
 <msubsup><mi>&#x222b;</mi><mn>0</mn><mn>1</mn></msubsup>
 <msup><mi>x</mi><mn>2</mn></msup>
 <mi>d</mi>
 <mi>x</mi>
</mrow>]]></eg>

<graphic source="image/calculus1-defint-ex2.gif" alt="\mosubsup\int{0}{1} {\msup{x}{2}} d x"/>

</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>As an indefinite integral applied to a function, the <el>int</el> element corresponds to
the <symbolref cd="calculus1" name="int"/> symbol from the <cdref cd="calculus1"/> content
dictionary. As a definite integral applied to a function, the <el>int</el> element
corresponds to the <symbolref cd="calculus1" name="defint"/> symbol
from the <cdref cd="calculus1"/> content dictionary.</p>


<p>When no bound variables are present, the translation
  of an indefinite integral to Strict Content Markup is straight
  forward.  When bound variables are present, the following rule
  should be used.</p>

<div  id="contm_p2s.int" role="strict-mathml-example">
           <head>Rewrite: int</head>

<p>Translate an indefinite integral, where 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is an
arbitrary expression involving the bound variable(s) 
<code meta="ci"><![CDATA[<ci>x</ci>]]></code>
<eg meta="ci" role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <ci>expression-in-x</ci>
</apply>]]></eg>
to the expression
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">int</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <ci>expression-in-x</ci>
    </bind>
  </apply>
  <ci>x</ci>
</apply>]]></eg>

Note that as <var>x</var> is not bound in the original indefinite integral,
the integrated function is applied to the variable <var>x</var> making it
an explicit free variable in Strict Content Markup expression, even though
it is bound in the subterm used as an argument to <symbolref  cd="calculus1" name="int"/>.</p>

</div>

<div id="contm_strict-int" role="strict-mathml-example">
<p>For instance, the expression
<eg role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <apply><cos/><ci>x</ci></apply>
</apply>]]></eg>
has the Strict Content MathML equivalent
<eg role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">int</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <apply><cos/><ci>x</ci></apply>
    </bind>
  </apply>
  <ci>x</ci>
</apply>
]]></eg>
</p>
</div>


<p>For a definite integral without bound variables, the
translation is also straightforward.</p>

<div id="contm_strict-domainofapplication-nobvar" role="strict-mathml-example">
<p> For instance, the integral of a differential form <var>f</var> over an arbitrary domain
<var>C</var> represented as

<eg role="mathml"><![CDATA[
<apply><int/>
  <domainofapplication><ci>C</ci></domainofapplication>
  <ci>f</ci>
</apply>]]></eg>

is equivalent to the Strict Content MathML:

<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="calculus1">defint</csymbol><ci>C</ci><ci>f</ci></apply>]]></eg>
</p>

<p>Note, however, the additional remarks on the translations of other
kinds of qualifiers that may be used to specify a domain of integration in the rules for
definite integrals following.</p>
</div>


<p><phrase>When bound variables are present,</phrase> the situation is more complicated in general, and the
following rule<phrase>s are</phrase> used.</p>

<div id="contm_p2s.defint" role="strict-mathml-example">
           <head>Rewrite: defint</head>

<p>Translate a definite integral, where 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is an
arbitrary expression involving the bound variable(s) 
<code meta="ci"><![CDATA[<ci>x</ci>]]></code>
<eg meta="ci" role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <domainofapplication><ci>D</ci></domainofapplication>
  <ci>expression-in-x</ci>
</apply>]]></eg>
to the expression
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply><csymbol cd="calculus1">defint</csymbol>
  <ci>D</ci>  
  <bind><csymbol cd="fns1">lambda</csymbol>
  <bvar><ci>x</ci></bvar>
  <ci>expression-in-x</ci>
  </bind>
</apply>]]></eg>

</p>
</div>

<p>But the definite integral with an <el>lowlimit</el>/<el>uplimit</el> pair carries the
strong intuition that the range of integration is oriented, and thus swapping lower and
upper limits will change the sign of the result. To accommodate this, use the following special
translation rule:</p>

<div id="contm_p2s.int.LUlimit" role="strict-mathml-example">
           <head>Rewrite: defint limits</head>

<eg meta="ci" role="mathml"><![CDATA[
<apply><int/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><ci>a</ci></lowlimit>
  <uplimit><ci>b</ci></uplimit>
  <ci>expression-in-x</ci>
</apply>]]></eg>
<p>
where
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code>
 is an expression in the variable <var>x</var>
is translated to to the expression:</p>
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply><csymbol cd="calculus1">defint</csymbol>
  <apply><csymbol cd="interval1">oriented_interval</csymbol>
    <ci>a</ci> <ci>b</ci>
  </apply>
  <bind><csymbol cd="fns1">lambda</csymbol>
  <bvar><ci>x</ci></bvar>
  <ci>expression-in-x</ci>
  </bind>
</apply>]]></eg>

<p>The <symbolref cd="interval1" name="oriented_interval"/>
  symbol is also used when translating the <el>interval</el>
  qualifier, when it is used to specify the domain of integration.
  Integration is assumed to proceed from the left endpoint to the
  right endpoint.</p>

<p>The case for multiple integrands is treated analogously.</p>
</div>

<div id="contm_strict-condition" role="strict-mathml-example">
<p>Note that use of the <el>condition</el>
  <phrase>qualifier</phrase> <phrase>also
    requires special treatment.  In particular, it</phrase> extends to multivariate domains by
using extra bound variables and a domain corresponding to a cartesian product as in:</p>

<eg role="mathml"><![CDATA[
<bind><int/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <condition>
    <apply><and/>
      <apply><leq/><cn>0</cn><ci>x</ci></apply>
      <apply><leq/><ci>x</ci><cn>1</cn></apply>
      <apply><leq/><cn>0</cn><ci>y</ci></apply>
      <apply><leq/><ci>y</ci><cn>1</cn></apply>
    </apply>
  </condition>
  <apply><times/>
    <apply><power/><ci>x</ci><cn>2</cn></apply>
    <apply><power/><ci>y</ci><cn>3</cn></apply>
  </apply>
</bind>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="calculus1">defint</csymbol>
 <apply><csymbol cd="set1">suchthat</csymbol>
  <apply><csymbol cd="set1">cartesianproduct</csymbol>
   <csymbol cd="setname1">R</csymbol>
   <csymbol cd="setname1">R</csymbol>
  </apply>
  <apply><csymbol cd="logic1">and</csymbol>
   <apply><csymbol cd="arith1">leq</csymbol><cn>0</cn><ci>x</ci></apply>
   <apply><csymbol cd="arith1">leq</csymbol><ci>x</ci><cn>1</cn></apply>
   <apply><csymbol cd="arith1">leq</csymbol><cn>0</cn><ci>y</ci></apply>
   <apply><csymbol cd="arith1">leq</csymbol><ci>y</ci><cn>1</cn></apply>
  </apply>
  <bind><csymbol cd="fns11">lambda</csymbol>
   <bvar><ci>x</ci></bvar>
   <bvar><ci>y</ci></bvar>
   <apply><csymbol cd="arith1">times</csymbol>
    <apply><csymbol cd="arith1">power</csymbol><ci>x</ci><cn>2</cn></apply>
    <apply><csymbol cd="arith1">power</csymbol><ci>y</ci><cn>3</cn></apply>
   </apply>
  </bind>
 </apply>
</apply>]]></eg>
</div>

</div4>

<div4 id="contm_diff"><head>Differentiation <el role="defn emptytag">diff</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">Differential-Operator</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="calculus1" name="diff"/></td></tr>
</tbody>
</table>

<p>The <el>diff</el> element is the differentiation operator element for functions or
expressions of a single variable.  It may be applied directly to an actual function
thereby denoting a function which is the derivative of the original function, or it can be
applied to an expression involving a single variable.</p>

<div id="calculus1.diff.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[<apply><diff/><ci>f</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msup><mi>f</mi><mo>&#x2032;</mo></msup>]]></eg>

<graphic source="image/calculus1-diff-ex2.gif" alt="\msup{f}{\unicode{8242}}"/>
</div>

<div id="calculus1.diff.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><diff/>
    <bvar><ci>x</ci></bvar>
    <apply><sin/><ci>x</ci></apply>
  </apply>
  <apply><cos/><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mfrac>
  <mrow><mi>d</mi><mrow><mi>sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow></mrow>
  <mrow><mi>d</mi><mi>x</mi></mrow>
 </mfrac>
 <mo>=</mo>
 <mrow><mi>cos</mi><mo>&#x2061;</mo><mi>x</mi></mrow>
</mrow>]]></eg>

<graphic source="image/calculus1-diff-ex1.gif" alt="{ {\frac{{d{\mathop{{\minormal{sin}}}x}}}{{dx}}} = {\mathop{{\minormal{cos}}}x} }"/>
</div>

<p>The <el>bvar</el> element may also contain a <el>degree</el> element, which specifies
the order of the derivative to be taken.</p>

<div id="calculus1.diff.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><diff/>
  <bvar><ci>x</ci><degree><cn>2</cn></degree></bvar>
  <apply><power/><ci>x</ci><cn>4</cn></apply>
</apply>]]></eg>

<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mfrac>
 <mrow>
  <msup><mi>d</mi><mn>2</mn></msup>
  <msup><mi>x</mi><mn>4</mn></msup>
 </mrow>
 <mrow><mi>d</mi><msup><mi>x</mi><mn>2</mn></msup></mrow>
</mfrac>]]></eg>

</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>For the translation to strict Markup it is crucial to realize that in the expression
case, the variable is actually not bound by the differentiation operator.</p>

<div id="contm_p2s.diff" role="strict-mathml-example">
           <head>Rewrite: diff</head>

<p>Translate an expression 
<eg meta="ci" role="mathml"><![CDATA[
<apply><diff/>
  <bvar><ci>x</ci></bvar>
  <ci>expression-in-x</ci>
</apply>]]></eg>
where
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is an
 expression in the variable <var>x</var>
to the expression
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">diff</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <ci>E</ci>
    </bind>
  </apply>
  <ci>x</ci>
</apply>]]></eg>
Note that the differentiated function is applied to the variable
<var>x</var> making its status as a free variable explicit in strict
markup. Thus the strict equivalent of  
<eg role="mathml"><![CDATA[
<apply><diff/>
  <bvar><ci>x</ci></bvar>
  <apply><sin/><ci>x</ci></apply>
</apply>]]></eg>
is
<eg role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">diff</csymbol>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <apply><csymbol cd="transc1">sin</csymbol><ci>x</ci></apply>
    </bind>
  </apply>
  <ci>x</ci>
</apply>]]></eg></p>
</div>

<p>If the <el>bvar</el> element contains a <el>degree</el> element, use the
<code>nthdiff</code> symbol.</p>

<div id="contm_p2s.nthdiff" role="strict-mathml-example">
           <head>Rewrite: nthdiff</head>
<eg meta="ci" role="mathml"><![CDATA[
<apply><diff/>
  <bvar><ci>x</ci><degree><ci>n</ci></degree></bvar>
  <ci>expression-in-x</ci>
</apply>]]></eg>
<p>where
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is an
 is an expression in the variable <var>x</var>
 is translated to to the expression:</p>
<eg meta="ci" role="mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">nthdiff</csymbol>
    <ci>n</ci>
    <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <ci>expression-in-x</ci>
    </bind>
  </apply>
  <ci>x</ci>
</apply>]]></eg>
</div>
<div id="contm_nthdiff_ex" role="strict-mathml-example">
<p>For example</p>
<eg role="mathml"><![CDATA[
<apply><diff/>
  <bvar><degree><cn>2</cn></degree><ci>x</ci></bvar>
  <apply><sin/><ci>x</ci></apply>
</apply>]]></eg>

<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">nthdiff</csymbol>
    <cn>2</cn>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <apply><csymbol cd="transc1">sin</csymbol><ci>x</ci></apply>
    </bind>
  </apply>
  <ci>x</ci>
</apply>]]></eg>
</div>
</div4>

<div4 id="contm_partialdiff">
  <head>Partial Differentiation <el role="defn emptytag">partialdiff</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">partialdiff</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="calculus1" name="partialdiff"/> <symbolref cd="calculus1" name="partialdiffdegree"/></td></tr>
</tbody>
</table>

<p>The <el>partialdiff</el> element is the partial differentiation operator element for
functions or expressions in several variables.</p>

<p>For the case of partial differentiation of a function, the
containing <el>partialdiff</el> takes two arguments: firstly a list of
indices indicating by position which function arguments are involved in
constructing the partial derivatives, and secondly the actual function
to be partially differentiated.  The indices may be repeated.</p>

<div id="calculus1.partialdiff.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><partialdiff/>
  <list><cn>1</cn><cn>1</cn><cn>3</cn></list>
  <ci type="function">f</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msub>
  <mi>D</mi>
  <mrow><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn></mrow>
 </msub>
 <mi>f</mi>
</mrow>]]></eg>

<graphic source="image/calculus1-partialdiff-ex3.gif" alt="{\msub{D}{{{1},{1},{3}}}f}"/>
</div>
<div id="calculus1.partialdiff.ex3b" role="mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><partialdiff/>
  <list><cn>1</cn><cn>1</cn><cn>3</cn></list>
  <lambda>
   <bvar><ci>x</ci></bvar>
   <bvar><ci>y</ci></bvar>
   <bvar><ci>z</ci></bvar>
   <apply><ci>f</ci><ci>x</ci><ci>y</ci><ci>z</ci></apply>
  </lambda>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mfrac>
 <mrow>
  <msup><mo>&#x2202;</mo><mn>3</mn></msup>
  <mrow>
   <mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi><mi>y</mi><mi>z</mi></mfenced>
 </mrow>
 </mrow>
 <mrow>
  <mrow><mo>&#x2202;</mo><msup><mi>x</mi><mn>2</mn></msup></mrow>
  <mrow><mo>&#x2202;</mo><mi>z</mi></mrow>
 </mrow>
</mfrac>]]></eg>

<graphic source="image/calculus1-partialdiff-ex3b.gif" alt="{\frac{{ {\msup{\unicode{8706}}{3}} {f{\left(x,y,z\right)}} }}{{ {\unicode{8706}{\msup{x}{2}}} {\unicode{8706}z} }}}"/>

</div>

<p>In the case of algebraic expressions, the bound variables are given by <el>bvar</el>
elements, which are children of the containing <el>apply</el> element. The <el>bvar</el>
elements may also contain <el>degree</el> element, which specify the order of the partial
derivative to be taken in that variable.</p>

<div id="calculus1.partialdiff.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><partialdiff/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <apply><ci type="function">f</ci><ci>x</ci><ci>y</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mfrac>
 <mrow>
  <msup><mo>&#x2202;</mo><mn>2</mn></msup>
  <mrow>
   <mi>f</mi>
   <mo>&#x2061;</mo>
   <mfenced><mi>x</mi><mi>y</mi></mfenced>
  </mrow>
 </mrow>
 <mrow>
  <mrow><mo>&#x2202;</mo><mi>x</mi></mrow>
  <mrow><mo>&#x2202;</mo><mi>y</mi></mrow>
 </mrow>
</mfrac>]]></eg>

<graphic source="image/calculus1-partialdiff-ex2.gif" alt="{\frac{{\msup{\unicode{8706}}{{2}}{\mathop{f}{\left(x,y\right)}}}}{{{\unicode{8706}x}{\unicode{8706}y}}}}"/>
</div>

<p>Where a total degree of differentiation must be specified, this is
indicated by use of a <el>degree</el> element at the top level,
i.e. without any associated <el>bvar</el>, as a child of the
containing <el>apply</el> element.</p>

<div id="calculus1.partialdiff.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><partialdiff/>
  <bvar><ci>x</ci><degree><ci>m</ci></degree></bvar>
  <bvar><ci>y</ci><degree><ci>n</ci></degree></bvar>
  <degree><ci>k</ci></degree>
  <apply><ci type="function">f</ci>
    <ci>x</ci>
    <ci>y</ci>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mfrac>
 <mrow>
  <msup><mo>&#x2202;</mo><mi>k</mi></msup>
  <mrow>
   <mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi><mi>y</mi></mfenced>
  </mrow>
 </mrow>
 <mrow>
  <mrow><mo>&#x2202;</mo><msup><mi>x</mi><mi>m</mi></msup></mrow>
  <mrow><mo>&#x2202;</mo><msup><mi>y</mi><mi>n</mi></msup></mrow>
 </mrow>
</mfrac>]]></eg>

<graphic source="image/calculus1-partialdiff-ex1.gif" alt="{\frac{{\msup{\unicode{8706}}{k}{\mathop{f}{\left(x,y\right)}}}}{{{\unicode{8706}\msup{x}{m}}{\unicode{8706}\msup{y}{n}}}}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When applied to a function, the <el>partialdiff</el> element
corresponds to the <symbolref cd="calculus1" name="partialdiff"/>
symbol from the <cdref cd="calculus1"/> content dictionary. No special
rules are necessary as the two arguments of <el>partialdiff</el>
translate directly to the two arguments of
<symbolref cd="calculus1" name="partialdiff"/>.</p>

<div id="contm_p2s.partialdiff" role="strict-mathml-example">
           <head>Rewrite: partialdiffdegree</head>

<p>If <el>partialdiff</el> is used with an expression and
<el>bvar</el> qualifiers it is rewritten to
Strict Content MathML using the 
<symbolref cd="calculus1" name="partialdiffdegree"/> symbol.

<eg meta="ci" role="mathml"><![CDATA[
<apply><partialdiff/>
  <bvar><ci>x1</ci><degree><ci>n1</ci></degree></bvar>
  <bvar><ci>xk</ci><degree><ci>nk</ci></degree></bvar>
  <degree><ci>total-n1-nk</ci></degree>
  <ci>expression-in-x1-xk</ci>
</apply>]]></eg>
<code meta="ci"><![CDATA[<ci>expression-in-x1-xk</ci>]]></code> is an
arbitrary expression involving the bound variables.</p>
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">partialdiffdegree</csymbol>
    <apply><csymbol cd="list1">list</csymbol>
      <ci>n1</ci> <ci>nk</ci>
    </apply>
    <ci>total-n1-nk</ci>
    <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x1</ci></bvar>
    <bvar><ci>xk</ci></bvar>
    <ci>expression-in-x1-xk</ci>
   </bind>
  </apply>
  <ci>x1</ci>
  <ci>xk</ci>
</apply>]]></eg>
<p>If any of the bound variables do not use a <el>degree</el> qualifier, 
<code><![CDATA[<cn>1</cn>]]></code> should be used in place of the degree.
If the original expression did not use the total degree qualifier then 
the second argument to <symbolref cd="calculus1" name="partialdiffdegree"/>
should be the sum of the degrees, for example
<eg meta="ci" role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">plus</csymbol>
  <ci>n1</ci> <ci>nk</ci>
</apply>]]></eg></p>
</div>

<div id="contm_p2s.partialdiff.ex1" role="strict-mathml-example">
<p>With this rule, the expression
<eg role="mathml"><![CDATA[
<apply><partialdiff/>
  <bvar><ci>x</ci><degree><ci>n</ci></degree></bvar>
  <bvar><ci>y</ci><degree><ci>m</ci></degree></bvar>
  <apply><sin/>
    <apply><times/><ci>x</ci><ci>y</ci></apply>
  </apply>
</apply>]]></eg>
is translated into 
<eg role="strict-mathml"><![CDATA[
<apply>
  <apply><csymbol cd="calculus1">partialdiffdegree</csymbol>
    <apply><csymbol cd="list1">list</csymbol>
      <ci>n</ci><ci>m</ci>
    </apply>
    <apply><csymbol cd="arith1">plus</csymbol>
      <ci>n</ci><ci>m</ci>
    </apply>
    <bind><csymbol cd="fns1">lambda</csymbol>
      <bvar><ci>x</ci></bvar>
      <bvar><ci>y</ci></bvar>
      <apply><csymbol cd="transc1">sin</csymbol>
        <apply><csymbol cd="arith1">times</csymbol>
          <ci>x</ci><ci>y</ci>
        </apply>
      </apply>
    </bind>
    <ci>x</ci>
    <ci>y</ci>
  </apply>
</apply>]]></eg>
</p>
</div>

</div4>

<div4 id="contm_divergence"><head>Divergence <el role="defn emptytag">divergence</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-veccalc</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="veccalc1" name="divergence"/></td></tr>
</tbody>
</table>

<p>The <el>divergence</el> element is the vector calculus divergence
operator, often called div. It represents the divergence function
which takes one argument which should be a vector of scalar-valued
functions, intended to represent a vector-valued function, and returns
the scalar-valued function giving the divergence of the argument.</p>

<div id="veccalc1.divergence.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><divergence/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>div</mi><mo>&#x2061;</mo><mfenced><mi>a</mi></mfenced></mrow>]]></eg>

<graphic source="image/veccalc1-divergence-ex1.gif" alt="{\mathop{{\minormal{div}}}{\left(a\right)}}"/>
</div>

<div id="veccalc1.divergence.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><divergence/>
  <ci type="vector">E</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>div</mi><mo>&#x2061;</mo><mfenced><mi>E</mi></mfenced></mrow>]]></eg>

<graphic source="image/veccalc1-divergence-ex2.gif" alt="{\mathop{{\minormal{div}}}{\left(E\right)}}"/>

<eg role="mathml"><![CDATA[
<mrow><mo>&#x2207;</mo><mo>&#x22c5;</mo><mi>E</mi></mrow>]]></eg>

<graphic source="image/veccalc1-divergence-ex2-2.gif" alt="{\unicode{8711}\unicode{8901}E}"/>

</div>

<p>The functions defining the coordinates may be defined implicitly as expressions defined
in terms of the coordinate names, in which case the coordinate names must be provided as
bound variables.</p>

<div id="veccalc1.divergence.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><divergence/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <bvar><ci>z</ci></bvar>
  <vector>
    <apply><plus/><ci>x</ci><ci>y</ci></apply>
    <apply><plus/><ci>x</ci><ci>z</ci></apply>
    <apply><plus/><ci>z</ci><ci>y</ci></apply>
  </vector>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>div</mi>
 <mo>&#x2061;</mo>
 <mo>(</mo>
 <mtable>
  <mtr><mtd>
   <mi>x</mi>
   <mo>&#x21a6;</mo>
   <mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow>
  </mtd></mtr>
  <mtr><mtd>
   <mi>y</mi>
   <mo>&#x21a6;</mo>
   <mrow><mi>x</mi><mo>+</mo><mi>z</mi></mrow>
  </mtd></mtr>
  <mtr><mtd>
   <mi>z</mi>
   <mo>&#x21a6;</mo>
   <mrow><mi>z</mi><mo>+</mo><mi>y</mi></mrow>
  </mtd></mtr>
 </mtable>
 <mo>)</mo>
</mrow>]]></eg>

<graphic source="image/veccalc1-divergence-ex3.gif"
alt="{\left.\mathop{{\minormal{div}}}\middle({\begin{matrix}x\unicode{8614}{x+y}\\y\unicode{8614}{x+z}\\z\unicode{8614}{z+y}\end{matrix}}\middle)\right.}"/>

</div>

</div4>

<div4 id="contm_grad">
  <head>Gradient <el role="defn emptytag">grad</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-veccalc</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="veccalc1" name="grad"/></td></tr>
</tbody>
</table>
  <p>The <el>grad</el> element is the vector calculus gradient operator, often called
  grad. It is used to represent the grad function, which takes one
  argument which should be a scalar-valued function and returns a
  vector of functions.</p> 

<div id="veccalc1.gradient.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><grad/><ci type="function">f</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>grad</mi><mo>&#x2061;</mo><mfenced><mi>f</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/veccalc1-gradient-ex1.gif" alt="{\mathop{{\minormal{grad}}}{\left(f\right)}}"/>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x2207;</mo><mo>&#x2061;</mo>
 <mfenced><mi>f</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/veccalc1-gradient-ex1-2.gif" alt="{\unicode{8711}\unicode{8289}{\left(f\right)}}"/>

</div>

  <p>The functions defining the coordinates may be defined implicitly as expressions
  defined in terms of the coordinate names, in which case the coordinate names must be
  provided as bound variables.</p>  

  <div id="veccalc1.gradient.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><grad/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <bvar><ci>z</ci></bvar>
  <apply><times/><ci>x</ci><ci>y</ci><ci>z</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>grad</mi>
 <mo>&#x2061;</mo>
 <mrow>
  <mo>(</mo>
  <mfenced><mi>x</mi><mi>y</mi><mi>z</mi></mfenced>
  <mo>&#x21a6;</mo>
  <mrow>
   <mi>x</mi><mo>&#x2062;</mo><mi>y</mi><mo>&#x2062;</mo><mi>z</mi>
  </mrow>
  <mo>)</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/veccalc1-gradient-ex2.gif" alt="{\mathop{{\minormal{grad}}}{\left.\middle({\left(x,y,z\right)}\unicode{8614}{x\unicode{8290}y\unicode{8290}z}\middle)\right.}}"/>

</div>
</div4>

<div4 id="contm_curl"><head>Curl <el role="defn emptytag">curl</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-veccalc</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="veccalc1" name="curl"/></td></tr>
</tbody>
</table>

  <p>The <el>curl</el> element is used to represent the curl function
  of vector calculus. It takes one argument which should be a vector
  of scalar-valued functions, intended to represent a vector-valued
  function, and returns a vector of functions.</p>

  <div id="veccalc1.curl.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><curl/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>curl</mi><mo>&#x2061;</mo><mfenced><mi>a</mi></mfenced></mrow>]]></eg>

<graphic source="image/veccalc1-curl-ex1.gif" alt="{\mathop{{\minormal{curl}}}{\left(a\right)}}"/>

<eg role="mathml"><![CDATA[
<mrow><mo>&#x2207;</mo><mo>&#xd7;</mo><mi>a</mi></mrow>]]></eg>

<graphic source="image/veccalc1-curl-ex1-2.gif" alt="{\unicode{8711}\unicode{215}a}"/>

</div>

  <p>The functions defining the coordinates may be defined implicitly as expressions
  defined in terms of the coordinate names, in which case the coordinate names must be
  provided as bound variables.</p>

</div4>

<div4 id="contm_laplacian"><head>Laplacian <el role="defn emptytag">laplacian</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-veccalc</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="veccalc1" name="Laplacian"/></td></tr>
</tbody>
</table>

<p>The <el>laplacian</el> element represents the Laplacian operator of
vector calculus.  The Laplacian takes a single argument which is a
vector of scalar-valued functions representing a vector-valued
function, and returns a vector of functions.</p>

  <div id="veccalc1.laplacian.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><laplacian/><ci type="vector">E</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mo>&#x2207;</mo><mn>2</mn></msup>
 <mo>&#x2061;</mo>
 <mfenced><mi>E</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/veccalc1-laplacian-ex1.gif" alt="{\msup{\unicode{8711}}{{2}}\unicode{8289}{\left(E\right)}}"/>
</div>
  <p>The functions defining the coordinates may be defined implicitly as expressions
  defined in terms of the coordinate names, in which case the coordinate names must be
  provided as bound variables.</p>
  <div id="veccalc1.laplacian.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><laplacian/>
  <bvar><ci>x</ci></bvar>
  <bvar><ci>y</ci></bvar>
  <bvar><ci>z</ci></bvar>
  <apply><ci>f</ci><ci>x</ci><ci>y</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mo>&#x2207;</mo><mn>2</mn></msup>
 <mo>&#x2061;</mo>
 <mrow>
  <mo>(</mo>
  <mfenced><mi>x</mi><mi>y</mi><mi>z</mi></mfenced>
  <mo>&#x21a6;</mo>
  <mrow>
   <mi>f</mi>
   <mo>&#x2061;</mo>
   <mfenced><mi>x</mi><mi>y</mi></mfenced>
  </mrow>
  <mo>)</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/veccalc1-laplacian-ex2.gif" alt="{\msup{\unicode{8711}}{{2}}\unicode{8289}{\left.\middle({\left(x,y,z\right)}\unicode{8614}{\mathop{f}{\left(x,y\right)}}\middle)\right.}}"/>

</div>

</div4>
</div3>

<div3 id="contm_sets">
  <head>Theory of Sets</head>

<div4 id="contm_set"><head>Set <el role="defn starttag">set</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-setlist-constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>, <kw role="parsing_ref">type</kw>?</td></tr>
     <tr>
       <th><att>type</att> Attribute Values</th>
       <td><attval>set</attval> | <attval>multiset</attval> | text </td>
     </tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>*</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="set"/>, <symbolref cd="multiset1" name="multiset"/></td></tr>
</tbody>
</table>

  <p>The <el>set</el> represents a function which constructs
  mathematical sets from its arguments. It is an n-ary function. The
  members of the set to be constructed may be given explicitly as
  child elements of the constructor, or specified by rule as described
  in <specref ref="contm_container_constructor"/>.  There is no implied ordering to
  the elements of a set.</p>

  <div id="set1.set.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<set>
  <ci>a</ci><ci>b</ci><ci>c</ci>
</set>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>}</mo>
</mrow>]]></eg>

<graphic source="image/set1-set-ex1.gif" alt="{\left.\middle\{a,b,c\middle\}\right.}"/>
</div>

  <p>In general, a set can be constructed by providing a function and a domain of
  application.  The elements of the set correspond to the values obtained by evaluating
  the function at the points of the domain.</p>
  <div id="set1.suchthat.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<set>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><lt/><ci>x</ci><cn>5</cn></apply>
  </condition>
  <ci>x</ci>
</set>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo>
 <mi>x</mi>
 <mo>|</mo>
 <mrow><mi>x</mi><mo>&lt;</mo><mn>5</mn></mrow>
 <mo>}</mo>
</mrow>]]></eg>

<graphic source="image/set1-suchthat-ex1.gif" alt="{\left.\middle\{x\middle|{x\lt{5}}\middle\}\right.}"/>
</div>
  <div id="set1.suchthat.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<set>
  <bvar><ci type="set">S</ci></bvar>
  <condition>
    <apply><in/><ci>S</ci><ci type="list">T</ci></apply>
  </condition>
  <ci>S</ci>
</set>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo>
 <mi>S</mi>
 <mo>|</mo>
 <mrow><mi>S</mi><mo>&#x2208;</mo><mi>T</mi></mrow>
 <mo>}</mo>
</mrow>]]></eg>

<graphic source="image/set1-suchthat-ex2.gif" alt="{\left.\middle\{S\middle|{S\unicode{8712}T}\middle\}\right.}"/>
</div>
  <div id="set1.suchthat.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<set>
  <bvar><ci> x </ci></bvar>
  <condition>
    <apply><and/>
      <apply><lt/><ci>x</ci><cn>5</cn></apply>
      <apply><in/><ci>x</ci><naturalnumbers/></apply>
    </apply>
  </condition>
  <ci>x</ci>
</set>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>{</mo>
 <mi>x</mi>
 <mo>|</mo>
 <mrow>
  <mrow><mo>(</mo><mi>x</mi><mo>&lt;</mo><mn>5</mn><mo>)</mo></mrow>
  <mo>&#x2227;</mo>
  <mrow>
   <mi>x</mi><mo>&#x2208;</mo><mi mathvariant="double-struck">N</mi>
  </mrow>
 </mrow>
 <mo>}</mo>
</mrow>]]></eg>

<graphic source="image/set1-suchthat-ex3.gif" alt="{\left.\middle\{x\middle|{{\left.\middle(x\lt{5}\middle)\right.}\unicode{8743}{x\unicode{8712}{\midoublestruck{N}}}}\middle\}\right.}"/>
</div>
</div4>

<div4 id="contm_list"><head>List <el role="defn starttag">list</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-setlist-constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>,  <kw role="parsing_ref">order</kw></td></tr>
     <tr>
       <th><att>order</att> Attribute Values</th>
       <td>"numeric" | "lexicographic"</td>
     </tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>*</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="interval1" name="interval_cc"/>, <symbolref cd="list1" name="list"/></td></tr>
</tbody>
</table>

  <p>The <el>list</el> elements represents the n-ary function which
  constructs a list from its arguments. Lists differ from sets in that
  there is an explicit order to the elements.</p>

  <p>The list entries and order may be given explicitly.</p>   

  <div id="list1.list.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<list>
  <ci>a</ci><ci>b</ci><ci>c</ci>
</list>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>)</mo>
</mrow>]]></eg>

<graphic source="image/list1-list-ex1.gif" alt="{\left.\middle(a,b,c\middle)\right.}"/>
</div>

  <p>In general a list can be constructed by providing a function and
  a domain of application.  The elements of the list correspond to the
  values obtained by evaluating the function at the points of the
  domain. When this method is used, the ordering of the list elements
  may not be clear, so the kind of ordering may be specified by the
  <att>order</att> attribute.  Two orders are supported: lexicographic
  and numeric.</p>

  <div id="list1.suchthat.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<list order="numeric">
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><lt/><ci>x</ci><cn>5</cn></apply>
  </condition>
</list>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>(</mo>
 <mi>x</mi>
 <mo>|</mo>
 <mrow><mi>x</mi><mo>&lt;</mo><mn>5</mn></mrow>
 <mo>)</mo>
</mrow>]]></eg>

<graphic source="image/list1-suchthat-ex1.gif" alt="{\left.\middle(x\middle|{x\lt{5}}\middle)\right.}"/>
</div>
</div4>

<div4 id="contm_union"><head>Union <el role="defn emptytag">union</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="union"/></td></tr>
</tbody>
</table>

  <p>The <el>union</el> element is used to denote the n-ary union of sets. It takes sets as arguments,
  and denotes the set that contains all the elements that occur in any
  of them.</p>

  <p>Arguments may be explicitly specified.</p>

  <div id="set1.union.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><union/><ci>A</ci><ci>B</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x222a;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-union-ex1.gif" alt="{A\unicode{8746}B}"/>
</div>

<p>Arguments may also be specified using qualifier elements as described in
<specref ref="contm_nary"/>. operator element can be used as a binding
operator to construct the union over a collection of sets.</p>

  <div id="set1.big_union.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><union/>
  <bvar><ci type="set">S</ci></bvar>
  <domainofapplication>
    <ci type="list">L</ci>
  </domainofapplication>
  <ci type="set"> S</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><munder><mo>&#x22c3;</mo><mi>L</mi></munder><mi>S</mi></mrow>]]></eg>

<graphic source="image/set1-big_union-ex1.gif" alt="{\munder{\unicode{8899}}{L}S}"/>
</div>
</div4>

<div4 id="contm_intersect"><head>Intersect <el role="defn emptytag">intersect</el></head>
<table role="syntax">
<tbody>

<tr><th>Class</th><td><intref ref="contm_nary">nary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="intersect"/></td></tr>
</tbody>
</table>
  <p>The <el>intersect</el> element is used to denote the n-ary
  intersection of sets. It takes sets as arguments, and denotes the
  set that contains all the elements that occur in all of them.  Its arguments may be explicitly specified in the
  enclosing <el>apply</el> element, or specified using qualifier
  elements as described in <specref ref="contm_nary"/>.</p> 

  <div id="set1.intersect.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><intersect/>
  <ci type="set"> A </ci>
  <ci type="set"> B </ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2229;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-intersect-ex1.gif" alt="{A\unicode{8745}B}"/>
</div>

  <div id="set1.big_intersect.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><intersect/>
  <bvar><ci type="set">S</ci></bvar>
  <domainofapplication><ci type="list">L</ci></domainofapplication>
  <ci type="set"> S </ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><munder><mo>&#x22c2;</mo><mi>L</mi></munder><mi>S</mi></mrow>]]></eg>
<graphic source="image/set1-big_intersect-ex1.gif" alt="{\munder{\unicode{8898}}{L}S}"/>

</div>
</div4>

<div4 id="contm_in"><head>Set inclusion <el role="defn emptytag">in</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="in"/></td></tr>
</tbody>
</table>

  <p>The <el>in</el> element represents the set inclusion relation.
  It has two arguments, an element and a set. It is used to denote
  that the element is in the given set.</p> 

  <div id="set1.in.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/><ci>a</ci><ci type="set">A</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>&#x2208;</mo><mi>A</mi></mrow>]]></eg>

<graphic source="image/set1-in-ex1.gif" alt="{a\unicode{8712}A}"/>
</div>

  <p>When translating to Strict Content Markup, if the <att>type</att>
  has value <attval>multiset</attval>, then the <symbolref
  cd="multiset1" name="in"/> symbol from <cdref cd="multiset1"/> should
  be used instead.</p>

</div4>

<div4 id="contm_notin"><head>Set exclusion <el role="defn emptytag">notin</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="notin"/></td></tr>
</tbody>
</table>
  <p>The <el>notin</el> represents the negated set inclusion
  relation. It has two arguments, an element and a set. It is
  used to denote that the element is not in the given set.</p> 

  <div id="set1.notin.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><notin/><ci>a</ci><ci type="set">A</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>a</mi><mo>&#x2209;</mo><mi>A</mi></mrow>]]></eg>

<graphic source="image/set1-notin-ex1.gif" alt="{a\unicode{8713}A}"/>
</div>

  <p>When translating to Strict Content Markup, if the <att>type</att> has value <attval>multiset</attval>, then
  the <symbolref cd="multiset1" name="in"/> symbol from <cdref
  cd="multiset1"/> should be used instead.</p> 

</div4>

<div4 id="contm_subset"><head>Subset <el role="defn emptytag">subset</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_reln">nary-set-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="subset"/></td></tr>
</tbody>
</table>

  <p>The <el>subset</el> element represents the subset relation.  It is used to denote that the
  first argument is a subset of the second.  As described in <specref
  ref="contm_nary_reln"/>, it may also be used as an n-ary operator to express
  that each argument is a subset of its predecessor.</p>

  <div id="set1.subset.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><subset/>
  <ci type="set">A</ci>
  <ci type="set">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2286;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-subset-ex1.gif" alt="{A\unicode{8838}B}"/>
</div>
</div4>


<div4 id="contm_prsubset">
<head>Proper Subset <el role="defn emptytag">prsubset</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_reln">nary-set-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="prsubset"/></td></tr>
</tbody>
</table>


  <p>The <el>prsubset</el> element represents the proper subset
  relation, i.e. that the first argument is a proper subset of the
  second.  As described in <specref ref="contm_nary_reln"/>, it may
  also be used as an n-ary operator to express that each argument is a
  proper subset of its predecessor.</p>

  <div id="set1.prsubset.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><prsubset/>
  <ci type="set">A</ci>
  <ci type="set">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2282;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-prsubset-ex1.gif" alt="{A\unicode{8834}B}"/>
</div>
</div4>

<div4 id="contm_notsubset"><head>Not Subset <el role="defn emptytag">notsubset</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="notsubset"/></td></tr>
</tbody>
</table>

  <p>The <el>notsubset</el> element represents the negated subset
  relation. It is used to denote that the first argument is not a subset of the
  second.</p>

  <div id="set1.notsubset.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><notsubset/>
  <ci type="set">A</ci>
  <ci type="set">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2288;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-notsubset-ex1.gif" alt="{A\unicode{8840}B}"/>
</div>

 <p>When translating to Strict Content Markup, if the <att>type</att> has value <attval>multiset</attval>, then
  the <symbolref cd="multiset1" name="in"/> symbol from <cdref
  cd="multiset1"/> should be used instead.</p> 

</div4>


<div4 id="contm_notprsubset"><head>Not Proper Subset <el role="defn emptytag">notprsubset</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="notprsubset"/></td></tr>
</tbody>
</table>

  <p>The <el>notprsubset</el> element represents the negated proper
  subset relation. It is used to denote that the first argument is not
  a proper subset of the second.</p>

  <div id="set1.notprsubset.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><notprsubset/>
  <ci type="set">A</ci>
  <ci type="set">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2284;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-notprsubset-ex1.gif" alt="{A\unicode{8836}B}"/>
</div>
 <p>When translating to Strict Content Markup, if the <att>type</att> has value <attval>multiset</attval>, then
  the <symbolref cd="multiset1" name="in"/> symbol from <cdref
  cd="multiset1"/> should be used instead.</p> 
</div4>

<div4 id="contm_setdiff"><head>Set Difference <el role="defn emptytag">setdiff</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="setdiff"/>, <symbolref cd="multiset1" name="setdiff"/></td></tr>
</tbody>
</table>

  <p>The <el>setdiff</el> element represents set difference
  operator. It takes two sets as arguments, and denotes the set that
  contains all the elements that occur in the first set, but not in
  the second.</p> 

  <div id="set1.setdiff.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><setdiff/>
  <ci type="set">A</ci>
  <ci type="set">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2216;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-setdiff-ex1.gif" alt="{A\unicode{8726}B}"/>
</div>
 <p>When translating to Strict Content Markup, if the <att>type</att> has value <attval>multiset</attval>, then
  the <symbolref cd="multiset1" name="in"/> symbol from <cdref
  cd="multiset1"/> should be used instead.</p> 
</div4>

<div4 id="contm_card"><head>Cardinality <el role="defn emptytag">card</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="size"/>, <symbolref cd="multiset1" name="size"/></td></tr>
</tbody>
</table>

  <p>The <el>card</el> element represents the cardinality function,
  which takes a set argument and returns its cardinality, i.e. the
  number of elements in the set.  The cardinality of a set is a
  non-negative integer, or an infinite cardinal number.</p>

  <div id="set1.size.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><card/><ci>A</ci></apply>
  <cn>5</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mo>|</mo><mi>A</mi><mo>|</mo></mrow>
 <mo>=</mo>
 <mn>5</mn>
</mrow>]]></eg>

<graphic source="image/set1-size-ex1.gif" alt="{{\left.\middle|A\middle|\right.}={5}}"/>
</div>
  <p>When translating to Strict Content Markup, if the <att>type</att>
  has value <attval>multiset</attval>, then the <symbolref
  cd="multiset1" name="size"/> symbol from <cdref cd="multiset1"/> should be used
  instead.</p>
</div4>


<div4 id="contm_cartesianproduct"><head>Cartesian product <el role="defn emptytag">cartesianproduct</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="cartesian_product"/></td></tr>
</tbody>
</table>

<p>The <el>cartesianproduct</el> element is used to represents the
Cartesian product operator. It takes sets as arguments, which may be
explicitly specified in the enclosing <el>apply</el> element, or
specified using qualifier elements as described in <specref
ref="contm_nary"/>.</p>

  <div id="set1.cartesianproduct.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><cartesianproduct/><ci>A</ci><ci>B</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#xd7;</mo><mi>B</mi></mrow>]]></eg>

<graphic source="image/set1-cartesianproduct-ex1.gif" alt="{A\unicode{215}B}"/>
</div>
</div4>

</div3>

<div3><head>Sequences and Series</head>

<div4 id="contm_sum"><head>Sum <el role="defn emptytag">sum</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">sum</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="sum"/></td></tr>
</tbody>
</table>

  <p>The <el>sum</el> element represents the n-ary addition operator.
  The terms of the sum are normally specified by rule through the use of
  qualifiers.  While it can be used with an explicit list of
  arguments, this is strongly discouraged, and the <el>plus</el>
  operator should be used instead in such situations.</p>

  <p>The <el>sum</el> operator may be used either with or without
  explicit bound variables.  When a bound variable is used, the
  <el>sum</el> element is followed by one or more <el>bvar</el>
  elements giving the index variables, followed by qualifiers giving
  the domain for the index variables. The final child in the enclosing
  <el>apply</el> is then an expression in the bound variables, and the
  terms of the sum are obtained by evaluating this expression at each
  point of the domain of the index variables.  Depending on the
  structure of the domain, the domain of summation is often given
  by using <el>uplimit</el> and <el>lowlimit</el> to specify upper and
  lower limits for the sum.</p>

  <p>When no bound variables are explicitly given, the final child of
  the enclosing <el>apply</el> element must be a function, and the
  terms of the sum are obtained by evaluating the function at
  each point of the domain specified by qualifiers.</p>

  <div id="arith1.sum.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sum/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><ci>a</ci></lowlimit>
  <uplimit><ci>b</ci></uplimit>
  <apply><ci>f</ci><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>

<eg role="mathml"><![CDATA[
<mrow>
 <munderover>
  <mo>&#x2211;</mo>
  <mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow>
  <mi>b</mi>
 </munderover>
 <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
</mrow>]]></eg>

<graphic source="image/arith1-sum-ex1.gif" alt="{\munderover{\unicode{8721}}{{x=a}}{b}{\mathop{f}{\left(x\right)}}}"/>

</div>
  <div id="arith1.sum.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sum/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><in/><ci>x</ci><ci type="set">B</ci></apply>
  </condition>
  <apply><ci type="function">f</ci><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munder>
  <mo>&#x2211;</mo>
  <mrow><mi>x</mi><mo>&#x2208;</mo><mi>B</mi></mrow>
 </munder>
 <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
</mrow>]]></eg>

<graphic source="image/arith1-sum-ex2.gif" alt="{\munder{\unicode{8721}}{{x\unicode{8712}B}}{\mathop{f}{\left(x\right)}}}"/>

</div>
  <div id="arith1.sum.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sum/>
  <domainofapplication>
    <ci type="set">B</ci>
  </domainofapplication>
  <ci type="function">f</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><munder><mo>&#x2211;</mo><mi>B</mi></munder><mi>f</mi></mrow>]]></eg>

<graphic source="image/arith1-sum-ex3.gif" alt="{\munder{\unicode{8721}}{B}f}"/>

</div>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>When no explicit bound variables are used, no special rules are
required to rewrite sums as Strict Content beyond the generic rules
for rewriting expressions using qualifiers.  However, when bound
variables are used, it is necessary to introduce a <el>lambda</el>
construction to rewrite the expression in the bound variables as a
function.</p>

<div id="contm_strict-sum" role="strict-mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sum/>
  <bvar><ci>i</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><cn>100</cn></uplimit>
  <apply><power/><ci>x</ci><ci>i</ci></apply>
</apply>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">sum</csymbol>
  <apply><csymbol cd="interval1">integer_interval</csymbol>
    <cn>0</cn>
    <cn>100</cn>
  </apply>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>i</ci></bvar>
    <apply><csymbol cd="arith1">power</csymbol><ci>x</ci><ci>i</ci></apply>
  </bind>
</apply>]]></eg>
</div>
</div4>

<div4 id="contm_product"><head>Product <el role="defn emptytag">product</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">product</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="arith1" name="product"/></td></tr>
</tbody>
</table>

  <p>The <el>product</el> element represents the n-ary multiplication operator.
  The terms of the product are normally specified by rule through the use of
  qualifiers.  While it can be used with an explicit list of
  arguments, this is strongly discouraged, and the <el>times</el>
  operator should be used instead in such situations.</p>

  <p>The <el>product</el> operator may be used either with or without
  explicit bound variables.  When a bound variable is used, the
  <el>product</el> element is followed by one or more <el>bvar</el>
  elements giving the index variables, followed by qualifiers giving
  the domain for the index variables. The final child in the enclosing
  <el>apply</el> is then an expression in the bound variables, and the
  terms of the product are obtained by evaluating this expression at
  each point of the domain.  Depending on the structure of the domain,
  it is commonly given using <el>uplimit</el> and <el>lowlimit</el>
  qualifiers.</p>

  <p>When no bound variables are explicitly given, the final child of
  the enclosing <el>apply</el> element must be a function, and the
  terms of the product are obtained by evaluating the function
  at each point of the domain specified by qualifiers.</p>

  <div id="arith1.product.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><product/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><ci>a</ci></lowlimit>
  <uplimit><ci>b</ci></uplimit>
  <apply><ci type="function">f</ci>
    <ci>x</ci>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munderover>
  <mo>&#x220f;</mo>
  <mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow>
  <mi>b</mi>
 </munderover>
 <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
</mrow>]]></eg>

<graphic source="image/arith1-product-ex1.gif" alt="{\munderover{\unicode{8719}}{{x=a}}{b}{\mathop{f}{\left(x\right)}}}"/>

</div>
  <div id="arith1.product.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><product/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><in/>
      <ci>x</ci>
      <ci type="set">B</ci>
    </apply>
  </condition>
  <apply><ci>f</ci><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munder>
  <mo>&#x220f;</mo>
  <mrow><mi>x</mi><mo>&#x2208;</mo><mi>B</mi></mrow>
 </munder>
 <mrow><mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi></mfenced></mrow>
</mrow>]]></eg>

<graphic source="image/arith1-product-ex2.gif" alt="{\munder{\unicode{8719}}{{x\unicode{8712}B}}{\mathop{f}{\left(x\right)}}}"/>

</div>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>When no explicit bound variables are used, no special rules are
required to rewrite products as Strict Content beyond the generic rules
for rewriting expressions using qualifiers.  However, when bound
variables are used, it is necessary to introduce a <el>lambda</el>
construction to rewrite the expression in the bound variables as a
function.</p>

<div id="contm_strict-product" role="strict-mathml-example">
<p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><product/>
  <bvar><ci>i</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <uplimit><cn>100</cn></uplimit>
  <apply><power/><ci>x</ci><ci>i</ci></apply>
</apply>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="arith1">product</csymbol>
  <apply><csymbol cd="interval1">integer_interval</csymbol>
    <cn>0</cn>
    <cn>100</cn>
  </apply>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>i</ci></bvar>
    <apply><csymbol cd="arith1">power</csymbol><ci>x</ci><ci>i</ci></apply>
  </bind>
</apply>]]></eg>
</div>
</div4>

<div4 id="contm_limit"><head>Limits <el role="defn emptytag">limit</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_otherclass">limit</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td>
<kw role="parsing_ref">lowlimit</kw>,
<kw role="parsing_ref">condition</kw>
</td></tr>
<tr><th>OM Symbols</th><td>
<symbolref cd="limit1" name="limit"/>,
<symbolref cd="limit1" name="both_sides"/>,
<symbolref cd="limit1" name="above"/>,
<symbolref cd="limit1" name="below"/>,
<symbolref cd="limit1" name="null"/>
</td></tr>
</tbody>
</table>


<p>The <el>limit</el> element represents the operation of taking a limit of a
sequence. The limit point is expressed by specifying a <el>lowlimit</el> and a
<el>bvar</el>, or by specifying a <el>condition</el> on one or more bound variables.</p>

<div id="limit1.limit.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><limit/>
  <bvar><ci>x</ci></bvar>
  <lowlimit><cn>0</cn></lowlimit>
  <apply><sin/><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munder>
  <mi>lim</mi>
  <mrow><mi>x</mi><mo>&#x2192;</mo><mn>0</mn></mrow>
 </munder>
 <mrow><mi>sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow>
</mrow>]]></eg>

<graphic source="image/limit1-limit-ex1.gif" alt="{\munder{{\minormal{lim}}}{{x\unicode{8594}{0}}}{\mathop{{\minormal{sin}}}x}}"/>
</div>
<div id="limit1.limit.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><limit/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><tendsto/><ci>x</ci><cn>0</cn></apply>
  </condition>
  <apply><sin/><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munder>
  <mi>lim</mi>
  <mrow><mi>x</mi><mo>&#x2192;</mo><mn>0</mn></mrow>
 </munder>
 <mrow><mi>sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow>
</mrow>]]></eg>

<graphic source="image/limit1-limit-ex2.gif" alt="{\munder{{\minormal{lim}}}{{x\unicode{8594}{0}}}{\mathop{{\minormal{sin}}}x}}"/>
</div>
<div id="limit1.limit.ex3" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><limit/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><tendsto type="above"/><ci>x</ci><ci>a</ci></apply>
  </condition>
  <apply><sin/><ci>x</ci></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <munder>
  <mi>lim</mi>
  <mrow><mi>x</mi><mo>&#x2192;</mo><msup><mi>a</mi><mo>+</mo></msup></mrow>
 </munder>
 <mrow><mi>sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow>
</mrow>]]></eg>

<graphic source="image/limit1-limit-ex3.gif" alt="{\munder{{\minormal{lim}}}{{x\unicode{8594}\msup{a}{+}}}{\mathop{{\minormal{sin}}}x}}"/>
</div>

<p>The direction from which a limiting value is approached is given as an argument
<symbolref cd="limit1" name="limit"/> in Strict Content MathML, which supplies the
direction specifier symbols <symbolref cd="limit1" name="both_sides"/>, <symbolref cd="limit1" name="above"/>, and <symbolref cd="limit1" name="below"/> for this
purpose. The first correspond to the values <attval>all</attval>, <attval>above</attval>,
and <attval>below</attval> of the <att>type</att> attribute of the <el>tendsto</el>
element below. The <symbolref cd="limit1" name="null"/> symbol corresponds to the case
where no <att>type</att> attribute is present. We translate</p>

<div id="contm_strict-limit" role="strict-mathml-example">
<head>Rewrite: limits condition</head>
<eg meta="ci cn" role="mathml"><![CDATA[
<apply><limit/>
  <bvar><ci>x</ci></bvar>
  <condition>
    <apply><tendsto/><ci>x</ci><cn>0</cn></apply>
  </condition>
  <ci>expression-in-x</ci>
</apply>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg meta="ci cn #-null"  role="strict-mathml"><![CDATA[
<apply><csymbol cd="limit1">limit</csymbol>
  <cn>0</cn>
  <csymbol cd="limit1">null</csymbol>
  <bind><csymbol cd="fns1">lambda</csymbol>
    <bvar><ci>x</ci></bvar>
    <ci>expression-in-x</ci>
  </bind>
</apply>]]></eg>
<p>where 
<code meta="ci"><![CDATA[<ci>expression-in-x</ci>]]></code> is an
arbitrary expression involving the bound variable(s), and the choice of
symbol, <symbolref cd="limit1" name="null"/> depends on the
<att>type</att> attribute of the <el>tendsto</el> element as
described above.</p>

</div>
</div4>

<div4 id="contm_tendsto"><head>Tends To <el role="defn emptytag">tendsto</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-reln</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw>, <kw role="parsing_ref">type</kw>?</td></tr>
     <tr>
       <th><att>type</att> Attribute Values</th>
       <td> string</td>
     </tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="limit1" name="limit"/></td></tr>
</tbody>
</table>

  <p>The <el>tendsto</el> element is used to express the relation that
  a quantity is tending to a specified value. While this is used
  primarily as part of the statement of a mathematical limit, it
  exists as a construct on its own to allow one to capture
  mathematical statements such as "As x tends to y," and to provide a
  building block to construct more general kinds of limits.</p>

  <p>The <el>tendsto</el> element takes the attributes <att>type</att> to set the
  direction from which the limiting value is approached.</p>

  <div id="limit1.tendsto.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><tendsto type="above"/>
  <apply><power/><ci>x</ci><cn>2</cn></apply>
   <apply><power/><ci>a</ci><cn>2</cn></apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mi>x</mi><mn>2</mn></msup>
 <mo>&#x2192;</mo>
 <msup><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo></msup>
</mrow>]]></eg>

<graphic source="image/limit1-tendsto-ex1.gif" alt="\msup{x}{2}\unicode{8594}\msup{\msup{a}{2}}{+}"/>
</div>
  <div id="limit1.tendsto.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><tendsto/>
  <vector><ci>x</ci><ci>y</ci></vector>
   <vector>
     <apply><ci type="function">f</ci><ci>x</ci><ci>y</ci></apply>
     <apply><ci type="function">g</ci><ci>x</ci><ci>y</ci></apply>
   </vector>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mfenced><mtable>
  <mtr><mtd><mi>x</mi></mtd></mtr>
  <mtr><mtd><mi>y</mi></mtd></mtr>
</mtable></mfenced>
<mo>&#x2192;</mo>
<mfenced><mtable>
  <mtr><mtd>
    <mi>f</mi><mo>&#x2061;</mo><mfenced><mi>x</mi><mi>y</mi></mfenced>
  </mtd></mtr>
  <mtr><mtd>
    <mi>g</mi><mo>&#x2061;</mo><mfenced><mi>x</mi><mi>y</mi></mfenced>
  </mtd></mtr>
</mtable></mfenced>]]></eg>

<graphic source="image/limit1-tendsto-ex2.gif"
alt="{{\left.\middle({\begin{matrix}x\\y\end{matrix}}\middle)\right.}\unicode{8594}{\left.\middle({\begin{matrix}{\mathop{f}{\left(x,y\right)}}\\{\mathop{g}{\left(x,y\right)}}\end{matrix}}\middle)\right.}}"/>
</div>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>The usage of <el>tendsto</el> to qualify a limit is formally
defined by writing the expression in Strict Content MathML via the
rule <specref ref="contm_strict-limit"/>. The meanings of other more
idiomatic uses of <el>tendsto</el> are not formally defined by this
specification. When rewriting these cases to Strict Content MathML,
<el>tendsto</el> should be rewritten to an annotated identifier as
shown below.</p>

<div id="contm_strict_tendsto" role="strict-mathml-example">
<head>Rewrite: tendsto</head>
<eg role="mathml"><![CDATA[
<tendsto/>]]>
</eg>
<p>Strict Content MathML equivalent:</p>
<eg role="mathml"><![CDATA[
<semantics>
 <ci>tendsto</ci>
 <annotation-xml encoding="MathML-Content">
  <tendsto/>
 </annotation-xml>
</semantics>]]></eg>
</div>
</div4>
</div3>

<div3 id="contm_elemclass"><head>Elementary classical functions</head>

<div4 id="contm_trig"><head>Common trigonometric functions
<phrase>
<el role="defn emptytag">sin</el>,
<el role="defn emptytag">cos</el>,
<el role="defn emptytag">tan</el>,
<el role="defn emptytag">sec</el>,
<el role="defn emptytag">csc</el>,
<el role="defn emptytag">cot</el>
</phrase>
 </head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-elementary</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="sin"/></td></tr>
</tbody>
</table>


<p>These operator elements denote the standard trigonometric functions.  Since their standard
interpretations are widely known, they are discussed as a group.
</p>

<div id="transc1.sin.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sin/><ci>x</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow>]]></eg>

<graphic source="image/transc1-sin-ex1.gif" alt="{\mathop{{\minormal{sin}}}x}"/>
</div>
<div id="transc1.sin.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sin/>
  <apply><plus/>
    <apply><cos/><ci>x</ci></apply>
    <apply><power/><ci>x</ci><cn>3</cn></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>sin</mi>
 <mo>&#x2061;</mo>
 <mrow>
  <mo>(</mo>
  <mrow><mi>cos</mi><mo>&#x2061;</mo><mi>x</mi></mrow>
  <mo>+</mo>
  <msup><mi>x</mi><mn>3</mn></msup>
  <mo>)</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/transc1-sin-ex2.gif" alt="{\mathop{{\minormal{sin}}}{\left.\middle({\mathop{{\minormal{cos}}}x}+\msup{x}{{3}}\middle)\right.}}"/>
</div>
</div4>

<div4 id="contm_invtrig"><head>Common inverses of trigonometric functions
<el role="defn emptytag">arcsin</el>,
<el role="defn emptytag">arccos</el>,
<el role="defn emptytag">arctan</el>,
<el role="defn emptytag">arcsec</el>,
<el role="defn emptytag">arccsc</el>,
<el role="defn emptytag">arccot</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-elementary</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="arcsin"/></td></tr>
</tbody>
</table>
<p>These operator elements denote the inverses of standard trigonometric functions.
Differing definitions are in use so for maximum interoperability applications evaluating
such expressions should follow the definitions in <bibref ref="Abramowitz1977"/>.</p>

<div id="transc1.arcsin.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><arcsin/><ci>x</ci></apply>]]></eg>
<p>Sample Presentations</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>arcsin</mi>
 <mo>&#x2061;</mo>
 <mi>x</mi>
</mrow>]]></eg>
<graphic source="image/transc1-arcsin-ex1.gif" alt="{\mathop{{\minormal{arcsin}}}x}"/>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mi>sin</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup>
 <mo>&#x2061;</mo>
 <mi>x</mi>
</mrow>]]></eg>
<graphic source="image/transc1-arcsin-ex2.gif" alt="{\mathop{{\minormal{sin}}^{-1}}x}"/>
</div>

</div4>
<div4 id="contm_hyperbolic"><head>Common hyperbolic functions
<el role="defn emptytag">sinh</el>,
<el role="defn emptytag">cosh</el>,
<el role="defn emptytag">tanh</el>,
<el role="defn emptytag">sech</el>,
<el role="defn emptytag">csch</el>,
<el role="defn emptytag">coth</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-elementary</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="sinh"/></td></tr>
</tbody>
</table>
<p>These operator elements denote the standard hyperbolic functions.
Since their standard interpretations are widely known, they are discussed as a group.</p>

<div id="transc1.sinh.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sinh/><ci>x</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>sinh</mi><mo>&#x2061;</mo><mi>x</mi></mrow>]]></eg>

<!--<graphic source="image/transc1-sinh-ex1.gif" alt="{\mathop{{\minormal{sinh}}}x}"/>-->
</div>
</div4>

<div4 id="contm_invhyperbolic"><head>Common inverses of hyperbolic functions
<el role="defn emptytag">arcsinh</el>,
<el role="defn emptytag">arccosh</el>,
<el role="defn emptytag">arctanh</el>,
<el role="defn emptytag">arcsech</el>,
<el role="defn emptytag">arccsch</el>,
<el role="defn emptytag">arccoth</el> </head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-elementary</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="arcsinh"/></td></tr>
</tbody>
</table>
<p>These operator elements denote the inverses of standard hyperbolic functions.
Differing definitions are in use so for maximum interoperability applications evaluating
such expressions should follow the definitions in <bibref ref="Abramowitz1977"/>.</p>

<div id="transc1.arcsinh.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><arcsinh/><ci>x</ci></apply>]]></eg>
<p>Sample Presentations</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>arcsinh</mi>
 <mo>&#x2061;</mo>
 <mi>x</mi>
</mrow>]]></eg>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mi>sinh</mi><mrow><mo>-</mo><mn>1</mn></mrow></msup>
 <mo>&#x2061;</mo>
 <mi>x</mi>
</mrow>]]></eg>

<!--<graphic source="image/transc1-arcsinh-ex1.gif" alt="{\mathop{{\minormal{asinh}}}x}"/>-->
</div>
</div4>

<div4 id="contm_exp"><head>Exponential <el role="defn emptytag">exp</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="exp"/></td></tr>
</tbody>
</table>
<p>The <el>exp</el> element represents the exponentiation function
associated with the inverse of the ln function. It takes one
argument.</p>
<div id="transc1.exp.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><exp/><ci>x</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msup><mi>e</mi><mi>x</mi></msup>]]></eg>

<graphic source="image/transc1-exp-ex1.gif" alt="\msup{e}{x}"/>
</div>
</div4>

<div4 id="contm_ln"><head>Natural Logarithm <el role="defn emptytag">ln</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="ln"/></td></tr>
</tbody>
</table>
<p>The <el>ln</el> element represents the natural logarithm function.</p>
<div id="transc1.ln.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><ln/><ci>a</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>ln</mi><mo>&#x2061;</mo><mi>a</mi></mrow>]]></eg>

<graphic source="image/transc1-ln-ex1.gif" alt="{\mathop{{\minormal{ln}}}a}"/>
</div>
</div4>

<div4 id="contm_log"><head>Logarithm <el role="defn emptytag">log</el>
<phrase>, <el role="defn starttag">logbase</el></phrase>
</head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">logbase</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="transc1" name="log"/></td></tr>
</tbody>
</table>

<p>The <el>log</el> elements represents the logarithm function
relative to a given base.  When present, the <el>logbase</el>
qualifier specifies the base. Otherwise, the base is assumed to be 10.
<el>apply</el>.</p>

<div id="transc1.log.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><log/>
  <logbase><cn>3</cn></logbase>
  <ci>x</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><msub><mi>log</mi><mn>3</mn></msub><mo>&#x2061;</mo><mi>x</mi></mrow>]]></eg>

<graphic source="image/transc1-log-ex1.gif" alt="{\msub{{\minormal{log}}}{{3}}\unicode{8289}x}"/>
</div>
<div id="transc1.log.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><log/><ci>x</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>log</mi><mo>&#x2061;</mo><mi>x</mi></mrow>]]></eg>

<graphic source="image/transc1-log-ex2.gif" alt="{\mathop{{\minormal{log}}}x}"/>
</div>

<p><emph>Mapping to Strict Content MathML</emph></p>

<p>When mapping <el>log</el> to Strict Content, one uses the
<symbolref cd="transc1" name="log"/> symbol denoting the function
that returns the log of its second argument with respect to the base
specified by the first argument.  When <el>logbase</el> is present, it
determines the base.  Otherwise, the default base of 10 must be
explicitly provided in Strict markup.  See the following example.</p>

<div id="contm_strict_log" role="strict-mathml-example">
<eg role="mathml"><![CDATA[<apply><plus/>
  <apply>
    <log/>
    <logbase><cn>2</cn></logbase>
    <ci>x</ci>
  </apply>
  <apply>
    <log/>
    <ci>y</ci>
  </apply>
</apply>
]]>
</eg>
<p>Strict Content MathML equivalent:</p>
<eg role="mathml"><![CDATA[<apply>
  <csymbol cd="arith1">plus</csymbol>
  <apply>
    <csymbol cd="transc1">log</csymbol>
    <cn>2</cn>
    <ci>x</ci>
  </apply>
  <apply>
    <csymbol cd="transc1">log</csymbol>
    <cn>10</cn>
    <ci>y</ci>
  </apply>
</apply>]]></eg>
</div>
</div4>
</div3>

<div3><head>Statistics</head>

<div4 id="contm_mean"><head>Mean <el role="defn emptytag">mean</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_unary">nary-stats</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_dist1" name="mean"/>, <symbolref cd="s_data1" name="mean"/></td></tr>
</tbody>
</table>

<p>The <el>mean</el> element represents the function returning arithmetic mean or average of a
data set or random variable.</p>

<div id="s_data1.mean.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><mean/>
  <cn>3</cn><cn>4</cn><cn>3</cn><cn>7</cn><cn>4</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x27E8;</mo>
 <mn>3</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>3</mn>
 <mo>,</mo><mn>7</mn><mo>,</mo><mn>4</mn>
 <mo>&#x27E9;</mo>
</mrow>]]></eg>

<graphic source="image/s_data1-mean-ex1.gif" alt="{\unicode{9001}{3},{4},{3},{7},{4}\unicode{9002}}"/>
</div>
<div id="s_dist1.mean.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><mean/><ci>X</ci></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x27E8;</mo><mi>X</mi><mo>&#x27E9;</mo>
</mrow>]]></eg>

<graphic source="image/s_dist1-mean-ex1.gif" alt="{\unicode{9001}X\unicode{9002}}"/>

<eg role="mathml"><![CDATA[
<mover><mi>X</mi><mo>&#xaf;</mo></mover>]]></eg>

<graphic source="image/s_dist1-mean-ex1-2.gif" alt="{\overline{X}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When the <el>mean</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="s_data1" name="mean"/> symbol from the <cdref cd="s_data1"/> content dictionary, as described in
<specref ref="contm_strict-opel"/>. When it is applied to a distribution, then the
<symbolref cd="s_dist1" name="mean"/> symbol from the <cdref cd="s_dist1"/> content
dictionary should be used.  In the case with qualifiers use <specref ref="contm_p2s.lifted"/> 
with the same caveat.</p>
</div4>

<div4 id="contm_sdev"><head>Standard Deviation <el role="defn emptytag">sdev</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_unary">nary-stats</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_dist1" name="sdev"/>, <symbolref cd="s_data1" name="sdev"/></td></tr>
</tbody>
</table>

<p>The <el>sdev</el> element is used to denote the standard deviation
function for a data set or random variable.  Standard deviation is a
statistical measure of dispersion given by the square root of the
variance.</p>

<div id="s_data1.sdev.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sdev/>
  <cn>3</cn><cn>4</cn><cn>2</cn><cn>2</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x3c3;</mo>
 <mo>&#x2061;</mo>
 <mfenced><mn>3</mn><mn>4</mn><mn>2</mn><mn>2</mn></mfenced>
</mrow>]]></eg>

<graphic source="image/s_data1-sdev-ex1.gif" alt="{\unicode{963}\unicode{8289}{\left({3},{4},{2},{2}\right)}}"/>
</div>
<div id="s_dist1.sdev.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><sdev/>
  <ci type="discrete_random_variable">X</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>&#x3c3;</mo>
 <mo>&#x2061;</mo><mfenced><mi>X</mi></mfenced>
</mrow>]]></eg>

<graphic source="image/s_dist1-sdev-ex1.gif" alt="{\unicode{963}\unicode{8289}{\left(X\right)}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When the <el>sdev</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="s_data1" name="sdev"/> 
symbol from the <cdref cd="s_data1"/> content dictionary, as described in
<specref ref="contm_strict-opel"/>. When it is applied to a distribution, then the
<symbolref cd="s_dist1" name="sdev"/> symbol from the <cdref cd="s_dist1"/> content
dictionary should be used. In the case with qualifiers use
<specref ref="contm_p2s.lifted"/> with the same caveat.</p>
</div4>

<div4 id="contm_variance"><head>Variance <el role="defn emptytag">variance</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_unary">nary-stats</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_dist1" name="variance"/>, <symbolref cd="s_data1" name="variance"/></td></tr>
</tbody>
</table>

<p>The <el>variance</el> element represents the variance of a data set
or random variable. Variance is a statistical measure of dispersion,
averaging the squares of the deviations of possible values from their
mean.</p>

<div id="s_data1.variance.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><variance/>
  <cn>3</cn><cn>4</cn><cn>2</cn><cn>2</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup>
  <mo>&#x3c3;</mo>
  <mn>2</mn>
 </msup>
 <mo>&#x2061;</mo>
 <mfenced><mn>3</mn><mn>4</mn><mn>2</mn><mn>2</mn></mfenced>
</mrow>]]></eg>

<graphic source="image/s_data1-variance-ex1.gif" alt="\msup{\unicode{963}}{2}\unicode{8289}\left(3,4,2,2\right)"/>

</div>
<div id="s_dist1.variance.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><variance/>
  <ci type="discrete_random_variable"> X</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msup><mo>&#x3c3;</mo><mn>2</mn></msup>
 <mo>&#x2061;</mo>
 <mfenced><mi>X</mi></mfenced>
</mrow>
 ]]></eg>

<graphic source="image/s_dist1-variance-ex1.gif" 
alt="\msup{\unicode{963}}{2}\unicode{8289}\left(X\right)"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When the <el>variance</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="s_data1" name="variance"/> 
symbol from the <cdref cd="s_data1"/> content dictionary, as described in
<specref ref="contm_strict-opel"/>. When it is applied to a distribution, then the
<symbolref cd="s_dist1" name="variance"/> symbol from the <cdref cd="s_dist1"/> content
dictionary should be used. In the case with qualifiers use <specref ref="contm_p2s.lifted"/> 
with the same caveat.</p>
</div4>

<div4 id="contm_median"><head>Median <el role="defn emptytag">median</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_unary">nary-stats</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_data1" name="median"/></td></tr>
</tbody>
</table>
<p>The <el>median</el> element represents an operator returning the
median of its arguments. The median is a number separating the lower
half of the sample values from the upper half.</p>

<div id="s_data1.median.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><median/>
  <cn>3</cn><cn>4</cn><cn>2</cn><cn>2</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>median</mi>
 <mo>&#x2061;</mo>
 <mfenced><mn>3</mn><mn>4</mn><mn>2</mn><mn>2</mn></mfenced>
</mrow>]]></eg>

<graphic source="image/s_data1-median-ex1.gif" 
alt="{\mathop{{\minormal{median}}}{\left({3},{4},{2},{2}\right)}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When the <el>median</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="s_data1" name="median"/> 
symbol from the <cdref cd="s_data1"/> content dictionary, as described in
<specref ref="contm_strict-opel"/>.</p>
</div4>

<div4 id="contm_mode"><head>Mode <el role="defn emptytag">mode</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary_unary">nary-stats</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_data1" name="mode"/></td></tr>
</tbody>
</table>

<p>The <el>mode</el> element is used to denote the mode of its arguments. The mode is
the value which occurs with the greatest frequency.</p>

<div id="s_data1.mode.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><mode/>
  <cn>3</cn><cn>4</cn><cn>2</cn><cn>2</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>mode</mi>
 <mo>&#x2061;</mo>
 <mfenced><mn>3</mn><mn>4</mn><mn>2</mn><mn>2</mn></mfenced>
</mrow>]]></eg>

<graphic source="image/s_data1-mode-ex1.gif" 
alt="{\mathop{{\minormal{mode}}}{\left({3},{4},{2},{2}\right)}}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<p>When the <el>mode</el> element is applied to an explicit list of arguments, the
translation to Strict Content markup is direct, using the <symbolref cd="s_data1" name="mode"/> 
symbol from the <cdref cd="s_data1"/> content dictionary, as described in
<specref ref="contm_strict-opel"/>.</p>
</div4>

<div4 id="contm_moment">
<head>Moment <el role="defn emptytag">moment</el>, <el role="defn starttag">momentabout</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-functional</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">degree</kw>, 
<kw role="parsing_ref">momentabout</kw></td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="s_data1" name="moment"/>, 
<symbolref cd="s_dist1" name="moment"/></td></tr>
</tbody>
</table>

<p>The <el>moment</el> element is used to denote the <var>i</var>th moment of a set of data set or
random variable. The <el>moment</el> function accepts the <el>degree</el> and
<el>momentabout</el> qualifiers. If present, the <el>degree</el> schema denotes the order of
the moment. Otherwise, the moment is assumed to be the first order moment. When used with
<el>moment</el>, the <el>degree</el> schema is expected to contain a
single child. If present, the <el>momentabout</el> schema denotes the  
point about which the moment is taken. Otherwise, the moment is
assumed to be the moment about zero.</p>
<div id="s_data1.moment.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><moment/>
  <degree><cn>3</cn></degree>
  <momentabout><mean/></momentabout>
  <cn>6</cn><cn>4</cn><cn>2</cn><cn>2</cn><cn>5</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msub>
 <mrow>
  <mo>&#x27E8;</mo>
  <msup>
   <mfenced><mn>6</mn><mn>4</mn><mn>2</mn><mn>2</mn><mn>5</mn></mfenced>
   <mn>3</mn>
  </msup>
  <mo>&#x27E9;</mo>
 </mrow>
 <mi>mean</mi>
</msub>]]></eg>

<graphic source="image/s_data1-moment-ex1.gif" 
alt="\msub{{\unicode{9001}\msup{{\left({6},{4},{2},{2},{5}\right)}}{{3}}\unicode{9002}}}{{\minormal{mean}}}"/>
</div>
<div id="s_dist1.moment.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><moment/>
  <degree><cn>3</cn></degree>
  <momentabout><ci>p</ci></momentabout>
  <ci>X</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msub>
 <mrow>
  <mo>&#x27E8;</mo>
  <msup><mi>X</mi><mn>3</mn></msup>
  <mo>&#x27E9;</mo>
 </mrow>
 <mi>p</mi>
</msub>]]></eg>

<graphic source="image/s_dist1-moment-ex1.gif" 
alt="\msub{{\unicode{9001}\msup{X}{{3}}\unicode{9002}}}{p}"/>
</div>

<p><emph>Mapping to Strict Markup</emph></p>

<div id="contm_strict-moment-degree" role="strict-mathml-example">
<p>When rewriting to Strict Markup, the <symbolref cd="s_dist1"
name="moment"/> <phrase>symbol from the <cdref cd="s_data1"/> content 
dictionary</phrase> is used <phrase>when the <el>moment</el> element is applied 
to an explicit list of arguments.  When it is applied to a distribution, then the 
<symbolref cd="s_dist1" name="moment"/> symbol from the <cdref cd="s_dist1"/> content
dictionary should be used.</phrase> <phrase>Both operators take</phrase> 
the degree as the first argument, the point as the second, <phrase>followed by</phrase> 
the data set or random variable <phrase>respectively</phrase>.</p>

<eg role="mathml"><![CDATA[
<apply><moment/>
  <degree><cn>3</cn></degree>
  <momentabout><ci>p</ci></momentabout>
  <ci>X</ci>
</apply>]]></eg>
<p>Strict Content MathML equivalent</p>
<eg role="strict-mathml"><![CDATA[
<apply><csymbol cd="s_dist1">moment</csymbol>
  <cn>3</cn>
  <ci>p</ci>
  <ci>X</ci>
</apply>]]></eg>
</div>
</div4>
</div3>


<div3><head>Linear Algebra</head>

  <div4 id="contm_vector">
    <head>Vector <el role="defn starttag">vector</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>*</td></tr>
<tr><th>OM Symbol</th>
     <td>
       <symbolref cd="linalg2" name="vector"/>
     </td>
</tr>
</tbody>
</table>

    <p>A vector is an ordered n-tuple of values representing an element of an
    n-dimensional vector space.</p>

    <p>For purposes of interaction with matrices and matrix multiplication, vectors are
    regarded as equivalent to a matrix consisting of a single column, and the transpose of
    a vector as a matrix consisting of a single row. </p>

    <p>The components of a <el>vector</el> may be given explicitly as
    child elements, or specified by rule as described in <specref
    ref="contm_container_constructor"/>.</p>  

    <div id="linalg2.vector.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<vector>
  <apply><plus/><ci>x</ci><ci>y</ci></apply>
  <cn>3</cn>
  <cn>7</cn>
</vector>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>(</mo>
 <mtable>
  <mtr><mtd><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow></mtd></mtr>
  <mtr><mtd><mn>3</mn></mtd></mtr>
  <mtr><mtd><mn>7</mn></mtd></mtr>
 </mtable>
 <mo>)</mo>
</mrow>]]></eg>

<graphic source="image/linalg2-vector-ex1.gif" 
alt="{\left.\middle({\begin{matrix}{x+y}\\{3}\\{7}\end{matrix}}\middle)\right.}"/>

<eg role="mathml"><![CDATA[
<mfenced>
  <mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow>
  <mn>3</mn>
  <mn>7</mn>
</mfenced>]]></eg>

<graphic source="image/linalg2-vector-ex1-2.gif" alt="{\left({x+y},{3},{7}\right)}"/>

</div>
</div4>

<div4 id="contm_matrix"><head>Matrix <el role="defn starttag">matrix</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>*</td></tr>
<tr><th>OM Symbol</th>
     <td>
       <symbolref cd="linalg2" name="matrix"/>
     </td>
</tr>
</tbody>
</table>

    <p>A matrix is regarded as made up of matrix rows, each of which can be 
    thought of as a special type of vector.</p>

    <p>Note that the behavior of the <el>matrix</el> and <el>matrixrow</el> elements is
    substantially different from the <el>mtable</el> and <el>mtr</el> presentation
    elements.</p>

    <p>The <el>matrix</el> element is a <emph>constructor</emph>
    element, so the entries may be given explicitly as child elements,
    or specified by rule as described in <specref
    ref="contm_container_constructor"/>.  In the latter case, the
    entries are specified by providing a function and a 2-dimensional
    domain of application.  The entries of the matrix correspond to
    the values obtained by evaluating the function at the points of
    the domain.</p>

  <div id="linalg6.matrix.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<matrix>
  <bvar><ci type="integer">i</ci></bvar>
  <bvar><ci type="integer">j</ci></bvar>
  <condition>
    <apply><and/>
      <apply><in/>
        <ci>i</ci>
        <interval><ci>1</ci><ci>5</ci></interval>
      </apply>
      <apply><in/>
        <ci>j</ci>
        <interval><ci>5</ci><ci>9</ci></interval>
      </apply>
    </apply>
  </condition>
  <apply><power/><ci>i</ci><ci>j</ci></apply>
</matrix>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mo>[</mo>
 <msub><mi>m</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
 <mo>|</mo>
 <mrow>
  <msub><mi>m</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
  <mo>=</mo>
  <msup><mi>i</mi><mi>j</mi></msup>
 </mrow>
 <mo>;</mo>
 <mrow>
  <mrow>
   <mi>i</mi>
   <mo>&#x2208;</mo>
   <mfenced open="[" close="]"><mi>1</mi><mi>5</mi></mfenced>
  </mrow>
  <mo>&#x2227;</mo>
  <mrow>
   <mi>j</mi>
   <mo>&#x2208;</mo>
   <mfenced open="[" close="]"><mi>5</mi><mi>9</mi></mfenced>
  </mrow>
 </mrow>
 <mo>]</mo>
</mrow>]]></eg>

<graphic source="image/linalg6-matrix-ex1.gif" 
alt="{\left.[\msub{m}{{i,j}}\middle|{\msub{m}{{i,j}}=\msup{i}{j}};{{i\unicode{8712}{\left[1,5\right]}}\unicode{8743}{j\unicode{8712}{\left[5,9\right]}}}]\right.}"/>

</div>
</div4>

<div4 id="contm_matrixrow"><head>Matrix row <el role="defn starttag">matrixrow</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-constructor</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Qualifiers</th><td><kw role="parsing_ref">BvarQ</kw>,
<kw role="parsing_ref">DomainQ</kw></td></tr>
<tr><th>Content</th><td><kw role="parsing_ref">ContExp</kw>*</td></tr>
<tr><th>OM Symbol</th>
     <td>
       <symbolref cd="linalg2" name="matrixrow"/>
     </td>
</tr>
</tbody>
</table>
  <p>This element is an n-ary constructor used to represent rows of matrices.</p>

  <p>Matrix rows are not directly rendered by themselves outside of the
  context of a matrix.</p>
</div4>


<div4 id="contm_determinant"><head>Determinant <el role="defn emptytag">determinant</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-linalg</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="linalg1" name="determinant"/></td></tr>
</tbody>
</table>
<p>This element is used for the unary function which returns the determinant of its argument, 
which should be a square matrix.</p>
<div id="linalg1.determinant.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><determinant/>
  <ci type="matrix">A</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>det</mi><mo>&#x2061;</mo><mi>A</mi></mrow>]]></eg>

<graphic source="image/linalg1-determinant-ex1.gif" alt="{\mathop{{\minormal{det}}}A}"/>

</div>
</div4>

<div4 id="contm_transpose"><head>Transpose <el role="defn emptytag">transpose</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_unary">unary-linalg</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="linalg1" name="transpose"/></td></tr>
</tbody>
</table>
<p>This element represents a unary function that signifies the transpose of the 
given matrix or vector.</p>
<div id="linalg1.transpose.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><transpose/>
  <ci type="matrix">A</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msup><mi>A</mi><mi>T</mi></msup>]]></eg>

<graphic source="image/linalg1-transpose-ex1.gif" alt="\msup{A}{T}"/>
</div>
</div4>

<div4 id="contm_selector">
    <head>Selector <el role="defn emptytag">selector</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_nary">nary-linalg</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="linalg1" name="vector_selector"/>, 
 <symbolref cd="linalg1" name="matrix_selector"/></td></tr>
</tbody>
</table>

    <p>The <el>selector</el> element is the operator for indexing into vectors, matrices
    and lists. It accepts one or more arguments. The first argument identifies the vector,
    matrix or list from which the selection is taking place, and the second and subsequent
    arguments, if any, indicate the kind of selection taking place.</p>

    <p>When <el>selector</el> is used with a single argument, it should be interpreted as
    giving the sequence of all elements in the list, vector or matrix given. The ordering
    of elements in the sequence for a matrix is understood to be first by column, then by
    row; so the resulting list is of matrix rows given entry by entry.  
    That is, for a matrix (<var>a</var><sub>i,j</sub>), where the indices denote row
    and column, respectively, the ordering would be <var>a</var><sub>1,1</sub>, 
<var>a</var><sub>1,2</sub>, ...  <var>a</var><sub>2,1</sub>, <var>a</var><sub>2,2</sub>
    ... etc.</p>
 
 <p>When two arguments are given, and the first is a vector or list, the second argument
  specifies the index of an entry in the list or vector. If the first argument is a matrix then
  the second argument specifies the index of a matrix row.</p>

   <p>When three arguments are given, the last one is ignored for a list or vector, and
    in the case of a matrix, the second and third arguments specify the row and column indices of
    the selected element.</p>

  <div id="linalg1.vector_selector.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><selector/><ci type="vector">V</ci><cn>1</cn></apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<msub><mi>V</mi><mn>1</mn></msub>]]></eg>
<graphic source="image/linalg1-vector_selector-ex1.gif" alt="\msub{V}{{1}}"/>

</div>
  <div id="linalg1.matrix_selector.ex2" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><selector/>
    <matrix>
      <matrixrow><cn>1</cn><cn>2</cn></matrixrow>
      <matrixrow><cn>3</cn><cn>4</cn></matrixrow>
    </matrix>
    <cn>1</cn>
  </apply>
  <matrix>
    <matrixrow><cn>1</cn><cn>2</cn></matrixrow>
  </matrix>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <msub>
  <mrow>
   <mo>(</mo>
   <mtable>
    <mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd></mtr>
    <mtr><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd></mtr>
   </mtable>
   <mo>)</mo>
  </mrow>
  <mn>1</mn>
 </msub>
 <mo>=</mo>
 <mrow>
  <mo>(</mo>
  <mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd></mtr></mtable>
  <mo>)</mo>
 </mrow>
</mrow>]]></eg>

<graphic source="image/linalg1-matrix_selector-ex2.gif" 
alt="\msub{\left({\begin{matrix} 1\endcell 2\\ 3\endcell 4\end{matrix}}\right)}{1}=\left(\begin{matrix} 1\endcell 2\end{matrix}\right)"/>
</div>
</div4>

<div4 id="contm_vectorproduct"><head>Vector product <el role="defn emptytag">vectorproduct</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-linalg</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="linalg1" name="vectorproduct"/></td></tr>
</tbody>
</table>

<p>This element represents the vector product. It takes two three-dimensional vector arguments 
and represents as value a three-dimensional vector.</p>
<div id="linalg1.vectorproduct.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><vectorproduct/>
    <ci type="vector"> A </ci>
    <ci type="vector"> B </ci>
 </apply>
  <apply><times/>
    <ci>a</ci>
    <ci>b</ci>
    <apply><sin/><ci>&#x3b8;</ci></apply>
    <ci type="vector"> N </ci>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>A</mi><mo>&#xd7;</mo><mi>B</mi></mrow>
 <mo>=</mo>
 <mrow>
  <mi>a</mi>
  <mo>&#x2062;</mo>
  <mi>b</mi>
  <mo>&#x2062;</mo>
  <mrow><mi>sin</mi><mo>&#x2061;</mo><mi>&#x3b8;</mi></mrow>
  <mo>&#x2062;</mo>
  <mi>N</mi>
 </mrow>
</mrow>]]></eg>

<graphic source="image/linalg1-vectorproduct-ex1.gif" 
alt="{{A\unicode{215}B}={a\unicode{8290}b\unicode{8290}{\mathop{{\minormal{sin}}}\unicode{952}}\unicode{8290}N}}"/>
</div>
</div4>

<div4 id="contm_scalarproduct"><head>Scalar product <el role="defn emptytag">scalarproduct</el></head>

<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_binary">binary-linalg</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="linalg1" name="scalarproduct"/></td></tr>
</tbody>
</table>

<p>This element represents the scalar product function. It takes two vector arguments 
and returns a scalar value.</p>
<div id="linalg1.scalarproduct.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><scalarproduct/>
    <ci type="vector">A</ci>
    <ci type="vector">B</ci>
  </apply>
  <apply><times/>
    <ci>a</ci>
    <ci>b</ci>
    <apply><cos/><ci>&#x3b8;</ci></apply>
  </apply>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>A</mi><mo>.</mo><mi>B</mi></mrow>
 <mo>=</mo>
 <mrow>
  <mi>a</mi>
  <mo>&#x2062;</mo>
  <mi>b</mi>
  <mo>&#x2062;</mo>
  <mrow><mi>cos</mi><mo>&#x2061;</mo><mi>&#x3b8;</mi></mrow>
 </mrow>
</mrow>]]></eg>

<graphic source="image/linalg1-scalarproduct-ex1.gif" 
alt="{{A.B}={a\unicode{8290}b\unicode{8290}{\mathop{{\minormal{cos}}}\unicode{952}}}}"/>
</div>
</div4>

<div4 id="contm_outerproduct"><head>Outer product <el role="defn emptytag">outerproduct</el></head>


<table role="syntax">
<tbody>
<tr><th>Class</th>
<td><intref ref="contm_binary">binary-linalg</intref></td>
</tr>
<tr><th>Attributes</th>
<td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td>
</tr>
<tr><th>OM Symbols</th>
<td><symbolref cd="linalg1" name="outerproduct"/></td>
</tr>
</tbody>
</table>

<p>This element represents the outer product function. It takes two vector arguments 
and returns as value a matrix.</p>

<div id="linalg1.outerproduct.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><outerproduct/>
  <ci type="vector">A</ci>
  <ci type="vector">B</ci>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mi>A</mi><mo>&#x2297;</mo><mi>B</mi></mrow>]]></eg>
<graphic source="image/linalg1-outerproduct-ex1.gif" alt="{A\unicode{8855}B}"/>
</div>
</div4>

</div3>



<div3 id="contm_constantsandsymbols"><head>Constant and Symbol Elements</head>

<p>This section explains the use of the Constant and Symbol elements.</p>

<div4 id="contm_integers"><head>integers <el role="defn emptytag">integers</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="Z"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of integers, positive, negative and zero.</p>
  <div id="setname1.integers.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="integer"> 42 </cn>
  <integers/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mn>42</mn><mo>&#x2208;</mo><mi mathvariant="double-struck">Z</mi></mrow>]]></eg>

<graphic source="image/setname1-integers-ex1.gif" alt="{{42}\unicode{8712}{\midoublestruck{Z}}}"/>
</div>
</div4>

<div4 id="contm_reals"><head>reals <el role="defn emptytag">reals</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="R"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of real numbers.</p>
  <div id="setname1.reals.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="real"> 44.997</cn>
  <reals/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mn>44.997</mn><mo>&#x2208;</mo><mi mathvariant="double-struck">R</mi>
</mrow>]]></eg>

<graphic source="image/setname1-reals-ex1.gif" alt="{{44.997}\unicode{8712}{\midoublestruck{R}}}"/>
</div>
</div4>

<div4 id="contm_rationals"><head>Rational Numbers <el role="defn emptytag">rationals</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="Q"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of rational numbers.</p>
  <div id="setname1.rationals.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="rational"> 22 <sep/>7</cn>
  <rationals/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mn>22</mn><mo>/</mo><mn>7</mn></mrow>
 <mo>&#x2208;</mo>
 <mi mathvariant="double-struck">Q</mi>
</mrow>]]></eg>

<graphic source="image/setname1-rationals-ex1.gif" 
alt="{{{22}/{7}}\unicode{8712}{\midoublestruck{Q}}}"/>
</div>
</div4>

<div4 id="contm_naturalnumbers"><head>Natural Numbers <el role="defn emptytag">naturalnumbers</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="N"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of natural numbers (including zero).</p>
  <div id="setname1.naturalnumbers.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="integer">1729</cn>
  <naturalnumbers/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mn>1729</mn><mo>&#x2208;</mo><mi mathvariant="double-struck">N</mi>
</mrow>]]></eg>

<graphic source="image/setname1-naturalnumbers-ex1.gif" 
alt="{{1729}\unicode{8712}{\midoublestruck{N}}}"/>
</div>
</div4>

<div4 id="contm_complexes"><head>complexes <el role="defn emptytag">complexes</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="C"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of complex numbers.</p>
  <div id="setname1.complexes.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="complex-cartesian">17<sep/>29</cn>
  <complexes/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mn>17</mn><mo>+</mo><mn>29</mn><mo>&#x2062;</mo><mi>i</mi></mrow>
 <mo>&#x2208;</mo>
 <mi mathvariant="double-struck">C</mi>
</mrow>]]></eg>

<graphic source="image/setname1-complexes-ex1.gif" 
alt="{{{17}+{29}\unicode{8290}i}\unicode{8712}{\midoublestruck{C}}}"/>
</div>
</div4>

<div4 id="contm_primes"><head>primes <el role="defn emptytag">primes</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="setname1" name="P"/></td></tr>
</tbody>
</table>
  <p>This element represents the set of positive prime numbers.</p>
  <div id="setname1.primes.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><in/>
  <cn type="integer">17</cn>
  <primes/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><mn>17</mn><mo>&#x2208;</mo><mi mathvariant="double-struck">P</mi></mrow>]]></eg>

<graphic source="image/setname1-primes-ex1.gif" alt="{{17}\unicode{8712}{\midoublestruck{P}}}"/>
</div>
</div4>

<div4 id="contm_exponentiale"><head>Exponential e <el role="defn emptytag">exponentiale</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="e"/></td></tr>
</tbody>
</table>

  <p>This element represents the base of the natural logarithm, approximately 2.718.</p>
  <div id="nums1.exponentiale.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><ln/><exponentiale/></apply>
  <cn>1</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>ln</mi><mo>&#x2061;</mo><mi>e</mi></mrow>
 <mo>=</mo>
 <mn>1</mn>
</mrow>]]></eg>

<graphic source="image/nums1-exponentiale-ex1.gif" alt="{{\mathop{{\minormal{ln}}}e}={1}}"/>
</div>
</div4>

<div4 id="contm_imaginaryi"><head>Imaginary i <el role="defn emptytag">imaginaryi</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="i"/></td></tr>
</tbody>
</table>
  <p>This element represents the mathematical constant which is the square root of -1, 
  commonly written i</p>
  <div id="nums1.imaginaryi.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><power/><imaginaryi/><cn>2</cn></apply>
  <cn>-1</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mn>-1</mn></mrow>]]></eg>

<graphic source="image/nums1-imaginaryi-ex1.gif" alt="{\msup{i}{{2}}={\mn{-1}}}"/>
</div>
</div4>

<div4 id="contm_notanumber"><head>Not A Number <el role="defn emptytag">notanumber</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="NaN"/></td></tr>
</tbody>
</table>
  <p>This element represents the notion of not-a-number, i.e. the result of an ill-posed 
  floating computation. See <bibref ref="IEEE754"/>.</p>
  <div id="nums1.notanumber.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><divide/><cn>0</cn><cn>0</cn></apply>
  <notanumber/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mn>0</mn><mo>/</mo><mn>0</mn></mrow>
 <mo>=</mo>
 <mi>NaN</mi>
</mrow>]]></eg>

<graphic source="image/nums1-notanumber-ex1.gif" alt="{{{0}/{0}}={\minormal{NaN}}}"/>
</div>
</div4>

<div4 id="contm_true"><head>True <el role="defn emptytag">true</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="true"/></td></tr>
</tbody>
</table>
  <p>This element represents the Boolean value true, i.e. the logical constant for truth.</p>
  <div id="logic1.true.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><or/>
    <true/>
     <ci type="boolean">P</ci>
  </apply>
  <true/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>true</mi><mo>&#x2228;</mo><mi>P</mi></mrow>
 <mo>=</mo>
 <mi>true</mi>
</mrow>]]></eg>

<graphic source="image/logic1-true-ex1.gif" 
alt="{{{\minormal{true}}\unicode{8744}P}={\minormal{true}}}"/>
</div>
</div4>


<div4 id="contm_false"><head>False <el role="defn emptytag">false</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="logic1" name="false"/></td></tr>
</tbody>
</table>
  <p>This element represents the Boolean value false, i.e. the logical constant for falsehood.</p>
  <div id="logic1.false.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><eq/>
  <apply><and/>
    <false/>
    <ci type="boolean">P</ci>
  </apply>
  <false/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mrow><mi>false</mi><mo>&#x2227;</mo><mi>P</mi></mrow>
 <mo>=</mo>
 <mi>false</mi>
</mrow>]]></eg>

<graphic source="image/logic1-false-ex1.gif" 
alt="{{{\minormal{false}}\unicode{8743}P}={\minormal{false}}}"/>
</div>
</div4>

<div4 id="contm_emptyset"><head>Empty Set <el role="defn emptytag">emptyset</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-set</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="set1" name="emptyset"/>, 
<symbolref cd="multiset1" name="emptyset"/></td></tr>
</tbody>
</table>
  <p>This element is used to represent the empty set, that is the set which contains no members.</p>

  <div id="set1.emptyset.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><neq/>
  <integers/>
  <emptyset/>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi mathvariant="double-struck">Z</mi><mo>&#x2260;</mo><mi>&#x2205;</mi>
</mrow>]]></eg>

<graphic source="image/set1-emptyset-ex1.gif" 
alt="{{\midoublestruck{Z}}\unicode{8800}\unicode{8709}}"/>

<p><emph>Mapping to Strict Markup</emph></p>

<p>In some situations, it may be clear from context that <el>emptyset</el> 
corresponds to the <symbolref cd="multiset1" name="emptyset"/> 
However, as there is no method other than annotation for an author to explicitly indicate this,
it is always acceptable to translate to the  <symbolref cd="set1" name="emptyset"/> symbol from the <cdref cd="set1"/> CD.</p>
</div>
</div4>

<div4 id="contm_pi"><head>pi <el role="defn emptytag">pi</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="pi"/></td></tr>
</tbody>
</table>
  <p>This element represents pi, approximately 3.142, which is the
  ratio of the circumference of a circle to its diameter.</p>  
  <div id="nums1.pi.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><approx/>
  <pi/>
  <cn type="rational">22<sep/>7</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>&#x3c0;</mi>
 <mo>&#x2243;</mo>
 <mrow><mn>22</mn><mo>/</mo><mn>7</mn></mrow>
</mrow>]]></eg>

<graphic source="image/nums1-pi-ex1.gif" alt="{\unicode{960}\unicode{8771}{{22}/{7}}}"/>
</div>
</div4>

<div4 id="contm_eulergamma"><head>Euler gamma <el role="defn emptytag">eulergamma</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="gamma"/></td></tr>
</tbody>
</table>
  <p>This element denotes the gamma constant, approximately 0.5772.</p> 
  <div id="nums1.eulergamma.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[
<apply><approx/>
  <eulergamma/>
  <cn>0.5772156649</cn>
</apply>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mrow>
 <mi>&#x3b3;</mi><mo>&#x2243;</mo><mn>0.5772156649</mn>
</mrow>]]></eg>

<graphic source="image/nums1-eulergamma-ex1.gif" 
alt="{\unicode{947}\unicode{8771}{0.5772156649}}"/>
</div>
</div4>

<div4 id="contm_infinity"><head>infinity <el role="defn emptytag">infinity</el></head>
<table role="syntax">
<tbody>
<tr><th>Class</th><td><intref ref="contm_constant">constant-arith</intref></td></tr>
<tr><th>Attributes</th><td><kw role="parsing_ref">CommonAtt</kw>, <kw role="parsing_ref">DefEncAtt</kw></td></tr>
<tr><th>Content</th><td>Empty</td></tr>
<tr><th>OM Symbols</th><td><symbolref cd="nums1" name="infinity"/></td></tr>
</tbody>
</table>
  <p>This element represents the notion of infinity.</p>
  <div id="nums1.infinity.ex1" role="mathml-example"><p>Content MathML</p>
<eg role="mathml"><![CDATA[<infinity/>]]></eg>
<p>Sample Presentation</p>
<eg role="mathml"><![CDATA[
<mi>&#x221e;</mi>]]></eg>

<graphic source="image/nums1-infinity-ex1.gif" alt="\unicode{8734}"/>
</div>
</div4>
</div3>

</div2>

<div2 id="contm_deprecated">
  <head>Deprecated Content Elements</head>

  <div3 id="contm_declare">
  <head>Declare <el role="defn starttag">declare</el></head>

   <table role="syntax">
     <tbody>
     <tr>
       <th>Attributes</th>
       <td><kw role="parsing_ref">CommonAtt</kw>,
          <kw role="parsing_ref">type</kw>,
          <kw role="parsing_ref">scope</kw>,
          <kw role="parsing_ref">occurrence</kw>,
          <kw role="parsing_ref">definitionURL</kw>,
          <kw role="parsing_ref">encoding</kw></td>
     </tr>
     <tr>
       <th><att>type</att> Attribute</th>
       <td>defines the MathML element type of the identifier declared.</td></tr>
     <tr>
       <th><att>scope</att> Attribute</th>
       <td>defines the scope of application of the declaration.</td></tr>
     <tr>
       <th><att>nargs</att> Attribute</th>
       <td>number of arguments for function declarations.</td></tr>
     <tr>
       <th><att>occurrence</att> Attribute values</th>
       <td><attval>prefix</attval> | <attval>infix</attval> |
           <attval>function-model</attval></td></tr>
     <tr>
       <th><att>definitionURL</att> Attribute</th>
       <td>URI pointing to detailed semantics of the function.</td></tr>
     <tr>
       <th><att>encoding</att> Attribute</th>
       <td>syntax of the detailed semantics of the function.</td></tr>

     <tr>
       <th>Content</th>
       <td><kw role="parsing_ref">ContExp</kw>,
           <kw role="parsing_ref">ContExp</kw>?</td>
     </tr>
     </tbody>
    </table>

  <p>MathML2 provided the <el>declare</el> element to bind properties like
  types to symbols and variables and to define abbreviations for structure sharing. This
  element is deprecated in MathML 3. Structure sharing can obtained via the <el>share</el>
  element (see <specref ref="contm_sharing"/> for details).
</p>
  </div3>

  <div3 id="contm_reln">
  <head>Relation <el role="defn starttag">reln</el></head>

   <table role="syntax">
     <tbody>
     <tr>
       <th>Content</th>
       <td><kw role="parsing_ref">ContExp</kw>*</td>
     </tr>
     </tbody>
    </table>

  <p>MathML1 provided the <el>reln</el> element to construct an equation or relation.
  This usage was deprecated in MathML 2.0 in favor of the more generally usable <el>apply</el>.</p>
  </div3>

  <div3 id="contm_fn">
  <head>Relation <el role="defn starttag">fn</el></head>

   <table role="syntax">
     <tbody>
     <tr>
       <th>Content</th>
       <td><kw role="parsing_ref">ContExp</kw></td>
     </tr>
     </tbody>
    </table>

  <p>MathML1 provided the <el>fn</el> element to extend the collection of known mathematical
  functions. This usage was deprecated in MathML 2.0 in favor of the more generally
  applicable <el>csymbol</el>.</p>
  </div3>

</div2>

 <div2 id="contm_p2s">
     <head>The Strict Content MathML Transformation</head>

     <p>MathML 3 assigns semantics to content markup by defining a
     mapping to Strict Content MathML.  Strict MathML, in turn, is in
     one-to-one correspondence with OpenMath, and the subset of
     OpenMath expressions obtained from content MathML expressions in
     this fashion all have well-defined semantics via the standard
     OpenMath Content Dictionary set.  Consequently, the mapping of
     arbitrary content MathML expressions to equivalent Strict Content
     MathML plays a key role in underpinning the meaning of content
     MathML.</p>

     <p>The mapping of arbitrary content MathML into Strict content
     MathML is defined algorithmically. The algorithm is described
     below as a collection of rewrite rules applying to specific
     non-Strict constructions.  The individual rewrite transformations
     have been described in detail in context above.  The goal of this
     section is to outline the complete algorithm in one place.</p>

     <p>The algorithm is a sequence of <phrase>nine</phrase> steps.  Each step is
     applied repeatedly to rewrite the input until no further
     application is possible. Note that in many programming languages,
     such as XSLT, the natural implementation is as a recursive
     algorithm, rather than the multi-pass implementation suggested by
     the description below. The translation to XSL is straightforward
     and produces the same eventual Strict Content MathML.  However,
     because the overall structure of the multi-pass algorithm is
     clearer, that is the formulation given here.</p>

     <p>To transform an arbitrary content MathML expression into
     Strict Content MathML, apply each of the following rules in turn
     to the input expression until all instances of the target
     constructs have been eliminated:</p>

<olist>
  <item>
    <p><emph>Rewrite non-strict <el>bind</el> and elminate deprecated elements</emph>: 
    Change the outer <el>bind</el> tags
    in binding expressions to <el>apply</el> if they have qualifiers or multiple
    children. This simplifies the algorithm by allowing the subsequent rules to be applied
    to non-strict binding expressions without case distinction. Note
    that the <phrase>later</phrase>
    rules will change the <el>apply</el> elements introduced in this step back to
    <el>bind</el> elements. <phrase>Also in this step, deprecated <el>reln</el> 
    elements are rewritten to <el>apply</el>, and <el>fn</el> elements are replaced by 
    the child expressions they enclose.</phrase></p>    
  </item>
  <item>
    <p><emph>Apply special case rules for idiomatic uses of qualifiers</emph>:
      <olist>
      <item>
        <p>Rewrite derivatives with rules <specref ref="contm_p2s.diff"/>, <specref ref="contm_p2s.nthdiff"/>, 
        and <specref ref="contm_p2s.partialdiff"/>
        to explicate the binding status of the variables involved.  
        </p>
      </item>
      <item>
        <p>Rewrite integrals with the rules <specref ref="contm_p2s.int"/><phrase>,  <specref ref="contm_p2s.defint"/></phrase>
        and <specref ref="contm_p2s.int.LUlimit"/> to disambiguate the status 
        of bound and free variables and of the orientation of the range of integration if
        it is given as a <el>lowlimit</el>/<el>uplimit</el> pair.
        </p>
      </item>
      <item><p>Rewrite limits as described in <specref
      ref="contm_strict_tendsto"/> and <specref ref="contm_strict-limit"/>.</p></item>
      <item><p>Rewrite sums and products as described in
      <specref ref="contm_sum"/> and <specref ref="contm_product"/>.</p></item>
      <item><p>Rewrite roots as described in <specref ref="contm_root"/>.</p></item>
      <item><p>Rewrite logarithms as described in <specref ref="contm_log"/>.</p></item>
      <item><p>Rewrite moments as described in <specref ref="contm_moment"/>.</p></item>
      </olist>
    </p>
  </item>
  <item>
    <p><emph>Rewrite Qualifiers to <el>domainofapplication</el></emph>:
    These rules rewrite all <el>apply</el> constructions using <el>bvar</el> and 
    qualifiers to those using only the general <el>domainofapplication</el> qualifier.
    <olist>
      <item>
        <p><emph>Intervals</emph>: Rewrite qualifiers given as <el>interval</el> and
        <el>lowlimit</el>/<el>uplimit</el> to intervals of integers via
        <specref ref="contm_limits-strict"/>.</p>
      </item>
      <item>
      <p><emph>Multiple <el>condition</el>s</emph>: Rewrite multiple <el>condition</el> 
      qualifiers to a single one by taking their conjunction. The resulting compound 
      <el>condition</el> is then rewritten to <el>domainofapplication</el> according 
      to rule <specref ref="contm_condition-strict"/>.</p>
      </item>
      <item>
        <p><emph>Multiple <el>domainofapplication</el>s</emph>: Rewrite multiple
        <el>domainofapplication</el> qualifiers to a single one by taking the
        intersection of the specified domains.</p>
      </item>
    </olist>
    </p>
  </item>
  <item>
    <p><emph>Normalize Container Markup</emph>:
     <olist>
      <item><p>Rewrite sets and lists by the rule 
      <specref ref="contm_rewrite_setliste"/>.</p>
      </item>
      <item id="contm_p2s_step_vector"><p>Rewrite interval, vectors, matrices, and matrix rows
      as described in <specref ref="contm_interval"/>, <specref ref="contm_vector"/>, 
      <specref ref="contm_matrix"/> and <specref ref="contm_matrixrow"/>. <phrase>Note any qualifiers will have been rewritten to <el>domainofapplication</el> and will be further rewritten in Step 6.</phrase></p> 
      </item>
      <item><p>Rewrite lambda expressions by the rules <specref  ref="contm_rewrite_lambda"/>
      and <specref  ref="contm_rewrite_lambda_domofa"/></p>
      </item>
      <item><p>Rewrite piecewise functions as described in <specref ref="contm_piecewise"/>.</p>
      </item>
     </olist>
    </p>
  </item>
  <item>
    <p><emph>Apply Special Case Rules for Operators using <el>domainofapplication</el> Qualifiers</emph>: 
    This step deals with the special cases for the operators introduced in 
    <specref ref="contm_opel"/>. There are different classes of special cases to be taken into account: 
    <olist>
      <item>
        <p>Rewrite <el>min</el>, <el>max</el>, <el>mean</el> and similar n-ary/unary operators
        by the rules <specref ref="contm_p2s.max"/>, <specref ref="contm_unary_nary_doma"/> 
        and <specref ref="contm_nary_unary_single"/>.
        </p>
      </item>
      <item>
        <p>Rewrite the quantifiers <el>forall</el> and <el>exists</el> used with <el>domainofapplication</el>
         to expressions using implication and conjunction by the rule <specref ref="contm_rewrite_quantifier"/>.
        </p>
      </item>
      <item>
        <p>Rewrite integrals used with a <el>domainofapplication</el> element (with or without a <el>bvar</el>) 
	    according to the rules <specref ref="contm_p2s.int"/><phrase> and
	    <specref ref="contm_p2s.defint"/></phrase>.
        </p>
      </item>
      <item><p>Rewrite sums and products used with a <el>domainofapplication</el> element 
	  (with or without a <el>bvar</el>) as described in 
	  <specref ref="contm_sum"/> and <specref ref="contm_product"/>.</p></item>
    </olist>
    </p>
  </item>
  <item>
    <p><emph>Eliminate <el>domainofapplication</el></emph>: At this stage, any
    <el>apply</el> has at most one <el>domainofapplication</el> child and special cases have been addressed. As
    <el>domainofapplication</el> is not Strict Content MathML, it is rewritten
    <olist>
      <item>
        <p>into an application of a restricted function via the rule
        <specref ref="contm_strict-doa"/> if the <el>apply</el> does not contain 
        a <el>bvar</el> child.</p> 
      </item>
      <item>
        <p>into an application of the <symbolref cd="fns2" name="predicate_on_list"/> symbol via the rules
        <specref ref="contm_rewrite_reln"/> and <specref ref="contm_rewrite_reln_bvar"/> 
        if used with a relation.</p>
      </item>
      <item>
        <p>into a construction with the <symbolref cd="fns2" name="apply_to_list"/> symbol
        via the general rule <specref ref="contm_p2s.lifted"/> for
        general n-ary operators.
        </p>
      </item> 
      <item>
        <p>into a construction using the <symbolref cd="set1" name="suchthat"/> symbol
        from the <cdref cd="set1"/> content dictionary in an <el>apply</el> with bound
        variables via the <specref ref="contm_dombind-strict"/> rule.</p>
        </item>
    </olist>
    </p>
  </item>
  <item>
    <p><emph>Rewrite non-strict token elements</emph>:
      <olist>
	<item>
	  <p>Rewrite numbers represented as <el>cn</el> elements where the <att>type</att> 
	    attribute is one of <attval>e-notation</attval>, <attval>rational</attval>,
	    <attval>complex-cartesian</attval>, <attval>complex-polar</attval>,
	    <attval>constant</attval> as strict <el>cn</el> via rules 
	    <specref ref="contm-strict-cn-sep"/>, <specref ref="contm_cn-base"/> 
	    and <specref ref="contm_cn_strict_const"/>.</p>
	</item>
	<item>
	  <p>Rewrite any <el>ci</el>, <el>csymbol</el> or <el>cn</el> containing
	    presentation MathML to <el>semantics</el> elements with rules  
	    <specref ref="contm_cn_pres"/> and <specref ref="contm_ci_pres"/> and 
	    the analogous rule for <el>csymbol</el>.</p>  
	</item>    
      </olist>
    </p>
  </item>
  <item>
    <p><emph>Rewrite operators</emph>: Rewrite any remaining operator defined in <specref ref="contm_opel"/> 
      to a <el>csymbol</el> referencing the symbol identified in the syntax table by the rule 
      <specref ref="contm_strict-opel"/>. <phrase>As noted in the descriptions of each 
	operator element, some require special case rules to determine the proper choice of symbol.  
	Some cases of particular note are:</phrase>
      <olist>
	<item><p>The order of the arguments for the
	    <intref ref="contm_selector"><el>selector</el></intref> operator must be 
	    rewritten, and the symbol depends on the type of the arguments.</p>
	</item> 
	<item><p>The choice of symbol for the <intref ref="contm_minus"><el>minus</el></intref> 
	    operator depends on the number of the arguments.</p> 
	</item> 
	<item><p>The choice of symbol for some set operators depends on the values of 
	    the <att>type</att> of the arguments.</p> 
	</item> 
	<item><p>The choice of symbol for some statistical operators depends on the values of 
	    the types of the arguments.</p> 
	</item> 
      </olist>
    </p>
  </item>
  <item>
    <p><emph>Rewrite non-strict attributes</emph>: 
      <olist>
	<item>
	  <p><emph>Rewrite the <att>type</att> attribute</emph>:
	    <phrase>At this point, all elements 
that accept the <att>type</att>, other than <el>ci</el> and <el>csymbol</el>, should have been
rewritten into Strict Content Markup equivalents without <att>type</att> attributes, 
where type information is reflected in the choice of operator symbol.</phrase> Now rewrite remaining
<el>ci</el> <phrase>and <el>csymbol</el></phrase> elements with a <att>type</att> attribute to a
strict expression with <el>semantics</el> according to rule<phrase>s</phrase>
<specref ref="contm_ci_strict_ex"/><phrase> and <specref ref="contm_csymbol_strict_ex"/></phrase>.  </p>
	</item>
	<item>
	  <p><emph>Rewrite <att>definitionURL</att> and <att>encoding</att> attributes</emph>: 
	    If the <att>definitionURL</att> and <att>encoding</att> attributes on a 
	    <el>csymbol</el> element can be interpreted as a reference to a
	    content dictionary (see <specref ref="contm_csymbol_extended"/> for details), then
	    rewrite to reference the content dictionary by the <att>cd</att> attribute instead. 
	  </p>
	</item>
	<item>
	  <p><emph>Rewrite attributes</emph>: Rewrite any element with attributes that are
	    not allowed in strict markup to a <el>semantics</el> construction with
	    the element without these attributes as the first child and the attributes in
	    <el>annotation</el> elements by rule <specref ref="contm_strict-attributes"/>.</p>
	</item>
      </olist>
    </p>
  </item>
</olist>
 </div2>

</div1><!--  Localwords:  div contm mkohlhas Exp Buswell Devitt emph nbsp specref gif -->
<!--  LocalWords:  notsheet bibref Chaundy blacksquare Cajori ndash kw  EBNF -->
<!--  LocalWords:  ulist PCDATA elem pmincm el cn ci definitionURL htm eg -->
<!--  LocalWords:  mySymbol mathml att cartesian sep cedef presm mn lt gt -->
<!--  LocalWords:  intref interf deprec deffun chg del bvar Christoffel def -->
<!--  LocalWords:  BigK inverseconstruct apos arcsin attval eq typeattrib tbody -->
<!--  LocalWords:  lowlimit uplimit usequalifier opwithqual domainofapplication -->
<!--  LocalWords:  genat ttr td matrixrow piecewise exp cos glist mtr mi OM -->
<!--  LocalWords:  gitem emptytag msub msup codomain TODO abs arg ident csc ln -->
<!--  LocalWords:  sinh cosh tanh sech csch coth arccos arctan arccosh arccot -->
<!--  LocalWords:  arccoth arccsc arccsch arcsec arcsech arcsinh arctanh rem ta -->
<!--  LocalWords:  laplacian approx setdiff vectorproduct scalarproduct ary max -->
<!--  LocalWords:  outerproduct gcd lcm sdev cartesianproduct partialdiff leq -->
<!--  LocalWords:  forall logbase momentabout maxmin neq factorof notin tendsto -->
<!--  LocalWords:  notsubset notprsubset geq prsubset ldots evalf mrow OverBar -->
<!--  LocalWords:  cd arith namespace openmath rationals exponentiale attrib ee -->
<!--  LocalWords:  parseable quot nargs radians ExponentialE ImaginaryI infin -->
<!--  LocalWords:  infty NotANumber  evaluatable scriptstyle naturalnumbers tau -->
<!--  LocalWords:  imaginaryi notanumber emptyset eulergamma BesselJ ll  pre -->
<!--  LocalWords:  rightarrow mathbb placeholders diffd circ mathrm mbox lfloor -->
<!--  LocalWords:  rfloor th sqrt lor neg overline Im lceil rceil equiv frac xy -->
<!--  LocalWords:  newpdiff mathop nabla subseteq nsubseteq setminus lim eulere -->
<!--  LocalWords:  searrow elemclass langle rangle ccc det subscripted ab -->
<!--  LocalWords:  transc mtable NaN CSS globatt bf bigl cdot bigcup bigcap URI  -->
<!--  LocalWords:  MathML Carroll Unicode csymbol OpenMath conformant min -->
<!--  LocalWords:  elments xor int diff sec cds unhandled op OMBVAR href DOM OMR -->
<!--  LocalWords:  xref xml CDATA inline MiKo MMLdefinition  maxima minima WG -->
<!--  LocalWords:  JSD undeprecated CDBase CDs documentclass maketitle cerror -->
<!--  LocalWords:  csymbols fivefac RDF MathMLCDs OMDoc Miko YYYY DD ORCCA PMML -->
<!--  LocalWords:  lang pMathML arglist cMathML Infoset ntn alt mcd ctop xsl dx dy dz -->
<!--  LocalWords:  exchangeability   OMI OMF OMV OMA OMBIND OMC OMATTR OMATP OME -->
<!--  LocalWords:  OMFOREIGN MCDs expr exprlist egroup elevel PostScript Ai ai -->
<!--  LocalWords:  xn minfinity significand DivisionByZero aDiff oc NaNs miko -->
<!-- LocalWords:  funtype CommonAtt hexdouble Datatypes StringMglyph BvarQ -->
<!-- LocalWords:  PresentationExp cartesion bigfloat cdgroup TypeAtt DomainQ iy -->
<!-- LocalWords:  mglyph setname suchthat defint fooCondition ContExp Aj DavidC -->
<!-- LocalWords:  ConstructorwithQualifiers BinderWithQualfiers IntSumProduct -->
<!-- LocalWords:  defintbounds defintcond nthdiff multiset CRC Zwillinger -->
<!-- LocalWords:  univariate BVar fn reln AnnVar merror pmml OMSTR cbytes Zbase
-->
<!-- LocalWords:  DEADBEEF Rbase entn bflt cmplx const fns vn DefEncAtt zA src
-->
<!-- LocalWords:  AnnotationXML LUlimits bvars LUlimit orderedintegral xk nk
-->
<!-- LocalWords:  bla PresentationExpression SymbolName CDGroups cdbase linalg
-->
<!-- LocalWords:  setlist minmax veccalc partialdiffdegree
-->
