<!DOCTYPE html>
<html>
  <head>
    <title>MediaStream Capture Scenarios</title>
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
    <script type="text/javascript" src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script type="text/javascript" class='remove'>
            var respecConfig = {
                  specStatus: "ED",
                  editors: [{
                            name: "Travis Leithead", 
                            company: "Microsoft Corp.",
                            url: "mailto:travis.leithead@microsoft.com?subject=MediaStream Capture Scenarios Feedback",
                            companyURL: "http://www.microsoft.com"}],
                  edDraftURI:   "https://w3c.github.io/mediacapture-scenarios/scenarios.html",
                  previousPublishDate: null,
                  noIDLIn:  true,
                  inlineCSS:  true,
                  noRecTrack:  true,
                  shortName:  "capture-scenarios",
                  wg:         ["Device APIs Working Group", "Web Real-Time Communications Working Group"],
                  wgURI:    ["https://www.w3.org/2009/dap/", "https://www.w3.org/2011/04/webrtc/"],
                  wgPublicList: "public-media-capture",
                  wgPatentURI:  ["https://www.w3.org/2004/01/pp-impl/43696/status", "https://www.w3.org/2004/01/pp-impl/47318/status"]
              };
    </script>
    <style type="text/css">
      /* ReSpec.js CSS optimizations (Richard Tibbett) - cut-n-paste :) */
      div.example {
          border-top: 1px solid #ff4500;
          border-bottom: 1px solid #ff4500;
          background: #fff;
          padding:    1em;
          font-size: 0.9em;
          margin-top: 1em;
      }
      div.example::before {
          content:    "Example";
          display:    block;
          width:      150px;
          background: #ff4500;
          color:  #fff;
          font-family:    initial;
          padding:    3px;
          padding-left: 5px;
          font-weight:    bold;
          margin: -1em 0 1em -1em;
      }

      /* Clean up pre.idl */
      pre.idl::before {
          font-size:0.9em;
      }

      /* Add better spacing to sections */
      section, .section {
          margin-bottom: 2em;
      }

      /* Reduce note & issue render size */
      .note, .issue {
          font-size:0.8em;
      }

      /* Add addition spacing to <ol> and <ul> for rule definition */
      ol.rule li, ul.rule li {
          padding:0.2em;
      }
    </style>
  </head>

  <body>
    <section id='abstract'>
      <p>
        This document collates the target scenarios for the Media Capture task force. Scenarios represent 
        the set of expected functionality that may be achieved by the use of the MediaStream Capture API. A set of 
        un-supported scenarios may also be documented here.
      </p>
      <p>This document builds on the assumption that the mechanism for obtaining fundamental access to local media
        capture device(s) is <code>navigator.getUserMedia</code> (name/behavior subject to this task force), and that 
        the vehicle for delivery of the content from the local media capture device(s) is a <code>MediaStream</code>. 
        Hence the title of this note.
      </p>
    </section>

    <section id="sotd">
      <p>
        This document is intended to represent the consensus of the media capture task force on the set of scenarios 
        supported by the MediaStream Capture API. It will eventually be released as a Note.
      </p>
    </section>
    

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        One of the goals of the joint task force between the Device and Policy working group and the Web Real Time 
        Communications working groups is to bring media capture scenarios from both groups together into one unified 
        API that can address all relevant use cases.
      </p>
      <p>
        The capture scenarios from WebRTC are primarily driven from real-time-communication-based scenarios, such as 
        capturing live chats, teleconferences, and other media streamed from over the network from potentially 
        multiple sources.
      </p>
      <p>
        The capture scenarios from DAP represent "local" capture scenarios that providing access to a user agent's 
        camera and other related experiences.
      </p>
      <p>
        Both groups include overlapping chartered deliverables in this space. Namely in DAP, 
        <a href="https://www.w3.org/2011/07/DeviceAPICharter">the charter specifies a recommendation-track deliverable</a>:
        <ul>
         <li>
           <dl>
             <dt>Capture API</dt>
             <dd>an API to manage a device's camera and microphone, e.g. to take a picture or record a sound.</dd>
           </dl>
         </li>
        </ul>
      </p>
      <p>
         And <a href="https://www.w3.org/2011/04/webrtc-charter.html">WebRTC's charter scope</a> describes enabling 
         real-time communications between web browsers that will require specific client-side technologies:
         <ul>
          <li>API functions to explore device capabilities, e.g. camera, microphone, speakers (currently in scope
           for the <a href="https://www.w3.org/2009/dap/">Device APIs &amp; Policy Working Group</a>)</li>
          <li>API functions to capture media from local devices (camera and microphone) (currently in scope for the 
            <a href="https://www.w3.org/2009/dap/">Device APIs &amp; Policy Working Group</a>)</li>
          <li>API functions for encoding and other processing of those media streams,</li>
          <li>API functions for decoding and processing (including echo cancelling, stream synchronization and a
            number of other functions) of those streams at the incoming end,</li>
          <li>Delivery to the user of those media streams via local screens and audio output devices (partially 
            covered with HTML5)</li>
         </ul>
      </p>
      <p>
         Note, that the scenarios described in this document specifically exclude declarative capture scenarios, such as those where media capture can be 
         obtained and submitted to a server entirely without the use of script. Such scenarios generally involve the use 
         of a UA-specific app or mode for interacting with the capture device, altering settings and completing the 
         capture. Such scenarios are currently captured by the DAP working group's <a href="https://dev.w3.org/2009/dap/camera/">HTML Media Capture</a>
         specification.
      </p>
      <p>
         The scenarios contained in this document are specific to scenarios in which web applications require direct access
         to the capture device, its settings, and the capture mechanism and output. Such scenarios are 
         crucial to building applications that can create a site-specific look-and-feel to the user's interaction with the 
         capture device, as well as utilize advanced functionality that may not be available in a declarative model.
      </p>
      <p>
         Some of the scenarios described in this document may overlap existing 
         <a href="https://tools.ietf.org/html/draft-ietf-rtcweb-use-cases-and-requirements-06">usage scenarios</a>
         defined by the <a href="https://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB Working Group</a>. This document
         is specifically focused on the capture aspects of media streams, while the linked document is geared toward
         networking and peer-to-peer RTC scenarios.
      </p>
    </section>
    <section>
      <h2>Concepts and Definitions</h2>
      <p>
         This section describes some terminology and concepts that frame an understanding of the design considerations 
         that follow. It is helpful to have a common understanding of some core concepts to ensure that the prose is
         interpreted uniformly.
      </p>
       <dl>
         <dt> Media Stream and <dfn>Stream</dfn></dt>
         <dd>This document uses these terms interchangeably.  They are intended to be
           a generalization of the more specific <code>MediaStream</code> interface as currently defined in the 
           WebRTC spec. Generally, a stream can be understood as a tube or conduit between sources (the stream's 
           generators) and destinations (the sinks). Streams don't generally include any type of significant buffer, that is, 
           content pushed into the stream from a source does not collect into any buffer for later collection. Rather, content 
           is simply dropped on the floor if the stream is not connected to a sink.  The content flowing through a media
           stream is not in any particular underlying format.  (Note that the    
        the WebRTC specification makes a similar assertion about the content flowing
        through a <code>MediaStream</code>.)
        </dd>
        <dt>Media Capture versus Recording</dt>
        <dd>This document uses 'media capture' to refer to the process of obtaining a stream of data
        	from a device.  As noted above, that data is not assumed to be in any particular format.  
        	'Recording', on the other hand, refers to the capture of media under application control
        	and in a specific, known, format.  Such data can be written to a local file or sent to a
        	remote destination.</dd>
        <dt>Shared devices, devices with manipulatable state, and virtualization</dt>
        <dd>
           <p>A shared device (in this document) is a media device (camera or microphone) that is usable by more than 
             one application at a time. When considering sharing a device (or not), an operating system must evaluate
             whether applications consuming the device will have the ability to manipulate the state of the device. A shared device 
             with manipulatable state has the side-effect of allowing one application to make changes to a device that will then
             affect other applications who are also sharing.
           </p>
           <p>To avoid these effects and unexpected state changes in applications, operating systems may virtualize a 
             device. Device virtualization (in a simplistic view) is an abstraction of the actual device, so that the abstraction
             is provided to the application rather than providing the actual device. When an application manipulates the state 
             of the virtualized device, changes occur only in the virtualized layer, and do not affect other applications that 
             may be sharing the device.
           </p>
           <p>Audio devices are commonly virtualized. This allows many applications to share the audio device and manipulate its
             state (e.g., apply different input volume levels) without affecting other applications.
           </p>
           <p>Video virtualization is more challenging and not as common. For example, the Microsoft Windows operating system does
             not virtualize webcam devices, and thus chooses not to share the webcam between applications. As a result, in order 
             for an application to use the webcam either 1) another application already using the webcam must yield it up or 2) 
             the requesting application may be allowed to "steal" the device.
           </p>
        </dd>
       </dl>
      </p>
    </section>
    <section>
      <h2>Scenarios</h2>
      <p>
         In this section, scenarios are presented first as a story that puts the scenario into perspective, and then 
         as a list of specific capture scenarios included in the story.
      </p>

      <section>
        <h3>"Check out this new hat!" (photo upload with audio caption)</h3>
        <p>
           	Amy logs in to her favorite social networking page. She wants to tell her friends about a new hat she recently 
            bought for an upcoming school play. She clicks a "select photo" drop-down widget on the site, and choses the 
            "from webcam" option. A blank video box appears on the site followed by a notice from the browser to "allow the 
            use of the webcam". She approves it (just like she did the last time she used her camera on this site), and immediately sees her own image as viewed by her webcam. She then hears 
            an audio countdown starting from "3", giving her time to adjust herself in the video frame so that her hat is 
            clearly visible. After the countdown reaches "0", the captured image is displayed along with some controls with 
            which to resize/crop the image. She crops the image so that it just showcases her hat. She then clicks a button 
            allowing her to record an "audio caption". A small box with an audio meter appears, immediately followed by 
            another prompt from her browser to "allow the use of the microphone". After approving it, she sees an indicator 
            showing that the microphone is listening, and then begins describing the features of her new hat. While she 
            speaks she sees that the microphone is picking up her voice because the audio meter is reacting to her voice. 
            She stops talking and after a moment the web page asks her to confirm that she's done with her caption. She 
            confirms that she is finished, and then clicks on "check in" which uploads her new picture and audio caption to 
            the social networking site's server.
        </p>
        <p>Requirements: <a href="#p1">P1</a>, <a href="#p1">P2</a>, <a href="#lm1">LM1</a>, 
        	<a href="#lm2">LM2</a>,<a href="#lm3">LM3</a>,<a href="#LM12">LM12</a>, <a href="#mc1">MC1</a>,
        	<a href="#mc2">MC2</a>.</p>
        

        <section>
          <h4>Variations</h4>
          <p>TBD</p>
        </section>
      </section>

      <section>
         <h3>Election podcast and commentary (video capture and chat)</h3>
         <p>
            Every Wednesday at 6:45pm, Adam logs into his video podcast web site for his scheduled 7pm half-hour broadcast 
            "commentary on the US election campaign". These podcasts are available to all his subscribers the next day, but 
            a few of his friends tune-in at 7 to listen to the podcast live. Adam selects the "prepare podcast" option, 
            is notified by the browser that he previously approved access to his webcam and microphone, and situates himself in front of the 
            webcam, using the "self-view" video window on the site. While waiting for 7pm to arrive, the video podcast site 
            indicates that two of his close friends are now online. He approves their request to listen live to the podcast. 
            Finally, at 7pm he selects "start podcast" and launches into his commentary. While capturing locally, Adam switches
            between several tabs in his browser to quote from web sites representing differing political views. Half-hour later, he wraps up his 
            concluding remarks, and opens the discussion up for comments. One of his friends has a comment, but has 
            requested anonymity, since the comments on the show are also recorded. Adam enables the audio-only setting for 
            that friend and directs him to share his comment. In response to the first comment another of Adam's friends 
            wants to respond. This friend has not requested anonymity, and so Adam enables the audio/video mode for that 
            friend, and hears the rebuttal. After a few back-and-forths, Adam sees that his half-hour is up, thanks his 
            audience, and clicks "end podcast". A few moments later that site reports that the podcast has been uploaded.
         </p>
         <p>Requirements: <a href="#p1">P3</a>,<a href="#p4">P4</a>, <a href="#lm1">LM1</a>,
         	<a href="#lm5">LM5</a>
         	<a href="#rm2">RM2</a>, <a href="#rm3">RM3</a>,<a href="#rm4">RM4</a>, <a href="#mc3">MC3</a>,
         	<a href="#mc6">MC6</a>.
         	</p>

         <section>
          <h4>Variations</h4>
          <p>TBD</p>
        </section>
      </section>

      <section>
        <h3>Find the ball assignment (media processing and recording)</h3>
        <p>
           	Alice is finishing up a college on-line course on image processing, and for the assignment she has to write 
            code that finds a blue ball in each video frame and draws a box around it. She has just finished testing her 
            code in the browser using her webcam to provide the input and the canvas element to draw the box around each 
            frame of the video input. To finish the assignment, she must upload a video to the assignment page, which 
            requires uploads to have a specific encoding (to make it easier for the TA to review and grade all the 
            videos) and to be no larger than 50MB (small camera resolutions are recommended) and no longer than 30 
            seconds. Alice is now ready; she enables the webcam, a video preview (to see herself and the ball with the box around it), changes the camera's resolution down to 320x200, starts a video capture along with her media processing code, and holds up the blue ball, moving it around.  As she moves the ball, her code processes each video frame, drawing the box around the ball. The video preview shows output of her code (namely herself with the box tracking the ball) so that she sees that it is working correctly.  After recording the output of her processing code for 30 seconds, Alice stops the recording and immediately uploads the recorded video to the assignment upload page using her class account.
        </p>
        <p>Requirements:<a href="#lm1">LM1</a>, <a href="#lm6">LM6</a>, <a href="#lm7">LM7</a>,
        	<a href="#mc1">MC1</a>,
        	<a href="#mc4">MC4</a>, <a href="#mc5">MC5</a>. </p>

         <section>
          <h4>Variations</h4>
          <section>
          <h5>Recording with post-processing</h5>
          <p>Alice decides to run her image-tracking code as a post-processing step.  She enables the webcam, a video preview (to see herself and the ball), changes the camera's resolution down to 320x200, starts a video recording, and holds up the blue ball, moving it around.  As she does this, the UA records the video stream of her and the ball.  After 30 seconds, she terminates the recording and saves the result to a file.  She then runs her image-processing software on the saved file, producing a new file that shows the box drawn around the moving ball.  She then previews the processed file to make sure it's correct, and uploads it to the assignment page using her class account.   </p>
          </section>
         </section>
        </section>
      </section>

      <section>
         <h3>Video diary at the Coliseum (multiple webcams and error handling)</h3>
         <p>
            Albert is on vacation in Italy. He has a device with a front and rear webcam, and a web application that lets 
            him document his trip by way of a video diary. After arriving at the Coliseum, he launches his video diary 
            app. There is no internet connection to his device. The app asks Albert which of his microphones and 
            webcams he'd like to use, and he activates both webcams (front and rear). Two video elements appear side-by-side 
            in the app. Albert uses his device to capture a few still shots of the Coliseum using the rear camera, then 
            starts recording a video, selecting the front-facing webcam to begin explaining where he is. While talking, 
            he selects the rear-facing webcam to capture a video of the Coliseum (without having to turn his device 
            around), and then switches back to the front-facing camera to continue checking in for his diary entry. 
            Albert has a lot to say about the Coliseum, but before finishing, his device warns him that the battery is 
            about to expire. At the same time, the device shuts down the cameras and microphones to conserve battery power. 
            Later, after plugging in his device at a coffee shop, Albert returns to his diary app and notes that his 
            recording from the Coliseum was saved. 
         </p>
         <p>Requirements: <a href="#p2">P2</a>, <a href="#lm9">LM9</a>,
         	<a href="#mc1">MC1</a>, <a href="#mc6">MC6</a>, <a href="#mc7">MC8</a>.</p>
      
      
        <section>
          <h4>Variations</h4>
          <section>
           <h5>Recording a sports event (simultaneous capture from multiple webcams)</h5>
           <p>Albert's day job is a sports commentator. He works for a local television station and records the local
            hockey games at various schools. Albert uses a web-based front-end on custom hardware that allows him to connect
            three cameras covering various angles of the game and a microphone with which he is running the commentary.
            The application records all of these cameras at once. After the game, Albert prepares the game highlights. He
            likes to highlight great plays by showing them from multiple angles. The final composited video is shown on the
            evening news.
           </p>
           <p>Requirements: <a href="#mc9">MC9</a>.</p>
     
          </section>
          <section>
           <h5>Picture-in-picture (capture a composed video)</h5>
           <p>While still on his Italy vacation, Albert hears that the Pope might make a public appearance at the vatican. Albert
            arrives early to claim a spot, and starts his video diary. He activates both front and rear cameras so that he can 
            capture both himself and the camera's view. He then sets up the view in his video diary so that the front-facing camera 
            displays in a small frame contained in one corner of the larger rear-facing camera's view rectangle (picture-in-picture).
            Albert excitely describes the sense of the crowd around him while simultaneously capturing the Pope's appearance. Afterward,
            Albert is happy that he didn't miss the moment by having to switch between cameras.
           </p>
           <p>Requirements: <a href="#lm9">LM9</a>, <a href="#lmc10">MC10</a>.</p>
        
          </section>
        </section>
      </section>

      <section>
        <h3>Conference call product debate (multiple conversations and capture review)</h3>
        <p>
           As part of a routine business video conference call, Amanda initiates a connection to the five other field 
           agents in her company via the company's video call web site. Amanda is the designated scribe and archivist; 
           she is responsible for keeping the meeting minutes and also saving the associated meeting video for later 
           archiving. As each field agent connects to the video call web site, and after granting permission, their 
           video feed is displayed on the site. After the five other field agents checkin, Amanda calls the meeting to 
           order and starts the meeting recorder. The recorder captures all participant's audio, and selects a video 
           channel to record based on dominance of the associated video channel's audio input level. As the meeting 
           continues, several product prototypes are discussed. One field agent has created draft product sketch that 
           he shows to the group by sending the image over his video feed. This image spurs a fast-paced debate and 
           Amanda misses several of the participant's discussion points in the minutes. She calls for a point of order, 
           and requests that the participants wait while she catches up. Amanda pauses the recording, rewinds it by 
           thirty seconds, and then re-plays it in order to catch the parts of the debate that she missed in the 
           minutes. When done, she resumes the recording and the meeting continues. Toward the end of the meeting, one 
           field agent leaves early and his call is terminated.
        </p>
        <p>Requirements: <a href="#p1">P1</a>, <a href="#p2">P2</a>, <a href="#p3">P3</a>, 
        	<a href="#lm1">LM1</a>, <a href="#lm4">LM4</a>, <a href="#rm2">RM2</a>, 
        	<a href="#rm5">RM5</a>, <a href="#rm6">RM6</a>, <a href="#mc1">MC1</a>, <a href="#mc6">MC6</a>,
        	<a href="#mc11">MC11</a>, <a href="#mc12">MC12</a>, <a href="#mc13">MC13</a>.        	
        	 </p>
       

         <section>
          <h4>Variations</h4>
          <section>
           <h5>Showcase demo on local screen (screen as an local media input source)</h5>
           <p>During the video conference call, Amanda invites a member of the product development team to demonstrate a 
            new visual design editor for the prototype. The design editor is not yet finished, but has the UI elements in 
            place. It currently only compiles on that developer's computer, but Amanda wants the field agents' feedback 
            since they will ultimately be using the tool. The developer is able to select the screen as a local media 
            source and send that video to the group as he demonstrates the UI elements.
           </p>
           <p>Requirements: <a href="#lm10">LM10</a>.</p>
         
          </section>          
        </section>
      </section>
      
      <section>
        <h3>Incident on driver-download page (device fingerprinting with malicious intent)</h3>
        <p>
           	While visiting a manufacturer's web site in order to download drivers for his new mouse, Austin unexpectedly 
            gets prompted by his browser to allow access to his device's webcam. Thinking that this is strange (why is 
            the page trying to use my webcam?), Austin denies the request. Several weeks later, Austin reads an article 
            in the newspaper in which the same manufacturer is being investigated by a business-sector watchdog agency 
            for poor business practice. Apparently this manufacturer was trying to discover how many visitors to their 
            site had webcams (and other devices) from a competitor. If that information could be discovered, then the 
            site would subject those users to slanderous advertising and falsified "webcam tests" that made it appear 
            as if their competitor's devices were broken in order to convince users to purchase their own brand of webcam.
        </p>
        <p>Requirements: <a href="#p5">P5</a>.</p>
       

          <section>
          <h4>Variations</h4>
          <p>TBD</p>
        </section>
      </section>
    </section>

    <section>
      <h2>Requirements</h2>
           		<p>PERMISSIONS</p>
      	<ol>
 
      		<li id="p1">The UA must  request the user's permission before accessing any media devices.</li>
      		<li id="p2">The UA must allow the user to grant permission to specific devices.  (Example: front camera is ok, back camera is not.)</li>
      		<li id="p3">The UA must request the user's permission before sending or receiving  a media stream to or from another user.</li> 
      		<li id="p4">The UA must be able to store permissions granted to certain applications. [THIS NEEDS TO BE RESTRICTED.]</li>
      		<li id="p5">The UA must not make information about the user's media devices available to the Application
      			until the user grants permission to use them.</li>
      		</ol>
      		<p>LOCAL MEDIA</p>
      		<ol>
      		<li id="lm1">The UA must be able to show the image stream from a camera on the screen.</li>
          <li id="lm2">The UA must be able to provide a visual display of the properties of the sound captured from from a microphone (volume in this  case).</li>
         <li id="lm3">The UA must be able to trigger an event based on the volume of sound over some period of
time (silence, in this case).</li>
<li id="lm4">The UA must be able to blend remote audio streams with the local stream.</li>
<li id="lm5">The UA must be able to continue sending and/or capturing media while the tab is in the background.</li>
<li id="lm6">The UA must be able to extract image frames from video.</li>
<li id="lm7">The UA must be able to insert image frames into a local video stream (or capture).</li>
<li id="lm8">The UA must be able to modify stream parameters such as size and frame rate within the
	limits set by the local hardware. </li>
	<li id="lm9">The UA must be able to display multiple local or remote streams simultaneously.</li>
	<li id="lm10">The UA must support the use of the local screen/display as a video source.</li>
	<li id="lm11">The UA must allow the user to pause or stop media streams via UXes (and not just the 
		buttons on the underlying hardware.)  The UX provided by the chrome must override any UX provided
		by the Application. </li>
		<li id="lm12">The UA must provide a UX letting the user know when it is using one or more of
			his media devices.</li>
	</ol>

<p>REMOTE MEDIA</p>
<p>These requirements for remote media are outside the scope of the Media Capture task force, but are relevant to
	the related WebRTC/rtcWeb work, which is a joint effort of the W3C and the IETF.  The <a href="https://datatracker.ietf.org/doc/draft-ietf-rtcweb-use-cases-and-requirements">
		scenarios
	and requirements document</a> for that effort contains requirements that are similar to those given here.
	They are listed in parentheses after each item. .</p>
<ol>
<li id="rm1">The UA must be able to transmit media to one or more remote sites and to receive media from them. (rtcWeb: F2, F4, F11, F12)</li>
<li id="rm2">The UA must be able to play audio and video media received from a remote site. (rtcWeb: F4, F10)</li>
<li id="rm3">The UA must be able to stop or pause the reception and/or transmission of any media stream independent of any other streams. (rtcWeb: A8)</li>
<li id="rm4">The UA must be able to add new remote media connections while a recording is running.  The new remote streams
	may or may not be included in the recording. </li>
	<li id="rm5">The UA must be able to send or receive a still image over a video stream. </li>
	<li id="rm6">The UA must provide the Application with the parameters of all streams (for example, audio level). (rtcWeb: F14, F38, A12, A14) </li>

	</ol>


<p>RECORDING</p>
<ol>
<li id="mc1">The UA must be able to record local or remote audio streams, video streams or still images from a camera or microphone 
	and store the result as a file.</li>
<li id="mc2"> The UA must enable the Application to trigger recording either from a button click or a timer event.</li>
<li id="mc3">The UA must be able to send recorded media to one or more remote locations while recording is running.</li>
<li id="mc4">The UA must enable the Application to select the recording format and resolution from those available on the local hardware.</li>
<li id="mc5">the UA must </a>enable the Application to set size contraints and time limits on recording. </li>
<li id="mc6">The UA must allow the user to switch recording between one or more local and remote streams without interruption.</li>
<li id="mc7">The UA must enable the Application to use device properties, such as battery level, to determine when to terminate media capture.</li>
<li id="mc8">The UA must enable error recovery in the case of premature termination of recording.</li>
<li id="mc9">The UA must support simultaneous recording from multiple devices into separate recordings.</li>
<li id="mc10">The UA must support simultaneous recording from multiple devices into a single recording. </li>
<li id="mc11">The UA must support the dynamic addition and deletion of  streams from a recording.</li>
<li id="mc12">The UA must enable the Application to pause and resume the recording of local or remote streams.</li>
<li id="mc13">The UA must enable the Application to rewind and replay a paused recorded stream.</li>

</ol>
    
    </section>
    

    
    <section>
      <h2>Design Considerations and Remarks</h2>

      <section>
        <h3>Stream initialization</h3>
        <p>A web application must be able to initiate a request for access to the user's webcam(s) and/or microphone(s). 
        Additionally, the web application should be able to "hint" at specific device characteristics that are desired by 
        the particular usage scenario of the application. User consent is required before obtaining access to the requested 
        stream.</p>
        <p>When the media capture devices have been obtained (after user consent), they must be associated with a 
        <code>MediaStream</code> object, be active, and populated with the appropriate tracks.
        The active capture devices will be configured according to user preference; the 
        user may have an opportunity to configure the initial state of the devices, select specific devices, and/or elect 
        to enable/disabled a subset of the requested devices at the point of consent or beyond—the user remains in control).
        </p>
        <p>It is recommended that the active <code>MediaStream</code> be associated with a browser UX in order to ensure that
         the user:
         <ul>
          <li>is made aware that their device's webcam and/or microphone is active (for this reason many webcams include a 
           light or other indicator that they are active, but this is not always the case--especially with most microphones embedded in 
           consumer devices)</li>
          <li>has a UX affordance to easily modify the capture device settings or shut off the associated capture device if necessary</li>
         </ul>
         Such a browser UX should be offered in a way that maintains visible even when a browser's tab (performing the capture)
         is sent to the background. For the purposes of many common scenarios (especially involving real-time communications), it is not
         recommended that the browser automatically shut down capture devices when the capturing browser tab is sent to the background.
         If such a scenario is desired by the application author, the tab switch may be detected via other browser events (e.g., the 
         <a href="https://www.w3.org/TR/page-visibility/">page visibility event</a>) and the <code>MediaStream</code> can be stopped via <code>stop()</code>.
        </p>
        <section>
         <h4>Privacy</h4>
         <p>Specific information about a given webcam and/or microphone must not be available until after the user has 
         granted consent. Otherwise "drive-by" fingerprinting of a UA's devices and characteristics can be obtained without 
         the user's knowledge—a privacy issue.</p>
         <p>In addition, care must be taken that webcam and audio devices are not able to record and stream data without the 
         user's knowledge. Explicit permission should be granted for a specific activity of a limited duration. Configuration 
         controls should be possible to enable age-limits on webcam use or other similar techniques.</p>
        </section>

        <section>
         <h4>Issues</h4>
         <ol>
          <li>What are the privacy/fingerprinting implications of the current "error" callback? Is it sufficiently "scary" 
              to warrant a change? Consider the following:
              <ul>
                 <li>If the user doesn’t have a webcam/mic, and the developer requests it, a UA would be expected to invoke 
                     the error callback immediately.</li>
                 <li>If the user does have a webcam/mic, and the developer requests it, a UA would be expected to prompt for 
                     access. If the user denies access, then the error callback is invoked.</li>
                 <li>Depending on the timing of the invocation of the error callback, scripts can still profile whether the 
                     UA does or does not have a given device capability.</li>
              </ul>
          </li>
          <li>In the case of a user with multiple video and/or audio capture devices, what specific permission is expected to 
              be granted for the "video" and "audio" options presented to <code>getUserMedia</code>? For example, does "video"
              permission mean that the user grants permission to any and all video capture devices? Similarly with "audio"? Is
              it a specific device only, and if so, which one? Given the privacy point above, my recommendation is that "video"
              permission represents permission to all possible video capture devices present on the user's device, therefore 
              enabling switching scenarios (among video devices) to be possible without re-acquiring user consent. Same for 
              "audio" and combinations of the two.
          </li>
          <li>When a user has only one of two requested device capabilities (for example only "audio" but not "video", and both 
              "audio" and "video" are requested), should access be granted without the video or should the request fail?
          </li>
          <li>Enabling control configuration of webcam based on age (parental control)</li>
          <li>Phishing and other attacks using webcam, audio (possible issue to note)</li>
         </ol>
        </section>
      </section>

      <section>
       <h3>Stream re-initialization</h3>

       <p>After requesting (and presumably gaining access to media capture devices) it is entirely possible for one or more of 
       the requested devices to stop or fail (for example, if a video device is claimed by another application, or if the user 
       unplugs a capture device or physically turns it off, or if the UA shuts down the device arbitrarily to conserve battery 
       power). In such a scenario it should be reasonably simple for the application to be notified of the situation, and for 
       the application to re-request access to the stream.
       </p>
       <p>Additional information might also be useful either in terms of <code>MediaStream</code> state such as an error object,
       or additional events like an <code>error</code> event (or both).
       </p>

          <section>
           <h4>Issues</h4>
           <ol>
            <li>How shall the stream be re-acquired efficiently? Is it merely a matter of re-requesting the entire 
                <code>MediaStream</code>, or can an "ended" mediastream be quickly revived? Reviving a local media stream makes 
                more sense in the context of the stream representing a set of device states, than it does when the stream 
                represents a network source. The WebRTC editors are considering moving the "ended" event from the 
                <code>MediaStream</code> to the <code>MediaStreamTrack</code> to help clarify these potential scenarios.
            </li>
            <li>What's the expected interaction model with regard to user-consent? For example, if the re-initialization 
                request is for the same device(s), will the user be prompted for consent again? Minor glitches in the stream 
                source connection should not revoke the user-consent.
            </li>
            <li>How can tug-of-war scenarios be avoided between two web applications both attempting to gain access to a 
                non-shared device at the same time? Should the API support the ability to request exclusive use of the 
                device?
            </li>
           </ol>
          </section>
     </section>

     <section>
      <h3>Preview a stream</h3>
      <p>The application should be able to connect a media stream (representing active media capture device(s) to one or more sinks
       in order to use/view the content flowing through the stream. In nearly all digital capture scenarios, "previewing" 
       the stream before initiating the capture is essential to the user in order to "compose" the shot (for example, 
       digital cameras have a preview screen before a picture or video is captured; even in non-digital photography, the 
       viewfinder acts as the "preview"). This is particularly important for visual media, but also for non-visual media 
       like audio.
      </p>
      <p>Note that media streams connected to a preview output sink are not in a "capturing" state as the media stream has 
       no default buffer (see the <a>Stream</a> definition in section 4). Content conceptually "within" the media stream 
       is streaming from the capture source device to the preview sink after which point the content is dropped (not 
       saved).
      </p>
      <p>The application should be able to affect changes to the media capture device(s) settings via the media stream 
       and view those changes happen in the preview.
      </p>
      <p>Today, the <code>MediaStream</code> object can be connected to several "preview" sinks in HTML5, including the 
       <code>video</code> and <code>audio</code> elements. (This support should also extend to the <code>source</code> 
       elements of each as well.) The connection is accomplished via <code>URL.createObjectURL</code>. For RTC scenarios, 
       <code>MediaStream</code>s are connected to <code>PeerConnection</code> sinks.
      </p>
      <p>An implementation should not limit the number or kind of sinks that a <code>MediaStream</code> is connected 
       to (including sinks for the purpose of previewing).</p>
      <section>
        <h4>Issues</h4>
        <ol>
         <li>Audio tag preview is somewhat problematic because of the acoustic feedback problem (interference that can 
          result from a loop between a microphone input that picks up the output from a nearby speaker). There are 
          software solutions that attempt to automatically compensate for these type of feedback problems. However, it 
          may not be appropriate to require implementations to all support such an acoustic feedback prevention 
          algorithm. Therefore, audio preview could be turned off by default and only enabled by specific opt-in. 
          Implementations without acoustic feedback prevention could fail to enable the opt-in?
         </li>
        </ol>
      </section>
     </section>

     <section>
      <h3>Stopping local devices</h3>
      <p>End-users need to feel in control of their devices. Likewise, it is expected that developers using a media stream 
       capture API will want to provide a mechanism for users to stop their in-use device(s) via the software (rather than 
       using hardware on/off buttons which may not always be available).
      </p>
      <p>Stopping or ending a media stream source device(s) in this context implies that the media stream source device(s)
       cannot be re-started. This is a distinct scenario from simply pausing the video/audio tracks of a given media stream.
      </p>
      <section>
       <h4>Issues</h4>
       <ol>
        <li>Is there a scenario where end-users will want to stop just a single device, rather than all devices participating 
         in the current media stream? In the WebRTC case there seems to be, e.g. if the current connection cannot handle both 
         audio and video streams then the user might want to back down to audio, or the user just wants to drop down to audio 
         because they decide they don't need video. But otherwise, e.g. for local use cases, mute seems more likely and less 
         disruptive (e.g. in terms of CPU load which might temporarily affect recorded quality of the remaining streams).
        </li>
       </ol>
      </section>
     </section>

     <section>
      <h3>Pre-processing</h3>
      <p>Pre-processing scenarios are a bucket of scenarios that perform processing on the "raw" or "internal" characteristics 
       of the media stream for the purpose of reporting information that would otherwise require processing of a known 
       format (i.e., at the media stream sink—like Canvas, or via capturing and post-processing), significant 
       computationally-expensive scripting, etc.
      </p>
      <p>Pre-processing scenarios will require the UAs to provide an implementation (which may be non-trivial). This is 
       required because the media stream's internal format should be opaque to user-code. Note, if a future 
       specification described an interface to allow low-level access to a media stream, such an interface would enable 
       user-code to implement many of the pre-processing scenarios described herein using post-processing techniques (see 
       next section).
      </p>
      <p>Pre-processing scenarios provide information that is generally desired <i>before</i> a stream need be connected to a 
       sink or captured.
      </p>
      <p>Pre-processing scenarios apply to both real-time-communication and local capture scenarios. Therefore, the 
       specification of various pre-processing requirements may likely fall outside the scope of this task force. However, 
       they are included here for scenario-completeness and to help ensure that a media capture API design takes them into 
       account.
      </p>
      <section>
       <h4>Examples</h4>
       <ol>
        <li>Audio end-pointing. As described in <a href="https://lists.w3.org/Archives/Public/www-archive/2011Mar/att-0001/microsoft-api-draft-final.html">a 
         speech API proposal</a>, audio end-pointing allows for the detection of noise, speech, or silence and raises events 
         when these audio states change. End-pointing is necessary for scenarios that programmatically determine when to 
         start and stop capturing an audio stream for purposes of hands-free speech commands, dictation, and a variety of 
         other speech and accessibility-related scenarios. The proposal linked above describes these scenarios in better 
         detail. Audio end-pointing would be required as a pre-processing scenario because it is a prerequisite to 
         starting/stopping a capture of the media stream itself.
        </li>
        <li>Volume leveling/automatic gain control. The ability to automatically detect changes in audio loudness and adjust 
         the input volume such that the output volume remains constant. These scenarios are useful in a variety of 
         heterogeneous audio environments such as teleconferences, live broadcasting involving commercials, etc. 
         Configuration options for volume/gain control of a media stream source device are also useful, and are explored 
         later on.
        </li>
        <li>Video face-recognition and gesture detection. These scenarios are the visual analog to the previously described 
         audio end-pointing scenarios. Face-recognition is useful in a variety of contexts from identifying faces in family 
         photographs, to serving as part of an identity management system for system access. Likewise, gesture recognition 
         can act as an input mechanism for a computer.
        </li>
       </ol>
      </section>
      <section>
       <h4>Issues</h4>
       <ol>
        <li>In general the set of audio pre-processing scenarios is much more constrained than the set of possible visual 
         pre-processing scenarios. Due to the large set of visual pre-processing scenarios (which could also be implemented 
         by scenario-specific post-processing in most cases), we may recommended that visual-related pre-processing 
         scenarios be excluded from the scope of our task force.
        </li>
        <li>The challenges of specifying pre-processing scenarios will be identifying what specific information should be 
         conveyed by the platform at a level at which serves the widest variety of scenarios. For example, 
         audio-end-pointing could be specified in high-level terms of firing events when specific words of a given language 
         are identified, or could be as low-level as reporting when there is silence/background noise and when there's not. 
         Not all scenarios will be able to be served by any API that is designed, therefore this group might choose to 
         evaluate which scenarios (if any) are worth including in the first version of the API.
        </li>
        <li>Similarly to gestures, speech recognition can also be used to control the stream itself. But both uses are about 
         interpreting the content to derive events, it may be that these capabilities should be addressed in some other spec. 
         The more generic capabilities (input level monitoring) or automatic controls based upon them (e.g. AGC) however are 
         useful to consider here. These might be simplified (initially) to boolean options (capture auto-start/pause and AGC).
         Going beyond that, input level events (e.g. threshold passing) or some realtime-updated attribute (input signal level)
         on the API would be very useful in capture scenarios.
        </li>
       </ol>
      </section>
     </section>

     <section>
      <h3>Post-processing</h3>
      <p>Post processing scenarios are a group of all scenarios that can be completed after either:</p>
      <ol>
       <li>Connecting the media stream to a sink (such as the <code>video</code> or <code>audio</code> elements</li>
       <li>Capturing the media stream to a known format (MIME type)</li>
      </ol>
      <p>Post-processing scenarios will continue to expand and grow as the web platform matures and gains capabilities. 
       The key to understanding the available post-processing scenarios is to understand the other facets of the web 
       platform that are available for use.
      </p>
      <p>Note: Depending on convenience and scenario usefullness, the post-processing scenarios in the toolbox below
       could be implemented as pre-processing capabilities (for example the Web Audio API). In general, this document
       views pre-processing scenarios as those provided by the <code>MediaStream</code> and post-processing scenarios 
       as those that consume a <code>MediaStream</code>.</p>
      <section>
       <h4>Web platform post-processing toolbox</h4>
       <p>The common post-processing capabilities for media stream scenarios are built on a relatively small set of web 
        platform capabilities. The capabilities described here are derived from current W3C draft specifications, many 
        of which have widely-deployed implementations:
       </p>
       <ol>
        <li>HTML5 <a href="https://dev.w3.org/html5/spec/Overview.html#the-video-element"><code>video</code></a> and 
         <a href="https://dev.w3.org/html5/spec/Overview.html#the-audio-element"><code>audio</code></a> tags. These elements are natural 
         candidates for media stream output sinks. Additionally, they provide an API (see 
         <a href="https://dev.w3.org/html5/spec/Overview.html#htmlmediaelement">HTMLMediaElement</a>) for interacting with 
         the source content. Note: in some cases, these elements are not well-specified for stream-type sources—this task 
         force may need to drive some stream-source requirements into HTML5.
        </li>
        <li>HTML5 <a href="https://dev.w3.org/html5/spec/Overview.html#the-canvas-element"><code>canvas</code></a> element 
         and the <a href="https://dev.w3.org/html5/2dcontext/">Canvas 2D context</a>. The <code>canvas</code> element employs 
         a fairly extensive 2D drawing API and will soon be extended with audio capabilities as well (<b>RichT, can you 
         provide a link?</b>). Canvas' drawing API allows for drawing frames from a <code>video</code> element, which is 
         the link between the media capture sink and the effects made possible via Canvas.
        </li>
        <li><a href="https://dev.w3.org/2006/webapi/FileAPI/">File API</a> and 
         <a href="https://www.w3.org/TR/file-writer-api/">File API Writer</a>. The File API provides various methods for 
         reading and writing to binary formats. The fundamental container for these binary files is the <code>Blob</code> 
         which put simply is a read-only structure with a MIME type and a length. The File API integrates with many other 
         web APIs such that the <code>Blob</code> can be used uniformly across the entire web platform. For example, 
         <code>XMLHttpRequest</code>, form submission in HTML, message passing between documents and web workers 
         (<code>postMessage</code>), and Indexed DB all support <code>Blob</code> use.
        </li>
        <li>Stream API. A new addition to 
         the WebApps WG, the <code>Stream</code> is another general-purpose binary container. The primary differences 
         between a <code>Stream</code> and a <code>Blob</code> is that the <code>Stream</code> is read-once, and has no 
         length. The Stream API includes a mechanism to buffer from a <code>Stream</code> into a <code>Blob</code>, and 
         thus all <code>Stream</code> scenarios are a super-set of <code>Blob</code> scenarios.
        </li>
        <li>JavaScript <a href="https://wiki.ecmascript.org/doku.php?id=strawman:typed_arrays">TypedArrays</a>. Especially 
         useful for post-processing scenarios, TypedArrays allow JavaScript code to crack-open a binary file 
         (<code>Blob</code>) and read/write its contents using the numerical data types already provided by JavaScript. 
         There's a cool explanation and example of TypedArrays 
         <a href="https://blogs.msdn.com/b/ie/archive/2011/12/01/working-with-binary-data-using-typed-arrays.aspx">here</a>.
        </li>
        <li><a href="https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html">Web Audio API</a>. A proposal 
         for processing and synthesizing audio in web applications. Additionally, that group publishes the <a href="https://www.w3.org/TR/audioproc/">
         Audio Processing API</a> containing additional information.
        </li>
       </ol>
       </section>
       <p>Of course, post-processing scenarios made possible after sending a media stream or captured media stream to a 
        server are unlimited.
       </p>
       <section>
        <h4>Time sensitivity and performance</h4>
        <p>Some post-processing scenarios are time-sensitive—especially those scenarios that involve processing large 
         amounts of data while the user waits. Other post-processing scenarios s are long-running and can have a performance 
         benefit if started before the end of the media stream segment is known. For example, a low-pass filter on a video.
        </p>
        <p>These scenarios generally take two approaches:</p>
        <ol>
         <li>Extract samples (video frames/audio clips) from a media stream sink and process each sample. Note that this 
          approach is vulnerable to sample loss (gaps between samples) if post-processing is too slow.
         </li>
         <li>Capture the media stream and extract samples from the captured native format. Note that this approach requires 
          significant understanding of the captured native format.
         </li>
        </ol>
        <p>
         Both approaches are valid for different types of scenarios.
        </p>
        <p>The first approach is the technique described in the current WebRTC specification for the "take a picture" 
         example.
        </p>
        <p>The second approach is somewhat problematic from a time-sensitivity/performance perspective given that the 
         captured content is only provided via a <code>Blob</code> today. A more natural fit for post-processing scenarios 
         that are time-or-performance sensitive is to supply a <code>Stream</code> as output from a capture. 
         Thus time-or-performance sensitive post-processing applications can immediately start processing the [unfinished] 
         capture, and non-sensitive applications can use the Stream API's <code>StreamReader</code> to eventually pack 
         the full <code>Stream</code> into a <code>Blob</code>.
        </p>
       </section>
       <section>
        <h4>Examples</h4>
        <ol>
         <li>Image quality manipulation. If you copy the image data to a canvas element you can then get a data URI or 
          blob where you can specify the desired encoding and quality e.g.
          <pre class="sh_javascript">
canvas.toDataURL('image/jpeg', 0.6);
// or
canvas.toBlob(function(blob) {}, 'image/jpeg', 0.2);</pre> 
         </li>
         <li>Image rotation. If you copy the image data to a canvas element and then obtain its 2D context you can then 
          call rotate() on that context object to rotate the displayed 'image'. You can then obtain the manipulated image 
          back via toDataURL or toBlob as above if you want to generate a file-like object that you can then pass around as 
          required.
         </li>
         <li>Image scaling. Thumbnails or web image formatting can be done by scaling down the captured image to a common 
          width/height and reduce the output quality.
         </li>
         <li>Speech-to-text. Post processing on a captured audio format can be done to perform client-side speech 
          recognition and conversion to text. Note, that speech recognition algorithms are generally done on the server for 
          time-sensitive or performance reasons.
         </li>
        </ol>
       </section>
       <p>This task force should evaluate whether some extremely common post-processing scenarios should be included as 
        pre-processing features.
       </p>
     </section>

     <section>
      <h3>Device Selection</h3>
      <p>A particular user agent may have zero or more devices that provide the capability of audio or video capture. In 
       consumer scenarios, this is typically a webcam with a microphone (which may or may not be combined), and a "line-in"
       and or microphone audio jack. The enthusiast users (e.g., audio recording enthusiasts), may have many more available 
       devices.
      </p>
      <p>Device selection in this section is not about the selection of audio vs. video capabilities, but about selection 
       of multiple devices within a given "audio" or "video" category (i.e., "kind"). The term "device" and "available 
       devices" used in this section refers to one or a collection of devices of a kind (e.g., that provide a common 
       capability, such as a set of devices that all provide "video").
      </p>
      <p>Providing a mechanism for code to reliably enumerate the set of available devices enables programmatic control 
       over device selection. Device selection is important in a number of scenarios. For example, the user selected the 
       wrong camera (initially) and wants to change the media stream over to another camera. In another example, the 
       developer wants to select the device with the highest resolution for capture.
      </p>
      <p>Depending on how stream initialization is managed in the consent user experience, device selection may or may not 
       be a part of the UX. If not, then it becomes even more important to be able to change device selection after media 
       stream initialization. The requirements of the user-consent experience will likely be out of scope for this task force.
      </p>
      <section>
       <h4>Privacy</h4>
       <ol>
        <li>As mentioned in the "Stream initialization" section, exposing the set of available devices before giving media stream 
         consent leads to privacy issues. Therefore, the device selection API should only be available after consent.
        </li>
        <li>Device selection should not be available for the set of devices within a given category/kind (e.g., "audio" 
         devices) for which user consent was not granted.
        </li>
       </ol>
      </section>
      <p>Device selection should be a mechanism for exposing device capabilities which inform the application of which device to 
       select. In order for the user to make an informed decision about which device to select (if at all), the developer's code would 
       need to make some sort of comparison between devices—such a comparison should be done based on device capabilities rather 
       than a guess, hint, or special identifier (see related issue below).
      </p>
      <p>Capture capabilities are an important decision-making point for media capture scenarios. However, capture capabilities 
       are not directly correlated with individual devices, and as such should not be mixed with the device capabilities. For 
       example, the capability of capturing audio in AAC vs. MP3 is not correlated with a given audio device, and therefore not a 
       decision making factor for device selection.
      </p>
      <section>
       <h4>Issues</h4>
       <ol>
        <li>The specification should provide guidance on what set of devices are to be made available—should it be the set of 
         potential devices, or the set of "currently available" devices (which I recommended since the non-available devices can't 
         be utilized by the developer's code, thus it doesn't make much sense to include them).
        </li>
        <li>A device selection API should expose device capability rather than by device identity. Device identity is a poor practice 
         because it leads to device-dependent testing code (for example, if "Name Brand Device", then…) similar to the problems that 
         exist today on the web as a result of user-agent detection. A better model is to enable selection based on capabilities. 
         Additionally, knowing the GUID or hardware name is not helpful to web developers as part of a scenario other than device 
         identification (perhaps for purposes of providing device-specific help/troubleshooting, for example).
        </li>
        <li>One strategy is to not return a set of devices, only the one that the user selected. Thus whether a device is "available" 
         (meaning known by the system, and able to be connected to at the current time) is something that could presented through the 
         browser UI and include other info (e.g. description of the device e.g. "front"/"back"/"internal"/"USB"/"Front Door"/...) as 
         known. Providing a list of cameras requires then that the app be capable of some decision making, and thus requires more info 
         which again is a privacy concern (resulting in a potential two-stage prompt: "Do you allow this app to know what cameras are 
         connected" then "Do you allow this app to connect to the 'front' camera?").
        </li>
       </ol>
      </section>
     </section>

    <section>
     <h3>Change user-selected device capabilities</h3>
     <p>In addition to selecting a device based on its capabilities, individual media capture devices may support multiple modes of 
      operation. For example, a webcam often supports a variety of resolutions which may be suitable for various scenarios (previewing 
      or capturing a sample whose destination is a web server over a slow network connection, capturing archival HD video for storing 
      locally). An audio device may have a gain control, allowing a developer to build a UI for an audio blender (varying the gain on 
      multiple audio source devices until the desired blend is achieved).
     </p>
     <p>A media capture API should support a mechanism to configure a particular device dynamically to suite the expected scenario. 
      Changes to the device should be reflected in the related media stream(s) themselves.
     </p>
     <p>If a device supports sharing (providing a virtual version of itself to an app), any changes to the device's manipulatable state 
      should by isolated to the application requesting the change. For example, if two applications are using a device, changes to the 
      device's configuration in one app should not affect the other one.
     </p>
     <p>Changes to a device capability should be made in the form of requests (async operations rather than synchronous commands). 
      Change requests allow a device time to make the necessary internal changes, which may take a relatively long time without 
      blocking other script. Additionally, script code can be written to change device characteristics without careful error-detection 
      (because devices without the ability to change the given characteristic would not need to throw an exception synchronously). 
      Finally, a request model makes sense even in RTC scenarios, if one party of the teleconference, wants to issue a request that 
      another party mute their device (for example). The device change request can be propagated over the <code>PeerConnection</code> 
      to the sender asynchronously.
     </p>
     <p>In parallel, changes to a device's configuration should provide a notification when the change is made. This allows web 
      developer code to monitor the status of a media stream's devices and report statistics and state information without polling the 
      device (especially when the monitoring code is separate from the author's device-control code). This is also essential when the 
      change requests are asynchronous; to allow the developer to know at which point the requested change has been made in the media 
      stream (in order to perform synchronization, or start/stop a capture, for example).
     </p>
     <section>
      <h4>Issues</h4>
      <ol>
       <li>If changing a particular device capability cannot be virtualized, this media capture task force should consider whether that 
        dynamic capability should be exposed to the web platform, and if so, what the usage policy around multiple access to that 
        capability should be.
       </li>
       <li>The specifics of what happens to a capture-in-progress when device behavior is changed must be described in the spec.
       </li>
      </ol>
     </section>
    </section>

    <section>
     <h3>Multiple active devices</h3>
     <p>In some scenarios, users may want to initiate capture from multiple devices at one time in multiple media streams. For example, 
      in a home-security monitoring scenario, a user agent may want to capture 10 unique video streams representing various locations being 
      monitored. The user may want to collect all 10 of these videos into one capture, or capture all 10 individually (or some 
      combination thereof).
     </p>
     <p>While such scenarios are possible and should be supported (even if they are a minority of the typical web-scenarios), it should be 
      noted that many devices (especially portable devices) supports the media capture by way of dedicated encoder hardware, and such hardware 
      may only be able to handle one stream at a time). Implementations should be able to provide a failure condition when multiple video sources
      are attempting to begin capture at the same time.
     </p>
    </section>

    <section>
     <h3>Capturing a media stream</h3>
     <p>In its most basic form, capturing a media stream is the process of converting the media stream into a known format during a 
      bracketed timeframe.
     </p>
     <p>Local media stream captures are common in a variety of sharing scenarios such as:
     </p>
     <ul>
      <li>capture a video and upload to a video sharing site</li>
      <li>capture a picture for my user profile picture in a given web app</li>
      <li>capture audio for a translation site</li>
      <li>capture a video chat/conference</li>
     </ul>
     <p>There are other offline scenarios that are equally compelling, such as usage in native-camera-style apps, or web-based capturing
      studios (where tracks are captured and later mixed).
     </p>
     <p>The core functionality that supports most capture scenarios is a simple start/stop capture pair.
     </p>
     <p>Ongoing captures should report progress either via the user agent, or directly through an API to enable developers to build UIs 
      that pass this progress notification along to users.
     </p>
     <p>A capture API should be designed to gracefully handle changes to the media stream, and should also report (and perhaps even 
      attempt to recover from) failures at the media stream source during capture.
     </p>
     <p>Uses of the captured information is covered in the Post-processing scenarios described previously. An additional usage is the 
      possibility of default save locations. For example, by default a UA may store temporary captures (those captures that are 
      in-progress) in a temp (hidden) folder. It may be desirable to be able to specify (or hint) at an alternate default capture
      location such as the users' common file location for videos or pictures.
     </p>
     <section>
      <h4>DVR Scenarios</h4>
      <p>Increasingly in the digital age, the ability to pause, rewind, and "go live" for streamed content is an expected scenario. 
       While this scenario applies mostly to real-time communication scenarios (and not to local capture scenarios), it is worth 
       mentioning for completeness.
      </p>
      <p>The ability to quickly "rewind" can be useful, especially in video conference scenarios, when you may want to quickly go 
       back and hear something you just missed. In these scenarios, you either started a capture from the beginning of the conference 
       and you want to seek back to a specific time, or you were only streaming it (not saving it) but you allowed yourself some amount 
       of buffer in order to review the last X minutes of video.
      </p>
      <p>To support these scenarios, buffers must be introduced (because the media stream is not implicitly buffered for this scenario). 
       In the capture scenario, as long as the UA can access previous parts of the capture (without terminating it) then this scenario 
       could be possible.
      </p>
      <p>In the streaming case, this scenario could be supported by adding a buffer directly into the media stream itself, or by capturing
       the media stream as previously mentioned. Given the complexities of integrating a buffer into the <code>MediaStream</code> proposal,
       using capture to accomplish this scenario is recommended.
      </p>
     </section>
     <section>
       <h4>Issues</h4>
       <ol>
        <li>There are few (if any) scenarios that require support for overlapping captures of a single media stream. Note, that the 
         <code>record</code> API (as described in early WebRTC drafts) implicitly supports overlapping capture by simply calling 
         <code>record()</code> twice. In the case of separate media streams (see previous section) overlapping recording makes sense. In 
         either case, initiating multiple captures should not be so easy so as to be accidental.
        </li>
       </ol>
      </section>
    </section>

    <section>
     <h3>Selection of a capture method</h3>
     <p>All post-processing scenarios for captured data require a known [standard] format. It is therefore crucial that the media capture 
      API provide a mechanism to specify the capture format. It is also important to be able to discover if a given format is supported.
     </p>
     <p>Most scenarios in which the captured data is sent to the server for upload also have restrictions on the type of data that the server 
      expects (one size doesn't fit all).
     </p>
     <p>It should not be possible to change captures on-the-fly without consequences (i.e., a stop and/or re-start or failure). It is 
      recommended that the mechanism for specifying a capture format not make it too easy to change the format (e.g., setting the format 
      as a property may not be the best design).
     </p>
     <section>
      <h4>Format detection</h4>
      <ul>
       <li>If we wish to re-use existing web platform concepts for format capability detection, the HTML5 <code>HTMLMediaElement</code> 
        supports an API called <code>canPlayType</code> which allows developer to probe the given UA for support of specific MIME types that 
        can be played by <code>audio</code> and <code>video</code> elements. A capture format checker could use this same approach.
       </li>
      </ul>
     </section>
    </section>

    <section>
     <h3>Programmatic activation of camera app</h3>
     <p>As mentioned in the introduction, declarative use of a capture device is out-of-scope. However, there are some potentially interesting 
      uses of a hybrid programmatic/declarative model, where the configuration of a particular media stream is done exclusively via the user 
      (as provided by some UA-specific settings UX), but the fine-grained control over the stream as well as the stream capture is 
      handled programmatically.
     </p>
     <p>In particular, if the developer doesn't want to guess the user's preferred settings, or if there are specific settings that may not be 
      available via the media capture API standard, they could be exposed in this manner.
     </p>
    </section>

    <section>
     <h3>Take a picture</h3>
     <p>A common usage scenario of local device capture is to simply "take a picture". The hardware and optics of many camera-devices often 
      support video in addition to photos, but can be set into a specific "camera mode" where the possible capture resolutions are 
      significantly larger than their maximum video resolution.
     </p>
     <p>The advantage to having a photo-mode is to be able to capture these very high-resolution images (versus the post-processing scenarios 
      that are possible with still-frames from a video source).
     </p>
     <p>Capturing a picture is strongly tied to the "video" capability because a video preview is often an important component to setting up 
      the scene and getting the right shot.
     </p>
     <p>Because photo capabilities are somewhat different from those of regular video capabilities, devices that support a specific "photo" 
      mode, should likely provide their "photo" capabilities separately from their "video" capabilities.
     </p>
     <p>Many of the considerations that apply to video capture also apply to taking a picture.
     </p>
     <section>
      <h4>Issues</h4>
      <ol>
       <li>What are the implications on the device mode switch on video captures that are in progress? Will there be a pause? Can this 
        problem be avoided?
       </li>
       <li>Should a "photo mode" be a type of user media that can be requested via <code>getUserMedia</code>?
       </li>
      </ol>
     </section>
    </section>

    <section>
     <h3>Picture tracks</h3>
     <p>Another common scenario for media streams is to share photos via a video stream. For example, a user may want to select a photo and 
      attach the photo to an active media stream in order to share that photo via the stream. In another example, the photo can be used as a 
      type of "video mute" where the photo can be sent in place of the active video stream when a video track is "disabled".
     </p>
     <section>
      <h4>Issues</h4>
      <ol>
       <li>It may be desireable to specify a photo/static image as a track type in order to allow it to be toggled on/off with a video track. 
        On the other hand, the sharing scenario could be fulfilled by simply providing an API to supply a photo for the video track "mute" 
        option (assuming that there's not a scenario that involves creating a parallel media stream that has both the photo track and the current 
        live video track active at once; such a use case could be satisfied by using two media streams instead).
       </li>
      </ol>
     </section>
    </section>

    <section>
     <h3>Caption Tracks</h3>
     <p>The HTML5 <code>HTMLMediaElement</code> now has the ability to display captures and other "text tracks". While not directly applicable to 
      local media stream scenarios (caption support is generally done out-of-band from the original capture), it could be something worth adding in 
      order to integrate with HTML5 videos when the source is a PeerConnection where real-time captioning is being performed and needs to be displayed.
     </p>
    </section>

   </section>

   <section>
    <h2>Acknowledgements</h2>
    <p>Special thanks to the following who have contributed to this document: 
     Harald Alvestrand,
     Robin Berjon, 
     Stefan Hakansson,
     Frederick Hirsch,
     Randell Jesup, 
     Bryan Sullivan, 
     Timothy B. Terriberry, 
     Tommy Widenflycht.
    </p>
   </section>
  </body>
</html>
