<!DOCTYPE html>
<html>
  <head>
    <meta  content="text/html; charset=utf-8"  http-equiv="content-type">
    <title>Overview of the CoverageJSON format</title>
    <script  class="remove"  src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
    <script  class="remove"  src="config.js"></script>
    <style  type="text/css">
 /* Force W3C logo to site side by side with OGC logo */
 .head img[src*="logos/W3C"] {
  display: inherit !important;
 }
 .head a:hover > img[src*='ogc'] {
  opacity: 0.8;
 }

 /* Styles to replicate key LODS styles */

 ul.hlist {
  list-style-type:none;
  background-color: #eee;
 }
 ul.hlist li {
  display:inline;
  margin-right: 1em;
  font-size:smaller;
 }
 .entity {
  border: 1px solid black;
  padding: 0.5em;
  margin-top: 0.5em;
 }
 .entity h4 {
  margin-top:0;
  }
 .entity dl {
  border: dashed thin black;
  border-width:1px 0;
  background-color:#eee;
  margin: 0 0.5em;
 }
 p.iri::before {
  content: "IRI: ";
  font-weight: bold;
  font-family:sans-serif;
 }
 p.iri {
  font-family:monospace;
 }
 span.logic {
  font-weight:bold;
  color:purple;
 }
 span.dotted {
  text-decoration-line:underline;
  text-decoration-style: dotted;
  text-decoration-color:black;
 }

table {
    border-collapse: collapse;
    caption-side: bottom;
}

table, th, td {
    border: 1px solid black;
    padding: 0.3em;
}


 </style>
  </head>
  <body>

    <section  id="abstract">
      <p>This Note describes CoverageJSON, a data format for describing "coverage" data in JavaScript Object Notation (JSON), and provides an overview of its design and capabilities. The primary intended purpose of the format is to enable data transfer between servers and web browsers, to support the development of interactive, data-driven web applications. "Coverage" data is a term that encompasses many kinds of data whose properties vary with space, time and other dimensions, including (but not limited to) satellite imagery, weather forecasts and river gauge measurements. We describe the motivation and objectives of the format, and provide a high-level overview of its structure and semantics. We compare CoverageJSON with other "coverage" formats and data models and provide links to tools and libraries that can help users to produce and consume data in this format. This Note does not attempt to describe the full CoverageJSON specification in detail: this is available at <a href="https://covjson.org/">the project website</a>.</p>
    </section>

    <section  id="sotd">
      <p>This is expected to be the final release of this document by the Spatial Data on the Web Working Group.</p>
      <p><strong>For OGC</strong> This is a Public Draft of a document prepared
        by the Spatial Data on the Web Working Group (<a  href="http://www.opengeospatial.org/projects/groups/sdwwg">SDWWG</a>)
        — a joint W3C-OGC project (see <a  href="https://www.w3.org/2015/spatial/charter">charter</a>).
        The document is prepared following W3C conventions. The document is
        released at this time to solicit public comment.</p>
    </section>

    <section  id="intro" >
      <h2>Introduction</h2>
      <section  id="coverage">
        <h3>What is a Coverage?</h3>
        <p>The term "coverage" is defined in [[ISO19123]] as a "feature that acts as a function to return values from its range for any direct position within its spatial, temporal or spatiotemporal domain". In other words, a coverage maps points in space and time to data values. For example, an aerial photograph can be modelled as a coverage that maps positions on the ground to colours. A river gauge maps points in time to flow values. A weather forecast maps points in space and time to values of temperature, wind speed, humidity and so forth. The image below illustrates three different kinds of coverage: a gridded temperature field from a numerical simulation, a set of point measurements and a vertical profile.</p>

        <img src="coverages.png" width="600px" alt="Illustration of different types of coverage" />

        <p class="note">Sometimes we see the word “coverage” used synonymously with “gridded data”, “raster data” or "imagery" but this isn’t really accurate. One can see from the above paragraph that non-gridded data (like a river gauge measurement) can also be modelled as coverages. Nevertheless, we often observe a bias toward gridded data in discussions (and software) that concern coverages.)</p>
      </section>

      <section id="existingmodels">
        <h3>Existing Coverage representations</h3>
        <p>The [[ISO19123]] specification defines an <em>abstract</em> data model for representing the data and metadata needed to encode coverage data. This abstract model can be instantiated in many different concrete formats. The OGC Coverage Implementation Schema (CIS) specification ([[OGC-CIS]]) describes a <em>concrete</em>, directly instantiable data model and XML serialisation based on the Geography Markup Language (GML). Other serialisations have been defined, sometimes by retrospectively mapping existing binary data formats to the ISO19123 abstract data model (e.g. [[NetCDF]]). Version 1.1 of the CIS specification supports a JSON serialization, which is created through a direct translation from GML types to JSON objects. (We provide a brief comparison of CIS-JSON with CoverageJSON <a href="#cis">below</a>.)</p>
      </section>

      <section id="motivation">
        <h3>Motivation and objectives</h3>
        <p>This document describes the CoverageJSON format and explains how it is well-suited to representation of spatial data on the Web: with a number of advantages for use in a web context, in comparison to alternative established approaches for serialisation of coverage data. It is a good match to the Use Case Requirements  [[SDW-UCR]] and Best Practices [[SDW-BP]] of the Spatial Data on the Web working group. It has been informed also by the Data on the Web Best Practices [[DWBP]]."</p>
<p>Serialisations (i.e. data formats) based upon community-specific binary formats and complex XML schemas provide usability challenges for the development of web applications. Javascript libraries do not always exist for these formats, and the formats are complex, requiring specialist knowledge on the part of the web developer. Our overall aim is to <strong>make it easier for web developers to consume coverage data in their applications</strong>, minimising the need for prior knowledge about community-specific data formats.</p>
        <p>Therefore our objective in this work was to develop a well-structured, consistent and easy-to-use JSON format for coverage data that fulfils the following criteria:</p>
        <ul>
          <li>Able to encode many different kinds of coverage, including multidimensional grids, timeseries, vertical profiles, polygon-based coverages, point clouds and more.</li>
          <li>Able to encode both continuous-valued data (e.g. temperature) and categorical data (e.g. land cover classification).</li>
          <li>Able to encode geospatial data using a variety of coordinate reference systems.</li>
          <li>Able to encode both scalar data (e.g. temperature) and vector data (e.g. velocities).</li>
          <li>Able to encode data with quality information, e.g. numerical uncertainties and quality flags.</li>
          <li>Clear and readable, focusing on common practices in the JSON community.</li>
          <li>Use a minimal set of encoding rules, to avoid complicating the development of client code.</li>
        </ul>
      </section>
    </section>

    <section  id="overview">
      <h2>Overview of CoverageJSON</h2>
      <p>The full specification for CoverageJSON is published on <a href="https://covjson.org/spec/">GitHub</a>,
         which also records all discussions that led to the design decisions in the format.
         The specification is split up into two documents:
         the core part, and a set of optional <a href="https://covjson.org/domain-types/">domain types</a> that ease interoperability.</p>

      <section id="structure">
      <h3 id="highLevelStructure">High-level structure</h3>
      <p>In CoverageJSON, a Coverage consists of the following objects:</p>
      <ul>
        <li>A <dfn>Domain</dfn> (exactly one), which encodes the set of points in space and time for which we have data values.</li>
        <li>A set of <dfn>Range</dfn> objects (one per scalar quantity), holding actual data values.</li>
        <li>A set of <dfn>Parameter</dfn> objects (one per scalar quantity), describing the data values.</li>
        <li>An optional set of <dfn>ParameterGroup</dfn> objects, which describe any semantic associations between Parameters.</li>
      </ul>
      <p>A sample skeleton document encoding a three-dimensional gridded Coverage with two Parameters (sea surface temperature and sea ice area fraction) is shown here:</p>
      <pre>
{
  "type" : "Coverage",
  "domain" : {
    "type": "Domain",
    "domainType" : "Grid",
    "axes" : {
      "x" : { /* Coordinate values */ },
      "y" : {                         },
      "t" : {                         }
    },
    "referencing" : [
      /* Coordinate referencing information */
    ]
  },
  "parameters" : {
    "SST"     : { /* Description of temperature values */ },
    "sea_ice" : { ... }
  },
  "ranges" : {
    "SST"     : { /* Encoding of temperature values, or link(s) */ },
    "sea_ice" : { ... }
  }
}
      </pre>
    </section>

    <section id="domain">
      <h3>Encoding the Domain</h3>
      <p>A <a href="https://covjson.org/spec/#domain-objects">Domain</a> is a collection of named orthogonal <dfn>axes</dfn> containing coordinate values, coupled with information about how to reference these values to one or more real-world coordinate reference systems. An axis can contain simple numeric values like latitudes or longitudes but can also contain composite values like tuples or polygons.</p>
      <p>The following is a complete example of a simple grid domain with longitude, latitude, and time axes, using the WGS84 longitude-latitude coordinate reference system and the Gregorian calendar:</p>
      <pre>
{
  "type" : "Domain",
  "domainType" : "Grid",
  "axes": {
    "x" : { "start": -179.5, "stop": 179.5, "num": 360 },
    "y" : { "start": 89.5, "stop": -89.5, "num": 180 },
    "t" : { "values": ["2001", "2002", "2003"] }
  },
  "referencing": [{
    "coordinates": ["x","y"],
    "system": {
      "type": "GeographicCRS",
      "id": "http://www.opengis.net/def/crs/OGC/1.3/CRS84"
    }
  }, {
    "coordinates": ["t"],
    "system": {
      "type": "TemporalRS",
      "calendar": "Gregorian"
    }
  }]
}
      </pre>
      <p>Note that different CRSs can be associated with different combinations of axes, providing a very flexible model that allows complex data to be encoded without the need to create composite CRSs. Axis values can also be categorical in nature (instead of numeric), enabling data values to be associated with entities that are not spatiotemporal coordinates.</p>

      <p class="note">This closely mirrors the structure of the RDF Data Cube Vocabulary [[VOCAB-DATA-CUBE]], in which orthogonal <dfn>dimensions</dfn> are combined to form the domain of the data cube. (A "dimension" in the data cube corresponds with an "axis" in CoverageJSON.) Therefore, although a formal mapping process has yet to be performed, we expect that interoperability between the RDF Data Cube and CoverageJSON is achievable. Some RDF Data Cube dimensions may be categorical or enumerated types rather than potentially continuous dimensions. The RDF Data Cube specification does not explicitly support spatiotemporal dimensions, but this is addressed in the [[QB4ST]] extensions. </p>

      <p>This mechanism allows for a huge variety of domain structures to be encoded, from multidimensional grids to one-dimensional trajectories through four-dimensional space. To ease the burden on clients, CoverageJSON allows an optional <dfn>domain type</dfn> property to be defined (see the example above). If the data provider specifies that the domain is of a known type, the client then knows in more detail what to expect when the domain is inspected. For example, if the domain type is "Grid", the client knows that the domain MUST have axes that are called <code>"x"</code> and <code>"y"</code> (corresponding to the two horizontal spatial dimensions) and MAY have axes called <code>"z"</code> and <code>"t"</code> (corresponding respectively to the vertical and temporal dimensions). A number of <a href="https://covjson.org/domain-types/">common domain types</a> are specified and there is a <a href="https://covjson.org/spec/#custom-types">mechanism for data providers to define and register their own types</a>. Note that in a typical document, short names (<code>"Grid"</code>, <code>"PointSeries"</code>, <code>"Trajectory"</code>, etc.) are used to indicate the domain type, but in fact these are full URIs in disguise - this becomes apparent when viewing CoverageJSON document as RDF using the JSON-LD context (see <a href="#rdf">below</a>).</p>
    </section>

    <section id="datavalues">
      <h3>Encoding of data values</h3>
      <p>Data in CoverageJSON is held in Range objects, which represent multi-dimensional arrays.
         There are two subtypes of Range objects:</p>
      <ul>
        <li>An <dfn>NdArray</dfn> object encodes the array in its entirety, in line. In fact, the data values are encoded in a
          <em>one-dimensional</em> array, with a <code>shape</code> property that defines how to "unwrap" the one-dimensional array into
          a multi-dimensional one.</li>
        <li>A <dfn>TiledNdArray</dfn> object splits up a multi-dimensional array into several parts and links to
         those parts via URI templates ([[RFC6570]]) where each part is an NdArray object.
         A single TiledNdArray may define several ways of splitting up the array (each way is a <em>tileset</em>), to cater for different access scenarios.</li>
      </ul>
      <p class="note">Readers may wonder why multi-dimensional arrays are not encoded as nested arrays in CoverageJSON. Nested arrays
        (i.e. "arrays of arrays") are harder to manipulate and reason over, since there is no guarantee that the inner arrays are of a consistent length.
        With a one-dimensional array it is easy to verify that <code>array.length</code> matches the required number of elements, defined by the shape of
        the domain and the numbers in the <code>shape</code> property.
        In addition, Javascript engines can treat one-dimensional arrays more efficiently than nested arrays. APIs can be provided to extract slices in any
        dimension as if the array were truly multi-dimensional. This mirrors the approach taken by libraries such as <a href="http://www.numpy.org">numpy</a>.</p>
      <p>Here is an example of an NdArray:</p><pre>
{
  "type" : "NdArray",
  "dataType": "float",
  "axisNames": ["t", "y", "x"],
  "shape": [1, 90, 90],
  "values": [
    12.2, 12.0, 13.3, ...
    /* 8100 numbers (1*90*90) in row-major order */
  ]
}</pre>

      <h4>Support for large datasets</h4>
      <p>For reasons of efficiency and convenience, data providers may prefer not to specify the range objects for all parameters inline in the same CoverageJSON document. In this case, there are two options:</p>
      <ol>
        <li>For some or all parameters, create a separate JSON document containing an NdArray, which holds the values of that parameter. Then insert a link to this document in the Coverage document in place of the inline NdArray.</li>
        <li>Additionally, the individual arrays may be split up into tiles, in which the values of each parameter are encoded in multiple JSON documents, each containing an NdArray.</li>
      </ol>
      <p>The following illustrates how a coverage may be split up into a particular tileset:</p>
      <img src="covjson-tiling.png" width="500" alt="Illustration of a tiled NdArray. The data array is split into a number of tiles, each of which will be represented by a separate CoverageJSON file" />
      <pre>
{
  "type" : "TiledNdArray",
  "dataType": "float",
  "axisNames": ["t", "y", "x"],
  "shape": [3, 180, 360],
  "tileSets": [{
    "tileShape": [1, 90, 90],
    "urlTemplate": "http://example.com/{t}/{y}/{x}.covjson"
  }]
}
      </pre>

      <p>This is a 3 dimensional data set with dimensions (x, y, t) divided into two dimensional tiles for each t value: 4 along the X axis, 2 along the y axis and 3 along the t axis. Each tile is an NdArray, encoded as above.</p>

    </section>

    <section id="parameters">
      <h3>Encoding of Parameter metadata</h3>
      <p>Data values are described in CoverageJSON using Parameter objects. These contain a minimal set of metadata needed to do something useful with the data values: a definition of the quantity being recorded (e.g. relative humidity, potential temperature, reflectance) and the units of measure in which the data values are expressed.</p>
      <p>The sample JSON document below shows a Parameter object describing the sea surface temperature variable from the above <a href="#highLevelStructure">skeleton JSON</a>.</p>
      <pre>
"SST" : {
  "type" : "Parameter",
  "observedProperty" : {
    "id" : "http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/",
    "label" : {
      "en" : "Sea Surface Temperature",
      "de" : "Meeresoberflächentemperatur"
    },
    "description" : {
      "en" : "The temperature of sea water near the surface",
      "de" : "Die Temperatur des Meerwassers nahe der Oberfläche"
    }
  },
  "unit" : {
    "label" : {
      "en" : "Degree Celsius",
      "de" : "Grad Celsius"
    },
    "symbol": {
      "value" : "Cel",
      "type" : "http://www.opengis.net/def/uom/UCUM/"
    }
  }
}
</pre>
      <p>Note that the main features of the Parameter metadata in this example are:</p>
      <ul>
        <li>a URI link to the definition of the parameter in question,</li>
        <li>a strongly-typed unit string, using UCUM encoding rules,</li>
        <li>internationalisation of human-readable strings (labels).</li>
      </ul>
<p>Other metadata, such as provenance information, is not part of the core CoverageJSON specification, but can be recorded via the <a href="#extensions">extension mechanism</a>.</p>

    </section>

    <section id="documents">
      <h3>CoverageJSON documents</h3>
      <p>A single CoverageJSON document can contain one of the following types of object:</p>
      <ul>
        <li>A single Coverage</li>
        <li>A collection of Coverages</li>
        <li>A standalone Domain</li>
        <li>An NdArray</li>
        <li>A TiledNdArray</li>
      </ul>
      <p>The top-level object within a document contains a “type” property that identifies the type of the object that it contains. Documents may be linked to other documents; in this way data providers can ensure that each individual document is of a manageable size, with large datasets being partitioned among a number of linked documents. (See "Support for large datasets" above.)</p>
    </section>

    <section id="rdf">
      <h3>CoverageJSON, JSON-LD and RDF</h3>
      <p>To a limited extent, a CoverageJSON document can be converted into RDF through the use of a JSON-LD context header. The extent to which this is possible is discussed in [[COV-JSONLD-RDF]].</p>
      <p>We did not consider that conversion to RDF should be a primary goal: we focused mainly on simplicity and readability of the format, under the assumption that few of the target users (web developers) would require a pure RDF representation of the data. Enabling a full conversion to RDF would require complicating the format (mainly for technical reasons including limitations of JSON-LD). Also, RDF is an unsuitable format for large arrays of data and so the Domain and Range would not convert efficiently.</p>
      <p>Nevertheless, CoverageJSON makes frequent use of URIs to denote key concepts, such as units, observed properties, coordinate reference systems, domain types and links to other CoverageJSON documents. Clients can make use of these to detect these concepts unambiguously, whether or not they perform a translation to RDF.</p>

      <p>By using the <a href="https://covjson.org/context.jsonld">canonical CoverageJSON JSON-LD context</a>,
         it is possible to convert the <a href="#parameters">above Parameter</a> directly into RDF triples:</p>
<pre>
_:SST &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;https://covjson.org/def/core#Parameter&gt; .
_:SST &lt;http://qudt.org/schema/qudt#unit&gt; _:SST_UNIT .
_:SST_UNIT &lt;http://qudt.org/schema/qudt#symbol&gt; &quot;Cel&quot;^^&lt;http://www.opengis.net/def/uom/UCUM/&gt; .
_:SST_UNIT &lt;http://www.w3.org/2004/02/skos/core#prefLabel&gt; &quot;Degree Celsius&quot;@en .
_:SST_UNIT &lt;http://www.w3.org/2004/02/skos/core#prefLabel&gt; &quot;Grad Celsius&quot;@de .
_:SST &lt;http://www.w3.org/2005/Incubator/ssn/ssnx/ssn#observedProperty&gt; &lt;http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/&gt; .
&lt;http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/&gt; &lt;http://purl.org/dc/terms/description&gt; &quot;Die Temperatur des Meerwassers nahe der Oberfl&auml;che&quot;@de .
&lt;http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/&gt; &lt;http://purl.org/dc/terms/description&gt; &quot;The temperature of sea water near the surface&quot;@en .
&lt;http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/&gt; &lt;http://www.w3.org/2004/02/skos/core#prefLabel&gt; &quot;Meeresoberfl&auml;chentemperatur&quot;@de .
&lt;http://vocab.nerc.ac.uk/standard_name/sea_surface_temperature/&gt; &lt;http://www.w3.org/2004/02/skos/core#prefLabel&gt; &quot;Sea Surface Temperature&quot;@en .
</pre>
<p class="note">An interesting area of future work would be to define two-way mappings between CoverageJSON and an RDF Data Cube representation (using the QB4ST extensions to the latter). As noted above, there are a number of similarities between the two representations, and defining such mappings should be possible.</p>
  </section>

  <section id="extensions">
      <h3>Extension points</h3>
      <p>CoverageJSON allows data providers to extend the format in a controlled manner to enable capabilities that are not supported by the core specification. The possible extensions that can be defined by users include:</p>
      <ul>
        <li><a href="https://covjson.org/spec/#custom-members">Custom properties</a> (e.g. high-level metadata such as licence information)</li>
        <li><a href="https://covjson.org/spec/#custom-types">Custom domain types</a> (enabling support for coverage types that are not foreseen in the existing domain types, e.g. rain radar measurements)</li>
        <li><a href="https://covjson.org/spec/#custom-types">Custom data types</a> for axes</li>
        <li><a href="https://covjson.org/spec/#custom-types">Custom referencing system types</a> (e.g. <a href="http://healpix.jpl.nasa.gov">HEALPix</a> grids)</li>
        <li><a href="https://covjson.org/spec/#custom-types">Different grammars for encoding unit symbols</a> (e.g. <a href="http://www.unidata.ucar.edu/software/udunits/">UDUNITS</a>)</li>
        <li><a href="https://covjson.org/spec/#coverage-objects">Alternative encodings for range values</a> (e.g. compressed encodings)</li>
      </ul>
      <p>In each case we recommend that URIs be used to denote these extensions (and to point to definitions), to avoid the possibility of clashes between extensions.</p>
    </section>

  </section>

  <section id="examples">
    <h2>Examples</h2>
    <p>Complete examples of CoverageJSON documents can be found via the <a href="https://covjson.org/playground/">Playground</a>. The same documents can be <a href="https://github.com/covjson/playground/tree/master/public/coverages">accessed directly on GitHub</a>. These examples include Coverages, Coverage Collections and tiled Coverages.</p>
  </section>

    <section  id="tools">
      <h2>Tools and libraries</h2>
      <p>We have developed a number of tools and libraries to help users produce, use and debug CoverageJSON documents. These are all published on the <a href="https://covjson.org/tools/">project website</a> and include:
      <ul>
        <li>A JavaScript API for reading CoverageJSON documents, intended for use by developers of web applications.</li>
        <li>A Plugin for the <a href="http://leafletjs.com">Leaflet</a> web mapping library.</li>
        <li>A “Playground” web application, in which users can paste and edit CoverageJSON documents, and view a live visualization.</li>
        <li>Online “Cookbook” documentation, with live examples linked to this playground. (We recommend that new users start here.)</li>
        <li>A Python library for converting to and from common scientific data formats (e.g. NetCDF)</li>
        <li>A Java library for converting data in a number of file formats (including NetCDF and GRIB) to CoverageJSON, implemented as an <a href="https://github.com/Reading-eScience-Centre/edal-java">EDAL</a> module.</li>
      </ul>
    </section>

    <section  id="otherDataModels">
      <h2>Relationship with other data models</h2>
      <p>In this section we compare the data model of CoverageJSON with that of other formats that are used to carry coverage data.</p>

      <section id="netcdf">
      <h3>NetCDF and CF-NetCDF</h3>
      <p class="note">[[NetCDF]] is a binary, platform-independent, domain-neutral data format for multidimensional data. Essentially, a NetCDF file is a collection of multidimensional arrays, plus metadata provided as key-value pairs. Metadata conventions are required to specialise NetCDF for particular communities. The <a href="http://cfconventions.org">Climate and Forecast</a> conventions are the pre-eminent conventions for geospatial NetCDF data. NetCDF files that conform to these conventions are known as "CF-NetCDF files". Note that there are different varieties of the NetCDF format and data model. Here we are concerned with the <a href="http://www.unidata.ucar.edu/software/netcdf/docs/netcdf_data_model.html#classic_model">"classic"</a> NetCDF data model. The <a href="http://www.unidata.ucar.edu/software/netcdf/docs/netcdf_data_model.html#enhanced_model">"enhanced"</a> data model is not supported by the CF conventions and is much less widely used in practice.</p>
      <p>The overall structure of CoverageJSON is quite close to that of [[NetCDF]], consisting essentially of a set of orthogonal domain axes that can be combined in different ways. One major difference is that in CoverageJSON, there is an explicit Domain object, whereas in NetCDF the domain is specified implicitly by linking data variables with coordinate variables. One consequence of this is that NetCDF files can contain several domains and hence several Coverages. A NetCDF file could therefore be converted to a single Coverage or a Coverage Collection in CoverageJSON.</p>
    </section>

      <section id="cis">
      <h3>OGC Coverage Implementation Schema (CIS)</h3>
      <p>The overall concepts of CoverageJSON are close to those of the [[ISO19123]] standard and the OGC standard Coverage Implementation Schema ([[OGC-CIS]]), which specialises ISO19123. The main points of difference are:</p>
      <ul>
        <li>CIS uses a different set of rules for gridded and non-gridded data, whereas CoverageJSON uses a single consistent set.</li>
        <li>CIS allows each Coverage to have exactly one CRS, whereas CoverageJSON allows different CRSs to be applied to different sets of coordinates in the domain (e.g. one CRS for x and y, and another CRS for z).</li>
        <li>Version 1.1 of CIS defines a JSON encoding that uses a near-literal translation of GML structures into JSON. CoverageJSON does not use GML as its starting point.</li>
      </ul>
    </section>

    <section>
      <h3>OGC TimeseriesML</h3>
      <p>CoverageJSON can be used to record data that take the form of timeseries, for example measurements of flow rate in in a river, or average London rainfall over time. [[TimeseriesML]] specializes in recording such data and provides some features that are not provided in CoverageJSON. In TimeseriesML, richer metadata can be added to describe in more detail the data values being measured (the range) and their relationship to time (the domain). For example, a data value in the range may be defined to represent an accumulation, maximum, minimum, average or several other functions of a quantity over time, and the time values in the domain may be defined to mark the start, end or middle of the time period in question. In CoverageJSON, this level of description is not yet possible.</p>
      <p>Version 1.0 of TimeseriesML (the current version at the time of writing) does not permit the association of multiple parameters with each data point, whereas this is permitted in CoverageJSON.</p>
    </section>
    </section>

    <section  id="mappingToUCR">
      <h2>Relationship to Use Cases and Requirements</h2>
      <p>The Spatial Data on the Web Working Group has created a set of <a href="https://www.w3.org/TR/sdw-ucr/">Use Cases and Requirements</a> for spatial data on the Web. A subset of these requirements are relevant to Coverage data. This section describes how CoverageJSON addresses relevant requirements.</p>
      <table id="table_covjson_ucr_xref">
	     <caption>How CoverageJSON relates to the Spatial Data on the Web Use Cases and Requirements Document</caption>
	     <tr>
	     	<th>Requirement</th><th>CoverageJSON approach</th>
	     </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#4DModelSpaceTime">4D model of space-time</td><td>Domains in CoverageJSON can have any number of dimensions. Many of the defined <a href="https://covjson.org/domain-types/">domain types</a> support 4D domains, including <a href="https://covjson.org/domain-types/#grid">grids</a> and <a href="https://covjson.org/domain-types/#trajectory">trajectories</a>.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Compatibility">Compatibility with existing practices</td><td>CoverageJSON incorporates the same overall concepts (domain, range, and metadata) as other coverage data models (see [[OGC-CIS]]). It <a href="https://covjson.org/spec/#differences-to-ogc-coverage-implementation-schema-cis">differs in some respects</a> from this standard.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Compressible">Compressibility</a></td><td>CoverageJSON consists of JSON objects, which can be compressed using standard approaches, for example by enabling gzip and the corresponding Content-Encoding in a web server.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#CoverageTemporalExtent">Coverage temporal extent</a></td><td>CoverageJSON has a means to add <a href="https://covjson.org/spec/#temporal-reference-systems">temporal references</a>.  This is defined to make the common case easy, (using the Gregorian calendar) but also allows alternative temporal reference systems.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Crawlability">Crawlability</a></td><td>Like any other 'file' on the web, CoverageJSON objects can have a URL and so can be found by crawlers.  To what extent an agent is able to interpret the contents of a CoverageJSON file is another question.  Also important for crawling and hence discovery might be metadata associated with CoverageJSON data. </td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#CRSDefinition">CRS definition</a></td><td>CoverageJSON defines an <a href="https://covjson.org/spec/#reference-system-objects">approach for specifying the CRS as a URI</a>.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#DeterminableCRS">Determinable CRS</a></td><td>CoverageJSON enables domains to be referenced to one or more CRSs, either through <a href="https://covjson.org/spec/#reference-system-objects">URI links or inline definitions</a>.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#DifferentTimeModels">Different time models</a></td><td>CoverageJSON supports a range of <a href="https://covjson.org/spec/#temporal-reference-systems">temporal reference systems</a>, defaulting to the Gregorian calendar.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Discoverability">Discoverability</a></td><td>CoverageJSON does not define how to include discovery metadata at the level of a CoverageJSON document. It is usually assumed that this metadata is contained elsewhere, e.g. in a catalogue. However, CoverageJSON does provide an <a href="https://covjson.org/spec/#custom-members">extension mechanism</a> for adding custom metadata to a document. This could be used to add discovery metadata, for example from the DCAT vocabulary [[DCAT]]. See <a href="https://github.com/covjson/specification/issues/71">this discussion</a>.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Georectification">Georectification</a></td><td>Coverage JSON has a flexible and extensible <a href="https://covjson.org/spec/#reference-system-objects">approach to specifying reference systems</a>, in which data can be referenced to any grid.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#GeoreferencedData">Georeferenced spatial data</a></td><td>See the Georectification requirement above.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Linkability">Linkability</a></td><td>CoverageJSON documents can contain links to external entities, including parameter definitions, CRS definitions or other CoverageJSON documents (see "Support for large datasets" above). CoverageJSON documents are intended to be published on the Web and can therefore be linked to.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#MachineToMachine">Machine to machine</a></td><td>CoverageJSON is designed for machine processing, although is also somewhat human-readable.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#MultilingualSupport">Multilingual support</a></td><td>CoverageJSON supports <a href="https://covjson.org/spec/#i18n-objects">multi-language labels</a></td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#ObservedPropertyInCoverage">Observed property in coverage</a></td><td>The observed property is defined in CoverageJSON as <a href="https://covjson.org/spec/#parameter-objects">Parameter objects</a>.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#Provenance">Provenance</a></td><td>CoverageJSON is intended primarily to describe the result of a procedure and does not provide a specific mechanism to describe the provenance or the procedure itself. The <a href="https://covjson.org/spec/#custom-members">extension mechanism</a> could be used to include relevant properties.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#QualityPerSample">Quality per sample</a></td><td>Quality information can be incorporated as additional parameters of a coverage. For example, quality flags can be encoded as categorical parameters, and numerical errors can be described as continuous parameters. <a href="https://covjson.org/spec/#parametergroup-objects">Parameter Group objects</a> provide a mechanism to associate parameters with each other to provide internal links between data values and their associated quality information.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#ReferenceDataChunks">Reference data chunks</a></td><td>There are two main approaches in CoverageJSON to dividing a large coverage into chunks.
			<ul>
         <li><a href="https://covjson.org/spec/#tiledndarray-objects">Tiled n-dimensional array</a></li>
			   <li><a href="https://github.com/covjson/specification/issues/66">Fragment identifiers</a> (still in discussion)</li>
			</ul>
      In each case, each chunk is given its own identifier. (Also, large collections of coverages, such as large collections of in situ observations, can be divided into <a href="https://covjson.org/spec/#coverage-collection-objects">Coverage collections</a>.)</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#SensingProcedure">Sensing procedure</a></td><td>As with "Provenance" above, CoverageJSON focuses on the results of the procedure, not the procedure itself. The text description of a <a href="https://covjson.org/spec/#parameter-objects">parameter</a> could potentially contain a description of the sensing method, or the <a href="https://covjson.org/spec/#custom-members">extension mechanism</a> could be used.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#SpatialVagueness">Spatial vagueness</a></td><td>It is possible to record spatially-vague data (i.e. data that is not associated with precise spatial coordinate values) in CoverageJSON. For example, a domain axis could be defined that records locations as identifiers, rather than numeric coordinates (e.g. "<code>['London', 'New York', 'Paris']</code>").</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#SSNLikeRepresentation">SSN-like representation</a></td><td>CoverageJSON does not attempt to provide a method to describe sensors (or any other provenance information, see above). However, CoverageJSON reuses the "observedProperty" property from SSN (<a href="https://www.w3.org/2005/Incubator/ssn/ssnx/ssn#observedProperty">https://www.w3.org/2005/Incubator/ssn/ssnx/ssn#observedProperty</a>). Usage of this can be seen in "CoverageJSON, JSON-LD and RDF" above. The <a href="https://covjson.org/spec/#custom-members">extension mechanism</a> could be used to provide more information if required.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#3DSupport">Support for 3D</a></td><td>CoverageJSON fully supports 3D data: see "4D model of space-time" above.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#TilingSupport">Support for tiling</a></td><td>CoverageJSON supports <a href="https://covjson.org/spec/#tiledndarray-objects">tiling</a>. (This mechanism is probably more suited to raster than vector data.)</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-ucr/#UseInComputationalModels">Use in Computational Models</a></td><td>CoverageJSON is a machine-readable format that can be both read by, and written by, computational models. However, it is primarily intended as a format for data exchange over wide-area networks, not an archive format. Therefore it is probably unlikely that the designer of a computational model would choose to read or write data in CoverageJSON directly. Tools to convert to and from NetCDF (a more common archive format) are <a href="https://github.com/Reading-eScience-Centre/pycovjson">under development</a>.</td>
		  </tr>
	  </table>
    </section>
    <section id="best-practices">
	  <h2>Relationship to Best Practices</h2>
	  <p>The Spatial Data on the Web Working Group has created a set of Best Practices for spatial data on the Web [[SDW-BP]]. A subset of these Best Practices are relevant to Coverage data. This section lists the Best Practices and describes how or whether CoverageJSON relates to each.</p>
	  <table id="table_covjson_ucr_xref">
	     <caption>How CoverageJSON relates to the Spatial Data on the Web Best Practices</caption>
	     <tr>
	     	<th>Best Practice</th><th>CoverageJSON approach</th>
	     </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#globally-unique-ids">Best Practice 1:</a> Use globally unique persistent HTTP URIs for Spatial Things</td><td>A coverage may itself be considered as a Spatial Thing, and its corresponding CoverageJSON document can be identified by an HTTP URI. This URI may be used in a CoverageCollection, or indeed any other document, such as a [[DCAT]] catalog./td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#indexable-by-search-engines">Best Practice 2:</a> Make your spatial data indexable by search engines</td><td>This is largely outside the scope of CoverageJSON, and is more likely to be relevant when publishing data catalogs, rather than individual Coverages.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#linking">Best Practice 3:</a> Link resources together to create the Web of data</td><td>Coverages, and parts of coverages, are assigned URIs and can be linked to. URIs are used in the definition of coordinate reference systems and to point to definitions of observed properties and units.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#semantic-thing">Best Practice 4:</a> Use spatial data encodings that match your target audience</td><td>CoverageJSON has a particular target audience in mind: web developers who like working with JSON representations of data, a group that is often unfamiliar with the more established OGC approaches to coverage data. Therefore CoverageJSON is a good solution when that group is the target audience.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#describe-geometry">Best Practice 5:</a> Provide geometries on the Web in a usable way</td><td>CoverageJSON reuses [[GeoJSON]]'s syntax for encoding geometries, which is widely used and understood.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#multiplegeometries">Best Practice 6:</a> Provide geometries at the right level of accuracy, precision, and size</td><td>CoverageJSON does not provide a means to specify the accuracy or precision of coordinate values. However, when publishing geometries the publisher can decide how many points are needed to adequately describe the geometry.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#bp-crs-choice">Best Practice 7:</a> Choose coordinate reference systems to suit your user's applications</td><td>The coordinate reference system used is specified in the domain of the coverage: so the most important CRS can be used to suit the application.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#bp-crs">Best Practice 8:</a> State how coordinate values are encoded</td><td>CoverageJSON has a clear specification of how coordinate values are encoded.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#relative-position">Best Practice 9:</a> Describe relative positioning</td><td>CoverageJSON enables CRSs to be specified in a range of ways, many of which (e.g. identifier-based systems) could support relative positioning.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#entity-level-links">Best Practice 10:</a> Use appropriate relation types to link Spatial Things</td><td>This Best Practice is outside of the scope of CoverageJSON.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#desc-changing-properties">Best Practice 11:</a> Provide information on the changing nature of spatial things</td><td>Most aspects of this Best Practice are outside of the scope of CoverageJSON, except in the sense that coverages are well suited to describing spatially referenced properties that change over time.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#convenience-apis">Best Practice 12:</a> Expose spatial data through 'convenience APIs'</td><td>CoverageJSON is designed to make coverage data available in a form suitable for processing by Javascript in web pages (as well as other possible applications). It can return entire coverage files, or smaller parts (tiles) of coverages as required. The choice of API is, however, outside the scope of CoverageJSON.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#spatial-info-dataset-metadata">Best Practice 13:</a> Include spatial metadata in dataset metadata</td><td>The domain of a CoverageJSON object contains machine readable specifications of the area (and time) covered by the dataset, as well as the coordinate reference system used.  CoverageJSON provides an extensibility mechanism allowing arbitrary additional metadata items to be added.</td>
		  </tr>
		  <tr>
		  	 <td><a href="https://www.w3.org/TR/sdw-bp/#desc-accuracy">Best Practice 14:</a> Describe the positional accuracy of spatial data</td><td>The positional accuracy and precision of coverage data depends in a complex way on the method by which the data was collected.  CoverageJSON itself does not incorporate detailed provenance metadata, though provides the possibility to link to external documentation or specifications of data collection methods and associated accuracy considerations.</td>
		  </tr>
		</table>
	</section>
   </body>
</html>
