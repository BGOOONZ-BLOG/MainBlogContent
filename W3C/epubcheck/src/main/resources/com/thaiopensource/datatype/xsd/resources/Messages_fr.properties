# First block doesn't need to be translated for epubcheck, as @murata0204 noted in
# https://github.com/IDPF/epubcheck/pull/472#issuecomment-58265808
#
# Non-unicode chars (german umlauts, etc..) must be escaped like \u00DF
# because otherwise Jing can't parse them. Bad UTF8-support

# Properties file specifying messages
enumeration_param=la facette \"enumeration\" n\u2019est pas autoris\u00E9e en tant que param\u00E8tre : utiliser l\u2019\u00E9l\u00E9ment \"value\".
whiteSpace_param=la facette \"whiteSpace\" n\u2019est pas autoris\u00E9e en tant que param\u00E8tre
unrecognized_param=param\u00E8tre \"{0}\" non reconnu
invalid_regex=expression r\u00E9guli\u00E8re invalide\u00A0: {0}
not_ordered=le param\u00E8tre peut seulement \u00EAtre appliqu\u00E9 \u00E0 un type de donn\u00E9e ordonn\u00E9
invalid_limit=\"{0}\" n\u2019est pas autoris\u00E9 par le type de base\u00A0: {1}
no_length=le type de base ne d\u00E9finit pas une unit\u00E9 de longueur
scale_not_derived_from_decimal=le param\u00E8tre \"scale\" ne peut \u00EAtre appliqu\u00E9 qu\u2019aux types d\u00E9riv\u00E9s de \"decimal\"
scale_not_non_negative_integer=le param\u00E8tre \"scale\" doit \u00EAtre un entier non n\u00E9gatif
length_not_non_negative_integer=le param\u00E8tre \"length\" doit \u00EAtre un entier non n\u00E9gatif
precision_not_derived_from_decimal=le param\u00E8tre \"precision\" ne peut \u00EAtre appliqu\u00E9 qu\u2019aux types d\u00E9riv\u00E9s de \"decimal\"
precision_not_positive_integer=le param\u00E8tre \"precision\" doit \u00EAtre un entier non n\u00E9gatif
regex_impl_not_found=Aucun moteur d\u2019expressions r\u00E9guli\u00E8res n\u2019a pu \u00EAtre trouv\u00E9; utilisez JDK 1.4 ou ajoutez Xerces2 \u00E0 votre classpath
regex_internal_error=erreur interne dans l\u2019expression r\u00E9guli\u00E8re pour le type de donn\u00E9es {0}

# validation errors
length_violation=doit \u00EAtre {0} avec une longueur \u00E9gale \u00E0 {1} (la longueur trouv\u00E9e est {2})
max_length_violation=doit \u00EAtre {0} avec une longueur d\u2019au plus {1} (la longueur trouv\u00E9e est {2})
min_length_violation=doit \u00EAtre {0} avec une longueur d\u2019au moins {1} (la longueur trouv\u00E9e est {2})
min_inclusive_violation=doit \u00EAtre {0} sup\u00E9rieur ou \u00E9gal \u00E0 {1}
min_exclusive_violation=doit \u00EAtre {0} sup\u00E9rieur \u00E0 {1}
max_inclusive_violation=doit \u00EAtre {0} inf\u00E9rieur ou \u00E9gal \u00E0 {1}
max_exclusive_violation=doit \u00EAtre {0} inf\u00E9rieur \u00E0 {1}
pattern_violation=doit \u00EAtre {0} satisfaisant l\u2019expression r\u00E9guli\u00E8re \"{1}\"
entity_violation=doit \u00EAtre un nom d\u00E9clar\u00E9 dans la DTD en tant qu\u2019entit\u00E9 non-pars\u00E9e
undeclared_prefix=doit un \u00EAtre un QName avec un pr\u00E9fixe, si sp\u00E9cifi\u00E9, d\u00E9clar\u00E9 (le pr\u00E9fixe \"{0}\" n\u2019est pas d\u00E9clar\u00E9)
precision_violation=doit \u00EAtre {0} avec au plus {1} chiffres significatifs ({2} chiffres ont \u00E9t\u00E9 trouv\u00E9s)
precision_1_violation=doit \u00EAtre {0} avec exactement un chiffre significatif ({1} chiffres ont \u00E9t\u00E9 trouv\u00E9s)
# part of the point is to avoid ugly "digit(s)" in the error message
scale_violation=doit \u00EAtre un nombre d\u00E9cimal avec au plus {0} chiffres significatifs apr\u00E8s la virgule ({1} chiffres ont \u00E9t\u00E9 trouv\u00E9s)
scale_0_violation=doit \u00EAtre un nombre d\u00E9cimal sans aucun chiffre significatif apr\u00E8s la virgule
scale_1_violation=doit \u00EAtre un nombre d\u00E9cimal avec au plus un chiffre significatif apr\u00E8s la virgule ({0} chiffres ont \u00E9t\u00E9 trouv\u00E9s)
lexical_violation=doit \u00EAtre {0}

# fragments substituted in above
lexical_space_string=une cha\u00EEne de caract\u00E8res
lexical_space_uri=une URI
lexical_space_boolean=un bool\u00E9en
lexical_space_decimal=un nombre d\u00E9cimal
lexical_space_float=un nombre en virgule flottante
lexical_space_duration=une dur\u00E9e
lexical_space_hex=une cha\u00EEne hexad\u00E9cimale
lexical_space_base64=une cha\u00EEne base64
lexical_space_integer=un entier
lexical_space_name=un nom XML
lexical_space_ncname=un nom XML sans double point
lexical_space_nmtoken=un NMTOKEN XML
lexical_space_qname=un QName XML
lexical_space_list=une liste d\u00E9limit\u00E9e pas espaces blancs
lexical_space_list_ncname=une liste de noms XML sans doubles points
lexical_space_list_nmtoken=une liste de NMTOKENs XML
lexical_space_date_y_m_d_time=une date et heure ISO
lexical_space_time=une heure ISO
lexical_space_date_y_m_d=une date ISO
lexical_space_date_y_m=une ann\u00E9e et mois ISO
lexical_space_date_y=une ann\u00E9e
lexical_space_date_m_d=un mois et jour ISO (de forme --MM-DD)
lexical_space_date_m=un mois ISO (de forme --MM)
lexical_space_date_d=un jour ISO (de forme --DD)
lexical_space_language=un identificateur de langage RFC 3066
