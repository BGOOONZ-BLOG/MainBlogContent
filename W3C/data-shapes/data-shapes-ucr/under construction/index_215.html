<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
		<title>SHACL Use Cases and Requirements</title>
		<script src='//www.w3.org/Tools/respec/respec-w3c-common'
		async class='remove'></script>
		<script class='remove'>
			var respecConfig = {
				specStatus: "ED",
				shortName:  "shacl-ucr",
				edDraftURI: "http://w3c.github.io/data-shapes/data-shapes-ucr/",
				editors: [{   name:       "Simon Steyskal",
				url:        "http://steyskal.info/",
				company:    "WU Vienna/Siemens AG",
				w3cid: "73545" },
				{   name:       "Karen Coyle",
				url:        "http://kcoyle.net/",
				company:    "DCMI",
				companyURL: "http://dublincore.org/",
				w3cid: "44865" }
				],
				wg:           "RDF Data Shapes Working Group",
				wgURI:        "https://www.w3.org/2014/data-shapes",
				wgPublicList: "public-rdf-shapes",
				wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73865/status",
				localBiblio:  {
				"SHACLspec": {
					title:    "Shapes Constraint Language (SHACL) Specification",
					href:     "http://w3c.github.io/data-shapes/shacl/",
					"authors": [
						"H. Knublauch",
						"E. Prud'hommeaux"
					],
					publisher: "xyz"
				}}
			};
		</script>
		<style>
		/* use tab-like headers for syntax examples */
div.exampleheader {
  font-size: 90%;
  float: left;
  background: #F9F9F9;
  color: #2F6FAB;
  border: 1px dashed #2F6FAB;
  border-bottom: 0px;
  padding-top: 2px;
}

div.exampleheader span.exampleheader {
  background: #F9F9F9;
  padding-top: 0px;
  padding-right: 10px;
  padding-left: 10px;
  padding-bottom: 3px;
  padding-top: 0px;
}

/* Also copy MediaWiki style here, so it will not look different when exported */
div.fssyntax pre, div.rdfxml pre, div.owlxml pre, div.turtle pre, div.manchester pre  {
  background-color: #F9F9F9;
  border: 1px dashed #2F6FAB;
  color: black;
  line-height: 1.1em;
  padding: 1em;
  clear: both;
  margin-left: 0em;
}</style>
	</head>
	<body>
		<section id='abstract'>
			<p>
				To foster the development of Shapes Constraint Language (SHACL), this document includes a set of use cases and  
				requirements that motivate a simple language and semantics for formulating structural constraints on <a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</a>. 
				All use cases provide realistic examples describing how people may use structural constraints to validate RDF instance data. Note, that this document avoids the use of any specific vocabulary that might be introduced by the <abbr title="Shapes Constraint Language">SHACL</abbr> specification.
			</p>
			</section>

			<section id='sotd'>

			</section>

			<!-- taken from http://www.w3.org/2014/data-shapes/charter -->
			<section>
				<h1>Scope and Motivation</h1>
				<p>
					One motivation for SHACL is <em>Application Integration</em>, where different software components, potentially maintained by different organizations, need to function together smoothly. As an everyday example, imagine an international company with a dozen divisions, each providing a feed of their Human Resources data to authorized users. Different divisions might use different software to produce their feeds, and there might be many distinct applications which consume the data, ranging from an employee phone book to a hiring-compliance monitoring system. 
				</p>
				<p>
					While systems like this are built and maintained around the world today, their complexity often becomes a problem. Not only are the systems expensive and sometimes unpleasant to maintain, but changing data fields and adding new applications can grow to be practically impossible. An "RDF Data Shapes" standard would help manage the complexity, greatly reducing the cost and hassle, by separating components while still allowing them to work together.
				</p>
				<p>
					Specifically, in this example, SHACL would allow: 
					<ul>
						<li>Developers of each data-consuming application could define the shapes their software needs to find in each feed, in order to work properly, with optional elements it can use to work bette</li>
						<li>When these developers want to modify their software, they can define new shapes they require.</li>
						<li>Management can offer guidance in the relative priorities of outputting particular shapes, based on the application(s) that use them. There might be target goals and deadlines.</li>
						<li>Developers of data-providing systems can read the shape definitions (and possibly related RDF Vocabulary definitions) to learn what they need to provide.</li>
						<li>Data providers can also validate their data against the definitions, to see if they are producing the right information. (Of course, this doesn't ensure the data is correct, just that it's the right shape.) </li>
						<li>Data consumers can validate incoming data against the expected shapes, to make sure they are getting the kind of data they were expecting. This can be done manually from time to time, or automatically on all data. This kind of validation is particularly important if producers and consumers keep updating their software to use new shapes to meet changing requirements. </li>
						<li>Intermediate systems can, in some cases, be written to convert data written to match one shape into data which matches a different shape. </li>
						<li>Some systems may be able to automatically generate user interface elements (e.g. HTML forms) and/or data bindings based on shapes.</li>
						<li>There may be optimizations in data processing possible when the data is known to conform to a single declared shape. </li>
					</ul>
				</p>
				<p>
					In all cases, the <em>semantics</em> of the data are determined by RDF and the vocabularies specified by the shape, so if the shapes match, the systems can reasonably be expected to interoperate correctly. 
				</p>
				<p>
					While SHACL is expected to have immediate everyday utility, as illustrated above, it has even wider potential applicability, ranging in scale. At the large end, SHACL might be used by loosely-knit communities, where data is provided by organizations which are not under any central authority, such as charities and researchers around the world concerned with quality-of-life measures. At the small end, SHACL might be used within a mobile application environment to provide interoperability among independent sensor modules and tools for analyzing and acting on sensor results. The common thread is that SHACL allow a loose coupling, where independently maintained elements of an overall system can reliably and comfortably interoperate. 
				</p>
			</section>

			<section>
				<h1>Organization of this Document</h1>
				<p>This document is organized as follows:</p>
				<ul>
					<li><strong><a href="#usecases" title="Use Cases">Use Cases</a></strong> are
						used to capture and model functional requirements. Use cases
						describe the system’s behavior under various conditions [[COCKBURN-2000]],
						cataloging who does what with the system, for what purpose, but
						without concern for system design or implementation. Each use case is identified by a
						reference number to aid cross-reference from other documentation. A variety of styles may be used to capture use cases,
						from a simple narrative to a structured description with actors,
						pre/post conditions, and non-functional requirements
						raised by the use case.</li>
					</ul>

		<!--<ul>
			<li><strong><a href="#userstories" title="User Stories">User Stories</a></strong>
				capture statements about system requirements written from a user
				or application perspective. They are typically lightweight and
				informal and can run from one line to a paragraph or two
				(sometimes described as an 'epic') [[xyz]]. 
				This document redacts a number of user stories around the theme of read/writeable linked data.
				Analysis of each user story reveals a
				number of (functional) use cases and other non-functional
				requirements. See <em>Device API Access Control Use Cases and Requirements</em> [[xyz]] for a good example
				of user stories and their analysis.</li>
		</ul>
		<ul>
			<li><strong><a href="#usecases" title="Use Cases">Use Cases</a></strong> are
				used to capture and model functional requirements. Use cases
				describe the system’s behavior under various conditions [[xyz]],
				cataloging who does what with the system, for what purpose, but
				without concern for system design or implementation. Each use case is identified by a
				reference number to aid cross-reference from other documentation;
				use case indexing in this document is based on rdb2rdf
				use cases [[xyz]]. A variety of styles may be used to capture use cases,
				from a simple narrative to a structured description with actors,
				pre/post conditions, step-by-step behaviors (as in <em>POWDER:
				Use Cases and Requirements</em> [[xyz]]), and non-functional requirements
				raised by the use case.</li>
			</ul>-->
			<ul>
				<li><strong><a href="#requirements" title="Requirements">Requirements</a></strong>
					list functional and non-functional or quality requirements, and the use cases
					they may be derived from/related to. This approach is exemplified in the <em>Use Cases and Requirements for the Data
					Catalog Vocabulary</em> [[DCAT-UCR]].</li>
				</ul>
			</section>

			<section>
				<h1 id="userstories">User Stories</h1>
				<!-- User Story 1 -->
			<section>
			  <h2><dfn>S12</dfn>: App interoperability</h2>
			  <p>There is one application (eg Cimba) which stores application state in RDF. 
			  It currently queries and modifies that state using HTTP GET and PUT operations on RDF Sources, but we have another version 
			  being developed that uses SPARQL to query and modify the data. The question is, how do we communicate the shape of the data 
			  this application reads and writes to other developers who want to make compatible applications? 
			  We want to say: as long as your data is of this form, Cimba will read it properly. 
			  We also want to say: Cimba may write data of any of these forms, so to be interoperable, your application will need to read and 
			  correctly process all of them. 
			   </p>
					
			    <p><strong>Summary:</strong> Requires the final "shape syntax" to be light-weight and less verbose than SPARQL.</p>

			    <p><strong>Related Requirements:</strong>  						<a>R5.1</a>,
						<a>R5.2</a>,
						<a>R5.3</a>,
						<a>R5.4</a>,
						<a>R5.9.1</a>,
						<a>R5.9.2</a>,
						<a>R5.9.3</a>, 
						<a>R11.5</a>, and
						<a>R11.7</a> </p>
		      </section>
	  </section>	
		
		<section>
			<h1 id="usecases">Use Cases</h1>
			<p>The following use cases are each derived from one or more of the user stories above. These use cases are explored in detail through their description and their related user stories and requirements. The examples they contain are included purely for illustrative purposes, and should not be interpreted normatively.</p>

			<!-- Use Case 1 -->
			<section>
				<h2>UC1: Defining constraints of properties or classes of an RDF graph</h2>
				<p> <strong>Description:</strong>
					This use case addresses the ability to constrain certain properties or classes of an RDF graph (i.e. defining their shape). 
					For example, one could formalize the requirement that each property must have an associated domain or that each node of type X 
					has to have required properties Y and Z. Being able to define and constrain shapes of entities in an RDF graph, allows 
					to check whether that graph is valid wrt. to those defined constraints.
				</p>
				<p>
					<strong>Related Use Cases:</strong>
					<a>UC1</a>,
					<a>UC2</a>,	
				</p>
				<p>
					<strong>Related Requirements:</strong>
				</p>
			</section>
			</section>
			<!-- Use Case 2 
			<section>
				<h2>UC2: Associating more than one shape to the same node of an RDF graph</h2>
				<p>
					This use case addresses the possibility to define more than one set of constraints (i.e. shape) for a single node of an RDF graph.
					In scenarios where nodes of an RDF graph might serve more than one role, this feature might be required.
				</p>
				<p>
					<strong>Related User Stories:</strong>
					<a>UC4</a>
				</p>
				<p>
					<strong>Related Requirements:</strong>
				</p>
			</section>
			
			<!-- Use Case 3 
			<section>
				<h2>UC3: Encapsulating complex constraint definitions into macros</h2>
				<p>
					This use case addresses the possibility to encapsulate complex constraint definitions into macros thus, allow their reuse in other shape definitions as 
					well as avoid verbose constraint declarations.
				</p>
				<p>
					<strong>Related User Stories:</strong>
					<a>UC16</a>
				</p>
				<p>
					<strong>Related Requirements:</strong>
				</p>
			</section>
			
			<!-- Use Case 3 
			<section>
				<h2>UC3: Associating more than one shape to the same node of an RDF graph</h2>
				<p>
					In scenarios where nodes of an RDF graph might serve more than one role, it  
				</p>
				<p>
					<strong>Related User Stories:</strong>
					<a>UC4</a>
				</p>
				<p>
					<strong>Related Requirements:</strong>
				</p>
			</section
		</section>-->
	    <section>
			<h1 id="requirements">Requirements</h1>
			<p>This section lists the requirements arising from the use-cases catalogued in this document. Specific requirements that have been de-prioritized or rejected have been left in the document for completeness, but are shown as struck out.</p>
			<dl>
				<!-- Requirement R1 -->
				<dt>
					<dfn>R1</dfn>: Higher-Level Language
				</dt>
				<dd>
					<p>
						<em>Constraints/shapes shall be specifiable in a higher-level language with 1. definitional capabilities, such as macro rolling up and naming, and 2. control infrastructure for, e.g., recursion.</em> 
					</p>
					<p>
						<strong>Motivation:</strong> 
						<a href="http://lelystad.informatik.uni-mannheim.de/rdf-validation/?q=node/127">Dublin Core Requirement 103</a>
					</p>
				</dd>

				<!-- Requirement R2 -->
				<dt>
					<dfn>R2</dfn>: Concise Language
				</dt>
				<dd>
					<p>
						<em>Constraints/shapes shall be specifiable in a concise language.</em> 
					</p>
					<p>
						<strong>Motivation:</strong> 
						<a href="http://lelystad.informatik.uni-mannheim.de/rdf-validation/?q=node/327">Dublin Core Requirement 184</a>
					</p>
				</dd>

				<!-- Requirement R3 -->
				<dt>
					<dfn>R3</dfn>: Addressability
				</dt>
				<dd>
					<p>
						<em>Collections of constraints/shapes may be addressable and discoverable. Individual constraints/shapes may be addressable and discoverable. </em> 
					</p>
					<p>
						<strong>Motivation:</strong> 
						<a href="http://lelystad.informatik.uni-mannheim.de/rdf-validation/?q=node/203">Dublin Core Requirement 147</a> and
						<a href="http://lelystad.informatik.uni-mannheim.de/rdf-validation/?q=node/204">Dublin Core Requirement 148</a>
					</p>
				</dd>

				<!-- Requirement R4 -->
				<dt>
					<dfn>R4</dfn>: Annotations
				</dt>
				<dd>
					<p>
						<em>Constraints/shapes may incorporate extra information that does not affect validation. It shall be possible to search for constraints/shapes with particular extra information. </em> 
					</p>
					<p>
						<strong>Motivation:</strong> 
						<a href="http://lelystad.informatik.uni-mannheim.de/rdf-validation/?q=node/415">Dublin Core Requirement 208</a>
					</p>
				</dd>


            <!-- Requirement R5.1  -->
            <dt>
				<dfn>R5.1</dfn>: Association of Class with Shape
			</dt>
			<dd>
				<p>
					<em>There must be an "easy" way of associating a shape with a class, meaning that nodes in a graph that are instances of that class must conform with that shape </em></p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC3</a>,
              		<a>UC10</a>,
              		<a>UC11</a>,
              		<a>UC12</a>,
              		<a>UC13</a>,
              		<a>UC15</a>,
              		<a>UC19</a>,
              		<a>UC20</a>,
              		<a>UC29</a>, and
              		<a>UC36</a>
              	</p>
				</dd>
	                <!-- Requirement R5.2 -->
	                <dt>
						<dfn>R5.2</dfn>: Property Min/Max Cardinality
					</dt>
					<dd>
						<p>
							<em>The stated values for a property may be limited by minimum/maximum cardinality, with typical patterns being [0..1], [1..1], [0..*] and [1..*].  </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC10</a>,
	                  		<a>UC11</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>, 
	                  		<a>UC20</a>, 
							<a>UC39</a>, and 
							<a>UC42</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.3 -->
	                <dt>
						<dfn>R5.3</dfn>: Property Datatype
					</dt>
					<dd>
						<p>
							<em>The values of a property may be limited to be an RDF Literal with a stated datatype, such as xsd:string or xsd:date. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC10</a>,
	                  		<a>UC11</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>, and
	                  		<a>UC20</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.4 -->
	                <dt>
						<dfn>R5.4</dfn>: Property Type
					</dt>
					<dd>
						<p>
							<em>The values of a property may be limited by their type, e.g., all children have to be of type person. </em></p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC10</a>,
	                  		<a>UC11</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>, and
	                  		<a>UC20</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.5 -->
	                <dt>
						<dfn>R5.5</dfn>: Property's RDF Node Type (e.g. only IRIs are allowed)
					</dt>
					<dd>
						<p>
							<em>The values of a property on instances of a class may be limited by their RDF node type, e.g. IRI, BlankNode, Literal, or BlankNodeOrIRI (for completeness we may want to support all 7 combinations including Node as parent). </em></p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC8</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.6 
	                <dt>
						<dfn>R5.6</dfn>: Property Default Value
					</dt>
					<dd>
						<p>
							<em>It should be possible to provide a default value for a given property, e.g. so that input forms can be pre-populated and to insert a required property that is missing in a web service call. This requirement is not about using default values as "inferred" triples at run-time. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a>,
	                  		<a>UC19</a>, and
	                  		<a>UC20</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.7 
	                <dt>
						<dfn>R5.7</dfn>: Property Labels at Shape
					</dt>
					<dd>
						<p>
							<em>It should be possible to provide human-readable descriptions of the role of a property in the context of a class, not just globally using triples that have the rdf:Property as subject. Multiple languages should be supported.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a> and
	                  		<a>UC19</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.8 
	                <dt>
						<dfn>R5.8</dfn>: Property Comment in a Shape
					</dt>
					<dd>
						<p>
							<em>It should be possible to provide human-readable descriptions of the role of a property in the context of a shape, not just globally using triples that have the rdf:Property as subject. Multiple languages should be supported.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a> and
	                  		<a>UC19</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.9 
	                <dt>
						<dfn>R5.9</dfn>: Datatype Property Facets
					</dt>
					<dd>
						<p>
							<em>For datatype properties it should be possible to define frequently needed "facets" to drive user interfaces and validate input against simple conditions, including min/max value, regular expressions, string length etc. similar to XSD datatypes.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>,
	                  		<a>UC11</a>,
	                  		<a>UC12</a>,
	                  		<a>UC13</a>,,
	                  		<a>UC19</a>,
	                  		<a>UC20</a>, and
	                  		<a>UC29</a>
	                  	</p>
	                </dd>
					
						                <!-- Requirement R5.9.1 --> 
	                <dt>
						<dfn>R5.9.1</dfn>: Datatype Property Facets: min/max values 
					</dt>
					<dd>
						<p>
							<em>Similar to xsd:minInclusive/maxExclusive</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>,
	                  		<a>UC11</a>,
	                  		<a>UC12</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>,
	                  		<a>UC20</a>, and
	                  		<a>UC29</a>
	                  	</p>
	                </dd>
					
						                <!-- Requirement R5.9.2 --> 
	                <dt>
						<dfn>R5.9.2</dfn>: Datatype Property Facets: regular expression patterns
					</dt>
					<dd>
						<p>
							<em>Pattern matching against regular expressions (xsd:pattern).</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>,
	                  		<a>UC11</a>,
	                  		<a>UC12</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>,
	                  		<a>UC20</a>, and
	                  		<a>UC29</a>
	                  	</p>
	                </dd>
					
						                <!-- Requirement R5.9.3--> 
	                <dt>
						<dfn>R5.9.3</dfn>: Datatype Property Facets: string length
					</dt>
					<dd>
						<p>
							<em>Constraining the length of a string.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>,
	                  		<a>UC11</a>,
	                  		<a>UC12</a>,
	                  		<a>UC13</a>,
	                  		<a>UC19</a>,
	                  		<a>UC20</a>, and
	                  		<a>UC29</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.10 -->
	                <dt>
						<dfn>R5.10</dfn>: Property Value Enumerations
					</dt>
					<dd>
						<p>
							<em>Shapes will provide exhaustive enumerations of the valid values (literals and IRIs).</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>,
	                  		<a>UC11</a>, and
	                  		<a>UC37</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R5.11 -->
	                <dt>
						<dfn>R5.11</dfn>: Properties Used in Inverse Direction
					</dt>
					<dd>
						<p>
							<em>Shapes can have constraints where the tested node is the object of a triple. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC36</a> 
	                  	</p>
	                </dd>

	                <!-- Requirement R5.12 
	                <dt>
						<dfn>R5.12</dfn>: Primary Keys
					</dt>
					<dd>
						<p>
							<em>It is often useful to declare a given (datatype) property as the "primary key" of a class, so that the system can enforce uniqueness and also automatically build URIs from user input and data imported from relational databases or spreadsheets. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC5</a> and
	                  		<a>UC25</a>
	                  	</p>
	                </dd>
	            </dl>
	        </dd>
			
			<!-- Requirement R6 -->
            <dt>
				<dfn>R6</dfn>: Complex Constraints
			</dt>
			<dd>
				<p>
					<em>The language should allow users to implement constraints that check complex conditions, with an expressivity as covered by the following sub-requirements (e.g. basic graph patterns, string and mathematical operations and comparison of multiple values). </em> 
				</p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC5</a>,
              		<a>UC21</a>,
              		<a>UC22</a>,
              		<a>UC23</a>,
              		<a>UC26</a>,
              		<a>UC27</a>, and
              		<a>UC30</a>
              	</p>
            
				</dd>
					                <!-- Requirement R6.1 
	                <dt>
						<dfn>R6.1</dfn>: Expressivity: Basic Graph Patterns
					</dt>
					<dd>
						<p>
							<em>Many constraints require matching patterns within the graph, often represented via linked triple patterns (SPO) and property paths. Requires variable bindings for matching, so that multiple values can be compared with each other. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC1</a>,
	                  		<a>UC5</a>,
	                  		<a>UC17</a>,
	                  		<a>UC21</a>, 
	                  		<a>UC22</a>,
	                  		<a>UC23</a>,
	                  		<a>UC26</a>,
	                  		<a>UC27</a>, and
	                  		<a>UC30</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R6.2 -->
	                <dt>
	                	<dfn>R6.2</dfn>: Expressivity: Non-Existence of Patterns
	                </dt>
	                <dd>
	                	<p>
	                		<em>Many constraints require that a certain pattern does not exist in the graph. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC1</a>,
	                		<a>UC2</a>,
	                		<a>UC22</a>, and
	                		<a>UC23</a>
	                	</p>
	                </dd>

	                <!-- Requirement R6.3 -->
	                <dt>
	                	<dfn>R6.3</dfn>: Expressivity: String Operations
	                </dt>
	                <dd>
	                	<p>
	                		<em>Some constraints require building new strings out of other strings, and building new URIs out of other values. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC5</a> and
	                		<a>UC23</a>
	                	</p>
	                </dd>

	                <!-- Requirement R6.4 -->
	                <dt>
	                	<dfn>R6.4</dfn>: Expressivity: Language Tags
	                </dt>
	                <dd>
	                	<p>
	                		<em>Some constraints require comparing language tags of RDF literals, e.g. to check that no language is used more than once per property. Also to produce multi-lingual error messages. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC21</a>, UC42
	                	</p>
	                </dd>

	                <!-- Requirement R6.5 -->
	                <dt>
	                	<dfn>R6.5</dfn>: Expressivity: Mathematical Operations
	                </dt>
	                <dd>
	                	<p>
	                		<em>Some constraints require mathematical calculations and comparisons, e.g. area = width * height. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC5</a>
	                	</p>
	                </dd>

	                <!-- Requirement R6.6 -->
	                <dt>
	                	<dfn>R6.6</dfn>: Expressivity: Literal Value Comparison
	                </dt>
	                <dd>
	                	<p>
	                		<em>Some constraints require operators such as &lt;, &gt;=, != etc, either against constants or other values that are dynamically retrieved at query time. Includes date/time comparison and functions such as NOW(). </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC5</a>,
	                		<a>UC21</a>, 
	                		<a>UC22</a>,
	                		<a>UC23</a>, and
	                		<a>UC27</a>
	                	</p>
	                </dd>

	                <!-- Requirement R6.7 -->
	                <dt>
	                	<dfn>R6.7</dfn>: Expressivity: Logical Operators
	                </dt>
	                <dd>
	                	<p>
	                		<em>The language should make it possible to express the basic logical operators intersection, union and negation of conditions. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC5</a>,
	                		<a>UC26</a>, and
	                		<a>UC35</a>
	                	</p>
	                </dd>

	                <!-- Requirement R6.8 -->
	                <dt>
						<dfn>R6.8</dfn>: Expressivity: Transitive Traversal of Properties
					</dt>
					<dd>
						<p>
							<em>Some constraints need to be able to traverse a property transitively, such as parent-child or partOf relationships. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC16</a>,
	                  		<a>UC23</a>, and
	                  		<a>UC26</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R6.9 
	                <dt>
						<dfn>R6.9</dfn>: Expressivity: Aggregations
					</dt>
					<dd>
						<p>
							<em>Some constraints require aggregating multiple values, especially via COUNT, MIN and MAX. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC22</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R6.10 
	                <dt>
						<dfn>R6.10</dfn>: Expressivity: Named Graphs
					</dt>
					<dd>
						<p>
							<em>Some constraints require looking up information from other named graphs, for example to verify that certain values exist in a controlled vocabulary or background knowledge. This information is usually not explicitly imported into the query graph, and having all sub-graphs in the default query graph would be too inefficient.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC5</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R6.11 -->
	                <dt>
						<dfn>R6.11</dfn>: Expressivity: Closed Shapes
					</dt>
					<dd>
						<p>
							Some data recipients will not act as generic triple stores. "Closed shapes" identify triples not matched by a property constraint in a shape. A few uses of closed shapes: a client tests that every triple being sent to a server will be accepted/processed; a server rejects any document with unexpected triples; a server accepts and ignores unexpected triples and returns a list of dropped triples to the client. (The control can probably be applied to the whole schema rather than individual shapes. At least, there's no use case or implementation experience to the contrary.) </p>
	                	</p>
						<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC4</a>
	                  	</p>
	                </dd>
	
	                <!-- Requirement R6.12 -->
	                <dt>
						<dfn>R6.12</dfn>: Expressivity: Checking for well-formed rdf:Lists
					</dt>
					<dd>
						<p>
							<em>There shall be a concise construct for expressing that a list must be well-formed.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC42</a>
<div class="note">This requirement has not been approved yet.</div>
	                  	</p>
	                </dd>


			
			        <!-- Requirement R6.13-->
	                <dt>
						<dfn>R6.13</dfn>: Expressivity: Placing constraints on the values of rdf:Lists
					</dt>
					<dd>
						<p>
							<em>There shall be a way of applying the constraints that we can express for normal properties (require a certain rdf:type, require a certain shape, require a certain datatype, require a certain node kind, etc.) to the members of rdf:Lists.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC42</a>
<div class="note">This requirement has not been approved yet.</div>
	                  	</p>
	                </dd>


	        
			<!-- Requirement R7 -->
            <dt>
				<dfn>R7</dfn>: Macro-Language Features
			</dt>
			<dd>
				<p>
					<em>The language should enable the definition of macros as short cuts to recurring patterns, and to enable inexperienced users define rich constraints. Macros should be high-level terms that improve overall readability, separation of concerns and maintainability. This overlaps with the already approved "Higher-Level Language". </em> 
				</p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC5</a>,
              		<!--<a>UC7</a>,-->
              		<a>UC16</a>,
              		<a>UC21</a>,
              		<a>UC27</a>,
              		<a>UC28</a>, and
              		<a>UC32</a>
              	</p>
            
				</dd>
	                <!-- Requirement R7.1 -->
	                <dt>
						<dfn>R7.1</dfn>: Named Shapes
					</dt>
					<dd>
						<p>
							<em>It should be possible to encapsulate a group of constraints (a Shape) into a named entity, so that the Shape can be reused in multiple places, also across the Web</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<!--<a>UC7</a>,-->
	                  		<a>UC16</a> and
	                  		<a>UC28</a>
	                  	</p>
	                </dd>
	                <!-- Requirement R7.2 -->
	                <dt>
						<dfn>R7.2</dfn>: Function and Property Macros
					</dt>
					<dd>
						<p>
							<em>In order to support maintainable and readable constraints, it should be possible to encapsulate recurring patterns into named entities such as functions and dynamically computed properties. This requirement is orthogonal to almost every user story. It includes a vocabulary to share function definitions. </em></p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC5</a>,
	                  		<a>UC16</a>, and
	                  		<a>UC28</a>
	                  	</p>
	                </dd>
	                <!-- Requirement R7.3 -->
	                <dt>
	                	<dfn>R7.3</dfn>: Constraint Macros
	                </dt>
	                <dd>
	                	<p>
	                		<em>Some constraint patterns are recurring with only slight modifications. Example: SKOS constraints that multiple properties must be pairwise disjoint. The language should make it possible to encapsulate such recurring patterns in a parameterizable form. Examples include SPIN/LDOM Templates.</em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC21</a>,
	                		<a>UC27</a>, and
	                		<a>UC28</a>
	                	</p>
	                </dd>
	                <!-- Requirement R7.4 -->
	                <dt>
						<dfn>R7.4</dfn>: Nested Constraint Macros
					</dt>
					<dd>
						<p>
							<em>It should be possible to combine the high-level terms of the constraint language into larger expressions using nested constraints. Examples of this include ShEx, Resource Shapes' oslc:valueShape and owl:allValuesFrom. </em></p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC32</a> and
	                  		<a>UC33</a>
	                  	</p>
	                </dd>

            <!-- Requirement R8 -->
            <dt>
				<dfn>R8</dfn>: Specialization of Shapes
			</dt>
			<dd>
				<p>
					<em>It should be possible to specialize/extend shapes so that the constraints defined for a more general (super) shape also apply to the specialized (sub) shape. Sub-shapes can only narrow down, i.e. further constrain.</em> 
				
				</p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC2</a>,
              		<a>UC5</a>,
              		<a>UC10</a>,
              		<a>UC11</a>,
              		<a>UC19</a>,
              		<a>UC20</a>,
              		<a>UC24</a>,
              		<a>UC25</a>,
              		<a>UC27</a>,
              		<a>UC28</a>, and
              		<a>UC29</a>
              	</p>
            </dd>
            <!-- Requirement R9 -->
            <dt>
				<dfn>R9</dfn>: Global Constraints
			</dt>
			<dd>
				<p>
					<em>It should be possible to specify constraint conditions that need to be checked "globally" for a whole graph, without referring to a specific set of resources or class. In programming languages such global entities are often called "static", but "global" is probably better known. </em> 
				</p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC35</a>
              	</p>
            </dd>
            <!-- Requirement R10 -->
            <dt>
            	<dfn>R10</dfn>: Vocabulary for Constraint Violations
            </dt>
            <dd>
            	<p>
            		<em>Instead of just reporting yes/no, the language needs to be able to return more meaningful messages including severity levels, human-readable error descriptions and pointers at specific patterns in the graph. </em> 
            	</p>
            	<p>
            		<strong>Motivation:</strong> 
            		<a>UC3</a>,
            		<a>UC34</a>, and
            		(almost every other use case)
            	</p>

            </dd>
              		<!-- Requirement R10.1 -->
            		<dt>
						<dfn>R10.1</dfn>: Severity Levels
					</dt>
					<dd>
						<p>
							<em>The language should allow the creation of error responses that can include severity levels as desired. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>
	                  	</p>
	                </dd>
	               <!--  Requirement R10.2 -->
	                <dt>
						<dfn>R10.2</dfn>: Human-readable Violation Messages
					</dt>
					<dd>
						<p>
							<em>The language should make it possible for constraint checks to create human-readable violation messages that can be either created explicitly by the user or generated dynamically from constraint definition. It should be possible to create such messages in multiple languages. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC3</a>
	                  	</p>
	                </dd>
	                <!-- Requirement R10.3 -->
	                <dt>
	                	<dfn>R10.3</dfn>: Constraint Violations should point at Specific Nodes
	                </dt>
	                <dd>
	                	<p>
	                		<em>The language should make it possible for authors of constraint checks to produce pointers at specific nodes and graph fragments that caused the violation. Typical examples of such information includes the starting point (root node), a path from the root, and specific values that caused the problem. </em> 
	                	</p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		<a>UC3</a>
	                	</p>
	                </dd>


            <!-- Requirement R11 
            <dt>
				<dfn>R11</dfn>: Modularization
			</dt>
			<dd>
				<p>
					<em>The language should support organizing constraint declarations in different groups, modules or graphs, and provide mechanisms to allow modules to point to each other. </em> 
				</p>
            	<p>
              		<strong>Motivation:</strong> 
              		<a>UC1</a>,
              		<a>UC36</a>, and
              		<a>UC37</a>
              	</p>
              	<dl>
              		<!-- Requirement R11.1 
            		<dt>
						<dfn>R11.1</dfn>: Organizing Constraints in Named Graphs
					</dt>
					<dd>
						<p>
							<em>The language should support using the standard linked data concept of named graphs (datasets) to organize constraint declarations. Such named graphs have a URI that is resolvable in the context of the application (e.g. on the public web via HTTP). Applications may define their own look-up mechanism to resolve such named graphs (e.g. to local database graphs or files). This includes the ability to separate a domain model from constraints. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC5</a>,
	                  		<a>UC6</a>,
	                  		<a>UC7</a>,
	                  		<a>UC13</a>,
	                  		<a>UC15</a>,
	                  		<a>UC20</a>,
	                  		<a>UC24</a>, and
	                  		<a>UC28</a>
	                  	</p>
	                </dd>
	                <!-- Requirement R11.2 
	                <dt>
						<dfn>R11.2</dfn>: Including Named Graphs for Query Evaluation
					</dt>
					<dd>
						<p>
							<em>The language should support including named graphs (similar to owl:imports) so that all constraints from the (transitively) included graphs are also applied for evaluation. Conceptually, all included graphs are a union graph that becomes the default query graph of the constraint evaluation. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC5</a>,
	                  		<a>UC6</a>,
	                  		<a>UC13</a>,
	                  		<a>UC20</a>, and
	                  		<a>UC24</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R11.3 
	                <dt>
						<dfn>R11.3</dfn>: Efficiency of the validation process
					</dt>
					<dd>
						<p>
							<em>The efficiency and complexity of the language should be taken into account. At least, it should be possible to identify some profiles of the language with minimum complexity.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC34</a> and other scenarios involving large graphs.
	                  	</p>
	                </dd>

	                <!-- Requirement R11.4 
	                <dt>
						<dfn>R11.4</dfn>: Execution on large databases
					</dt>
					<dd>
						<p>
							<em>The language should be efficient to execute on large databases, so that the execution engine can exploit native optimizations from the database. Some data that is needed for execution (such as the constraint definitions themselves, macros and functions) may not be present on each graph on the database. Therefore, it should be possible to separate the graphs needed at constraint evaluation time from those graphs that hold the complete definition of the constraint checking context. A possible solution would be to have another kind of include mechanism that links a data graph with (macro) libraries. Another way is to have some on-demand validation system.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC34</a> and other scenarios involving large graphs.
	                  	</p>
	                </dd>

	                <!-- Requirement R11.5 -->
	                <dt>
						<dfn>R11.5</dfn>: Profiles
					</dt>
					<dd>
						<p>
							<em>The language should include a notion of profiles, so that certain applications with limited features can only use certain elements of the overall language.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a>,
	                  		<a>UC19</a> and
	                  		<a>UC32</a>
	                  	</p>
	                </dd>


	                <!-- Requirement R11.6 
	                <dt>
						<dfn>R11.6</dfn>: Grouping Constraints into Contexts
					</dt>
					<dd>
						<p>
							<em>The language should make it possible to organize constraints so that they are applicable in certain contexts only. For example, application A may want to add constraints that do not apply for the more general application B. One approach would be to "tag" constraints with the URI of a context resource, and have the execution engine accept a context parameter to instruct it which constraints to ignore. Contexts could be organized into their own hierarchy and details would need to be worked out.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a>,
	                  		<a>UC19</a> and
	                  		<a>UC32</a>
	                  	</p>
	                </dd>


	                <!-- Requirement R11.7 -->
	                <dt>
						<dfn>R11.7</dfn>: Separation of structural from complex constraints
					</dt>
					<dd>
						<p>
							<em>There shall be a core language or SHACL profile that excludes any support for constraints defined via embedded SPARQL queries or other complex lower-level expressions. This is so that lightweight applications can validate constraints without requiring a SPARQL processor or similar subsystem.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a>,
	                  		<a>UC19</a> and
	                  		<a>UC32</a>
	                  	</p>
	                </dd>

	                <!--Requirement R11.8 -->
	                <dt>
	                	<dfn>R11.8</dfn>: Evaluating Constraints for a Single Node Only
	                </dt>
	                <dd>
	                	<p>
	                		<em>It should be possible to validate constraints on a single node in a graph. This may be impossible to implement 100% correctly, because sometimes a change to a resource invalidates conditions in a very different place in the graph. However, the language could propose a framework that identifies those constraints that SHOULD be checked when a given node is evaluated, e.g. by following its <code>rdf:type</code> and the superclasses of that. This would include validating <code>shacl:valueShape</code> but not <code>shacl:valueType</code>. </em> </p>
	                	<p>
	                		<strong>Motivation:</strong> 
	                		(Orthogonal to basically all use cases) 
	                	</p>
	                </dd>


	                <!-- Requirement R12
            		<dt>
						<dfn>R12</dfn>: Selection of nodes
					</dt>
					<dd>
						<p>
							<em>There must be some mechanism to select which nodes are going to be validated/constrained. Some possibilities: global selection (all the nodes in the RDF graph), nodes by type (the instances of some class), and specifc nodes.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
 
	                  	</p>
	                </dd>
	                <!-- Requirement R12.1-->
	                <dt>
						<dfn>R12.1</dfn>: Select Whole Graph
					</dt>
					<dd>
						<p>
							<em>It should be possible to select all the RDF nodes in a graph for validation. This is similar to the Global Constraints (<a>R9</a>) requirement.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC35</a>
	                  	</p>
	                </dd>

	                <!-- Requirement R12.2 -->
	                <dt>
						<dfn>R12.2</dfn>: Selection by Type
					</dt>
					<dd>
						<p>
							<em>It should be possible to have some mechanism to select the nodes that are instances of some class for validation.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		(Orthogonal to basically all stories)
	                  	</p>
	                </dd>

	                <!-- Requirement R12.3 -->
	                <dt>
						<dfn>R12.3</dfn>: Selection by Single Node
					</dt>
					<dd>
						<p>
							<em>It should be possible to select a single RDF node for validation.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		(Orthogonal to basically all stories)
	                  	</p>
	                </dd>

	                <!-- Requirement R13 
	                <dt>
						<dfn>R13</dfn>: Evolutionary Adoption Path
					</dt>
					<dd>
						<p>
							<em>The standard should provide a reasonable evolutionary path from existing systems and data models into the new closed constraint checking world.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		
	                  	</p>
	                </dd>-->

	
						                <!-- Requirement R14.1 -->
	                <dt>

						<dfn id="dfn-r14.1">R14.1</dfn>: Property Default Value
					</dt>
					<dd>
						<p>

							<em>It should be possible to provide a default value for a given property, e.g. so that input forms can be pre-populated. This requirement is not about using default values as "inferred" triples at run-time. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 

							<a>UC11</a>,
							<a>UC19</a>, and
							<a>UC20</a>
	                  	</p>
	                </dd>


					
						                <!-- Requirement R14.2 -->
	                <dt>

						<dfn id="dfn-r14.2">R14.2</dfn>: Property Labels at Shape
					</dt>
					<dd>
						<p>

							<em>It should be possible to provide human-readable labels of a property in the context of a shape, intended for human consumption such as documentation or UI, not just globally for the rdf:Property. Multiple languages should be supported.</em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 

	                  		<a>UC11</a> and
							<a>UC19</a>
	                  	</p>
	                </dd>

					
						                <!-- Requirement R14.3 -->
	                <dt>

						<dfn id="dfn-r14.3">R14.3</dfn>: Property Comment in a Shape
					</dt>
					<dd>
						<p>

							<em>It should be possible to provide human-readable descriptions of the role of a property in the context of a shape, not just globally using triples that have the rdf:Property as subject. Multiple languages should be supported. </em> 
						</p>
	                	<p>
	                  		<strong>Motivation:</strong> 
	                  		<a>UC11</a> and
							<a>UC19</a>
	                  	</p>
	                </dd>


			
			    </dl>

			</section>
		<!--
		<pre id="example1" class="example highlight">
						@prefix ro:  &lt;http://purl.org/wf4ever/ro#&gt; .
						@prefix dct: &lt;http://purl.org/dc/terms/&gt; .
						@prefix ore: &lt;http://www.openarchives.org/ore/&gt; .
						@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

						&lt;&gt; a ro:ResearchObject, ore:Aggregation ;
							dct:created "2012-12-01"^^xsd:dateTime .
					</pre>
					<div class="note">
							<p>
								The basic facilities provided by <a href="#ch_domain"><code>rdfs:domain</code></a>
								and <a href="#ch_range"><code>rdfs:range</code></a> do not provide any
								direct way to indicate property restrictions that are local to a class.
								Although it is possible to combine use <a href="#ch_domain"><code>rdfs:domain</code></a>
								and <a href="#ch_range"><code>rdfs:range</code></a> with sub-property
								hierarchies, direct support for such declarations are provided by richer
								Web Ontology languages such as OWL.
						</p>
					</div>-->
					<section class='appendix'>
						<h2>Acknowledgements</h2>
						<p>
							We would like to acknowledge the contributions of user story authors: Dean Allemang, Anamitra Bhattacharyya, Karen Coyle, Nick Crossley, Michel Dumontier, Jose Emilio Labra Gayo, Sandro Hawke, Dimitris Kontokostas, Holger Knublauch, David Martin, Dave McComb, Peter F. Patel-Schneider, Axel Polleres, Eric Prud'hommeaux, Arthur Ryman, Steve Speicher, and Simon Steyskal.
						</p>
					</section>

					<section id='tof'></section>
				</body>
				</html>
